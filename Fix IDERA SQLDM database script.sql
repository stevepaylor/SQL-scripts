 

---------- DATABASECREATE.SQL
/*----------------------------- Idera SQL diagnostic manager -------------------------------
**
**	Copyright Idera, Inc. 2005-2012
**		All rights reserved
**
**------------------------------------------------------------------------------------------
**
**	Description:  SQL script to install/migrate the SQLdm repository database.
**
**------------------------------------------------------------------------------------------
**
**	Instructions: 
**		1. Use the Find/Replace function to locate and replace all references to 
**			'SQLdmRepository' with the name of your SQLdm Repository Database.
**		2. Use the Find/Replace function to locate and replace all references to 
**			'SQLdmRepository' with the name of your SQLdm Repository Database.
**		3. Connect to the SQL Server that is hosting your SQLdm Repository database and 
**			execute this script.
**		4. Run the upgrade installer to complete the upgrade process.
**	
**------------------------------------------------------------------------------------------
*/
 
use [master]
set nocount on
GO

SET LANGUAGE us_english
GO

-- Get the SQL Server data path
declare @path nvarchar(256), @filename nvarchar(256), @upgrade bit
select @path = substring(filename, 1, charindex(N'master.mdf', lower(filename)) - 1) 
from 
	master..sysfiles
where 
	fileid = 1

select @filename = 'SQLdmRepository'

if (db_id( 'SQLdmRepository') is null)
begin		
	declare @createcommand nvarchar(2000)
	set @createcommand = 'create database ' + quotename(@filename) + '
	on (
		Name = ' + quotename(@filename) + ', 
		FileName = ' + quotename(@path + @filename + '.mdf','''') + ', '
		+ 'Size = 100MB, Filegrowth = 32MB
		)
	log on 
		(Name = ' + quotename(@filename+ '_log') + ', 
		FileName = ' + quotename(@path + @filename + '_log.ldf','''') + ', '
		+ 'Size = 5MB, Filegrowth = 32MB) 
	collate SQL_Latin1_General_CP1_CS_AS'
	execute(@createcommand)
end

GO

if (object_id('SQLdmRepository..fn_GetDatabaseVersion') is null)
begin
	print 'Setting recovery mode'
	ALTER DATABASE [SQLdmRepository] SET RECOVERY SIMPLE
end

GO

use [SQLdmRepository]

GO	

set quoted_identifier on
set ansi_nulls on
set ansi_warnings off

GO

-- Add SQLdmConsoleUser database role
if ((select count(uid) from dbo.sysusers where name = 'SQLdmConsoleUser' and issqlrole = 1) = 0)
begin
exec sp_addrole 'SQLdmConsoleUser'
end


if not exists(select name from sys.schemas where name = 'Grooming')
begin
	declare @cmd nvarchar(1000),@filename nvarchar(256), @schema nvarchar(500)
	set @filename = N'SQLdmRepository'
	set @schema = 'create schema Grooming authorization dbo'
	set @cmd = quotename(@filename) + N'.sys.sp_executesql'
	exec @cmd @schema
end

----------------------------------------------------------------------
Print 'Adding Install Utility Proc'
----------------------------------------------------------------------
---------------------------------------------------------------------------------------
--Create a proc that will help us to drop default constraints
---------------------------------------------------------------------------------------
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[p_DropDefaultConstraint]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[p_DropDefaultConstraint]
GO
create proc p_DropDefaultConstraint(@TableName nvarchar(256), @ColumnName nvarchar(256))
as
begin
	DECLARE @defname VARCHAR(100), @cmd VARCHAR(1000)

	set @defname = 
	(SELECT sc.name
	FROM sys.objects so JOIN sys.default_constraints sc
	ON so.object_id = sc.object_id 
	WHERE object_name(so.parent_object_id) = @TableName
	AND so.type = 'D'
	AND sc.parent_column_id = 
	 (SELECT column_id FROM sys.columns 
	 WHERE object_id = object_id(@TableName) AND 
	 name = @ColumnName))

	SET @cmd ='ALTER TABLE ' + quotename(@TableName) + ' DROP CONSTRAINT '
	+ quotename(@defname)

	EXEC(@cmd)
end

GO

----------------------------------------------------------------------
Print 'Processing Tables'
----------------------------------------------------------------------

IF (OBJECT_ID('RepositoryInfo') IS NULL)
BEGIN
CREATE TABLE [RepositoryInfo](
	[Name] [nvarchar](30) NOT NULL,
	[Internal_Value] [int] NULL,
	[Character_Value] [nvarchar](1024) NULL,
	CONSTRAINT [Name] PRIMARY KEY CLUSTERED 
	(
		[Name] ASC
	)
)
	insert into [RepositoryInfo](Name,Internal_Value) values ('PredictiveAnalyticsEnabled',1)
END
else
begin
	if not exists(select Name from [RepositoryInfo] where Name = 'PredictiveAnalyticsEnabled')
	begin
		insert into [RepositoryInfo](Name,Internal_Value) values ('PredictiveAnalyticsEnabled',0)
	end
end


create table #tempversion(Ind int, Name nvarchar(30),Internal_Value bigint, Character_Value nvarchar(50))
insert #tempversion
	exec master..xp_msver 'ProductVersion' 

if exists(select Name from [RepositoryInfo] where Name = 'SQLVersionAtUpgrade')
begin
	update [RepositoryInfo] 
		set [RepositoryInfo].Internal_Value = cast(left(#tempversion.Character_Value,4) as float),
			[RepositoryInfo].Character_Value = #tempversion.Character_Value
		from #tempversion
	where
		[RepositoryInfo].Name =  'SQLVersionAtUpgrade'
		
end
else
begin
	insert into [RepositoryInfo]  (Name, Internal_Value, Character_Value)
		select  
			'SQLVersionAtUpgrade',
			cast(left(Character_Value,4) as float),
			Character_Value
		from #tempversion

end

drop table #tempversion


GO

declare @cmptleveltarget int
select @cmptleveltarget = case when Internal_Value = 9 then 90 when Internal_Value = 10 then 100 else 110 end from RepositoryInfo where Name =  'SQLVersionAtUpgrade'
exec sp_dbcmptlevel 'SQLdmRepository', @cmptleveltarget

GO

----------------------------------------------------------------------

IF (OBJECT_ID('ManagementServices') IS NULL)
BEGIN

CREATE TABLE [ManagementServices](
	[ManagementServiceID] [uniqueidentifier] NOT NULL,
	[InstanceName] [nvarchar](15) NOT NULL,
	[MachineName] [nvarchar](15) NOT NULL,
	[Address] [nvarchar](256) NOT NULL,
	[Port] [int] NOT NULL,
	[DefaultCollectionServiceID] [uniqueidentifier] NULL,
	CONSTRAINT [PK_ManagementServices] PRIMARY KEY CLUSTERED 
	(
		[ManagementServiceID] ASC
	)
	) 

	CREATE UNIQUE INDEX [IXManagementServices] ON [ManagementServices]([MachineName],[InstanceName]) 

END

----------------------------------------------------------------------

IF (OBJECT_ID('CollectionServices') IS NULL)
BEGIN

CREATE TABLE [CollectionServices](
	[CollectionServiceID] [uniqueidentifier] NOT NULL,
	[InstanceName] [nchar](15) NOT NULL,
	[MachineName] [nchar](15) NOT NULL,
	[Address] [nvarchar](256) NOT NULL,
	[Port] [int] NOT NULL,
	[Enabled] [bit] NOT NULL,
	[LastHeartbeatUTC] [datetime] NULL,
	[ManagementServiceID] [uniqueidentifier] NOT NULL,
	CONSTRAINT [PK_CollectionService] PRIMARY KEY CLUSTERED 
	(
		[CollectionServiceID] ASC
	),
	CONSTRAINT [FKCollectionServicesManagementServices] FOREIGN KEY 
	(
		[ManagementServiceID]
	) 
	REFERENCES [ManagementServices] 
	(
		[ManagementServiceID]
	)
	ON DELETE CASCADE
	)

	CREATE UNIQUE INDEX [IXCollectionServices] ON [CollectionServices]([MachineName],[InstanceName]) 

END


--START : SQLdm 10.0 (Tarun Sapra) -Minimal Cloud Support --Created a new table for CloudSupportProviders mapping
IF (OBJECT_ID('CloudProviders') IS NULL)
	BEGIN	
		CREATE TABLE [dbo].[CloudProviders](
		[CloudProviderId] int NOT NULL,
		[CloudProviderName] varchar(500) NOT NULL,
		CONSTRAINT [PK_CloudProviders] PRIMARY KEY CLUSTERED ([CloudProviderId] ASC)
		)
	END
--END : SQLdm 10.0 (Tarun Sapra) -Minimal Cloud Support --Created a new table for CloudSupportProviders mapping


----------------------------------------------------------------------

IF (OBJECT_ID('MonitoredSQLServers') IS NULL)
BEGIN
CREATE TABLE  [MonitoredSQLServers]
	(
	[SQLServerID] [int] IDENTITY NOT NULL,
	[InstanceName] [nvarchar](256) NOT NULL,
	[Active] [bit] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_Active]  DEFAULT ((1)),
	[Deleted] [bit] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_Deleted]  DEFAULT ((0)),
	[RegisteredDate] [datetime] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_RegisteredDate]  DEFAULT (getutcdate()),
	[CollectionServiceID] [uniqueidentifier] NULL,
	[UseIntegratedSecurity] [bit] NOT NULL,
	[Username] [nvarchar](128) NULL,
	[Password] [nvarchar](128) NULL,
	[EncryptData] [bit] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_EncryptData] DEFAULT((0)),
	[TrustServerCert] [bit] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_TrustServerCert] DEFAULT((0)),
	[ScheduledCollectionIntervalInSeconds] [int] NOT NULL,
	[LastScheduledCollectionTime] [datetime] NULL,
	[ServerVersion] [nvarchar](30) NULL,
	[ServerEdition] [nvarchar](30) NULL,
	[MaintenanceModeEnabled] [bit] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_MaintenanceModeEnabled]  DEFAULT ((0)),
	[QueryMonitorEnabled] [bit] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_QueryMonitorEnabled]  DEFAULT ((0)),
	[QueryMonitorSqlBatchEventsEnabled] [bit] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_CaptureSqlBatches]  DEFAULT ((0)),
	[QueryMonitorSqlStatementEventsEnabled] [bit] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_CaptureSqlStatements]  DEFAULT ((0)),
	[QueryMonitorStoredProcedureEventsEnabled] [bit] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_QueryMonitorStoredProcedureEventsEnabled]  DEFAULT ((0)),
	[QueryMonitorDurationFilterInMilliseconds] [int] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_QueryMonitorDurationFilter]  DEFAULT ((500)),
	[QueryMonitorCpuUsageFilterInMilliseconds] [int] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_QueryMonitorCpuUsageFilterInMilliseconds]  DEFAULT ((0)),
	[QueryMonitorLogicalDiskReadsFilter] [int] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_QueryMonitorLogicalReadsFilter]  DEFAULT ((0)),
	[QueryMonitorPhysicalDiskWritesFilter] [int] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_QueryMonitorPhysicalWritesFilter]  DEFAULT ((0)),
	[QueryMonitorTraceFileSizeKB] [int] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_QueryMonitorTraceFileSizeKB]  DEFAULT ((1024)),
	[QueryMonitorTraceFileRollovers] [int] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_QueryMonitorTraceFileRollovers]  DEFAULT ((2)),
	[QueryMonitorTraceRecordsPerRefresh] [int] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_QueryMonitorTraceRecordsPerRefresh]  DEFAULT ((1000)),
	[ActivityMonitorEnabled] [bit] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_ActivityMonitorEnabled]  DEFAULT ((1)),
	[ActivityMonitorDeadlockEventsEnabled] [bit] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_ActivityMonitorDeadlockEventsEnabled]  DEFAULT ((0)),	
	[ActivityMonitorAutoGrowEventsEnabled] [bit] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_ActivityMonitorAutogrowEventsEnabled]  DEFAULT ((0)),	
	[ActivityMonitorBlockingEventsEnabled] [bit] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_ActivityMonitorBlockingEventsEnabled]  DEFAULT ((1)),		
	[ActivityMonitorBlockedProcessThreshold] [int] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_ActivityMonitorBlockedProcessThreshold] DEFAULT ((30)),		
	[GrowthStatisticsStartTime] [datetime] CONSTRAINT [DF_MonitoredSQLServers_GrowthStatisticsStartTime] DEFAULT '1900-01-01 3:00:00 AM',
	[ReorgStatisticsStartTime] [datetime] CONSTRAINT [DF_MonitoredSQLServers_ReorgStatisticsStartTime] DEFAULT '1900-01-01 3:00:00 AM',
	[LastGrowthStatisticsRunTime] [datetime] CONSTRAINT [DF_MonitoredSQLServers_LastGrowthStatisticsRunTime] DEFAULT NULL,
	[LastGrowthStatisticsRunTimeUTC] [datetime] CONSTRAINT [DF_MonitoredSQLServers_LastGrowthStatisticsRunTimeUTC] DEFAULT NULL,
	[LastReorgStatisticsRunTime] [datetime] CONSTRAINT [DF_MonitoredSQLServers_LastReorgStatisticsRunTime] DEFAULT NULL,
	[LastReorgStatisticsRunTimeUTC] [datetime] CONSTRAINT [DF_MonitoredSQLServers_LastReorgStatisticsRunTimeUTC] DEFAULT NULL,
	[EarliestDateImportedFromLegacySQLdm] [datetime] DEFAULT NULL,
	[GrowthStatisticsDays] [tinyint] DEFAULT 253,
	[ReorgStatisticsDays] [tinyint] DEFAULT 253,
	[TableStatisticsExcludedDatabases] [nvarchar] (max) DEFAULT NULL,
	[GroomAlerts] [int] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_GroomAlerts]  DEFAULT -1,
	[GroomMetrics] [int] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_GroomMetrics]  DEFAULT -1,
	[GroomTasks] [int] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_GroomTasks]  DEFAULT -1,
	[ReorgMinTableSizeKB] int NOT NULL CONSTRAINT [DF_MonitoredSQLServers_ReorgMinTableSize] DEFAULT 64,
	[GroomActivity] [int] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_GroomActivity]  DEFAULT -1,
	[CustomCounterTimeoutInSeconds] [int] DEFAULT 180,
	[OutOfProcOleAutomation] [bit] DEFAULT 0,
	[DisableReplicationMonitoring] [bit] DEFAULT 0,
	[MaintenanceModeType] [int] DEFAULT 0,
	[MaintenanceModeStart] [datetime] DEFAULT NULL,
	[MaintenanceModeStop]  [datetime] DEFAULT NULL,
	[MaintenanceModeDays] [smallint] DEFAULT NULL,
	[MaintenanceModeDurationSeconds] [int] DEFAULT NULL,	
    [MaintenanceModeRecurringStart] [datetime] DEFAULT NULL,
	[QueryMonitorAdvancedConfiguration] [nvarchar] (max) DEFAULT '<?xml version="1.0" encoding="utf-16"?><AdvancedQueryMonitorConfiguration xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><ApplicationExcludeLike><Like>SQLProfiler%</Like><Like>SQLDMO%</Like><Like>SQLAgent%</Like></ApplicationExcludeLike></AdvancedQueryMonitorConfiguration>',
	[DisableExtendedHistoryCollection] [bit] DEFAULT 0,
	[RefRangeUseDefaults] [bit] DEFAULT 1,
	[RefRangeStartTimeUTC] [datetime] DEFAULT NULL,
	[RefRangeEndTimeUTC] [datetime] DEFAULT NULL,
	[RefRangeDays] [tinyint] DEFAULT 124, 
	[DisableOleAutomation] bit DEFAULT 0,
	[DiskCollectionSettings] [nvarchar] (max) DEFAULT NULL,
	[QueryMonitorStopTimeUTC] [datetime] DEFAULT NULL,
	[InputBufferLimiter] [int] default 500 not null,
	[InputBufferLimited] [bit] default 0 not null,
	[ActiveClusterNode] [nvarchar](256) null,
	[PreferredClusterNode] [nvarchar](256) null,
	[RealServerName] [nvarchar](100) null,
	[FriendlyServerName] [nvarchar](256) null,
	[ActiveWaitCollectorStartTimeRelative] [datetime] DEFAULT NULL,
	[ActiveWaitCollectorRunTimeSeconds] [int] DEFAULT 0,
	[ActiveWaitCollectorCollectionTimeSeconds] [int] DEFAULT 30,
	[ActiveWaitCollectorEnabled] [bit] DEFAULT 0,
	[ActiveWaitLoopTimeMilliseconds] [int] DEFAULT 500,
	[ActiveWaitAdvancedConfiguration] [nvarchar] (max) DEFAULT null,
	[ActiveWaitXEEnable] bit DEFAULT 1 not null,
	[ActiveWaitXEFileSizeMB] int default 1 not null,
	[ActiveWaitXEFilesRollover] int default 3 not null,
	[ActiveWaitXERecordsPerRefresh] int default 1000 not null,
	[ActiveWaitXEMaxMemoryMB] int default 1 not null,
	[ActiveWaitXEEventRetentionMode] tinyint default 1 not null,
	[ActiveWaitXEMaxDispatchLatencySecs] int default 300 not null,
	[ActiveWaitXEMaxEventSizeMB] int default 1 not null,
	[ActiveWaitXEMemoryPartitionMode] int default 0 not null, 
	[ActiveWaitXETrackCausality] bit default 0 not null,
	[ActiveWaitXEStartupState] bit default 0 not null,
	[ActiveWaitsXEFileName] nvarchar(1024)default 'dm7XESessionOut.xel' not null,
	[ClusterCollectionSetting] [smallint] DEFAULT 0,
	[ServerPingInterval] [smallint] NOT NULL DEFAULT 30,
	[VHostID] [int] NULL,
	[VmUID] [nvarchar](256) NULL,
	[VmName] [nvarchar](256) NULL,
	[VmDomainName] [nvarchar](256) NULL,
	[AlertRefreshInMinutes] [bit] NOT NULL DEFAULT 1,
	[DatabaseStatisticsRefreshIntervalInSeconds] [int] NOT NULL DEFAULT 3600,
	[WmiCollectionEnabled] [bit] NOT NULL DEFAULT 0,
	[WmiConnectAsService] [bit] NOT NULL DEFAULT 1,
	[WmiUserName] [nvarchar](256) NULL,
	[WmiPassword] [nvarchar](256) NULL,
	[LastDatabaseCollectionTime] [datetime] NULL,
	[LastAlertRefreshTime] [datetime] NULL,
	[GroomAudit] [int] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_GroomAudit]  DEFAULT -1,
	[MaintenanceModeMonth] [int] NULL,
	[MaintenanceModeSpecificDay] [int] NULL,
	[MaintenanceModeWeekOrdinal] [int] NULL,
	[MaintenanceModeWeekDay] [int] NULL,
	[MaintenanceModeMonthDuration] [int] NULL,
	[MaintenanceModeMonthRecurringStart] [DATETIME] NULL,
    --SQLdm 9.0 (Ankit Srivastava): Query Monitoring with Extended Event Session  --   new columns for the table
	QueryMonitorTraceMonitoringEnabled BIT NOT NULL CONSTRAINT [DF_MonitoredSQLServers_QueryMonitorTraceMonitoringEnabled] DEFAULT(0),
	QueryMonitorCollectQueryPlan BIT NOT NULL CONSTRAINT [DF_MonitoredSQLServers_QueryMonitorCollectQueryPlan] DEFAULT(0) ,

	QueryMonitorCollectEstimatedQueryPlan BIT NOT NULL CONSTRAINT [DF_MonitoredSQLServers_QueryMonitorCollectEstimatedQueryPlan] DEFAULT(0) , --SQLdm 10.0 (Tarun Sapra) - Flag for collecting estimated query plan only

	--START SQLdm 9.1 (Ankit Srivastava): Activity Monitor with Extended Events  --   new columns for the table
	ActivityMonitorTraceMonitoringEnabled BIT NOT NULL CONSTRAINT [DF_MonitoredSQLServers_ActivityMonitorTraceMonitoringEnabled] DEFAULT(1), 
	[ActivityMonitorXEFileSizeMB] int default 1 not null,
	[ActivityMonitorXEFilesRollover] int default 3 not null,
	[ActivityMonitorXERecordsPerRefresh] int default 1000 not null,
	[ActivityMonitorXEMaxMemoryMB] int default 1 not null,
	[ActivityMonitorXEEventRetentionMode] tinyint default 1 not null,
	[ActivityMonitorXEMaxDispatchLatencySecs] int default 300 not null,
	[ActivityMonitorXEMaxEventSizeMB] int default 1 not null,
	[ActivityMonitorXEMemoryPartitionMode] int default 0 not null, 
	[ActivityMonitorXETrackCausality] bit default 0 not null,
	[ActivityMonitorXEStartupState] bit default 0 not null,
	[ActivityMonitorXEFileName] nvarchar(1024) not null CONSTRAINT [DF_MonitoredSQLServers_ActivityMonitorXEFileName] DEFAULT('AMExtendedEventLog.xel'),
	--END SQLdm 9.1 (Ankit Srivastava): Activity Monitor with Extended Events  --   new columns for the table

	--START SQLdm 9.1 (Sanjali Makkar): Configurable Coefficients for Health Index  --   new columns for the table
	[HealthIndexCoefficientForCriticalAlert] int default 6 not null,
	[HealthIndexCoefficientForWarningAlert] int default 2 not null,
	[HealthIndexCoefficientForInformationalAlert] int default 1 not null,
	--END SQLdm 9.1 (Sanjali Makkar): Configurable Coefficients for Health Index  --   new columns for the table

	--START SQLdm 9.1 (Ankit Srivastava): Query Monitor 9.0 Improvement feedback - adding new columns for uery monitoring extended event session configuration
	[QueryMonitorXEFileSizeMB] int default 20 Check ([QueryMonitorXEFileSizeMB] > -1) not null,
	[QueryMonitorXEFilesRollover] int default 5 Check ([QueryMonitorXEFilesRollover] > -1) not null,
	--END SQLdm 9.1 (Ankit Srivastava): Query Monitor 9.0 Improvement feedback - adding new columns for uery monitoring extended event session configuration
	[CloudProviderId] INT DEFAULT NULL,--SQLdm 10.0 (Gaurav Karwal): adding the reference to the cloud provider id in the monitored sql servers
	[GroomPrescriptiveAnalysis] int NOT NULL CONSTRAINT [DF_MonitoredSQLServers_GroomPrescriptiveAnalysis]  DEFAULT -1
	CONSTRAINT [PKMonitoredSQLServers] PRIMARY KEY CLUSTERED
	(
		[SQLServerID]
	)
)

CREATE UNIQUE INDEX [IX_U_MonitoredSQLServers_InstanceName] ON [MonitoredSQLServers]([InstanceName]) 

END
ELSE
BEGIN
	-- upgrade to 5.0.7
	IF (not exists(select id from syscolumns where id = object_id('MonitoredSQLServers') and name = 'ReorgMinTableSizeKB' collate database_default)) 
	BEGIN
		ALTER TABLE [MonitoredSQLServers] 
			ADD [ReorgMinTableSizeKB] int NOT NULL CONSTRAINT [DF_MonitoredSQLServers_ReorgMinTableSizeKB] DEFAULT 0
	END
	-- upgrade to 5.5.0
	IF (not exists(select id from syscolumns where id = object_id('MonitoredSQLServers') and name = 'GroomActivity' collate database_default)) 
	BEGIN
		ALTER TABLE [MonitoredSQLServers] 
			ADD [GroomActivity] [int] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_GroomActivity]  DEFAULT -1,
				[CustomCounterTimeoutInSeconds] [int] DEFAULT 180, 
				[OutOfProcOleAutomation] [bit] DEFAULT 0,
				[DisableReplicationMonitoring] [bit] DEFAULT 0
	END
	-- upgrade to 5.6
	IF (not exists(select id from syscolumns where id = object_id('MonitoredSQLServers') and name = 'MaintenanceModeType' collate database_default))
	BEGIN
		ALTER TABLE [MonitoredSQLServers]
			ADD [MaintenanceModeType] [int] DEFAULT 0,
				[MaintenanceModeStart] [datetime] DEFAULT NULL,
				[MaintenanceModeStop]  [datetime] DEFAULT NULL,
				[MaintenanceModeDays] [smallint] DEFAULT NULL,
				[MaintenanceModeDurationSeconds] [int] DEFAULT NULL,
				[MaintenanceModeRecurringStart] [datetime] DEFAULT NULL
	END
	-- upgrade to 5.6.0
	IF (not exists(select id from syscolumns where id = object_id('MonitoredSQLServers') and name = 'RefRangeStartTimeUTC' collate database_default)) 
	BEGIN
		ALTER TABLE [MonitoredSQLServers] 
			ADD [RefRangeUseDefaults] [bit] DEFAULT 1,
				[RefRangeStartTimeUTC] [datetime] DEFAULT NULL,
				[RefRangeEndTimeUTC] [datetime] DEFAULT NULL,
				[RefRangeDays] [tinyint] DEFAULT 124, 
				[QueryMonitorAdvancedConfiguration] [nvarchar] (max) DEFAULT '<?xml version="1.0" encoding="utf-16"?><AdvancedQueryMonitorConfiguration xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><ApplicationExcludeLike><Like>SQLProfiler%</Like><Like>SQLDMO%</Like><Like>SQLAgent%</Like></ApplicationExcludeLike></AdvancedQueryMonitorConfiguration>',
				[DisableExtendedHistoryCollection] [bit] DEFAULT 0
	END

	-- upgrade to 6.0
	IF (not exists(select id from syscolumns where id=object_id('MonitoredSQLServers') and name = 'DisableOleAutomation' collate database_default))
	BEGIN
		ALTER TABLE [MonitoredSQLServers]
			ADD [DisableOleAutomation] [bit] DEFAULT 0,
				[DiskCollectionSettings] [nvarchar] (max) DEFAULT NULL,
				[QueryMonitorStopTimeUTC] [datetime] DEFAULT NULL
	END

	-- upgrade to 6.0.1
	IF (not exists(select id from syscolumns where id=object_id('MonitoredSQLServers') and name = 'InputBufferLimiter' collate database_default))
	BEGIN
		ALTER TABLE [MonitoredSQLServers]
			ADD [InputBufferLimiter] [int] default 500 not null,
				[InputBufferLimited] [bit] default 0 not null 
	END

	-- upgrade to 6.1
	IF (not exists(select id from syscolumns where id=object_id('MonitoredSQLServers') and name = 'ActiveClusterNode' collate database_default))
	BEGIN
		ALTER TABLE [MonitoredSQLServers]
			ADD [ActiveClusterNode] [nvarchar](256) null,
			[PreferredClusterNode] [nvarchar](256) null,
			[QueryMonitorDeadlockEventsEnabled] [bit] NOT NULL CONSTRAINT [DF_MonitoredSQLServers_QueryMonitorDeadlockEventsEnabled]  DEFAULT ((0)),
			[RealServerName] [nvarchar](100) null
	END

	-- upgrade to 6.2
	IF (not exists(select id from syscolumns where id=object_id('MonitoredSQLServers') and name = 'ActiveWaitCollectorStartTimeRelative' collate database_default))
	BEGIN
		ALTER TABLE [MonitoredSQLServers]
			ADD [ActiveWaitCollectorStartTimeRelative] [datetime] DEFAULT NULL,
			[ActiveWaitCollectorRunTimeSeconds] [int] DEFAULT 0,
			[ActiveWaitCollectorCollectionTimeSeconds] [int] DEFAULT 30,
			[ActiveWaitCollectorEnabled] [bit] DEFAULT 0,
			[ActiveWaitLoopTimeMilliseconds] [int] DEFAULT 500,
			[ActiveWaitAdvancedConfiguration] [nvarchar] (max) DEFAULT null,
			[ClusterCollectionSetting] [smallint] DEFAULT 0
	END

	-- upgrade to 7.0
	IF (not exists(select id from syscolumns where id=object_id('MonitoredSQLServers') and name = 'ServerPingInterval' collate database_default))
	BEGIN
		ALTER TABLE [MonitoredSQLServers]
			ADD [ServerPingInterval] smallint NOT NULL DEFAULT 30
	END
	
	-- upgrade to 7.2
	IF (not exists(select id from syscolumns where id=OBJECT_ID('MonitoredSQLServers') and name='VHostID' collate database_default))
	BEGIN
		ALTER TABLE [MonitoredSQLServers]
			ADD [VHostID] [int] DEFAULT NULL,
			[VmUID] [nvarchar](256) DEFAULT NULL,
			[VmName] [nvarchar](256) DEFAULT NULL,
			[VmDomainName] [nvarchar](256) DEFAULT NULL
	END
	
	-- upgrade to 7.2
	IF (not exists(select id from syscolumns where id=OBJECT_ID('MonitoredSQLServers') and name='AlertRefreshInMinutes' collate database_default))
	BEGIN
		ALTER TABLE [MonitoredSQLServers]
			ADD [AlertRefreshInMinutes] [bit] NOT NULL DEFAULT 1
	END
	
	 --if the TableStatisticsExcludedDatabases column does not exist as a varchar then all field must be updated.
	 --Upgrade to 7.2
	IF (not exists(select sc.object_id from sys.columns sc inner join sys.types st on sc.system_type_id = st.system_type_id
		where object_id=OBJECT_ID('MonitoredSQLServers') 
		and sc.name='TableStatisticsExcludedDatabases' and lower(st.name) = 'nvarchar'  collate database_default))
	begin
		--drop default constraints
		exec p_DropDefaultConstraint 'MonitoredSQLServers','TableStatisticsExcludedDatabases'
		exec p_DropDefaultConstraint 'MonitoredSQLServers','QueryMonitorAdvancedConfiguration'
		exec p_DropDefaultConstraint 'MonitoredSQLServers','DiskCollectionSettings'
		exec p_DropDefaultConstraint 'MonitoredSQLServers','ActiveWaitAdvancedConfiguration'		
		
		alter table MonitoredSQLServers alter column QueryMonitorAdvancedConfiguration nvarchar(max)
		-- add the constraint back
		alter table MonitoredSQLServers with check
            add constraint df_QueryMonitorAdvancedConfiguration
            default '<?xml version="1.0" encoding="utf-16"?><AdvancedQueryMonitorConfiguration xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><ApplicationExcludeLike><Like>SQLProfiler%</Like><Like>SQLDMO%</Like><Like>SQLAgent%</Like></ApplicationExcludeLike></AdvancedQueryMonitorConfiguration>' for QueryMonitorAdvancedConfiguration
			
		alter table MonitoredSQLServers alter column  TableStatisticsExcludedDatabases nvarchar(max) null
		--This field might have been added as part of the 6.0 upgrade
		alter table MonitoredSQLServers alter column DiskCollectionSettings nvarchar(max) null
		alter table MonitoredSQLServers alter column ActiveWaitAdvancedConfiguration nvarchar(max) null
	end
	
	-- upgrade to 7.5
	IF (not exists(select id from syscolumns where id=OBJECT_ID('MonitoredSQLServers') and name='DatabaseStatisticsRefreshIntervalInSeconds' collate database_default))
	BEGIN
		ALTER TABLE [MonitoredSQLServers]
			ADD [DatabaseStatisticsRefreshIntervalInSeconds] [int] NOT NULL DEFAULT 3600,
				[WmiCollectionEnabled] [bit] NOT NULL DEFAULT 0,
				[WmiConnectAsService] [bit] NOT NULL DEFAULT 1,
				[WmiUserName] [nvarchar](256) NULL,
				[WmiPassword] [nvarchar](256) NULL
				
		-- For upgrades set the DatabaseStatisticsRefreshIntervalInSeconds to the same value as ScheduledCollectionIntervalInSeconds
		-- This will maintain the same behavior as the previous version
		exec('update [MonitoredSQLServers]
		set [DatabaseStatisticsRefreshIntervalInSeconds] = [ScheduledCollectionIntervalInSeconds]')
		
	END
	
	--upgrade to 7.5
	IF (not exists(select id from syscolumns where id=OBJECT_ID('MonitoredSQLServers') and name='ActiveWaitXEEnable' collate database_default))	
	begin
		ALTER TABLE [MonitoredSQLServers]
			ADD ActiveWaitXEEnable bit default 1 not null,
			ActiveWaitXEFileSizeMB int default 5 not null,
			ActiveWaitXEFilesRollover int default 1 not null,
			ActiveWaitXERecordsPerRefresh int default 1000 not null,
			ActiveWaitXEMaxMemoryMB int default 4 not null,
			ActiveWaitXEEventRetentionMode tinyint default 1 not null,
			ActiveWaitXEMaxDispatchLatencySecs int default 300 not null,
			ActiveWaitXEMaxEventSizeMB int default 8 not null,
			ActiveWaitXEMemoryPartitionMode int default 0 not null, 
			ActiveWaitXETrackCausality bit default 0 not null,
			ActiveWaitXEStartupState bit default 0 not null,
			ActiveWaitsXEFileName nvarchar(1024) default 'dm7XESessionOut.xel' not null,
			LastDatabaseCollectionTime datetime null,
			LastAlertRefreshTime datetime null
	end
	
	--upgrade to 8.0
	IF (not exists(select id from syscolumns where id=OBJECT_ID('MonitoredSQLServers') and name='ActivityMonitorBlockingEventsEnabled' collate database_default))	
	begin
		 EXEC sp_rename 'MonitoredSQLServers.QueryMonitorDeadlockEventsEnabled', 
		 'ActivityMonitorDeadlockEventsEnabled','COLUMN'

		ALTER TABLE [MonitoredSQLServers]
			ADD ActivityMonitorEnabled bit default 1 not null,
			ActivityMonitorBlockingEventsEnabled bit default 1 not null,
			ActivityMonitorAutoGrowEventsEnabled bit default 0 not null,
			ActivityMonitorBlockedProcessThreshold int default 30 not null,
			GroomAudit int NOT NULL CONSTRAINT [DF_MonitoredSQLServers_GroomAudit]  DEFAULT -1
	end	
	
	--upgrade to 8.5: Gaurav Karwal - For Maintenance Mode Monthly mode - END
	IF (not exists(select id from syscolumns where id=OBJECT_ID('MonitoredSQLServers') and name='MaintenanceModeMonth' collate database_default))	
	BEGIN
		ALTER TABLE [MonitoredSQLServers] 
		ADD MaintenanceModeMonth INT NULL,
		MaintenanceModeSpecificDay INT NULL,
		MaintenanceModeWeekOrdinal INT NULL,
		MaintenanceModeWeekDay INT NULL,
		MaintenanceModeMonthDuration INT NULL,
		MaintenanceModeMonthRecurringStart DATETIME NULL
	END	
	--upgrade to 8.5: Gaurav Karwal - For Maintenance Mode Monthly mode - END	

	--upgrade to 9.0 (Ankit Srivastava): Query Monitoring with Extended Event Session  --   new field for query Plan - START
	IF (not exists(select id from syscolumns where id=OBJECT_ID('MonitoredSQLServers') and name='QueryMonitorTraceMonitoringEnabled' collate database_default))	
	BEGIN
		ALTER TABLE [MonitoredSQLServers] 
		ADD QueryMonitorTraceMonitoringEnabled BIT NOT NULL CONSTRAINT [DF_MonitoredSQLServers_QueryMonitorTraceMonitoringEnabled] DEFAULT(0) 
	END	
	
	IF (not exists(select id from syscolumns where id = object_id('MonitoredSQLServers') and name = 'QueryMonitorCollectQueryPlan' collate database_default)) 
	BEGIN
		ALTER TABLE [MonitoredSQLServers] 
		ADD QueryMonitorCollectQueryPlan BIT NOT NULL CONSTRAINT [DF_MonitoredSQLServers_QueryMonitorCollectQueryPlan] DEFAULT(0) 
	END
	--upgrade to 9.0 (Ankit Srivastava): Query Monitoring with Extended Event Session  --   new field for query Plan - END

	--START upgrade to 10.0 (Tarun Sapra): Added a flag for collecting estimated query plan only
	IF (not exists(select id from syscolumns where id=OBJECT_ID('MonitoredSQLServers') and name='QueryMonitorCollectEstimatedQueryPlan' collate database_default))	
	BEGIN
		ALTER TABLE [MonitoredSQLServers] 
		ADD QueryMonitorCollectEstimatedQueryPlan BIT NOT NULL CONSTRAINT [DF_MonitoredSQLServers_QueryMonitorCollectEstimatedQueryPlan] DEFAULT (0)
	END	
	--END upgrade to 10.0 (Tarun Sapra): Added a flag for collecting estimated query plan only

	--START upgrade to 10.0 (Tarun Sapra): Added another column for cloud provider id
	IF (not exists(select id from syscolumns where id=OBJECT_ID('MonitoredSQLServers') and name='CloudProviderId' collate database_default))	
	BEGIN
		ALTER TABLE MonitoredSQLServers
		ADD CloudProviderId INT NULL DEFAULT NULL

		ALTER TABLE MonitoredSQLServers
		ADD CONSTRAINT fk_cloudProviderId FOREIGN KEY (CloudProviderId) REFERENCES CloudProviders(CloudProviderId)
	END	
	--END upgrade to 10.0 (Tarun Sapra): Added another column for cloud provider id
	-- START : SQLdm 10.0 (srishti) To support grooming
	IF (not exists(select id from syscolumns where id=OBJECT_ID('MonitoredSQLServers') and name='GroomPrescriptiveAnalysis' collate database_default))	
	BEGIN
		ALTER TABLE [MonitoredSQLServers] 
		ADD [GroomPrescriptiveAnalysis] int NOT NULL CONSTRAINT [DF_MonitoredSQLServers_GroomPrescriptiveAnalysis]  DEFAULT -1
	END
	-- END : SQLdm 10.0 (srishti) To support grooming
	--START upgrade to 9.1 (Ankit Srivastava): Activity Monitor with Extended Events  --   new columns for the table
	IF (not exists(select id from syscolumns where id=OBJECT_ID('MonitoredSQLServers') and name='ActivityMonitorTraceMonitoringEnabled' collate database_default))	
	BEGIN
		ALTER TABLE [MonitoredSQLServers] 
		ADD [ActivityMonitorTraceMonitoringEnabled] BIT NOT NULL CONSTRAINT [DF_MonitoredSQLServers_ActivityMonitorTraceMonitoringEnabled] DEFAULT(1),
			[ActivityMonitorXEFileSizeMB] int default 1 not null,
			[ActivityMonitorXEFilesRollover] int default 3 not null,
			[ActivityMonitorXERecordsPerRefresh] int default 1000 not null,
			[ActivityMonitorXEMaxMemoryMB] int default 1 not null,
			[ActivityMonitorXEEventRetentionMode] tinyint default 1 not null,
			[ActivityMonitorXEMaxDispatchLatencySecs] int default 300 not null,
			[ActivityMonitorXEMaxEventSizeMB] int default 1 not null,
			[ActivityMonitorXEMemoryPartitionMode] int default 0 not null, 
			[ActivityMonitorXETrackCausality] bit default 0 not null,
			[ActivityMonitorXEStartupState] bit default 0 not null,
			[ActivityMonitorXEFileName] nvarchar(1024) not null CONSTRAINT [DF_MonitoredSQLServers_ActivityMonitorXEFileName] DEFAULT('AMExtendedEventLog.xel')
	END
	--END upgrade to 9.1 (Ankit Srivastava): Activity Monitor with Extended Events  --   new columns for the table

	--START upgrade to 9.1 (Sanjali Makkar): Configurable Coefficients for Health Index  --   new columns for the table
	IF (not exists(select id from syscolumns where id=OBJECT_ID('MonitoredSQLServers') and name='HealthIndexCoefficientForCriticalAlert' collate database_default))	
	BEGIN
		ALTER TABLE [MonitoredSQLServers] 
		ADD [HealthIndexCoefficientForCriticalAlert] int default 6 not null
END
	IF (not exists(select id from syscolumns where id=OBJECT_ID('MonitoredSQLServers') and name='HealthIndexCoefficientForWarningAlert' collate database_default))	
	BEGIN
		ALTER TABLE [MonitoredSQLServers] 
		ADD	[HealthIndexCoefficientForWarningAlert] int default 2 not null
	END
	IF (not exists(select id from syscolumns where id=OBJECT_ID('MonitoredSQLServers') and name='HealthIndexCoefficientForInformationalAlert' collate database_default))	
	BEGIN
		ALTER TABLE [MonitoredSQLServers] 
		ADD	[HealthIndexCoefficientForInformationalAlert] int default 1 not null
	END
	--END upgrade to 9.1 (Sanjali Makkar): Configurable Coefficients for Health Index  --   new columns for the table
	--START upgrade to  9.1 (Ankit Srivastava): Query Monitor 9.0 Improvement feedback - adding new columns for uery monitoring extended event session configuration
	IF (not exists(select id from syscolumns where id=OBJECT_ID('MonitoredSQLServers') and name='QueryMonitorXEFileSizeMB' collate database_default))	
	BEGIN
		ALTER TABLE [MonitoredSQLServers] 
		ADD
	[QueryMonitorXEFileSizeMB] int default 20 Check ([QueryMonitorXEFileSizeMB] > -1) not null,
	[QueryMonitorXEFilesRollover] int default 5 Check ([QueryMonitorXEFilesRollover] > -1) not null
	END
	--END upgrade to  9.1 (Ankit Srivastava): Query Monitor 9.0 Improvement feedback - adding new columns for uery monitoring extended event session configuration
	
	--upgrade to 10.0 (Vandana Gogna): Add friendly names

	

END
go

if (exists(select id from syscolumns where id =  object_id('MonitoredSQLServers') and name = 'QueryMonitorExcludeProfiler' collate database_default))
	begin
		declare @SQLServerID int, @xmlstring nvarchar(2000), @lenstring int, @cmd nvarchar(2000)
		create table #UpgradeColumns(SQLServerID int, [QueryMonitorExcludeProfiler] bit, [QueryMonitorExcludeDMO] bit, [QueryMonitorExcludeAgent] bit)
		select @cmd = 'select SQLServerID, isnull([QueryMonitorExcludeProfiler],0), isnull([QueryMonitorExcludeDMO],0), isnull([QueryMonitorExcludeAgent],0) from MonitoredSQLServers'
		insert into #UpgradeColumns
			exec (@cmd)
		select @SQLServerID = min(SQLServerID) from #UpgradeColumns
		while isnull(@SQLServerID,0) > 0
		begin
			set @xmlstring= null
			if (select cast(isnull([QueryMonitorAdvancedConfiguration],'') as nvarchar(2000)) from MonitoredSQLServers where SQLServerID = @SQLServerID) = ''
			begin
				set @xmlstring = '<?xml version="1.0" encoding="utf-16"?><AdvancedQueryMonitorConfiguration xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><ApplicationExcludeLike>'
				set @lenstring = len(@xmlstring)
				if (select isnull([QueryMonitorExcludeProfiler],0) from #UpgradeColumns where SQLServerID = @SQLServerID) > 0
					set @xmlstring = @xmlstring + '<Like>SQLProfiler%</Like>'
				if (select isnull([QueryMonitorExcludeDMO],0) from #UpgradeColumns where SQLServerID = @SQLServerID) > 0
					set @xmlstring = @xmlstring + '<Like>SQLDMO%</Like>'
				if (select isnull([QueryMonitorExcludeAgent],0) from #UpgradeColumns where SQLServerID = @SQLServerID) > 0
					set @xmlstring = @xmlstring + '<Like>SQLAgent%</Like>'
				if len(@xmlstring) > @lenstring
					set @xmlstring = @xmlstring + '</ApplicationExcludeLike></AdvancedQueryMonitorConfiguration>'
				else
					set @xmlstring = null

				if @xmlstring is not null
					update MonitoredSQLServers
					set [QueryMonitorAdvancedConfiguration] = @xmlstring
					where SQLServerID = @SQLServerID
			end
			select @SQLServerID = min(SQLServerID) from #UpgradeColumns where SQLServerID > @SQLServerID
		end

		alter table MonitoredSQLServers drop constraint DF_MonitoredSQLServers_QueryMonitorExcludeProfiler
		alter table MonitoredSQLServers drop constraint DF_MonitoredSQLServers_QueryMonitorExcludeDMO
		alter table MonitoredSQLServers drop constraint DF_MonitoredSQLServers_QueryMonitorExcludeAgent

		alter table MonitoredSQLServers drop column [QueryMonitorExcludeProfiler] 
		alter table MonitoredSQLServers drop column [QueryMonitorExcludeDMO] 
		alter table MonitoredSQLServers drop column [QueryMonitorExcludeAgent]

		drop table #UpgradeColumns

	end

go
	--upgrade to 10.0 (Vandana Gogna): Add friendly names
	
	IF (not exists(select id from syscolumns where id=object_id('MonitoredSQLServers') and name = 'FriendlyServerName' collate database_default))
	BEGIN
		ALTER TABLE [MonitoredSQLServers]
			ADD [FriendlyServerName] [nvarchar](256) null
	END

----------------------------------------------------------------------

--START : SQLdm 10.0 (Rajesh) Predictive Analytics Changes
IF (OBJECT_ID('PrescriptiveRecommendationCategory') IS NULL)
BEGIN

CREATE TABLE [dbo].[PrescriptiveRecommendationCategory](
	[CategoryID] [int] NOT NULL,
	[Name] [nvarchar](100) NOT NULL,
	[ParentCategory] [int] NULL,
	[Description] [nvarchar](250) NULL,
 CONSTRAINT [PK_PrescriptiveRecommendationCategory] PRIMARY KEY CLUSTERED 
(
	[CategoryID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

END

--END : SQLdm 10.0 (Rajesh) Predictive Analytics Changes

----------------------------------------------------------------------

--START : SQLdm 10.0 (Rajesh) Predictive Analytics Changes

IF (OBJECT_ID('PrescriptiveRecommendation') IS NULL)
BEGIN
--START : SQLdm 10.0 (srishti) changing size of 4 columns(as follows) to accomadate data 
--Impact Explanation
--Info links
--Description
--Recommendation
--Problem Explanation
CREATE TABLE [dbo].[PrescriptiveRecommendation](
	[RecommendationID] [nvarchar](10) NOT NULL,
	[AdditionalConsiderations] [nvarchar](1500) NULL,
	[bitly] [nvarchar](500) NULL,
	[CategoryID] [int] NOT NULL,
	[ConfidenceFactor] [int] NULL,
	[Description] [nvarchar](4000) NULL,
	[Finding] [nvarchar](500) NULL,
	[ImpactExplanation] [nvarchar](4000) NULL,
	[ImpactFactor] [int] NULL,
	[InfoLinks] [nvarchar](4000) NULL,
	[PluralFormFinding] [nvarchar](500) NULL,
	[PluralFormImpactExplanation] [nvarchar](4000) NULL,
	[PluralFormRecommendation] [nvarchar](4000) NULL,
	[ProblemExplanation] [nvarchar](4000) NULL,
	[Recommendation] [nvarchar](max) NULL,
	[Relevance] [int] NULL,
	[Tags] [nvarchar](500) NULL,
	[IsActive] bit NOT NULL
 CONSTRAINT [PK_PrescripivetRecommendation] PRIMARY KEY CLUSTERED 
(
	[RecommendationID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]



ALTER TABLE [dbo].[PrescriptiveRecommendation]  WITH CHECK ADD  CONSTRAINT [FK_PrescriptiveRecommendation_PrescriptiveRecommendationCategory] FOREIGN KEY([CategoryID])
REFERENCES [dbo].[PrescriptiveRecommendationCategory] ([CategoryID])


ALTER TABLE [dbo].[PrescriptiveRecommendation] CHECK CONSTRAINT [FK_PrescriptiveRecommendation_PrescriptiveRecommendationCategory]


END

--END : SQLdm 10.0 (Rajesh) Predictive Analytics Changes

----------------------------------------------------------------------

--START : SQLdm 10.0 (Rajesh) Predictive Analytics Changes

IF (OBJECT_ID('PrescriptiveAnalyzerCategory') IS NULL)

BEGIN

CREATE TABLE [dbo].[PrescriptiveAnalyzerCategory](
	[ID] [int] NOT NULL,
	[Category]  [varchar](100) NOT NULL,
 CONSTRAINT [PK_PrescriptiveAnalyzerCategory] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]


END

--END : SQLdm 10.0 (Rajesh) Predictive Analytics Changes

----------------------------------------------------------------------

--START : SQLdm 10.0 (Rajesh) Predictive Analytics Changes

IF (OBJECT_ID('PrescriptiveAnalyzer') IS NULL)

BEGIN

CREATE TABLE [dbo].[PrescriptiveAnalyzer](
	[ID] [int] NOT NULL,
	[Name] [nvarchar](100) NULL,
	[AnalyzerCategoryID] [int] NOT NULL,
 CONSTRAINT [PK_PrescriptiveAnalyzer] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]


ALTER TABLE [dbo].[PrescriptiveAnalyzer]  WITH CHECK ADD  CONSTRAINT [FK_PrescriptiveAnalyzer_PrescriptiveAnalyzerCategory] FOREIGN KEY([AnalyzerCategoryID])
REFERENCES [dbo].[PrescriptiveAnalyzerCategory] ([ID])


ALTER TABLE [dbo].[PrescriptiveAnalyzer] CHECK CONSTRAINT [FK_PrescriptiveAnalyzer_PrescriptiveAnalyzerCategory]



END

--END : SQLdm 10.0 (Rajesh) Predictive Analytics Changes


--START : SQLdm 10.0 (srishti purohit) Predictive Analytics types
IF (OBJECT_ID('PrescriptiveAnalysisType') IS NULL)
BEGIN

CREATE TABLE [dbo].[PrescriptiveAnalysisType](
	[AnalysisTypeID] [int] NOT NULL,
	[AnalysisType] [nvarchar](100) NOT NULL,
 CONSTRAINT [PK_PrescriptiveAnalysisType] PRIMARY KEY CLUSTERED 
(
	[AnalysisTypeID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

END

--END : SQLdm 10.0 (srishti purohit) Predictive Analytics types

----------------------------------------------------------------------

--START : SQLdm 10.0 (Rajesh) Predictive Analytics Changes

IF (OBJECT_ID('PrescriptiveAnalysis') IS NULL)

BEGIN

CREATE TABLE [dbo].[PrescriptiveAnalysis](
	[AnalysisID] [int] IDENTITY(1,1) NOT NULL,
	[SQLServerID] [int] NOT NULL,
	[UTCAnalysisStartTime] [datetime] NULL,
	[UTCAnalysisCompleteTime] [datetime] NULL,
	[RecommendationCount] [int] NULL,
	--To check which type trigger the analysis
	[AnalysisTypeID] [int] NOT NULL,
	[RecordCreatedTimestamp] [datetime] NULL,
	[RecordUpdateDateTimestamp] [datetime] NULL,
 CONSTRAINT [PK_PrescriptiveAnalysis] PRIMARY KEY CLUSTERED 
(
	[AnalysisID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

ALTER TABLE [dbo].[PrescriptiveAnalysis]  WITH CHECK ADD  CONSTRAINT [FK_PrescriptiveAnalysis_PrescriptiveAnalysisType] FOREIGN KEY([AnalysisTypeID])
REFERENCES [dbo].[PrescriptiveAnalysisType] ([AnalysisTypeID])

END

--END : SQLdm 10.0 (Rajesh) Predictive Analytics Changes

----------------------------------------------------------------------


IF (OBJECT_ID('PrescriptiveAnalysisDetails') IS NULL)
BEGIN

CREATE TABLE [dbo].[PrescriptiveAnalysisDetails](
	[PrescriptiveAnalysisDetailsID] [int] IDENTITY(1,1) NOT NULL,
	[AnalysisID] [int] NOT NULL,
	[AnalyzerID] [int] NOT NULL,
	[Status] [int] NULL,
	[RecommendationCount] [int] NULL,
	[RecordCreatedTimestamp] [datetime] NULL,
	[RecordUpdateDateTimestamp] [datetime] NULL,
 CONSTRAINT [PK_PrescriptiveAnalysisDetails] PRIMARY KEY CLUSTERED 
(
	[PrescriptiveAnalysisDetailsID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]


ALTER TABLE [dbo].[PrescriptiveAnalysisDetails]  WITH CHECK ADD  CONSTRAINT [FK_PrescriptiveAnalysisDetails_PrescriptiveAnalysis] FOREIGN KEY([AnalysisID])
REFERENCES [dbo].[PrescriptiveAnalysis] ([AnalysisID]) ON DELETE CASCADE;

ALTER TABLE [dbo].[PrescriptiveAnalysisDetails] CHECK CONSTRAINT [FK_PrescriptiveAnalysisDetails_PrescriptiveAnalysis]

ALTER TABLE [dbo].[PrescriptiveAnalysisDetails]  WITH CHECK ADD  CONSTRAINT [FK_PrescriptiveAnalysisDetails_PrescriptiveAnalyzer] FOREIGN KEY([AnalyzerID])
REFERENCES [dbo].[PrescriptiveAnalyzer] ([ID])

ALTER TABLE [dbo].[PrescriptiveAnalysisDetails] CHECK CONSTRAINT [FK_PrescriptiveAnalysisDetails_PrescriptiveAnalyzer]


--END : SQLdm 10.0 (srishti) To support grooming



END

--END : SQLdm 10.0 (Rajesh) Predictive Analytics Changes

----------------------------------------------------------------------

--START : SQLdm 10.0 (Rajesh) Predictive Analytics Changes
--OptimiztionExecutionStatusMasterTable
IF (OBJECT_ID('PrescriptiveOptimiztionExecutionStatus') IS NULL)
BEGIN
	CREATE TABLE [PrescriptiveOptimiztionExecutionStatus](
		 [ID] [int] NOT NULL,
		 [Status] [nvarchar](100) NOT NULL,
		 [Description] [nvarchar](250) NULL,
		 
		CONSTRAINT [pk_PrescriptiveOptimiztionExecutionStatusID] PRIMARY KEY CLUSTERED 
		(
			[ID] ASC
		))
END

IF (OBJECT_ID('PrescriptiveAnalysisRecommendation') IS NULL)
BEGIN

CREATE TABLE [dbo].[PrescriptiveAnalysisRecommendation](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[RecommendationID] [nvarchar](10) NOT NULL,
	----Removing Columns which are directly referenced from PrescriptiveRecommendation
	--[RankID] [int] NULL, removed due to not useful
	[ComputedRankFactor] [float] NULL,
	--[Relevance] [decimal](18, 0) NULL,
	[PrescriptiveAnalysisDetailsID] [int] NULL,
	--[Description] [nvarchar](4000) NULL,
	--[Finding] [nvarchar](500) NULL,
	--[ImpactExplanation] [nvarchar](4000) NULL,
	--[ProblemExplanation] [nvarchar](4000) NULL,
    --[Recommendation] [nvarchar](max) NULL,
	[IsFlagged] [bit] NULL,
	[OptimizationStatusID] [INT] NOT NULL,	
	[OptimizationErrorMessage] [nvarchar](max) NULL,
 CONSTRAINT [PK_PrescriptiveAnalysisRecommendation] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]


ALTER TABLE [dbo].[PrescriptiveAnalysisRecommendation]  WITH CHECK ADD  CONSTRAINT [FK_PrescriptiveAnalysisRecommendation_PrescriptiveRecommendation] FOREIGN KEY([PrescriptiveAnalysisDetailsID])
REFERENCES [dbo].[PrescriptiveAnalysisDetails] ([PrescriptiveAnalysisDetailsID]) ON DELETE CASCADE;

ALTER TABLE [dbo].[PrescriptiveAnalysisRecommendation] CHECK CONSTRAINT [FK_PrescriptiveAnalysisRecommendation_PrescriptiveRecommendation]

ALTER TABLE [dbo].[PrescriptiveAnalysisRecommendation]  WITH CHECK ADD  CONSTRAINT [FK_PrescriptiveAnalysisRecommendation_PrescriptiveRecommendation1] FOREIGN KEY([RecommendationID])
REFERENCES [dbo].[PrescriptiveRecommendation] ([RecommendationID])


ALTER TABLE [dbo].[PrescriptiveAnalysisRecommendation] CHECK CONSTRAINT [FK_PrescriptiveAnalysisRecommendation_PrescriptiveRecommendation1]

ALTER TABLE [dbo].[PrescriptiveAnalysisRecommendation]  WITH CHECK ADD  CONSTRAINT [FK_OptimizationID] FOREIGN KEY([OptimizationStatusID])
REFERENCES [dbo].PrescriptiveOptimiztionExecutionStatus ([ID])
ALTER TABLE [dbo].[PrescriptiveAnalysisRecommendation] CHECK CONSTRAINT [FK_OptimizationID]

END
--END : SQLdm 10.0 (Rajesh) Predictive Analytics Changes

----------------------------------------------------------------------

IF (OBJECT_ID('ServerStatistics') IS NULL)
BEGIN

CREATE TABLE  [ServerStatistics] 
	(
	[SQLServerID] [int] NOT NULL ,
	[UTCCollectionDateTime] [datetime] NOT NULL ,
	[TimeDeltaInSeconds] [float] NOT NULL ,
	[AgentServiceStatus] [int] NULL,
    [SqlServerServiceStatus] [int] NULL,
    [DTCServiceStatus] [int] NULL,
    [FullTextSearchStatus] [int] NULL,
	[BufferCacheHitRatioPercentage] [float] NULL,
	[CheckpointWrites] [bigint] NULL,
	[ClientComputers] [int] NULL,
	[CPUActivityPercentage] [float] NULL,
	[CPUTimeDelta] [bigint] NULL,
	[CPUTimeRaw] [bigint] NULL,
	[FullScans] [bigint] NULL,
	[IdleTimeDelta] [bigint] NULL,
	[IdleTimePercentage] [float] NULL,
	[IdleTimeRaw] [bigint] NULL,
	[IOActivityPercentage] [float] NULL,
	[IOTimeDelta] [bigint] NULL,
	[IOTimeRaw] [bigint] NULL,
	[LazyWriterWrites] [bigint] NULL,
	[LockWaits] [bigint] NULL,
	[Logins] [bigint] NULL,
	[LogFlushes] [bigint] NULL,
	[SqlMemoryAllocatedInKilobytes] [bigint] NULL,
	[SqlMemoryUsedInKilobytes] [bigint] NULL,
	[OldestOpenTransactionsInMinutes] [bigint] NULL,
	[PacketErrors] [bigint] NULL,
	[PacketsReceived] [bigint] NULL,
	[PacketsSent] [bigint] NULL,
	[PageErrors] [bigint] NULL,
	[PageLifeExpectancy] [bigint] NULL,
	[PageLookups] [bigint] NULL,
	[PageReads] [bigint] NULL,
	[PageSplits] [bigint] NULL,
	[PageWrites] [bigint] NULL,
	[ProcedureCacheHitRatioPercentage] [float] NULL,
	[ProcedureCacheSizeInKilobytes] [bigint] NULL,
	[ProcedureCacheSizePercent] [float] NULL,
	[ReadAheadPages] [bigint] NULL,
	[ReplicationLatencyInSeconds] [float] NULL,
	[DistributionLatencyInSeconds] [float] NULL,
	[ReplicationSubscribed] [bigint] NULL,
	[ReplicationUndistributed] [bigint] NULL,
	[ReplicationUnsubscribed] [bigint] NULL,
	[ResponseTimeInMilliseconds] [int] NULL,
	[ServerVersion] [nvarchar](30) NULL,
	[SqlCompilations] [bigint] NULL,
	[SqlRecompilations] [bigint] NULL,
	[TableLockEscalations] [bigint] NULL,
	[TempDBSizeInKilobytes] [bigint] NULL,
	[TempDBSizePercent] [float] NULL,
	[Batches] [bigint] NULL,
	[UserProcesses] [int] NULL,
	[WorkFilesCreated] [bigint] NULL,
	[WorkTablesCreated] [bigint] NULL,
	[SystemProcesses] [int] NULL,
	[UserProcessesConsumingCPU] [int] NULL, 
	[SystemProcessesConsumingCPU] [int] NULL, 
	[BlockedProcesses] [int] NULL, 
	[OpenTransactions] [int] NULL,
	[DatabaseCount] [int] NULL,
	[DataFileCount] [int] NULL,
	[LogFileCount] [int] NULL,
	[DataFileSpaceAllocatedInKilobytes] [decimal] NULL,
	[DataFileSpaceUsedInKilobytes] [decimal] NULL,
	[LogFileSpaceAllocatedInKilobytes] [decimal] NULL,
	[LogFileSpaceUsedInKilobytes] [decimal] NULL,
	[TotalLocks] [decimal] NULL,
	[BufferCacheSizeInKilobytes] [bigint] NULL,
	[ActiveProcesses] [int] NULL,
	[LeadBlockers] [int] NULL,
	[CommittedInKilobytes] [bigint] NULL,
	[ConnectionMemoryInKilobytes] [bigint] NULL,
	[FreePagesInKilobytes] [bigint] NULL,
	[GrantedWorkspaceMemoryInKilobytes] [bigint] NULL,
	[LockMemoryInKilobytes] [bigint] NULL,
	[OptimizerMemoryInKilobytes] [bigint] NULL,
	[TotalServerMemoryInKilobytes] [bigint] NULL,
	[FreeCachePagesInKilobytes] [bigint] NULL,
	[CachePagesInKilobytes] [bigint] NULL,
	[MaxConnections] [bigint] NULL,
	[PhysicalMemoryInKilobytes] [bigint] NULL,
	[ProcessorCount] [int] NULL,
	[ProcessorsUsed] [int] NULL,
	[ProcessorType]  [nvarchar](20) NULL,
	[ServerHostName] [nvarchar](50) NULL,
	[RealServerName] [nvarchar](100) NULL,
	[WindowsVersion] [nvarchar](128) NULL,
	[SqlServerEdition] [nvarchar](30) NULL,
	[RunningSince] [datetime] NULL,
	[IsClustered] [bit] NULL,
	[ClusterNodeName] [nvarchar](256) NULL,
	[OsStatisticAvailability] [nvarchar](50) NULL,
	[Transactions] [bigint] NULL,
	[VersionStoreGenerationKilobytes] [bigint] NULL,
	[VersionStoreCleanupKilobytes] [bigint] NULL,
	[TempdbPFSWaitTimeMilliseconds] [bigint] NULL,
	[TempdbGAMWaitTimeMilliseconds] [bigint] NULL,
	[TempdbSGAMWaitTimeMilliseconds] [bigint] NULL,
	[SQLBrowserServiceStatus] [int] NULL,    --SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --add SQL browser service status column
	[SQLActiveDirectoryHelperServiceStatus] [int] NULL,  --SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --add SQL Active Directory Helper Service status column
	CONSTRAINT [PKServerStatistics] PRIMARY KEY CLUSTERED 
	(
		[SQLServerID],
		[UTCCollectionDateTime]
	),
	CONSTRAINT [FKServerStatisticsMonitoredSQLServers] FOREIGN KEY 
		(
		[SQLServerID]
		) 
	REFERENCES  [MonitoredSQLServers] 
		(
		[SQLServerID]
		) on delete cascade
	)
	-- 6.0 added for new installs (grooming job handles upgrade installs)
	CREATE INDEX [IXServerStatistics] ON [ServerStatistics]([SQLServerID],[UTCCollectionDateTime]) 
END
ELSE
BEGIN
	-- upgrade to 5.5.0
	IF (not exists(select id from syscolumns where id = object_id('ServerStatistics') and name = 'ActiveProcesses' collate database_default)) 
	BEGIN
		ALTER TABLE [ServerStatistics] 
			ADD 
			[ActiveProcesses] [int] NULL,
			[LeadBlockers] [int] NULL,
			[CommittedInKilobytes] [bigint] NULL,
			[ConnectionMemoryInKilobytes] [bigint] NULL,
			[FreePagesInKilobytes] [bigint] NULL,
			[GrantedWorkspaceMemoryInKilobytes] [bigint] NULL,
			[LockMemoryInKilobytes] [bigint] NULL,
			[OptimizerMemoryInKilobytes] [bigint] NULL,
			[TotalServerMemoryInKilobytes] [bigint] NULL,
			[FreeCachePagesInKilobytes] [bigint] NULL,
			[CachePagesInKilobytes] [bigint] NULL,
			[MaxConnections] [bigint] NULL,
			[PhysicalMemoryInKilobytes] [bigint] NULL,
			[ProcessorCount] [int] NULL,
			[ProcessorsUsed] [int] NULL,
			[ProcessorType]  [nvarchar](20) NULL,
			[ServerHostName] [nvarchar](50) NULL,
			[RealServerName] [nvarchar](100) NULL,
			[WindowsVersion] [nvarchar](128) NULL,
			[SqlServerEdition] [nvarchar](30) NULL,
			[RunningSince] [datetime] NULL,
			[IsClustered] [bit] NULL,
			[OsStatisticAvailability] [nvarchar](50) NULL
	END
	-- upgrade to 6.1
	IF (not exists(select id from syscolumns where id = object_id('ServerStatistics') and name = 'ClusterNodeName' collate database_default)) 
	BEGIN
		ALTER TABLE [ServerStatistics] 
			ADD [ClusterNodeName] [nvarchar](256) NULL
	END
	IF (not exists(select id from syscolumns where id = object_id('ServerStatistics') and name = 'DistributionLatencyInSeconds' collate database_default)) 
	BEGIN
		ALTER TABLE [ServerStatistics] 
			ADD [DistributionLatencyInSeconds] [float] NULL
	END
	if (not exists(select object_id from sys.columns where object_id = object_id('ServerStatistics') and name = 'VersionStoreGenerationKilobytes' collate database_default))
	begin
		exec sp_rename 'ServerStatistics.Transactions', 'Batches', 'COLUMN';

		ALTER TABLE [ServerStatistics] 
			ADD 
			[Transactions] [bigint] NULL,
			[VersionStoreGenerationKilobytes] [bigint] NULL,
				[VersionStoreCleanupKilobytes] [bigint] NULL,
				[TempdbPFSWaitTimeMilliseconds] [bigint] NULL,
				[TempdbGAMWaitTimeMilliseconds] [bigint] NULL,
				[TempdbSGAMWaitTimeMilliseconds] [bigint] NULL
	end
	--START: SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --add new SQL service status columns
	IF (not exists(select id from syscolumns where id = object_id('ServerStatistics') and name = 'SQLBrowserServiceStatus' collate database_default)) 
	BEGIN
		ALTER TABLE [ServerStatistics] 
			ADD [SQLBrowserServiceStatus] [int] NULL
	END

	IF (not exists(select id from syscolumns where id = object_id('ServerStatistics') and name = 'SQLActiveDirectoryHelperServiceStatus' collate database_default)) 
	BEGIN
		ALTER TABLE [ServerStatistics] 
			ADD [SQLActiveDirectoryHelperServiceStatus] [int] NULL
	END
	--END: SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --add new SQL service status columns
END

----------------------------------------------------------------------

IF (OBJECT_ID('OSStatistics') IS NULL)
BEGIN

CREATE TABLE  [OSStatistics] 
	(
	[SQLServerID] [int] NOT NULL ,
	[UTCCollectionDateTime] [datetime] NOT NULL ,
	[OSTotalPhysicalMemoryInKilobytes] [bigint] NULL,
	[OSAvailableMemoryInKilobytes] [bigint] NULL,
	[PagesPerSecond] [float] NULL,
	[ProcessorTimePercent] [float] NULL,
	[PrivilegedTimePercent] [float] NULL,
	[UserTimePercent] [float] NULL,	
	[ProcessorQueueLength] [float] NULL,
	[DiskTimePercent] [float] NULL,
	[DiskQueueLength] [float] NULL,
	CONSTRAINT [PKOSStatistics] PRIMARY KEY CLUSTERED 
	(
		[SQLServerID],
		[UTCCollectionDateTime]
	),
	CONSTRAINT [FKSOSStatisticsMonitoredSQLServers] FOREIGN KEY 
		(
		[SQLServerID]
		) 
	REFERENCES  [MonitoredSQLServers] 
		(
		[SQLServerID]
		) on delete cascade
	)

END

----------------------------------------------------------------------

IF (OBJECT_ID('QueryMonitor') IS NOT NULL)
BEGIN

IF (not exists(select id from syscolumns where id = object_id('QueryMonitor') and name = 'Spid' collate database_default)) 
begin
	ALTER TABLE [QueryMonitor]
			ADD Spid [int] NULL
end

IF (not exists(select id from syscolumns where id = object_id('QueryMonitor') and name = 'DeleteFlag' collate database_default)) 
begin
	ALTER TABLE [QueryMonitor]
			ADD DeleteFlag [bit] NULL
end


END

----------------------------------------------------------------------

IF (OBJECT_ID('SQLServerDatabaseNames') IS NULL)
BEGIN
CREATE TABLE  [SQLServerDatabaseNames] 
	(
	[DatabaseID] [int] IDENTITY NOT NULL ,
	[SQLServerID] [int] NOT NULL ,
	[DatabaseName] [nvarchar] (255) NOT NULL,
	[SystemDatabase] [bit] NOT NULL,
	[CreationDateTime] [datetime] DEFAULT NULL
	CONSTRAINT [PKSQLServerDatabaseNames] PRIMARY KEY CLUSTERED 
	(
		[DatabaseID]
	), 
	CONSTRAINT [FKSQLServerDatabaseNamesMonitoredSQLServers] FOREIGN KEY 
		(		
		[SQLServerID]	
		) 
	REFERENCES  [MonitoredSQLServers] 
		(
		[SQLServerID]
		) on delete cascade
	)

CREATE INDEX [IXSQLServerDatabaseNames] ON [SQLServerDatabaseNames]([SQLServerID],[DatabaseName]) 
END
ELSE
BEGIN
	IF (not exists(select id from syscolumns where id=object_id('SQLServerDatabaseNames') and name = 'CreationDateTime' collate database_default))
	BEGIN
		ALTER TABLE [SQLServerDatabaseNames]
			ADD [CreationDateTime] [datetime] DEFAULT NULL	
	END
END

if not exists(select * from sys.indexes where name = 'IXSQLServerDatabaseNameServerIDDBNameInclDBID')
Begin
	CREATE NONCLUSTERED INDEX [IXSQLServerDatabaseNameServerIDDBNameInclDBID] ON [dbo].[SQLServerDatabaseNames] 
	(
		[SQLServerID] ASC,
		[DatabaseName] ASC
	)
	INCLUDE ( [DatabaseID]) ON [PRIMARY]
end

if not exists(select * from sys.indexes where name = 'IXSQLServerDatabaseNamesServerIDDBID')
Begin
	CREATE NONCLUSTERED INDEX [IXSQLServerDatabaseNamesServerIDDBID] ON [dbo].[SQLServerDatabaseNames] 
	(
		[SQLServerID] ASC,
		[DatabaseID] ASC
	) ON [PRIMARY]
end

----------------------------------------------------------------------


IF (OBJECT_ID('DatabaseFiles') IS NULL)
BEGIN
CREATE TABLE  [DatabaseFiles] 
	(
	[FileID]  [int] IDENTITY NOT NULL ,
	[DatabaseID] [int] NOT NULL ,
	[FileName] [nvarchar](255),
	[FileType] [int],
	[FilePath] [nvarchar](MAX), --Update by Gaurav Karwal to accommodate new data
	[DriveName] [nvarchar](256),
	-- SQLdm 9.1 (Abhishek Joshi) -Filegroup improvements -add column for filegroup name
	[FileGroupName] [nvarchar](4000),
	CONSTRAINT [PKDatabaseFiles] PRIMARY KEY  CLUSTERED 
		(
		[FileID]
		), 
	CONSTRAINT [FKDatabaseFilesSQLServerDatabaseNames] FOREIGN KEY 
		(
		[DatabaseID]
		) 
	REFERENCES  [SQLServerDatabaseNames] 
		(
		[DatabaseID]
		)  on delete cascade
	)
END
--START: SQLdm 9.1 (Abhishek Joshi) -Filegroup improvements -add FileGroupName column if table already exists
ELSE
BEGIN
	if not exists(select name from sys.columns where object_id = object_id('DatabaseFiles') and name=N'FileGroupName' collate database_default )
	BEGIN
		alter table [DatabaseFiles]
			add [FileGroupName] [nvarchar](4000)
	END
	--Gaurav Karwal SQLdm 9.1: For accommodating screwed up file paths
	if exists(select name from sys.columns where object_id = object_id('DatabaseFiles') and name=N'FilePath' collate database_default )
	BEGIN
		alter table [DatabaseFiles]
			alter column [FilePath] [nvarchar](MAX)
	END
END
--END: SQLdm 9.1 (Abhishek Joshi) -Filegroup improvements -add FileGroupName column if table already exists


----------------------------------------------------------------------



IF (OBJECT_ID('DatabaseFileActivity') IS NULL)
BEGIN
CREATE TABLE  [DatabaseFileActivity] 
	(
	[FileID] [int] NOT NULL ,
	[UTCCollectionDateTime] [datetime] NOT NULL,
	[Reads] [bigint],
	[Writes] [bigint],
	[TimeDeltaInSeconds] [float],
	CONSTRAINT [PKDatabaseFileActivity] PRIMARY KEY CLUSTERED 
		(
		[UTCCollectionDateTime],
		[FileID]
		), 
	CONSTRAINT [FKDatabaseFileActivityDatabaseFiles] FOREIGN KEY 
		(
		[FileID]
		) 
	REFERENCES  [DatabaseFiles] 
		(
		[FileID]
		)  on delete cascade
	)
END



----------------------------------------------------------------------

IF (OBJECT_ID('TempdbFileData') IS NULL)
BEGIN
CREATE TABLE  [TempdbFileData] 
	(
	[FileID] [int] NOT NULL ,
	[UTCCollectionDateTime] [datetime] NOT NULL,
	[FileSizeInKilobytes] [bigint],
	[UserObjectsInKilobytes] [bigint],
	[InternalObjectsInKilobytes] [bigint],
	[VersionStoreInKilobytes] [bigint],
	[MixedExtentsInKilobytes] [bigint],
	[UnallocatedSpaceInKilobytes] [bigint],
	[TimeDeltaInSeconds] [float],
	CONSTRAINT [PKTempdbFileData] PRIMARY KEY CLUSTERED 
		(
		[UTCCollectionDateTime],
		[FileID]
		), 
	CONSTRAINT [FKTempdbFileActivityDatabaseFiles] FOREIGN KEY 
		(
		[FileID]
		) 
	REFERENCES  [DatabaseFiles] 
		(
		[FileID]
		)  on delete cascade
	)
END

----------------------------------------------------------------------

-- upgrade to 7.5
if (exists(select object_id from sys.columns where object_id = object_id('DatabaseStatistics') and name = 'DataFileSizeInKilobytes' collate database_default)) 
BEGIN
	-- upgrade to 6.0
	IF (not exists(select id from syscolumns where id = object_id('DatabaseStatistics') and name = 'NumberReads' collate database_default)) 
	BEGIN
		ALTER TABLE [DatabaseStatistics] 
			ADD
			[NumberReads] [decimal] NULL,
			[NumberWrites] [decimal] NULL,
			[BytesRead] [decimal] NULL,
			[BytesWritten] [decimal] NULL,
			[IoStallMS] [decimal] NULL
	end
	
	declare @cmd nvarchar(1000)
	Set @cmd = (
    select N'drop index DatabaseStatistics.' + name + '; '
    from sys.indexes where object_id = object_id('DatabaseStatistics') and type > 1
    for xml path(''))
    
    exec sp_executesql @cmd

	exec sp_rename 'FKDatabaseStatisticsSQLServerDatabaseNames','FKDatabaseStatisticsSQLServerDatabaseNames_upgrade'
	exec sp_rename 'DatabaseStatistics','DatabaseStatistics_upgrade'
	exec sp_rename 'PKDatabaseStatistics','PKDatabaseStatistics_upgrade'
	
END


IF (OBJECT_ID('DatabaseStatistics') IS NULL)
BEGIN
	CREATE TABLE  [DatabaseStatistics] 
		(
		[DatabaseStatisticsID] [bigint] IDENTITY(-9223372036854775808,1) UNIQUE CLUSTERED,
		[DatabaseID] [int] NOT NULL ,
		[UTCCollectionDateTime] [datetime] NOT NULL,
		[DatabaseStatus] [int] NULL,
		[Transactions] [bigint] NULL ,
		[LogFlushWaits] [bigint] NULL ,
		[LogFlushes] [bigint] NULL ,
		[LogKilobytesFlushed] [bigint] NULL ,
		[LogCacheReads] [bigint] NULL ,
		[LogCacheHitRatio] [float] NULL ,
		[TimeDeltaInSeconds] [float],
		[NumberReads] [decimal] NULL,
		[NumberWrites] [decimal] NULL,
		[BytesRead] [decimal] NULL,
		[BytesWritten] [decimal] NULL,
		[IoStallMS] [decimal] NULL,
		[DatabaseSizeTime] [datetime] NULL,
		[LastBackupDateTime] [datetime] NULL -- SQLdm 10.0 (Vandana Gogna) - Database backup alerts
		CONSTRAINT [PKDatabaseStatistics] PRIMARY KEY NONCLUSTERED 
			(
			[DatabaseID],
			[UTCCollectionDateTime]
			), 
		CONSTRAINT [FKDatabaseStatisticsSQLServerDatabaseNames] FOREIGN KEY 
			(
			[DatabaseID]
			) 
		REFERENCES  [SQLServerDatabaseNames] 
			(
			[DatabaseID]
			)  on delete cascade
		)
	

END
--START SQLdm 10.0 (Vandana Gogna) - Database backup alerts
ELSE
BEGIN
	IF (not exists(select id from syscolumns where id = object_id('DatabaseStatistics') and name = 'LastBackupDateTime' collate database_default)) 
	BEGIN
		ALTER TABLE [DatabaseStatistics] 
			ADD
			[LastBackupDateTime] [datetime] NULL
	END
END
--END SQLdm 10.0 (Vandana Gogna) - Database backup alerts

IF (OBJECT_ID('stageDatabaseStatistics') IS NULL)
BEGIN
	CREATE TABLE [dbo].[stageDatabaseStatistics]
	(
		[SourceID] [uniqueidentifier] NOT NULL,
		[ServerID] [int] NOT NULL,
		[DatabaseName] [nvarchar](255) NOT NULL,
		[SystemDatabase] [bit] NOT NULL,
		[UTCCollectionDateTime] [datetime] NOT NULL,
		[DatabaseStatus] [int] NULL,
		[Transactions] [bigint] NULL,
		[LogFlushWaits] [bigint] NULL,
		[LogFlushes] [bigint] NULL,
		[LogKilobytesFlushed] [bigint] NULL,
		[LogCacheReads] [bigint] NULL,
		[LogCacheHitRatio] [float] NULL,
		[TimeDeltaInSeconds] [float] NULL,
		[NumberReads] [decimal](18, 0) NULL,
		[NumberWrites] [decimal](18, 0) NULL,
		[BytesRead] [decimal](18, 0) NULL,
		[BytesWritten] [decimal](18, 0) NULL,
		[IoStallMS] [decimal](18, 0) NULL,
		[DatabaseCreateDate] [datetime] NULL,
		[LastBackupDateTime] [datetime] NULL -- SQLdm 10.0 (Vandana Gogna) - Database backup alerts
	)
END
ELSE
BEGIN
	--START SQLdm 10.0 (Vandana Gogna) - Database backup alerts
	IF (not exists(select id from syscolumns where id = object_id('stageDatabaseStatistics') and name = 'LastBackupDateTime' collate database_default)) 
	BEGIN
		ALTER TABLE [stageDatabaseStatistics] 
			ADD
			[LastBackupDateTime] [datetime] NULL
	END
END
--END SQLdm 10.0 (Vandana Gogna) - Database backup alerts

IF NOT EXISTS(SELECT * FROM sys.indexes WHERE name = 'IXSourceServerIDUTCCollectionTime' )
Begin
	CREATE NONCLUSTERED INDEX [IXSourceServerIDUTCCollectionTime] ON [dbo].[stageDatabaseStatistics] 
	(
		[SourceID] ASC,
		[ServerID] ASC,
		[UTCCollectionDateTime] ASC
	) ON [PRIMARY]
End

IF NOT EXISTS(SELECT * FROM sys.indexes WHERE name = 'IXSourceIDIncServerDBNameSystemCreate' )
Begin
	CREATE NONCLUSTERED INDEX [IXSourceIDIncServerDBNameSystemCreate] ON [dbo].[stageDatabaseStatistics] 
	(
		[SourceID] ASC
	)
	INCLUDE ([ServerID],
		[DatabaseName],
		[SystemDatabase],
		[DatabaseCreateDate]) ON [PRIMARY]
END

-- In case of upgrade this table may be re-created in p_PostInstallUpgrade
IF (OBJECT_ID('DatabaseSize') IS NULL)
BEGIN
	CREATE TABLE  [DatabaseSize] 
	(
		[DatabaseSizeID] [bigint] IDENTITY(-9223372036854775808,1) UNIQUE CLUSTERED,
		[DatabaseID] [int] NOT NULL ,
		[UTCCollectionDateTime] [datetime] NOT NULL,
		[DatabaseStatus] [int] NULL,
		[DataFileSizeInKilobytes] [decimal] NULL,
		[LogFileSizeInKilobytes] [decimal] NULL,
		[DataSizeInKilobytes] [decimal] NULL,
		[LogSizeInKilobytes] [decimal] NULL,
		[TextSizeInKilobytes] [decimal] NULL,
		[IndexSizeInKilobytes] [decimal] NULL,
		[LogExpansionInKilobytes] [decimal] NULL,
		[DataExpansionInKilobytes] [decimal] NULL,
		[PercentLogSpace] [float] NULL,
		[PercentDataSize] [float] NULL,
		[TimeDeltaInSeconds] [float],
		[DatabaseStatisticsTime] [datetime] NULL,
		CONSTRAINT [PKDatabaseSize] PRIMARY KEY NONCLUSTERED 
			(
			[DatabaseID],
			[UTCCollectionDateTime]
			), 
		CONSTRAINT [FKDatabaseSizeSQLServerDatabaseNames] FOREIGN KEY 
			(
			[DatabaseID]
			) 
		REFERENCES  [SQLServerDatabaseNames] 
			(
			[DatabaseID]
			)  on delete cascade
		)

	create index [IXDatabaseSizeUTCCollectionDateTime] ON [DatabaseSize] ([UTCCollectionDateTime]) include ([DatabaseID], [DataSizeInKilobytes], [TextSizeInKilobytes], [IndexSizeInKilobytes])

END

----------------------------------------------------------------------

IF (OBJECT_ID('SQLServerTableNames') IS NULL)
BEGIN
CREATE TABLE  [SQLServerTableNames] 
	(
	[TableID] [int] IDENTITY NOT NULL ,
	[DatabaseID] [int] NOT NULL ,
	[TableName] [nvarchar] (255)   NOT NULL,
	[SchemaName] [nvarchar] (255) NOT NULL,
	[SystemTable] [bit] NOT NULL,
	CONSTRAINT [PKSQLServerTableNames] PRIMARY KEY  CLUSTERED 
	(
		[TableID]
	),  
	CONSTRAINT [FKSQLServerTableNamesSQLServerDatabaseNames] FOREIGN KEY 
		(
		[DatabaseID]
		) 
	REFERENCES  [SQLServerDatabaseNames] 
		(
		[DatabaseID]
		)  on delete cascade
	)

CREATE INDEX [IXSQLServerTableNames1] ON [SQLServerTableNames]([DatabaseID],[TableName]) 
	
END

----------------------------------------------------------------------

IF (OBJECT_ID('TableGrowth') IS NULL)
BEGIN
CREATE TABLE  [TableGrowth] 
	(
	[TableID] [int] NOT NULL ,
	[UTCCollectionDateTime] [datetime] NOT NULL ,
	[NumberOfRows] [bigint] NULL,
	[DataSize] [float] NULL,
	[TextSize] [float] NULL,
	[IndexSize] [float] NULL,
	[TimeDeltaInSeconds] [float] DEFAULT (86400),
	CONSTRAINT [PKTableGrowth] PRIMARY KEY  CLUSTERED 
	(
		[TableID],
		[UTCCollectionDateTime]
	),
	CONSTRAINT [FKTableGrowth] FOREIGN KEY 
		(
		[TableID]
		) 
	REFERENCES  [SQLServerTableNames] 
		(
		[TableID]
		)  on delete cascade
	)
END



IF (OBJECT_ID('TableReorganization') IS NULL)
BEGIN
CREATE TABLE  [TableReorganization] 
	(
	[TableID] [int] NOT NULL ,
	[UTCCollectionDateTime] [datetime] NOT NULL ,
	[ScanDensity] [float] NULL, 
	[LogicalFragmentation] [float] NULL, 
	[TimeDeltaInSeconds] [float] DEFAULT (86400),
	CONSTRAINT [PKTableReorganization] PRIMARY KEY  CLUSTERED 
	(
		[TableID],
		[UTCCollectionDateTime]
	),
	CONSTRAINT [FKTableReorganization] FOREIGN KEY 
		(
		[TableID]
		) 
	REFERENCES  [SQLServerTableNames] 
		(
		[TableID]
		)  on delete cascade
	)
END


----------------------------------------------------------------------

IF (OBJECT_ID('LicenseKeys') IS NULL)
BEGIN
CREATE TABLE [LicenseKeys](
	[LicenseID] [uniqueidentifier] NOT NULL,
	[LicenseKey] [nvarchar](255) NOT NULL,
	[DateAddedUtc] [datetime] NOT NULL,
	CONSTRAINT [PKLicenseKeys] PRIMARY KEY CLUSTERED 
	(
		[LicenseID]
	)
)

	CREATE UNIQUE INDEX [IXLicenseKeys] ON [LicenseKeys]([LicenseKey]) 

END

IF (OBJECT_ID('NotificationRules') IS NULL)
BEGIN
CREATE TABLE [NotificationRules](
	[RuleID] [uniqueidentifier] NOT NULL,
	[SerializedObject] [nvarchar] (max) NOT NULL,
	CONSTRAINT [PKNotificationRules] PRIMARY KEY CLUSTERED 
	(
		[RuleID] ASC
	)
)
END
ELSE
BEGIN
	IF (not exists(select sc.object_id from sys.columns sc inner join sys.types st on sc.system_type_id = st.system_type_id
		where object_id=OBJECT_ID('NotificationRules') 
		and sc.name='SerializedObject' and lower(st.name) = 'nvarchar'  collate database_default))
	begin
		alter table NotificationRules alter column SerializedObject nvarchar(max) NOT NULL
	END
END

IF (OBJECT_ID('NotificationProviders') IS NULL)
BEGIN
CREATE TABLE [NotificationProviders](
	[ProviderId] [uniqueidentifier] NOT NULL,
	[SerializedType] [nvarchar] (64) NOT NULL,
	[SerializedObject] [nvarchar] (max) NOT NULL,
	CONSTRAINT [PKNotificationProviders] PRIMARY KEY CLUSTERED 
	(
		[ProviderId] ASC
	)
)
END
ELSE
BEGIN
IF (not exists(select sc.object_id from sys.columns sc inner join sys.types st on sc.system_type_id = st.system_type_id
		where object_id=OBJECT_ID('NotificationProviders') 
		and sc.name='SerializedObject' and lower(st.name) = 'nvarchar'  collate database_default))
	begin
		alter table NotificationProviders alter column SerializedObject nvarchar(max) NOT NULL
	END
END
----------------------------------------------------------------------
IF (OBJECT_ID('AlertTemplateLookup') IS NULL)
BEGIN
CREATE TABLE [dbo].[AlertTemplateLookup](
	[TemplateID] [int] NOT NULL IDENTITY(0,1),
	[Name] [nvarchar] (256) NOT NULL DEFAULT ('Default'),
	[Description] [nvarchar] (1024) NULL,
	[Default] [bit] NOT NULL DEFAULT (1)
	CONSTRAINT [PKAlertTemplateLookup] PRIMARY KEY CLUSTERED
	(
		[TemplateID]
	)
)
END


----------------------------------------------------------------------

IF (OBJECT_ID('DBMetrics') IS NULL)
BEGIN
	CREATE TABLE DBMetrics([MetricID] int)
END


----------------------------------------------------------------------

IF (OBJECT_ID('DefaultMetricThresholds') IS NULL)
BEGIN
CREATE TABLE [DefaultMetricThresholds](
	[UserViewID] [int] NOT NULL,
	[Metric] [int] NOT NULL,
	[Enabled] [bit] NOT NULL,
	[WarningThreshold] [nvarchar](1024) NULL,
	[CriticalThreshold] [nvarchar](1024) NULL,
	[Data] [nvarchar] (max) NULL,
	[InfoThreshold] [nvarchar](1024) NULL,
	[ThresholdInstanceID] [int] CONSTRAINT [DFDefaultMetricThresholdsThresholdInstanceID] DEFAULT -1 NOT NULL,
	[ThresholdEnabled] [bit] CONSTRAINT [DFDefaultMetricThresholdsThresholdEnabled] DEFAULT ((1)) NOT NULL,
	[IsBaselineEnabled] [bit] DEFAULT ((0)) NOT NULL,
	[BaselineWarningThreshold] [nvarchar](1024) NULL,
	[BaselineCriticalThreshold] [nvarchar](1024) NULL,
	[BaselineInfoThreshold] [nvarchar](1024) NULL,
	CONSTRAINT [PKDefaultMetricThresholds] PRIMARY KEY CLUSTERED 
	(
		[UserViewID] ASC,
		[Metric] ASC,
		[ThresholdInstanceID] ASC
	),
	CONSTRAINT [FKDefaultMetricThresholdsAlertTemplateLookup] FOREIGN KEY([UserViewID])
	REFERENCES [AlertTemplateLookup] ([TemplateID])
	ON DELETE CASCADE
)
END
ELSE
begin
	-- upgrade to 7.0
	IF (not exists(select id from syscolumns where id = object_id('DefaultMetricThresholds') and name = 'InfoThreshold' collate database_default)) 
	BEGIN
		ALTER TABLE [DefaultMetricThresholds] 
			ADD
			[InfoThreshold] [nvarchar](1024) NULL
	end
	IF (exists(select [UserViewID] from [DefaultMetricThresholds] Where [UserViewID] = 0))
	BEGIN
		IF (not exists(select [TemplateID] from [AlertTemplateLookup] where [TemplateID] = 0))
		BEGIN
			INSERT INTO AlertTemplateLookup (
				[Name],
				[Description],
				[Default]) 
			VALUES (
				'Default Template', 
				'SQLdm Default Template created by Management Services', 
				1)
		END
	END
	IF (not exists(select [OBJECT_ID] from sys.foreign_keys where name = 'FKDefaultMetricThresholdsAlertTemplateLookup' and parent_object_id = object_id(N'[dbo].DefaultMetricThresholds')))	
	BEGIN
		ALTER TABLE [DefaultMetricThresholds] WITH CHECK 
		ADD CONSTRAINT [FKDefaultMetricThresholdsAlertTemplateLookup] FOREIGN KEY([UserViewID])
		REFERENCES [AlertTemplateLookup] ([TemplateID])
		ON DELETE CASCADE	
	END
	--Upgrade to 7.2 if Data is not nvarchar(max)
	IF (not exists(select sc.object_id from sys.columns sc inner join sys.types st on sc.system_type_id = st.system_type_id
		where object_id=OBJECT_ID('DefaultMetricThresholds') 
		and sc.name='Data' and lower(st.name) = 'nvarchar'  collate database_default))
	begin
		alter table [DefaultMetricThresholds] alter column [Data] nvarchar(max) NULL
	END
	
	--Upgrade to 7.5 Add ThresholdInstanceID
	IF (not exists(select id from syscolumns where id = OBJECT_ID('DefaultMetricThresholds') and name = 'ThresholdInstanceID' collate database_default))
	BEGIN
		ALTER TABLE [DefaultMetricThresholds] DROP CONSTRAINT [PKDefaultMetricThresholds]
		ALTER TABLE [DefaultMetricThresholds]
			ADD
			[ThresholdInstanceID] [int] 
			CONSTRAINT [DFDefaultMetricThresholdsThresholdInstanceID] DEFAULT -1 NOT NULL,
			[ThresholdEnabled] [bit]
			CONSTRAINT [DFDefaultMetricThresholdsThresholdEnabled] DEFAULT ((1)) NOT NULL
		ALTER TABLE [DefaultMetricThresholds] ADD CONSTRAINT [PKDefaultMetricThresholds] PRIMARY KEY CLUSTERED 
		(
			[UserViewID] ASC,
			[Metric] ASC,
			[ThresholdInstanceID] ASC
		)
	END
	-- upgrade to 10.0
	-- START --Srishti Purohit -- To accomadate baseline alert feature
	IF (not exists(select id from syscolumns where id = object_id('DefaultMetricThresholds') and name = 'IsBaselineEnabled' collate database_default))
	BEGIN
		ALTER TABLE [DefaultMetricThresholds]
			ADD
			[IsBaselineEnabled] [bit] DEFAULT ((0)) NOT NULL,
			[BaselineWarningThreshold] [nvarchar](1024) NULL,
			[BaselineCriticalThreshold] [nvarchar](1024) NULL,
			[BaselineInfoThreshold] [nvarchar](1024) NULL
	END
	-- END --Srishti Purohit -- To accomadate baseline alert feature
	
end


----------------------------------------------------------------------

IF (OBJECT_ID('MetricThresholds') IS NULL)
BEGIN
CREATE TABLE [MetricThresholds](
	[SQLServerID] [int] NOT NULL,
	[Metric] [int] NOT NULL,
	[Enabled] [bit] NOT NULL,
	[WarningThreshold] [nvarchar](1024) NULL,
	[CriticalThreshold] [nvarchar](1024) NULL,
	[Data] [nvarchar] (max) NULL,
	[UTCSnoozeStart] [datetime] NULL,
	[UTCSnoozeEnd] [datetime] NULL,
	[SnoozeStartUser] [nvarchar](255) NULL,
	[SnoozeEndUser] [nvarchar](255) NULL,
	[InfoThreshold] [nvarchar](1024) NULL,
	[ThresholdInstanceID] [int] CONSTRAINT [DFMetricThresholdsThresholdInstanceID] DEFAULT -1 NOT NULL,
	[ThresholdEnabled] [bit] CONSTRAINT [DFMetricThresholdsThresholdEnabled] DEFAULT ((1)) NOT NULL,
	[IsBaselineEnabled] [bit] DEFAULT ((0)) NOT NULL,
	[BaselineWarningThreshold] [nvarchar](1024) NULL,
	[BaselineCriticalThreshold] [nvarchar](1024) NULL,
	[BaselineInfoThreshold] [nvarchar](1024) NULL,
	CONSTRAINT [PKMetricThresholds] PRIMARY KEY CLUSTERED 
	(
		[SQLServerID] ASC,
		[Metric] ASC,
		[ThresholdInstanceID] ASC
	),
	CONSTRAINT [FKMetricThresholdsMonitoredSQLServers] FOREIGN KEY
	(
		[SQLServerID]
	)
	REFERENCES [MonitoredSQLServers] 
	(
		[SQLServerID]
	)  on delete cascade
)
END
ELSE
BEGIN
	-- upgrade to 5.6.0
	IF (not exists(select id from syscolumns where id = object_id('MetricThresholds') and name = 'UTCSnoozeStart' collate database_default)) 
	BEGIN
		ALTER TABLE [MetricThresholds] 
			ADD 
			[UTCSnoozeStart] [datetime] NULL,
			[UTCSnoozeEnd] [datetime] NULL,
			[SnoozeStartUser] [nvarchar](255) NULL,
			[SnoozeEndUser] [nvarchar](255) NULL
	END
	-- upgrade to 7.0
	IF (not exists(select id from syscolumns where id = object_id('MetricThresholds') and name = 'InfoThreshold' collate database_default))
	BEGIN
		ALTER TABLE [MetricThresholds]
			ADD
			[InfoThreshold] [nvarchar](1024) NULL
	END
	
	--Upgrade to 7.2 if Data is not nvarchar(max)
	IF (not exists(select sc.object_id from sys.columns sc inner join sys.types st on sc.system_type_id = st.system_type_id
		where object_id=OBJECT_ID('MetricThresholds') 
		and sc.name='Data' and lower(st.name) = 'nvarchar'  collate database_default))
	begin
		alter table MetricThresholds alter column [Data] nvarchar(max) NULL
	END
	
	--Upgrade to 7.5 if ThresholdInstanceID does not exist
	IF (not exists(select id from syscolumns where id = OBJECT_ID('MetricThresholds') and name = 'ThresholdInstanceID' collate database_default))
	BEGIN
		ALTER TABLE [MetricThresholds] DROP CONSTRAINT [PKMetricThresholds]
		ALTER TABLE [MetricThresholds]
			ADD
			[ThresholdInstanceID] [int] 
			CONSTRAINT [DFMetricThresholdsThresholdInstanceID] DEFAULT -1 NOT NULL,
			[ThresholdEnabled] [bit] 
			CONSTRAINT [DFMetricThresholdsThresholdEnabled] DEFAULT ((1)) NOT NULL
		ALTER TABLE [MetricThresholds] ADD CONSTRAINT [PKMetricThresholds] PRIMARY KEY CLUSTERED 
		(
			[SQLServerID] ASC,
			[Metric] ASC,
			[ThresholdInstanceID] ASC
		)
	END
	-- upgrade to 10.0
	-- START --Srishti Purohit -- To accomadate baseline alert feature
	IF (not exists(select id from syscolumns where id = object_id('MetricThresholds') and name = 'IsBaselineEnabled' collate database_default))
	BEGIN
		ALTER TABLE [MetricThresholds]
			ADD
			[IsBaselineEnabled] [bit] DEFAULT ((0)) NOT NULL,
			[BaselineWarningThreshold] [nvarchar](1024) NULL,
			[BaselineCriticalThreshold] [nvarchar](1024) NULL,
			[BaselineInfoThreshold] [nvarchar](1024) NULL
	END
	-- END --Srishti Purohit -- To accomadate baseline alert feature
END


---------------------------------------------------------------------

IF (OBJECT_ID('Alerts') IS NULL)
BEGIN
CREATE TABLE [Alerts](
		[AlertID] bigint IDENTITY NOT NULL,
		[UTCOccurrenceDateTime] datetime NOT NULL,
		[ServerName] nvarchar(256) NULL,
		[DatabaseName] nvarchar(255) NULL,
		[TableName] nvarchar(255) NULL,
		[Active] bit NULL,
		[Metric] int NULL,
		[Severity] tinyint NULL,
		[StateEvent] tinyint NULL,
		[Value] float NULL,
		[Heading] nvarchar(256) NULL,
		[Message] nvarchar(1024) NULL,
		[QualifierHash] nvarchar(28) NULL,
		[LinkedData] uniqueidentifier NULL,
		CONSTRAINT [PK_Alerts] PRIMARY KEY CLUSTERED
			(AlertID));

	ALTER TABLE dbo.Alerts WITH NOCHECK
		ADD CONSTRAINT [FK_AlertsMonitoredSQLServers] FOREIGN KEY(ServerName)
		REFERENCES dbo.MonitoredSQLServers (InstanceName)
		ON DELETE CASCADE;

	ALTER TABLE [Alerts] CHECK CONSTRAINT [FK_AlertsMonitoredSQLServers];

	-- Add nonclustered indexes
	CREATE NONCLUSTERED INDEX [IX_Alerts_Metric_UTCOccurrenceDateTime] ON [Alerts] 
	(
		[Metric] ASC,
		[UTCOccurrenceDateTime] ASC,
		[ServerName] ASC
	)
	INCLUDE ([DatabaseName],
		[Severity],
		[Message],
		[Heading],
		[QualifierHash],
		[LinkedData]);
		
	CREATE NONCLUSTERED INDEX [IX_Alerts_PredictiveTrainingIndex] ON [Alerts] 
	(
		[ServerName] ASC,
		[Metric] ASC,
		[Severity] ASC,
		[UTCOccurrenceDateTime] ASC
	)
	INCLUDE (StateEvent);

	CREATE NONCLUSTERED INDEX [IX_Alerts_ViewSupport] ON [Alerts] 
	(
		[ServerName] ASC,
		[Metric] ASC,
		[UTCOccurrenceDateTime] ASC,
		[AlertID] ASC
	)
	INCLUDE ([DatabaseName],
		[TableName],
		[Severity],
		[Active],
		[StateEvent],
		[Value],
		[Heading],
		[Message]
	);

	-- IXAlerts2 added to keep grooming from doing a table scan
	CREATE NONCLUSTERED INDEX [IXAlerts2] ON [Alerts] 
	(
		[ServerName] ASC,
		[UTCOccurrenceDateTime] DESC,
		[Active] ASC
	)

	CREATE NONCLUSTERED INDEX [IXAlerts4] ON [Alerts]
	(
		[UTCOccurrenceDateTime] DESC,
		[ServerName] ASC,
		[Severity] ASC
	)

	CREATE NONCLUSTERED INDEX [IXAlerts5] on [Alerts]
	(
		[ServerName] ASC,
		[UTCOccurrenceDateTime] ASC
	) INCLUDE ([AlertID]) ON [PRIMARY]

END
ELSE
BEGIN
	-- upgrade to 5.5.0
	IF (not exists(select id from syscolumns where id = object_id('Alerts') and name = 'LinkedData' collate database_default)) 
	BEGIN
		ALTER TABLE [Alerts] 
			ADD [LinkedData] [uniqueidentifier] NULL
	END
END


----------------------------------------------------------------------

IF (OBJECT_ID('Tasks') IS NULL)
BEGIN
CREATE TABLE [Tasks](
	[TaskID] [int] IDENTITY NOT NULL,
	[ServerName] [nvarchar] (256) NULL,
	[Subject] [nvarchar](256) NOT NULL,
	[Message] [nvarchar](1024) NULL,
	[Comments] [nvarchar](1024) NULL,
	[Owner] [nvarchar](256) NULL,
	[CreatedOn] [datetime] NOT NULL,
	[CompletedOn] [datetime] NULL,
	[Status] [tinyint] NOT NULL,
	[Metric] [int] NULL,
	[Severity] [tinyint] NULL,
	[Value] [float] NULL,
	[EventID] [int] NULL,
	[DatabaseName] [nvarchar] (255) NULL,
	CONSTRAINT [PKTasks] PRIMARY KEY CLUSTERED 
	(
		[TaskID]
	)
)

CREATE NONCLUSTERED INDEX [IXTasks] ON [Tasks] 
(
	[ServerName] ASC,
	[CreatedOn] ASC,
	[Status] ASC,
	[Severity] ASC
)
END
ELSE
BEGIN
	-- upgrade to 5.5.0
	IF (not exists(select id from syscolumns where id = object_id('Tasks') and name = 'DatabaseName' collate database_default)) 
	BEGIN
		ALTER TABLE [Tasks] 
			ADD [DatabaseName] [nvarchar] (255) NULL
	END
END

----------------------------------------------------------------------

IF (OBJECT_ID('MetricInfo') IS NULL)
BEGIN
CREATE TABLE [MetricInfo](
	[Metric] [int] NOT NULL,
	[UTCLastChangeDateTime] [datetime] NOT NULL CONSTRAINT [DF_MetricInfo_UTCLastChangeDateTime]  DEFAULT ((GETUTCDATE())),
	[Rank] [int] NOT NULL,
	[Category] [nvarchar](64) NOT NULL,
	[Name] [nvarchar] (128) NOT NULL,
	[Description] [nvarchar](512) NOT NULL,
	[Comments] [nvarchar] (max) NULL,
	CONSTRAINT [PKMetricInfo] PRIMARY KEY CLUSTERED 
	(
		[Metric]
	)
	)
END
ELSE
BEGIN
	-- upgrade to 5.5.0
	IF (not exists(select id from syscolumns where id = object_id('MetricInfo') and name = 'UTCLastChangeDateTime' collate database_default)) 
	BEGIN
		ALTER TABLE [MetricInfo] ADD 
			[UTCLastChangeDateTime] [datetime] NOT NULL CONSTRAINT [DF_MetricInfo_UTCLastChangeDateTime]  DEFAULT ((GETUTCDATE()))
	END
	
		--Upgrade to 7.2 if Comments is not nvarchar(max)
	IF (not exists(select sc.object_id from sys.columns sc inner join sys.types st on sc.system_type_id = st.system_type_id
		where object_id=OBJECT_ID('MetricInfo') 
		and sc.name='Comments' and lower(st.name) = 'nvarchar'  collate database_default))
	begin
		alter table [MetricInfo] alter column [Comments] nvarchar(max) NULL
	END
END


----------------------------------------------------------------------

IF (OBJECT_ID('ServerActivity') IS NULL)
BEGIN
CREATE TABLE [ServerActivity](
	[SQLServerID] [int] NOT NULL,
	[UTCCollectionDateTime] [datetime] NOT NULL,
	[StateOverview] [nvarchar] (max) NULL,
	[SystemProcesses] [image] NULL,
	[SessionList] [image] NULL,
	[LockStatistics] [image] NULL,
	[LockList] [image] NULL,
	[RefreshType] int null,
	CONSTRAINT [PKServerActivity] PRIMARY KEY CLUSTERED 
	(
		[SQLServerID],
		[UTCCollectionDateTime]
	),
	CONSTRAINT [FKServerActivityMonitoredSQLServers] FOREIGN KEY 
		(
		[SQLServerID]
		) 
	REFERENCES [MonitoredSQLServers] 
		(
		[SQLServerID]
		) on delete cascade
	)
END
ELSE
BEGIN
	--Upgrade to 7.2 if StateOverview is not nvarchar(max)
	IF (not exists(select sc.object_id from sys.columns sc inner join sys.types st on sc.system_type_id = st.system_type_id
		where object_id=OBJECT_ID('ServerActivity') 
		and sc.name='StateOverview' and lower(st.name) = 'nvarchar'  collate database_default))
	begin
		alter table [ServerActivity] alter column [StateOverview] nvarchar(max) NULL
	END
	
	if (not exists(select object_id from sys.columns where object_id = object_id('ServerActivity') and name = 'RefreshType' collate database_default))
	begin
		alter table [ServerActivity] add [RefreshType] int null
	end
END
----------------------------------------------------------------------
IF (OBJECT_ID('GroomingLog') IS NULL)
BEGIN
CREATE TABLE [GroomingLog](
	[RunID] [uniqueidentifier] NOT NULL,
	[Sequence] int NOT NULL,
	[UTCActionEndDateTime] [datetime] NOT NULL,
	[Action] [nvarchar](256) NOT NULL,
	[AffectedRecords] [int] NULL,
	[InstanceName] [nvarchar](256) NULL
	)
END


if exists(select name from sys.objects where name = 'PKGroomingLog') 
begin
	alter table [GroomingLog] drop constraint [PKGroomingLog]
end	

if not exists(select * from sys.indexes where name = 'GroomingLogCL')
begin
	create clustered index [GroomingLogCL] on [GroomingLog]([UTCActionEndDateTime])
end

----------------------------------------------------------------------
IF (OBJECT_ID('MetricMetaData') IS NULL)
BEGIN
CREATE TABLE [dbo].[MetricMetaData](
	[Metric] [int] NOT NULL,
	[UTCLastChangeDateTime] [datetime] NOT NULL CONSTRAINT [DF_MetricMetaData_UTCLastChangeDateTime]  DEFAULT ((GETUTCDATE())),
	[Deleted] [bit] NOT NULL CONSTRAINT [DF_MetricMetaData_Deleted]  DEFAULT ((0)),
	[Class] [int] NOT NULL,
	[Flags] [int] NOT NULL,
	[MinValue] [int] NOT NULL,
	[MaxValue] [bigint] NOT NULL,
	[DefaultWarningValue] [bigint] NOT NULL,
	[DefaultCriticalValue] [bigint] NOT NULL,
	[DoNotifications] [bit] NOT NULL,
	[EventCategory] [int] NULL,
	[DefaultMessageID] [int] NULL,
	[AlertEnabledDefault] [bit] NOT NULL,
	[ValueComparison] [int] NOT NULL,
	[ValueType] [nvarchar](128) NOT NULL,
	[Rank] int NULL, 
	[DefaultInfoValue] [bigint] NOT NULL,
	TableName NVARCHAR(256) NULL,
	ColumnName NVARCHAR(256) NULL,
	[IsValidForSqlExpress] [BIT] NOT NULL CONSTRAINT [DF_MetricMetaData_IsValidForSqlExpress] DEFAULT(0),
	[BaselineMaxValue] [bigint] NOT NULL DEFAULT (300),
	[BaselineDefaultWarningValue] [bigint] NOT NULL DEFAULT (120),
	[BaselineDefaultCriticalValue] [bigint] NOT NULL DEFAULT (100),
	[BaselineDefaultInfoValue] [bigint] NOT NULL DEFAULT (50),
	CONSTRAINT [PKMetricMetaData] PRIMARY KEY CLUSTERED
	(
		[Metric]
	)
)
END
ELSE
BEGIN
	-- upgrade to 7.0
	if (not exists(select id from syscolumns where id = object_id('MetricMetaData') and name = 'DefaultInfoValue' collate database_default))
	BEGIN
		ALTER TABLE [MetricMetaData] ADD
			[DefaultInfoValue] [bigint] NULL
	END

	--upgrade to 8.5: Ashu - For metric history display in Web console
	IF (not exists(select id from syscolumns where id=OBJECT_ID('MetricMetaData') and name='TableName' collate database_default))	
	BEGIN
		ALTER TABLE [MetricMetaData] ADD TableName NVARCHAR(256) NULL;
	END		

	IF (not exists(select id from syscolumns where id=OBJECT_ID('MetricMetaData') and name='ColumnName' collate database_default))	
	BEGIN
		ALTER TABLE [MetricMetaData] ADD ColumnName NVARCHAR(256) NULL;
	END		
	--upgrade to 8.5: Ashu - For metric history display in Web console - END	

	-- upgrade to 8.6 :Ankit Srivastava - For supressing alerts in SQL Express 
	IF (not exists(select id from syscolumns where id = object_id('MetricMetaData') and name = 'IsValidForSqlExpress' collate database_default)) 
	BEGIN
		ALTER TABLE [MetricMetaData] ADD 
			[IsValidForSqlExpress] [BIT] NOT NULL CONSTRAINT [DF_MetricMetaData_IsValidForSqlExpress] DEFAULT(0) 
	END
	-- upgrade to 10.0 :Srishti - For baseline configuration alert
	IF (not exists(select id from syscolumns where id = object_id('MetricMetaData') and name = 'BaselineMaxValue' collate database_default)) 
	BEGIN
		ALTER TABLE [MetricMetaData] ADD 
			[BaselineMaxValue] [bigint] DEFAULT(99999999) NOT NULL,
			[BaselineDefaultWarningValue] [bigint] DEFAULT(100) NOT NULL,
			[BaselineDefaultCriticalValue] [bigint] DEFAULT(120) NOT NULL,
			[BaselineDefaultInfoValue] [bigint] DEFAULT(50) NOT NULL
	END
END

----------------------------------------------------------------------
IF (OBJECT_ID('MetricMetaDataMessages') IS NULL)
BEGIN
CREATE TABLE [dbo].[MetricMetaDataMessages](
	[Metric] [int] NOT NULL,
	[MessageID] [int] NOT NULL,
	[EventID] [bigint] NULL,
	[HeaderTemplate] [nvarchar](256) NOT NULL,
	[BodyTemplate] [nvarchar](512) NOT NULL,
	[TodoTemplate] [nvarchar](512) NOT NULL,
	[PulseTemplate] [nvarchar](256) NOT NULL,
	--START: SQLdm 10.0 (Tarun Sapra): DE45820-ALert 'Details'  should be changed for all the baseline alerts
	[HeaderTemplate_Baseline] [nvarchar](256) NULL,
	[BodyTemplate_Baseline] [nvarchar](512) NULL,
	[TodoTemplate_Baseline] [nvarchar](512) NULL,
	[PulseTemplate_Baseline] [nvarchar](256) NULL
	--END: SQLdm 10.0 (Tarun Sapra): DE45820-ALert 'Details'  should be changed for all the baseline alerts
	CONSTRAINT [PKMetricMetaDataMessages] PRIMARY KEY CLUSTERED
	(
		[Metric],
		[MessageID]
	)
) 
END
ELSE
BEGIN
	-- upgrade to 7.0
	if (not exists(select id from syscolumns where id = object_id('MetricMetaDataMessages') and name = 'PulseTemplate' collate database_default))
	BEGIN
		ALTER TABLE [MetricMetaDataMessages] ADD
			[PulseTemplate] [nvarchar](256) NULL
	END

	--upgrade to 10.0
	if (not exists(select id from syscolumns where id = object_id('MetricMetaDataMessages') and name = 'HeaderTemplate_Baseline' collate database_default))
	BEGIN
		ALTER TABLE [MetricMetaDataMessages] ADD
			[HeaderTemplate_Baseline] [nvarchar](256) NULL
	END
	if (not exists(select id from syscolumns where id = object_id('MetricMetaDataMessages') and name = 'BodyTemplate_Baseline' collate database_default))
	BEGIN
		ALTER TABLE [MetricMetaDataMessages] ADD
			[BodyTemplate_Baseline] [nvarchar](256) NULL
	END
	if (not exists(select id from syscolumns where id = object_id('MetricMetaDataMessages') and name = 'TodoTemplate_Baseline' collate database_default))
	BEGIN
		ALTER TABLE [MetricMetaDataMessages] ADD
			[TodoTemplate_Baseline] [nvarchar](256) NULL
	END
	if (not exists(select id from syscolumns where id = object_id('MetricMetaDataMessages') and name = 'PulseTemplate_Baseline' collate database_default))
	BEGIN
		ALTER TABLE [MetricMetaDataMessages] ADD
			[PulseTemplate_Baseline] [nvarchar](256) NULL
	END

END


----------------------------------------------------------------------
IF (OBJECT_ID('MetricMetaDataMessageMap') IS NULL)
BEGIN
CREATE TABLE [dbo].[MetricMetaDataMessageMap](
	[Metric] [int] NOT NULL,
	[Value] [int] NOT NULL,
	[MessageID] [int] NOT NULL,
	CONSTRAINT [PKMetricMetaDataMessageMap] PRIMARY KEY CLUSTERED
	(
		[Metric],
		[Value]
	)
) 
END

----------------------------------------------------------------------
IF (OBJECT_ID('CustomCounterDefinition') IS NULL)
BEGIN
CREATE TABLE [dbo].[CustomCounterDefinition](
	[Metric] [int] IDENTITY(1000,1) NOT NULL,
	[UTCLastChangeDateTime] [datetime] NOT NULL CONSTRAINT [DF_CustomCounterDefinition_UTCLastChangeDateTime]  DEFAULT ((GETUTCDATE())),
	[MetricType] [int] NOT NULL,
	[CalculationType] [int] NOT NULL,
	[Enabled] [bit] NOT NULL,
	[Scale] [float] NOT NULL,
	[Object] [nvarchar](256) NULL,
	[Counter] [nvarchar](256) NULL,
	[Instance] [nvarchar](256) NULL,
	[Batch] [nvarchar] (max) NULL,
	[ServerType] [nvarchar](256) NULL DEFAULT ('Unknown'),
	CONSTRAINT [PKCustomCounterDefinition] PRIMARY KEY CLUSTERED 
	(
		[Metric] 
	)
) 
END
ELSE
BEGIN
	--Upgrade to 7.2 if Batch is not nvarchar(max)
	IF (not exists(select sc.object_id from sys.columns sc inner join sys.types st on sc.system_type_id = st.system_type_id
		where object_id=OBJECT_ID('CustomCounterDefinition') 
		and sc.name='Batch' and lower(st.name) = 'nvarchar'  collate database_default))
	begin
		alter table [CustomCounterDefinition] alter column [Batch] nvarchar(max) NULL
	END
	
	 --Upgrade to 8.5 (HyperV) if column ServerType does not exist
	IF (not exists(select sc.object_id from sys.columns sc inner join sys.types st on sc.system_type_id = st.system_type_id
		where object_id=OBJECT_ID('CustomCounterDefinition') 
		and sc.name='ServerType' and lower(st.name) = 'nvarchar'  collate database_default))
	BEGIN
		ALTER TABLE [dbo].CustomCounterDefinition ADD ServerType [nvarchar](256) NULL DEFAULT('Unknown')
	END
	ELSE
	BEGIN
		-- Upgrade to 8.6 from 8.5 if column ServerType exist
		DECLARE @Default sysname
		SET @Default = (SELECT OBJECT_NAME(cdefault) FROM syscolumns WHERE id = OBJECT_ID('CustomCounterDefinition') AND name = 'ServerType')
		
		IF(LEN(@Default) > 0)
		BEGIN
			EXEC ('ALTER TABLE [dbo].CustomCounterDefinition DROP CONSTRAINT ' + @Default)
		END
		
		ALTER TABLE [dbo].[CustomCounterDefinition] ALTER COLUMN [ServerType] [nvarchar](256) NULL
		ALTER TABLE [dbo].[CustomCounterDefinition] ADD  DEFAULT ('Unknown') FOR [ServerType]
	END
END
----------------------------------------------------------------------
IF (OBJECT_ID('CustomCounterMap') IS NULL)
BEGIN
CREATE TABLE [dbo].[CustomCounterMap](
	[SQLServerID] [int] NOT NULL,
	[Metric] [int] NOT NULL,
	CONSTRAINT [PKCustomCounterMap] PRIMARY KEY CLUSTERED 
	(
		[SQLServerID],
		[Metric]
	),
	CONSTRAINT [FKCustomCounterMapMetricMetaData] 
		FOREIGN KEY([Metric])
		REFERENCES [MetricMetaData] ([Metric]) 
			on delete cascade,
	CONSTRAINT [FKCustomCounterMapMonitoredSQLServers] 
		FOREIGN KEY([SQLServerID])
		REFERENCES [MonitoredSQLServers] ([SQLServerID])
			on delete cascade
) 
END

----------------------------------------------------------------------
IF (OBJECT_ID('CustomCounterStatistics') IS NULL)
BEGIN
CREATE TABLE [dbo].[CustomCounterStatistics](
	[SQLServerID] [int] NOT NULL ,
	[UTCCollectionDateTime] [datetime] NOT NULL ,
	[MetricID] [int] NOT NULL,	
	[TimeDeltaInSeconds] [float] NULL ,
	[RawValue] [decimal](38,9) NULL,
	[DeltaValue] [decimal](38,9) NULL,
	[ErrorMessage] [nvarchar](255) NULL,
	[RunTimeInMilliseconds] [float] NULL,
	CONSTRAINT [PKCustomCounterStatistics] PRIMARY KEY CLUSTERED
	(
		[SQLServerID],
		[UTCCollectionDateTime],
		[MetricID]
	),
	CONSTRAINT [FKCustomCounterStatisticsMonitoredSQLServers] FOREIGN KEY 
		(
		[SQLServerID]
		) 
	REFERENCES  [MonitoredSQLServers] 
		(
		[SQLServerID]
		) on delete cascade
) 
END

----------------------------------------------------------------------
IF (OBJECT_ID('Permission') IS NULL)
BEGIN
CREATE TABLE [dbo].[Permission] (
	[PermissionID] [int] IDENTITY NOT NULL, 
	[LoginSID] [varbinary](85) NOT NULL,
	[Permission] [int] NOT NULL,
	[Enabled] [bit] NOT NULL,
	[Comment] [nvarchar](1024) NULL,
	WebAppPermission BIT  NOT NULL,
	CONSTRAINT [PKPermission] PRIMARY KEY CLUSTERED 
		(
		[PermissionID]
		)
	
)
IF((SELECT COUNT(0)FROM sys.default_constraints WHERE [object_id] = OBJECT_ID('Permission') AND LOWER(name) collate database_default ='df_webapppermission' collate database_default) = 0)
	BEGIN
		ALTER TABLE Permission ADD CONSTRAINT DF_WebAppPermission DEFAULT 1 FOR WebAppPermission
	END
END
ELSE
BEGIN
	IF((SELECT COUNT(0) FROM sys.columns WHERE [object_id] = OBJECT_ID('Permission') AND LOWER(name) collate database_default = 'webapppermission' collate database_default) =0)
	BEGIN
		ALTER TABLE [dbo].[Permission] ADD WebAppPermission BIT  NULL
	END
	IF((SELECT COUNT(0)FROM sys.default_constraints WHERE  LOWER(name) collate database_default ='df_webapppermission' collate database_default) = 0)
	BEGIN
		ALTER TABLE Permission ADD CONSTRAINT DF_WebAppPermission DEFAULT 1 FOR WebAppPermission
	END
END

IF (OBJECT_ID('PermissionServers') IS NULL)
BEGIN
CREATE TABLE  [dbo].[PermissionServers] (
	[PermissionID] [int] NOT NULL,
	[SQLServerID] [int] NOT NULL,
	CONSTRAINT [PKPermissionServers] PRIMARY KEY CLUSTERED 
		(
		[PermissionID],
		[SQLServerID]
		),
	CONSTRAINT [FKSPermissionServersMonitoredSQLServers] FOREIGN KEY 
		(
		[SQLServerID]
		) 
	REFERENCES  [MonitoredSQLServers] 
		(
		[SQLServerID]
		) on delete cascade,
	CONSTRAINT [FKSPermissionServersPermission] FOREIGN KEY 
		(
		[PermissionID]
		) 
	REFERENCES  [Permission] 
		(
		[PermissionID]
		) on delete cascade
)
END

----------------------------------------------------------------------
IF (OBJECT_ID('DiskDrives') IS NULL)
BEGIN
CREATE TABLE [dbo].[DiskDrives] (
	[SQLServerID] int NOT NULL,
	[UTCCollectionDateTime] datetime NOT NULL ,
	[DriveName] nvarchar(256) NOT NULL,
	[UnusedSizeKB] dec(18,0),
	[TotalSizeKB] dec(18,0),
	[DiskIdlePercent] bigint,
	[AverageDiskQueueLength] bigint,
	[AverageDiskMillisecondsPerRead] bigint,
	[AverageDiskMillisecondsPerTransfer] bigint,
	[AverageDiskMillisecondsPerWrite] bigint,
	[DiskReadsPerSecond] bigint,
	[DiskTransfersPerSecond] bigint,
	[DiskWritesPerSecond] bigint,
	[DatabaseSizeTime] datetime null,
	CONSTRAINT [PKDiskDrives] PRIMARY KEY CLUSTERED
	(
		[SQLServerID],
		[UTCCollectionDateTime],
		[DriveName]
	)
)

		create index IXDiskDrivesDatabaseSizeTime on [DiskDrives]([DatabaseSizeTime])
END
ELSE
BEGIN
	-- upgrade to 6.0
	if (not exists(select id from syscolumns where id = object_id('DiskDrives') and name = 'DriveName' collate database_default and length >= 512))
	BEGIN
		ALTER TABLE [DiskDrives]
			ALTER COLUMN [DriveName] [nvarchar](256) NOT NULL
	END

	-- upgrade to 6.1
	IF (not exists(select id from syscolumns where id = object_id('DiskDrives') and name = 'AverageDiskMillisecondsPerRead' collate database_default)) 
	BEGIN
		ALTER TABLE [DiskDrives] ADD 
			[AverageDiskMillisecondsPerRead] bigint,
			[AverageDiskMillisecondsPerTransfer] bigint,
			[AverageDiskMillisecondsPerWrite] bigint
	END

	-- upgrade to 6.2 SP2
	IF (not exists(select id from syscolumns where id = object_id('DiskDrives') and name = 'DiskReadsPerSecond' collate database_default)) 
	BEGIN
		ALTER TABLE [DiskDrives] ADD 
			[DiskReadsPerSecond] bigint,
			[DiskTransfersPerSecond] bigint,
			[DiskWritesPerSecond] bigint
	END
	
	if (not exists(select object_id from sys.columns where object_id = object_id('DiskDrives') and name = 'DatabaseSizeTime' collate database_default)) 
	begin
		ALTER TABLE [DiskDrives] ADD [DatabaseSizeTime] datetime NULL
		create index IXDiskDrivesDatabaseSizeTime on [DiskDrives]([DatabaseSizeTime])
	end
	
	
END

----------------------------------------------------------------------
IF (OBJECT_ID('BaselineMetaData') IS NULL)
BEGIN
CREATE TABLE [dbo].[BaselineMetaData] (
	[ItemID] int NOT NULL,
	[Name] nvarchar(128) NULL,
	[Description] nvarchar(255) NULL,
	[Category] nvarchar(128) NULL,
	[Unit] nvarchar(32) NULL,
	[Format] nvarchar(64) NULL,
	[NullFormat] nvarchar(64) NULL,
	[MetricID] int DEFAULT NULL,
	[StatisticTable] nvarchar(256) NULL,
	[MetricValue] nvarchar(256) NULL,
	[Decimals] int NULL,
	[LLimit] int NULL,
	[ULimit] bigint NULL,
	[Scale] decimal(15,9) NULL,
	CONSTRAINT [PKBaselineMetaData] PRIMARY KEY CLUSTERED
	(
		[ItemID]
	)
)
END
----------------------------------------------------------------------
IF (OBJECT_ID('MirroringParticipants') IS NULL)
BEGIN
CREATE TABLE [MirroringParticipants](
	[DatabaseID] [int] NOT NULL,
	[mirroring_guid] [uniqueidentifier] NOT NULL,
	[role] [tinyint] NULL,
	[principal_address] [nvarchar](128) NULL,
	[Mirror_address] [nvarchar](128) NULL,
	[witness_address] [nvarchar](128) NULL,
	[safety_level] [int] NULL,
	[is_suspended] [bit] NULL,
	[mirroring_state] [tinyint] NULL,
	[witness_status] [tinyint] NULL,
	[mirror_instanceID] [int] NULL,
	[principal_instanceID] [int] NULL,
	[partner_instance] [nvarchar](128) NULL,
	[last_updated] [datetime] NULL,
        CONSTRAINT [PKMirroringParticipants] PRIMARY KEY CLUSTERED 
        (
			[DatabaseID] ASC
		),
		CONSTRAINT [FKMirroringParticipantsSQLServerDatabaseNames] 
			FOREIGN KEY([DatabaseID]) REFERENCES [SQLServerDatabaseNames] ([DatabaseID])ON DELETE CASCADE,

	)
end
-----------------------------------------------------------------------

IF (OBJECT_ID('MirroringPreferredConfig') IS NULL)
BEGIN
CREATE TABLE [dbo].[MirroringPreferredConfig](
	[MirroringGuid] [uniqueidentifier] NOT NULL,
	[MirrorInstanceID] [int] NULL,
	[PrincipalInstanceID] [int] NULL,
	[NormalConfiguration] [bit] NOT NULL,
	[DatabaseName] [nvarchar](128) NULL,
	[WitnessAddress] [nvarchar](128) NULL,
	CONSTRAINT [PKMirroringPreferredConfig] PRIMARY KEY CLUSTERED 
	(
		[MirroringGuid] ASC
	))

END
------------------------------------------------------------------------
IF (OBJECT_ID('MirroringStatistics') IS NULL)
BEGIN
CREATE TABLE [dbo].[MirroringStatistics](
	[DatabaseID] [int] NOT NULL,
	[mirroring_guid] [uniqueidentifier] NOT NULL,
	[UTCCollectionDateTime] [datetime] NOT NULL,
	[role] [tinyint] NULL,
	[mirroring_state] [tinyint] NULL,
	[witness_status] [tinyint] NULL,
	[log_generation_rate] [int] NULL,
	[unsent_log] [int] NULL,
	[send_rate] [int] NULL,
	[unrestored_log] [int] NULL,
	[recovery_rate] [int] NULL,
	[transaction_delay] [int] NULL,
	[transactions_per_sec] [int] NULL,
	[average_delay] [int] NULL,
	[time_recorded] [datetime] NULL,
	[time_behind] [datetime] NULL,
	[local_time] [datetime] NULL,
	 CONSTRAINT [PKMirroringStatistics] PRIMARY KEY CLUSTERED 
	(
		[DatabaseID] ASC,
		[UTCCollectionDateTime] ASC
	),
	CONSTRAINT [FKMirroringStatisticsSQLServerDatabaseNames] 
		FOREIGN KEY([DatabaseID])REFERENCES [dbo].[SQLServerDatabaseNames] ([DatabaseID])
		ON DELETE CASCADE
	)
END
---------------------------------------------------------------------------
IF (OBJECT_ID('Tags') IS NULL)
BEGIN
CREATE TABLE [dbo].[Tags]
(
	[Id] [int] IDENTITY(1,1) NOT NULL,
	[Name] [nvarchar](50) NOT NULL,
	CONSTRAINT [PKTags] PRIMARY KEY CLUSTERED 
	(
		[Id] ASC
	)
) 
END
---------------------------------------------------------------------------
IF (OBJECT_ID('ServerTags') IS NULL)
BEGIN
CREATE TABLE [dbo].[ServerTags]
(
	[SQLServerId] [int] NOT NULL,
	[TagId] [int] NOT NULL,
	CONSTRAINT [PKServerTags] PRIMARY KEY CLUSTERED 
	(
		[SQLServerId] ASC,
		[TagId] ASC
	),
	CONSTRAINT [FKServerTagsMonitoredSQLServers] FOREIGN KEY
	(
		[SQLServerId]
	) 
	REFERENCES [dbo].[MonitoredSQLServers] 
	(
		[SQLServerID]
	)
	ON DELETE CASCADE,
	CONSTRAINT [FKServerTagsTags] FOREIGN KEY
	(
		[TagId]
	)
	REFERENCES [dbo].[Tags] 
	(
		[Id]
	)
	ON DELETE CASCADE
)
END
---------------------------------------------------------------------------
IF (OBJECT_ID('CustomCounterTags') IS NULL)
BEGIN
CREATE TABLE [dbo].[CustomCounterTags]
(
	[Metric] [int] NOT NULL,
	[TagId] [int] NOT NULL,
	CONSTRAINT [PK_CustomCounterTags] PRIMARY KEY CLUSTERED 
	(
		[Metric] ASC,
		[TagId] ASC
	),
	CONSTRAINT [FK_CustomCounterTags_CustomCounterDefinition] FOREIGN KEY
	(
		[Metric]
	)
	REFERENCES [dbo].[CustomCounterDefinition] 
	(
		[Metric]
	)
	ON DELETE CASCADE,
	CONSTRAINT [FK_CustomCounterTags_Tags] FOREIGN KEY
	(
		[TagId]
	)
	REFERENCES [dbo].[Tags] 
	(
		[Id]
	)
	ON DELETE CASCADE
)
END
---------------------------------------------------------------------------
IF (OBJECT_ID('PermissionTags') IS NULL)
BEGIN
CREATE TABLE [dbo].[PermissionTags]
(
	[PermissionId] [int] NOT NULL,
	[TagId] [int] NOT NULL,
	CONSTRAINT [PK_PermissionTags] PRIMARY KEY CLUSTERED 
	(
		[PermissionId] ASC,
		[TagId] ASC
	),
	CONSTRAINT [FK_PermissionTags_Permission] FOREIGN KEY
	(
		[PermissionId]
	)
	REFERENCES [dbo].[Permission] 
	(
		[PermissionID]
	)
	ON DELETE CASCADE,
	CONSTRAINT [FK_PermissionTags_Tags] FOREIGN KEY
	(
		[TagId]
	)
	REFERENCES [dbo].[Tags] 
	(
		[Id]
	)
	ON DELETE CASCADE
)
END
---------------------------------------------------------------------------
IF (OBJECT_ID('ReportIntervals') IS NULL)
BEGIN
CREATE TABLE [dbo].[ReportIntervals](
	[Value] [int] NULL,
	[Label] [varchar](50) NULL
) ON [PRIMARY]
END
----------------------------------------------------------------------------
IF (OBJECT_ID('ReportPeriods') IS NULL)
BEGIN
CREATE TABLE [dbo].[ReportPeriods](
	[Value] [int] NULL,
	[Label] [varchar](50) NULL
) ON [PRIMARY]
END
----------------------------------------------------------------------------
IF (OBJECT_ID('ReportPeriodIntervals') IS NULL)
BEGIN
CREATE TABLE [dbo].[ReportPeriodIntervals](
	[ReportNumber] [int] NOT NULL,
	[PeriodValue] [int] NOT NULL,
	[IntervalValue] [int] NOT NULL,
 CONSTRAINT [PK_ReportPeriodIntervals] PRIMARY KEY CLUSTERED 
(
	[ReportNumber] ASC,
	[PeriodValue] ASC,
	[IntervalValue] ASC
) ON [PRIMARY]
) ON [PRIMARY]
END
----------------------------------------------------------------------------
IF (OBJECT_ID('SQLServerVersions') IS NULL)
BEGIN
CREATE TABLE [dbo].[SQLServerVersions](
	[MajorVersion] [int] NOT NULL,
	[MinorVersion] [int] NOT NULL,
	[BuildNumber] [int] NOT NULL,
	[VersionName] [nvarchar](30),
	[ServicePackName] [nvarchar](5)
) ON [PRIMARY]
END

------------------------------------------------------------------------------------------

IF (OBJECT_ID('ReplicationTopology') IS NULL)
BEGIN
CREATE TABLE [dbo].[ReplicationTopology]
(
	[PublisherInstance] [nvarchar](128) NOT NULL,
	[PublisherDB] [nvarchar](128) NOT NULL,
	[Publication] [nvarchar](128),
	[LastPublisherSnapshotDateTime] [datetime],
	[LastDistributorSnapshotDateTime] [datetime],
	[LastSubscriberSnapshotDateTime] [datetime],
	[DistributorInstance] [nvarchar](128),
	[DistributorDB] [nvarchar](128),
	[SubscriberInstance] [nvarchar](128),
	[SubscriberDB] [nvarchar](128),
	[PublisherDBID] [int],
	[DistributorDBID] [int],
	[SubscriberDBID] [int],
	[SubscribedTransactions] [int],
	[NonSubscribedTransactions] [int],
	[NonDistributedTransactions] [int],
	[ReplicationLatency] [float],
	[MaxSubscriptionLatency] [int],
	[ReplicationType] [tinyint],
	[SubscriptionType] [tinyint],
	[LastSubscriberUpdate] [datetime],
	[LastSyncStatus] [tinyint],
	[LastSyncSummary] [nvarchar](128),
	[LastSyncTime] [datetime],
	[SubscriptionStatus] [tinyint],
	[PublicationDescription] [nvarchar](255),
	[ArticleCount] [int]
)
END
-----------------------------------------------------------------------------------------------
IF (OBJECT_ID('CounterMasterList') IS NULL)
BEGIN
CREATE TABLE [dbo].[CounterMasterList](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[CounterName] [nvarchar](255) NOT NULL,
	[CounterFriendlyName] [nvarchar](255) NULL,
	[CounterType] [int] NULL,
	[AvailableInCustomReport] [bit] NULL
) ON [PRIMARY]
END
-----------------------------------------------------------------------------------------------
IF (OBJECT_ID('CustomReports') IS NULL)
BEGIN
CREATE TABLE [dbo].[CustomReports](
	[ID] [int] IDENTITY(1,1) NOT NULL,
	[reportName] [nvarchar](255) NOT NULL,
	[reportText] [ntext] NULL,
	[reportShortDescription] [nvarchar](255) NULL,
	[ShowTopServers] [bit] default 0
 CONSTRAINT [PK_CustomReports] PRIMARY KEY CLUSTERED 
(
	[ID] ASC
) ON [PRIMARY]
) ON [PRIMARY]


CREATE UNIQUE NONCLUSTERED INDEX [IX_CustomReports] ON [dbo].[CustomReports] 
(
	[ID] ASC,
	[reportName] ASC
) ON [PRIMARY]
END
ELSE
BEGIN
	IF (not exists(select id from syscolumns where id=object_id('CustomReports') and name = 'ShowTopServers' collate database_default))
	BEGIN
		ALTER TABLE [CustomReports]
			ADD [ShowTopServers] [bit] default 0
	END
END
-----------------------------------------------------------------------------------------------
IF (OBJECT_ID('CustomReportsCounters') IS NULL)
BEGIN
CREATE TABLE [dbo].[CustomReportsCounters](
	[ID] [int] NOT NULL,
	[GraphNumber] [int] NOT NULL,
	[CounterShortDescription] [nvarchar](255) NULL,
	[CounterName] [nvarchar](255) NULL,
	[Aggregation] [int] NULL,
	[Source] [int] NULL
	CONSTRAINT [PK_CustomReportsCounters] PRIMARY KEY CLUSTERED 
	(
		[ID] ASC,
		[GraphNumber] ASC
	) ON [PRIMARY],
	CONSTRAINT [FK_CustomReportsCounters_CustomReports] FOREIGN KEY([ID]) 
	REFERENCES [dbo].[CustomReports] ([ID]) ON DELETE CASCADE
) ON [PRIMARY]
END

-----------------------------------------------------------------------------------------------
IF (OBJECT_ID('WaitCategories') IS NULL)
BEGIN
CREATE TABLE [dbo].[WaitCategories](
	[CategoryID] [int] IDENTITY NOT NULL,
	[Category] [varchar](120) UNIQUE NOT NULL,
	[ExcludeFromCollection] [bit] DEFAULT ((0)),
	CONSTRAINT [PKWaitCategories] PRIMARY KEY CLUSTERED 
	(
		[CategoryID] ASC
	),
	) ON [PRIMARY]
END

-----------------------------------------------------------------------------------------------
IF (OBJECT_ID('WaitTypes') IS NULL)
BEGIN
CREATE TABLE [dbo].[WaitTypes](
	[WaitTypeID] [int] IDENTITY NOT NULL,
	[WaitType] [varchar](120) NOT NULL,
	[CategoryID] [int] NULL,
	[Description] [nvarchar](1000),
	[HelpLink] [nvarchar](500)
	CONSTRAINT [PKWaitTypes] PRIMARY KEY CLUSTERED 
	(
		[WaitTypeID] ASC
	)
	CONSTRAINT [FKWaitTypesWaitCategories] FOREIGN KEY 
		(
		[CategoryID]
		) 
	REFERENCES  [WaitCategories] 
		(
		[CategoryID]
		) on delete cascade) ON [PRIMARY]
END  

-----------------------------------------------------------------------------------------------
IF (OBJECT_ID('WaitStatistics') IS NULL)
BEGIN
CREATE TABLE [dbo].[WaitStatistics](
	[WaitStatisticsID] [bigint] IDENTITY NOT NULL,
	[SQLServerID] [int] NOT NULL ,
	[UTCCollectionDateTime] [datetime] NOT NULL ,
	[TimeDeltaInSeconds] [float] NULL,
	CONSTRAINT [FKWaitStatisticsMonitoredSQLServers] FOREIGN KEY 
		(
		[SQLServerID]
		) 
	REFERENCES  [MonitoredSQLServers] 
		(
		[SQLServerID]
		) on delete cascade,
	CONSTRAINT [UKWaitStatistics] UNIQUE NONCLUSTERED
	(
		[WaitStatisticsID] ASC
	),
	CONSTRAINT [PKWaitStatistics] PRIMARY KEY CLUSTERED 
	(
		[UTCCollectionDateTime],[SQLServerID] ASC
	)
	) ON [PRIMARY]
END

-----------------------------------------------------------------------------------------------
IF (OBJECT_ID('WaitStatisticsDetails') IS NULL)
BEGIN
CREATE TABLE [dbo].[WaitStatisticsDetails](
	[WaitStatisticsID] [bigint] NOT NULL,
	[WaitTypeID] [int] NOT NULL,
	[WaitingTasks] [bigint] NULL,
	[WaitTimeInMilliseconds] [bigint] NULL,
	[MaxWaitTimeInMilliseconds] [bigint] NULL,
	[ResourceWaitTimeInMilliseconds] [bigint] NULL,
	CONSTRAINT [FKWaitStatisticsDetailsWaitTypes] FOREIGN KEY 
		(
		[WaitTypeID]
		) 
	REFERENCES  [WaitTypes] 
		(
		[WaitTypeID]
		) on delete cascade,
	CONSTRAINT [FKWaitStatisticsDetailsWaitStatistics] FOREIGN KEY 
		(
		[WaitStatisticsID]
		) 
	REFERENCES  [WaitStatistics] 
		(
		[WaitStatisticsID]
		) on delete cascade,
	CONSTRAINT [PKWaitStatisticsDetails] PRIMARY KEY CLUSTERED 
	(
		[WaitStatisticsID], [WaitTypeID] ASC
	)
	) ON [PRIMARY]
END

-----------------------------------------------------------------------------------------------
IF (OBJECT_ID('XEMapKeys') IS NULL)
BEGIN

CREATE TABLE [dbo].[XEMapKeys](
	[WaitType] varchar(120) NOT NULL,
	[SQLVersion] [int] NOT NULL,
	[MapKey] [int] NOT NULL,
 CONSTRAINT [PK_XEMapKeys] PRIMARY KEY CLUSTERED 
(
	[WaitType] ASC,
	[SQLVersion] ASC
))
END
-----------------------------------------------------------------------------------------------


IF (OBJECT_ID('SQLStatements') IS NULL)
BEGIN
CREATE TABLE [dbo].[SQLStatements](
	[SQLStatementID] int identity,
	[SQLStatementHash] varchar(30),
	[SQLStatement] varchar(4000),
	[Overflow] bit,
	CONSTRAINT [UKSQLStatementHash] UNIQUE NONCLUSTERED
		(
			[SQLStatementHash] ASC
		),
	CONSTRAINT [PKSQLStatements] PRIMARY KEY CLUSTERED 
		(
			[SQLStatementID] ASC
		))

END

-----------------------------------------------------------------------------------------------
IF (OBJECT_ID('SQLStatementsOverflow') IS NULL)
BEGIN
CREATE TABLE [dbo].[SQLStatementsOverflow](
	[SQLStatementID] int,
	[SQLStatementOverflow] nvarchar(max),
	CONSTRAINT [PKSQLStatementsUnicode] PRIMARY KEY CLUSTERED 
	(
		[SQLStatementID] ASC
	),
	CONSTRAINT [FKSQLStatementsUnicodeSQLStatements] FOREIGN KEY 
		(
		[SQLStatementID]
		) 
	REFERENCES  [SQLStatements] 
		(
		[SQLStatementID]
		) on delete cascade)

	
END
else
begin
	-- Upgrade table if originally installed on 2000
	if exists(select id from syscolumns where id =  object_id('SQLStatementsOverflow') and name = 'SQLStatementOverflow' collate database_default and length > -1)
	begin
		alter table SQLStatementsOverflow alter column SQLStatementOverflow nvarchar(max)
	end
end

-----------------------------------------------------------------------------------------------
IF (OBJECT_ID('SQLSignatures') IS NULL)
BEGIN
CREATE TABLE [dbo].[SQLSignatures](
	[SQLSignatureID] int identity,
	[SQLSignatureHash] varchar(30) NOT NULL,
	[SQLSignature] varchar(4000),
	[Overflow] bit,
	[SQLStatementExampleID] int,
	[DoNotAggregate] bit,
	CONSTRAINT [UKSQLSignatureHash] UNIQUE NONCLUSTERED
	(
		[SQLSignatureHash] ASC
	),
	CONSTRAINT [PKSQLSignatures] PRIMARY KEY CLUSTERED 
	(
		[SQLSignatureID] ASC
	))

	CREATE INDEX [IXSignatureExample] on [SQLSignatures]([SQLStatementExampleID])
END

-- Upgrade table if originally installed on 2000
if (not exists(select 1 from INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE where CONSTRAINT_NAME = 'FKSQLSignaturesSQLStatements' collate database_default))
begin
	
	ALTER TABLE [SQLSignatures]
	ADD CONSTRAINT [FKSQLSignaturesSQLStatements] FOREIGN KEY 
		(
		[SQLStatementExampleID]
		) 
	REFERENCES  [SQLStatements] 
		(
		[SQLStatementID]
		) on delete set null
end


-----------------------------------------------------------------------------------------------
IF (OBJECT_ID('SQLSignaturesOverflow') IS NULL)
BEGIN
CREATE TABLE [dbo].[SQLSignaturesOverflow](
	[SQLSignatureID] int,
	[SQLSignatureOverflow] nvarchar(max),
	CONSTRAINT [PKSQLSignaturesUnicode] PRIMARY KEY CLUSTERED 
	(
		[SQLSignatureID] ASC
	),
	CONSTRAINT [FKSQLSignaturesUnicodeSQLSignatures] FOREIGN KEY 
		(
		[SQLSignatureID]
		) 
	REFERENCES  [SQLSignatures] 
		(
		[SQLSignatureID]
		) on delete cascade)

END

-- Upgrade table if originally installed on 2000
if exists(select id from syscolumns where id =  object_id('SQLSignaturesOverflow') 
	and name = 'SQLSignatureOverflow' collate database_default and length > -1)
begin
	alter table SQLSignaturesOverflow alter column SQLSignatureOverflow nvarchar(max)
end
-----------------------------------------------------------------------------------------------
IF (OBJECT_ID('HostNames') IS NULL)
BEGIN
CREATE TABLE [dbo].[HostNames](
	[HostNameID] int identity,
	[HostName] nvarchar(256),
	CONSTRAINT [UKHostName] UNIQUE NONCLUSTERED
	(
		[HostName] ASC
	),
	CONSTRAINT [PKHostNames] PRIMARY KEY CLUSTERED 
	(
		[HostNameID] ASC
	))
END

-----------------------------------------------------------------------------------------------
IF (OBJECT_ID('ApplicationNames') IS NULL)
BEGIN
CREATE TABLE [dbo].[ApplicationNames](
	[ApplicationNameID] int identity,
	[ApplicationName] nvarchar(256),
	CONSTRAINT [UKApplicationName] UNIQUE NONCLUSTERED
	(
		[ApplicationName] ASC
	),
	CONSTRAINT [PKApplicationNames] PRIMARY KEY CLUSTERED 
	(
		[ApplicationNameID] ASC
	))
END

-----------------------------------------------------------------------------------------------
IF (OBJECT_ID('LoginNames') IS NULL)
BEGIN
CREATE TABLE [dbo].[LoginNames](
	[LoginNameID] int identity,
	[LoginName] nvarchar(256),
	CONSTRAINT [UKLoginName] UNIQUE NONCLUSTERED
	(
		[LoginName] ASC
	),
	CONSTRAINT [PKLoginNames] PRIMARY KEY CLUSTERED 
	(
		[LoginNameID] ASC
	))
END

-----------------------------------------------------------------------------------------------
IF (OBJECT_ID('ActiveWaitStatistics') IS NULL)
BEGIN
CREATE TABLE [dbo].[ActiveWaitStatistics](
	[ActiveWaitID] [int] IDENTITY,
	[SQLServerID] [int] NOT NULL ,
	[UTCCollectionDateTime] [datetime] NOT NULL ,	
	[StatementUTCStartTime] [datetime] NOT NULL,
	[StatementLocalStartTime] [datetime],
	[WaitDuration] [bigint],
	[SessionID] [smallint],
	[WaitTypeID] [int],
	[HostNameID] [int],
	[ApplicationNameID] [int],
	[LoginNameID] [int],
	[DatabaseID] [int],
	[SQLStatementID] [int],
	[MSTicks] [bigint],
	[SQLSignatureID] [int],
	CONSTRAINT [FKActiveWaitStatisticsMonitoredSQLServers] FOREIGN KEY 
		(
		[SQLServerID]
		)
	REFERENCES  [MonitoredSQLServers] 
		(
		[SQLServerID]
		) on delete cascade,
	CONSTRAINT [FKActiveWaitStatisticsWaitTypes] FOREIGN KEY 
		(
		[WaitTypeID]
		) 
	REFERENCES  [WaitTypes] 
		(
		[WaitTypeID]
		) on delete cascade,
	CONSTRAINT [FKActiveWaitStatisticsHostNames] FOREIGN KEY 
		(
		[HostNameID]
		) 
	REFERENCES  [HostNames] 
		(
		[HostNameID]
		) on delete no action,
	CONSTRAINT [FKActiveWaitStatisticsApplicationNames] FOREIGN KEY 
		(
		[ApplicationNameID]
		) 
	REFERENCES  [ApplicationNames] 
		(
		[ApplicationNameID]
		) on delete no action,
	CONSTRAINT [FKActiveWaitStatisticsLoginNames] FOREIGN KEY 
		(
		[LoginNameID]
		) 
	REFERENCES  [LoginNames] 
		(
		[LoginNameID]
		) on delete no action,

	CONSTRAINT [FKActiveWaitStatisticsSQLServerDatabaseNames] FOREIGN KEY 
		(
		[DatabaseID]
		) 
	REFERENCES  [SQLServerDatabaseNames] 
		(
		[DatabaseID]
		) on delete no action,
	CONSTRAINT [FKActiveWaitStatisticsSQLStatements] FOREIGN KEY 
		(
		[SQLStatementID]
		) 
	REFERENCES  [SQLStatements] 
		(
		[SQLStatementID]
		) on delete cascade)
	CREATE CLUSTERED INDEX [IXActiveWaitStatistics] on [ActiveWaitStatistics]([StatementUTCStartTime])
	CREATE INDEX [IXActiveWaitStatisticsMSTicks] on [ActiveWaitStatistics]([SQLServerID],[MSTicks])
END


-- upgrade to 6.5
IF (not exists(select id from syscolumns where id=object_id('ActiveWaitStatistics') and name = 'SQLSignatureID' collate database_default))
BEGIN
		ALTER TABLE [ActiveWaitStatistics]
			ADD [SQLSignatureID] [int],
			[StatementLocalStartTime] datetime
END


--SQLdm 9.0 (Ankit Srivastava): Query Monitoring with Extended Event Session  -- Created new tables for Query Plans .
-------------------------------------------------------------------------------------
IF (OBJECT_ID('SQLQueryPlans') IS NULL)
BEGIN
CREATE TABLE [dbo].[SQLQueryPlans](
	[PlanID] int identity(1,1),
	[SQLStatementID] int ,
	[PlanXML] varchar(4000), --(Base64 encoded, compressed XML)
	[Overflow] bit,
	[IsActualPlan] bit NOT NULL DEFAULT 1, --SQLdm 10.0 (Tarun Sapra)- Flag for determining if the plan is actual or estimated
	CONSTRAINT [PKSQLQueryPlans] PRIMARY KEY CLUSTERED 
		(
			[PlanID] ASC
		),
	CONSTRAINT [FKSQLQueryPlansSQLStatementID] FOREIGN KEY 
			(
			[SQLStatementID]
			) 
		REFERENCES  [SQLStatements] 
			(
			[SQLStatementID]
			)  on delete cascade
		)

END

--Start -Upgrade to 10.0 (Tarun Sapra) - Estimated Query Plan View -- Flag for determining if the plan is actual or estimated
	if not exists(select name from sys.columns where object_id = object_id('SQLQueryPlans') and name=N'IsActualPlan' collate database_default )
	BEGIN
		ALTER TABLE SQLQueryPlans
		ADD IsActualPlan BIT NOT NULL DEFAULT 1	
	END
--End -Upgrade to 10.0 (Tarun Sapra) - Estimated Query Plan View -- Flag for determining if the plan is actual or estimated
------------------------------------------------------------------------------------------
--SQLdm 9.0 (Ankit Srivastava): Query Monitoring with Extended Event Session  --   new table for query plan overflowe
IF (OBJECT_ID('SQLQueryPlansOverflow') IS NULL)
BEGIN
CREATE TABLE [dbo].[SQLQueryPlansOverflow](
	[PlanID] int,
	[PlanXMLOverflow] nvarchar(max),
	CONSTRAINT [PKSQLQueryPlansOverflow] PRIMARY KEY CLUSTERED 
	(
		[PlanID] ASC
	),
	CONSTRAINT [PKSQLQueryPlansOverflowPlanID] FOREIGN KEY 
		(
		[PlanID]
		) 
	REFERENCES  [SQLQueryPlans] 
		(
		[PlanID]
		) on delete cascade
	)	
	
END
------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
IF (OBJECT_ID('QueryMonitorStatistics') IS NULL)
BEGIN

CREATE TABLE  [QueryMonitorStatistics] 
	(
	[QueryStatisticsID] [int] IDENTITY,
	[SQLServerID] [int] NOT NULL ,
	[UTCCollectionDateTime] [datetime] NOT NULL ,
	[StatementUTCStartTime] [datetime] NOT NULL,
	[StatementLocalStartTime] [datetime],
	[CompletionTime] as dateadd(ss,[DurationMilliseconds]/1000,[StatementUTCStartTime]),
	[DurationMilliseconds] [bigint] NULL,
	[CPUMilliseconds] [bigint] NULL,
	[Reads] [bigint] NULL,
	[Writes] [bigint] NULL,
	[HostNameID] [int],
	[ApplicationNameID] [int],
	[LoginNameID] [int],
	[DatabaseID] [int],
	[StatementType] [int] NULL,
	[SQLStatementID] [int],
	[SQLSignatureID] [int],
	[SessionID] [smallint],
	--Start -Upgrade to 9.0 (Ankit Srivastava ) - Query Plan View -- Added new column for PlanID
	[PlanID] [int] NULL,
	CONSTRAINT [FKQueryMonitorStatisticsSQLQueryPlans] FOREIGN KEY 
		(
		[PlanID]
		)
	REFERENCES  [SQLQueryPlans] 
		(
		[PlanID]
		),
	CONSTRAINT [FKQueryMonitorStatisticsMonitoredSQLServers] FOREIGN KEY 
		(
		[SQLServerID]
		)
	--End -Upgrade to 9.0 (Ankit Srivastava ) - Query Plan View -- Added new column for PlanID
	REFERENCES  [MonitoredSQLServers] 
		(
		[SQLServerID]
		) on delete cascade,
	CONSTRAINT [FKQueryMonitorStatisticsHostNames] FOREIGN KEY 
		(
		[HostNameID]
		) 
	REFERENCES  [HostNames] 
		(
		[HostNameID]
		) on delete no action,
	CONSTRAINT [FKQueryMonitorStatisticsApplicationNames] FOREIGN KEY 
		(
		[ApplicationNameID]
		) 
	REFERENCES  [ApplicationNames] 
		(
		[ApplicationNameID]
		) on delete no action,
	CONSTRAINT [FKQueryMonitorStatisticsLoginNames] FOREIGN KEY 
		(
		[LoginNameID]
		) 
	REFERENCES  [LoginNames] 
		(
		[LoginNameID]
		) on delete no action,
	CONSTRAINT [FKQueryMonitorStatisticsSQLServerDatabaseNames] FOREIGN KEY 
		(
		[DatabaseID]
		) 
	REFERENCES  [SQLServerDatabaseNames] 
		(
		[DatabaseID]
		) on delete no action,
	CONSTRAINT [FKQueryMonitorStatisticsSQLStatements] FOREIGN KEY 
		(
		[SQLStatementID]
		) 
	REFERENCES  [SQLStatements] 
		(
		[SQLStatementID]
		) on delete no action,
	CONSTRAINT [FKQueryMonitorStatisticsSQLSignatures] FOREIGN KEY 
		(
		[SQLSignatureID]
		)  
	REFERENCES  [SQLSignatures] 
		(
		[SQLSignatureID]
		) on delete no action
	)

	CREATE CLUSTERED INDEX [IXQueryMonitorStatistics] on [QueryMonitorStatistics]([StatementUTCStartTime])

	create index [IXQueryMonitorStatisticsSQLServerIDGrooming] on [QueryMonitorStatistics]([SQLServerID])
		
	create index [IXQueryMonitorStatisticsQueryStatisticsID] on [QueryMonitorStatistics]([QueryStatisticsID])
	
	CREATE INDEX [IXQueryMonitorStatisticsSQLServerID] ON [QueryMonitorStatistics] ([SQLServerID],[DurationMilliseconds], [StatementType]) 
		INCLUDE ([StatementUTCStartTime], [CPUMilliseconds], [Reads], [Writes], [HostNameID], [ApplicationNameID], [LoginNameID], [DatabaseID], [SQLStatementID], [SQLSignatureID], [SessionID])
END
else
begin
	-- Correct computed column if necessary
	if exists(select name from sys.computed_columns where object_id = object_id('QueryMonitorStatistics') and name=N'CompletionTime' and definition like '%UTCCollectionDateTime%')
	begin
		alter table QueryMonitorStatistics
			drop column [CompletionTime] 
		alter table QueryMonitorStatistics
			add [CompletionTime] as dateadd(ss,[DurationMilliseconds]/1000,[StatementUTCStartTime])
	end	
	--Start -Upgrade to 9.0 (Ankit Srivastava ) - Query Plan View -- Added new column for PlanID
	if not exists(select name from sys.columns where object_id = object_id('QueryMonitorStatistics') and name=N'PlanID' collate database_default )
	BEGIN
		alter table QueryMonitorStatistics
			add [PlanID] int NULL
		alter table QueryMonitorStatistics
			Add constraint [FKQueryMonitorStatisticsSQLQueryPlans] FOREIGN KEY 
			(
				[PlanID]
			)
			references [SQLQueryPlans] 
			(
				[PlanID]
			)
	END
	--End -Upgrade to 9.0 (Ankit Srivastava) - Query Plan View -- Added new column for PlanID	
		
end

-----------------------------------------------------------------------------------------------
IF (OBJECT_ID('AllSQLStatements') is not null)
BEGIN
	DROP VIEW  [dbo].[AllSQLStatements]
END
GO
create view [dbo].[AllSQLStatements]
as
	select
		ss.[SQLStatementID],
		ss.[SQLStatementHash],
		[SQLStatement] = cast(case when [Overflow] = 1 then so.[SQLStatementOverflow] else ss.[SQLStatement] end as nvarchar(max))
	from
		SQLStatements ss
		left join SQLStatementsOverflow so
		on ss.SQLStatementID = so.SQLStatementID

go

-----------------------------------------------------------------------------------------------
IF (OBJECT_ID('AllSQLSignatures') is not null)
BEGIN
	DROP VIEW  [dbo].[AllSQLSignatures]
END
GO
create view [dbo].[AllSQLSignatures]
as
	select
		ss.[SQLSignatureID],
		ss.[SQLSignatureHash],
		[SQLSignature] = cast(case when [Overflow] = 1 then so.[SQLSignatureOverflow] else ss.[SQLSignature] end as nvarchar(max)),
		[SQLStatementExample] = s.[SQLStatement],
		[DoNotAggregate] = ss.[DoNotAggregate]
	from
		SQLSignatures ss
		left join SQLSignaturesOverflow so
		on ss.SQLSignatureID = so.SQLSignatureID
		left join AllSQLStatements s
		on ss.[SQLStatementExampleID] = s.[SQLStatementID]

go
-------------------------------------------------------------------------------------------------
IF (OBJECT_ID('Blocks') IS NULL)
BEGIN
Create TABLE [dbo].[Blocks](
	[BlockID] [uniqueidentifier] NOT NULL,
	[XActID] [bigint] NOT NULL,
	[SQLServerID] [int] NOT NULL,
	[UTCCollectionDateTime] [datetime] NOT NULL,
	[XDLData] [nvarchar](max) NULL,
	CONSTRAINT [PKBlocks] PRIMARY KEY NONCLUSTERED
	(
		[BlockID]
	),
	CONSTRAINT [FKBlocksMonitoredSQLServers] FOREIGN KEY 
		(
		[SQLServerID]
		)
	REFERENCES  [MonitoredSQLServers] 
		(
		[SQLServerID]
		) on delete cascade 
	)

CREATE UNIQUE NONCLUSTERED INDEX [IX_Blocks] ON [dbo].[Blocks]
(
	[XActID] ASC,
	[UTCCollectionDateTime] ASC
)
END

-----------------------------------------------------------------------------------------------
IF (OBJECT_ID('BlockingSessionStatistics') IS NULL)
BEGIN

CREATE TABLE  [BlockingSessionStatistics] 
	(
	[BlockingSessionID] [int] IDENTITY,
	[SQLServerID] [int] NOT NULL ,
	[UTCCollectionDateTime] [datetime] NOT NULL,
	[BlockID] [uniqueidentifier] NULL,
	[BlockingUTCStartTime] [datetime] NOT NULL,
	[BlockingLocalStartTime] [datetime],
	[BlockingDurationMilliseconds] [bigint] NULL,
	[HostNameID] [int],
	[ApplicationNameID] [int],
	[LoginNameID] [int],
	[DatabaseID] [int],
	[SQLStatementID] [int],
	[SQLSignatureID] [int],
	[SessionID] [smallint],
	CONSTRAINT [FKBlockingSessionStatisticsMonitoredSQLServers] FOREIGN KEY 
		(
		[SQLServerID]
		)
	REFERENCES  [MonitoredSQLServers] 
		(
		[SQLServerID]
		) on delete cascade,
	CONSTRAINT [FKBlockingSessionStatisticsHostNames] FOREIGN KEY 
		(
		[HostNameID]
		) 
	REFERENCES  [HostNames] 
		(
		[HostNameID]
		) on delete no action,
	CONSTRAINT [FKBlockingSessionStatisticsApplicationNames] FOREIGN KEY 
		(
		[ApplicationNameID]
		) 
	REFERENCES  [ApplicationNames] 
		(
		[ApplicationNameID]
		) on delete no action,
	CONSTRAINT [FKBlockingSessionStatisticsLoginNames] FOREIGN KEY 
		(
		[LoginNameID]
		) 
	REFERENCES  [LoginNames] 
		(
		[LoginNameID]
		) on delete no action,
	CONSTRAINT [FKBlockingSessionStatisticsSQLServerDatabaseNames] FOREIGN KEY 
		(
		[DatabaseID]
		) 
	REFERENCES  [SQLServerDatabaseNames] 
		(
		[DatabaseID]
		) on delete no action,
	CONSTRAINT [FKBlockingSessionStatisticsSQLStatements] FOREIGN KEY 
		(
		[SQLStatementID]
		) 
	REFERENCES  [SQLStatements] 
		(
		[SQLStatementID]
		) on delete no action,
	CONSTRAINT [FKBlockingSessionStatisticsSQLSignatures] FOREIGN KEY 
		(
		[SQLSignatureID]
		) 
	REFERENCES  [SQLSignatures] 
		(
		[SQLSignatureID]
		) on delete no action	
	)
	CREATE CLUSTERED INDEX [IXBlockingSessionStatistics] on [BlockingSessionStatistics]([BlockingUTCStartTime])
	--SQLdm 9.1 (Ankit Srivastava ) --Rally Defect DE43572 -- Adding index to improve the query performance
	CREATE NONCLUSTERED INDEX [IXBlockingSessionStatistics_DurationMilliSeconds] on [BlockingSessionStatistics]([BlockingDurationMilliseconds])
END
ELSE
BEGIN
	if (not exists(select object_id from sys.columns where object_id = object_id('BlockingSessionStatistics') and name = 'BlockID' collate database_default)) 
	begin
		ALTER TABLE [BlockingSessionStatistics] add [BlockID] [uniqueidentifier] NULL
	end
	
END
----------------------------------------------------------------------------

IF (OBJECT_ID('Deadlocks') IS NULL)
BEGIN
CREATE TABLE  [Deadlocks] 
	(
	[DeadlockID] [uniqueidentifier] NOT NULL,
	[SQLServerID] [int] NOT NULL ,
	[UTCCollectionDateTime] [datetime] NOT NULL ,
	[XDLData] nvarchar(max) NULL,
	CONSTRAINT [PKDeadlocks] PRIMARY KEY 
	(
		[DeadlockID]
	),
	CONSTRAINT [FKSDeadlocksMonitoredSQLServers] FOREIGN KEY 
		(
		[SQLServerID]
		)
	REFERENCES  [MonitoredSQLServers] 
		(
		[SQLServerID]
		) on delete cascade 
	)
	
	CREATE INDEX [IXDeadlocks] ON [Deadlocks]([SQLServerID],[UTCCollectionDateTime]) 

END
ELSE
BEGIN
	if (exists(select id from syscolumns where id =  object_id('Deadlocks') and name = 'XDLData' collate database_default and length > -1))
	begin
		execute('alter table Deadlocks alter column XDLData nvarchar(max)')
	end
END

-----------------------------------------------------------------------------------------------
IF (OBJECT_ID('DeadlockProcesses') IS NULL)
BEGIN

CREATE TABLE  [DeadlockProcesses] 
	(
	[DeadlockProcessID] int IDENTITY,
	[DeadlockID] [uniqueidentifier],
	[SQLServerID] [int] NOT NULL ,
	[UTCCollectionDateTime] [datetime] NOT NULL ,
	[UTCOccurrenceDateTime] datetime,
	[LocalOccurrenceDateTime] datetime,
	[HostNameID] [int],
	[ApplicationNameID] [int],
	[LoginNameID] [int],
	[DatabaseID] [int],
	[SQLStatementID] [int],
	[SQLSignatureID] [int],
	[SessionID] [smallint],
	CONSTRAINT [PKDeadlockProcesses] PRIMARY KEY 
	(
		[DeadlockProcessID]
	),
	CONSTRAINT [FKDeadlockProcessesDeadlocks] FOREIGN KEY 
		(
		[DeadlockID]
		)
	REFERENCES  [Deadlocks] 
		(
		[DeadlockID]
		) on delete cascade,
	CONSTRAINT [FKDeadlockProcessesHostNames] FOREIGN KEY 
		(
		[HostNameID]
		) 
	REFERENCES  [HostNames] 
		(
		[HostNameID]
		) on delete no action,
	CONSTRAINT [FKDeadlockProcessesApplicationNames] FOREIGN KEY 
		(
		[ApplicationNameID]
		) 
	REFERENCES  [ApplicationNames] 
		(
		[ApplicationNameID]
		) on delete no action,
	CONSTRAINT [FKDeadlockProcessesLoginNames] FOREIGN KEY 
		(
		[LoginNameID]
		) 
	REFERENCES  [LoginNames] 
		(
		[LoginNameID]
		) on delete no action,
	CONSTRAINT [FKDeadlockProcessesSQLServerDatabaseNames] FOREIGN KEY 
		(
		[DatabaseID]
		) 
	REFERENCES  [SQLServerDatabaseNames] 
		(
		[DatabaseID]
		) on delete no action,
	CONSTRAINT [FKDeadlockProcessesSQLStatements] FOREIGN KEY 
		(
		[SQLStatementID]
		) 
	REFERENCES  [SQLStatements] 
		(
		[SQLStatementID]
		) on delete no action,
	CONSTRAINT [FKDeadlockProcessesSQLSignatures] FOREIGN KEY 
		(
		[SQLSignatureID]
		) 
	REFERENCES  [SQLSignatures] 
		(
		[SQLSignatureID]
		) on delete no action
		)
		--SQLdm 9.1 (Ankit Srivastava ) --Rally Defect DE43572 -- Adding index to improve the query performance
		CREATE index [DeadlockProcess_NonClustered] on DeadlockProcesses([SQLServerID],[UTCOccurrenceDateTime],[SQLSignatureID])
END

if not exists(select name from sys.indexes where name = 'DeadlockProcessDeadlockID')
begin

	create index DeadlockProcessDeadlockID on DeadlockProcesses([DeadlockID])

end


-----------------------------------------------------------------------------------------------
IF (OBJECT_ID('QuerySignatureAggregation') IS NULL)
BEGIN
create table QuerySignatureAggregation
(
	[QuerySignatureAggregationID] int identity,
	[SQLServerID] int,
	[EventUTCStartTime] datetime,	
	[QueryMonitorOccurrences] dec(38,0),
	[WaitOcurrences] dec(38,0),
	[BlockingOcurrences] dec(38,0),
	[DeadlockOcurrences] dec(38,0),
	[TotalDurationMilliseconds] dec(38,0),
	[MaxDurationMilliseconds] dec(38,0),
	[TotalCPUMilliseconds] dec(38,0),
	[MaxCPUMilliseconds] dec(38,0),
	[TotalReads] dec(38,0),
	[MaxReads] dec(38,0),	
	[TotalWrites] dec(38,0),
	[MaxWrites] dec(38,0),
	[StatementType] int,
	[TotalBlockingDurationMilliseconds] dec(38,0),
	[MaxBlockingDurationMilliseconds] dec(38,0),
	[TotalWaitDuration] dec(38,0),
	[MaxWaitDuration] dec(38,0),
	[ApplicationNameID] int,
	[DatabaseID] int,
	[SQLSignatureID] int,
	CONSTRAINT [PKQuerySignatureAggregation] PRIMARY KEY 
	(
		[QuerySignatureAggregationID]
	),
	CONSTRAINT [FKQuerySignatureAggregationMonitoredSQLServers] FOREIGN KEY 
		(
		[SQLServerID]
		)
	REFERENCES  [MonitoredSQLServers] 
		(
		[SQLServerID]
		)  on delete cascade,
	CONSTRAINT [FKQuerySignatureAggregationApplicationNames] FOREIGN KEY 
		(
		[ApplicationNameID]
		) 
	REFERENCES  [ApplicationNames] 
		(
		[ApplicationNameID]
		) on delete no action,
	CONSTRAINT [FKQuerySignatureAggregationSQLServerDatabaseNames] FOREIGN KEY 
		(
		[DatabaseID]
		) 
	REFERENCES  [SQLServerDatabaseNames] 
		(
		[DatabaseID]
		) on delete no action,
	CONSTRAINT [FKQuerySignatureAggregationSQLSignatures] FOREIGN KEY 
		(
		[SQLSignatureID]
		) 
	REFERENCES  [SQLSignatures] 
		(
		[SQLSignatureID]
		) on delete no action
	)
	--SQLdm 9.1 (Ankit Srivastava ) --Rally Defect DE43572 -- Adding index to improve the query performance
	create index [QuerySignatureAggregation_SQLServerID] on QuerySignatureAggregation([SQLServerID])
end

--------------------------------------------------------------
IF (OBJECT_ID('PredictiveModels') IS NULL)
BEGIN

	CREATE TABLE [PredictiveModels]
	(
		[SQLServerID] [int]   NOT NULL,
		[Metric]      [int]   NOT NULL,
		[Severity]    [int]   NOT NULL,
		[Timeframe]   [int]   NOT NULL,
		[Model]       [image] NOT NULL,
		CONSTRAINT [PK_PredictiveModels] PRIMARY KEY CLUSTERED 
		(
			[SQLServerID] ASC,
			[Metric]      ASC,
			[Severity]    ASC,
			[Timeframe]   ASC
		),
		CONSTRAINT [FKPredictiveModelsServerID] FOREIGN KEY 
		(
			[SQLServerID]
		)	
		REFERENCES [MonitoredSQLServers] 
		(
			[SQLServerID]
		)  on delete cascade
	)	

END

--------------------------------------------------------------
IF (OBJECT_ID('PredictiveForecasts') IS NULL)
BEGIN

	CREATE TABLE [PredictiveForecasts]
	(
		[SQLServerID] [int]   NOT NULL,
		[Metric]      [int]   NOT NULL,
		[Severity]    [int]   NOT NULL,
		[Timeframe]   [int]   NOT NULL,
		[Forecast]    [int]   NOT NULL,
		[Accuracy]    [decimal](5,2) NOT NULL,
		[Expiration]  [datetime] NOT NULL,
		CONSTRAINT [PK_PredictiveForecasts] PRIMARY KEY CLUSTERED 
		(
			[SQLServerID] ASC,
			[Metric]      ASC,
			[Severity]    ASC,
			[Timeframe]   ASC
		),
		CONSTRAINT [FKPredictiveForecastsServerID] FOREIGN KEY 
		(
			[SQLServerID]
		)	
		REFERENCES [MonitoredSQLServers] 
		(
			[SQLServerID]
		)  on delete cascade
	)	

END

--------------------------------------------------------------
IF (OBJECT_ID('RunQueryScripts') IS NULL)
BEGIN
	CREATE TABLE [RunQueryScripts]
	(
		[ScriptID] [int] IDENTITY(1,1) NOT NULL,
		[Type] [smallint] NOT NULL DEFAULT ((1)),
		[Name] [nvarchar](100) NOT NULL,
		[ScriptText] [nvarchar] (max) NOT NULL,
		CONSTRAINT [PK_RunQueryScripts] PRIMARY KEY CLUSTERED 
		(
			[ScriptID] ASC
		)
	)
END
ELSE
BEGIN
	--Upgrade to 7.2 if StateOverview is not nvarchar(max)
	IF (not exists(select sc.object_id from sys.columns sc inner join sys.types st on sc.system_type_id = st.system_type_id
		where object_id=OBJECT_ID('RunQueryScripts') 
		and sc.name='ScriptText' and lower(st.name) = 'nvarchar'  collate database_default))
	begin
		alter table [RunQueryScripts] alter column [ScriptText] nvarchar(max) NOT NULL
	END
END

--------------------------------------------------------------

IF (OBJECT_ID('VirtualHostServers') IS NULL)
BEGIN
	CREATE TABLE [VirtualHostServers]
	(
		[VHostID] [int] IDENTITY(1,1) NOT NULL,
		[VHostName] [nvarchar](256) NOT NULL,
		[VHostAddress] [nvarchar](256) NOT NULL,
		[Active] [bit] NOT NULL,
		[Deleted] [bit] NOT NULL,
		[Username] [nvarchar](128) NULL,
		[Password] [nvarchar](128) NULL,
		[RegisteredDate] [datetime] NOT NULL,
		[ServerType] [nvarchar](128) NOT NULL,
		CONSTRAINT [PKVirtualHostServers] PRIMARY KEY CLUSTERED 
		(
			[VHostID] ASC
		)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]

	ALTER TABLE [dbo].[VirtualHostServers] ADD CONSTRAINT [DF_VirtualServers_Active] DEFAULT ((1)) FOR [Active]

	ALTER TABLE [dbo].[VirtualHostServers] ADD CONSTRAINT [DF_VirtualHostServers_Deleted] DEFAULT ((0)) FOR [Deleted]

	ALTER TABLE [dbo].[VirtualHostServers] ADD CONSTRAINT [DF_VirtualHostServers_RegisteredDate] DEFAULT (getutcdate()) FOR [RegisteredDate]

	ALTER TABLE [dbo].[VirtualHostServers] ADD CONSTRAINT [UQ_VirtualHostServers_VHostAddress] UNIQUE NONCLUSTERED ([VHostAddress])
END
ELSE
BEGIN	
    --Upgrade to 8.5 (HyperV) if column ServerType does not exist
	IF (not exists(select sc.object_id from sys.columns sc inner join sys.types st on sc.system_type_id = st.system_type_id
		where object_id=OBJECT_ID('VirtualHostServers') 
		and sc.name='ServerType' and lower(st.name) = 'nvarchar'  collate database_default))
	BEGIN
		ALTER TABLE [dbo].[VirtualHostServers] ADD ServerType nvarchar(128) NOT NULL DEFAULT('Unknown')
	END
END
--------------------------------------------------------------

IF (OBJECT_ID('VMConfigData') IS NULL)
BEGIN

	create table [dbo].VMConfigData (
		[SQLServerID] int not null,
		[UTCCollectionDateTime] datetime not null,
		[UUID] nvarchar(128) null,				-- summary.config.instanceUUID
		[VMName] nvarchar(256) null,			-- summary.config.name
		[VMHeartBeat] int null,					-- guestHeartbeatStatus
		[DomainName] nvarchar(256) null,		-- guest.hostname
		[BootTime] datetime null,				-- runtime.boottime
		[NumCPUs] int null,						-- summary.config.numCpu
		[CPULimit] bigint null,					-- resourceConfig.cpuAllocation.limit
		[CPUReserve] bigint null,				-- resourceConfig.cpuAllocation.reservation
		[MemSize] bigint null,					-- summary.config.memorySizeMB
		[MemLimit] bigint null,					-- resourceConfig.memoryAllocation.limit
		[MemReserve] bigint null,				-- resourceConfig.memoryAllocation.reservation
		Constraint [PKVMConfigData] PRIMARY KEY CLUSTERED
		(
			[SQLServerID] ASC,
			[UTCCollectionDateTime] ASC
		)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]

	ALTER TABLE [dbo].[VMConfigData]  WITH CHECK ADD  CONSTRAINT [FKVMConfigDataMonitoredSQLServers] FOREIGN KEY([SQLServerID])
	REFERENCES [dbo].[MonitoredSQLServers] ([SQLServerID])
	ON DELETE CASCADE

	ALTER TABLE [dbo].[VMConfigData] CHECK CONSTRAINT [FKVMConfigDataMonitoredSQLServers]
	
	CREATE INDEX [IX_VMConfigData_UTCCollectionDateTime] on [VMConfigData]([UTCCollectionDateTime])
END

--------------------------------------------------------------

IF (OBJECT_ID('ESXConfigData') IS NULL)
BEGIN

	create table [dbo].ESXConfigData (
		[SQLServerID] int not null,
		[UTCCollectionDateTime] datetime not null,
		[UUID] nvarchar(128) null,				-- summary.hardware.uuid
		[HostName] nvarchar(256) null,			-- summary.config.name
		[DomainName] nvarchar(256) null,		-- config.network.dnsconfig.hostname + config.network.dnsconfig.domainname
		[Status] int null,						-- summary.overallStatus
		[BootTime] datetime null,				-- runtime.boottime
		[CPUMHz] int null,						-- summary.hardware.CPUMhz
		[NumCPUCores] smallint null,			-- summary.hardware.numCpuCores
		[NumCPUPkgs] smallint null,				-- summary.hardware.numCpuPkgs
		[NumCPUThreads] smallint null,			-- summary.hardware.numCpuThreads
		[NumNICs] int null,						-- summary.hardware.numNics
		[MemorySize] bigint null				-- summary.hardware.memorySize
		Constraint [PKESXConfigData] PRIMARY KEY CLUSTERED
		(
			[SQLServerID] ASC,
			[UTCCollectionDateTime] ASC
		)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]

	ALTER TABLE [dbo].[ESXConfigData]  WITH CHECK ADD  CONSTRAINT [FKESXConfigDataMonitoredSQLServers] FOREIGN KEY([SQLServerID])
	REFERENCES [dbo].[MonitoredSQLServers] ([SQLServerID])
	ON DELETE CASCADE

	ALTER TABLE [dbo].[ESXConfigData] CHECK CONSTRAINT [FKESXConfigDataMonitoredSQLServers]
	
	CREATE INDEX [IX_ESXConfigData_UTCCollectionDateTime] on [ESXConfigData]([UTCCollectionDateTime])

END

--------------------------------------------------------------

IF (OBJECT_ID('VMStatistics') IS NULL)
BEGIN

	create table [dbo].VMStatistics (
		[SQLServerID] int not null,
		[UTCCollectionDateTime] datetime not null,
		[CPUUsage] float null,
		[CPUUsageMHz] int null,
		[CPUReady] bigint null,
		[CPUSwapWait] bigint null,
		[MemSwapInRate] bigint null,
		[MemSwapOutRate] bigint null,
		[MemSwapped] bigint null,
		[MemActive] bigint null,
		[MemConsumed] bigint null,
		[MemGranted] bigint null,
		[MemBalooned] bigint null,
		[MemUsage] float null,
		[DiskRead] bigint null,
		[DiskWrite] bigint null, 
		[DiskUsage] bigint null,
		[NetUsage] bigint null,
		[NetReceived] bigint null,
		[NetTransmitted] bigint null,
		[PagePerSecVM] bigint null,
		[AvailableByteVm] bigint null
		Constraint [PKVMStatistics] PRIMARY KEY CLUSTERED
		(
			[SQLServerID] ASC,
			[UTCCollectionDateTime] ASC
		)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]

	ALTER TABLE [dbo].[VMStatistics]  WITH CHECK ADD  CONSTRAINT [FKVMStatisticsMonitoredSQLServers] FOREIGN KEY([SQLServerID])
	REFERENCES [dbo].[MonitoredSQLServers] ([SQLServerID])
	ON DELETE CASCADE

	ALTER TABLE [dbo].[VMStatistics] CHECK CONSTRAINT [FKVMStatisticsMonitoredSQLServers]
	
	CREATE INDEX [IX_VMStatistics_UTCCollectionDateTime] on [VMStatistics]([UTCCollectionDateTime])

END
ELSE
BEGIN
---upgrade to sqldm 8.5 (Gaurav Karwal): Fixed a bug in the script (START)
	IF (NOT EXISTS(select id from syscolumns where id=OBJECT_ID('VMStatistics') and name='PagePerSecVM' collate database_default))
	BEGIN
		ALTER TABLE VMStatistics ADD [PagePerSecVM] BIGINT NULL
	END
	IF (NOT EXISTS(select id from syscolumns where id=OBJECT_ID('VMStatistics') and name='AvailableByteVm' collate database_default))
	BEGIN
		ALTER TABLE VMStatistics ADD [AvailableByteVm] BIGINT NULL
	END
---upgrade to sqldm 8.5 (Gaurav Karwal): Fixed a bug in the script (END)
END

--------------------------------------------------------------

IF (OBJECT_ID('ESXStatistics') IS NULL)
BEGIN

	create table [dbo].[ESXStatistics] (
		[SQLServerID] int not null,
		[UTCCollectionDateTime] datetime not null,
		[CPUUsage] float null,
		[CPUUsageMHz] int null,
		[MemSwapInRate] bigint null,
		[MemSwapOutRate] bigint null,
		[MemActive] bigint null,
		[MemConsumed] bigint null,
		[MemGranted] bigint null,
		[MemBalooned] bigint null,
		[MemUsage] float null,
		[DiskRead] bigint null,
		[DiskWrite] bigint null, 
		[DiskDeviceLatency] bigint null,
		[DiskKernelLatency] bigint null,
		[DiskQueueLatency] bigint null,
		[DiskTotalLatency] bigint null,
		[DiskUsage] bigint null,
		[NetUsage] bigint null,
		[NetReceived] bigint null,
		[NetTransmitted] bigint null,
		[MemPagePerSec] bigint null,
		[AvailableMemBytes] bigint null
		Constraint [PKESXStatistics] PRIMARY KEY CLUSTERED
		(
			[SQLServerID] ASC,
			[UTCCollectionDateTime] ASC
		)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
	) ON [PRIMARY]

	ALTER TABLE [dbo].[ESXStatistics]  WITH CHECK ADD  CONSTRAINT [FKESXStatisticsMonitoredSQLServers] FOREIGN KEY([SQLServerID])
	REFERENCES [dbo].[MonitoredSQLServers] ([SQLServerID])
	ON DELETE CASCADE

	ALTER TABLE [dbo].[ESXStatistics] CHECK CONSTRAINT [FKESXStatisticsMonitoredSQLServers]

	CREATE INDEX [IX_ESXStatistics_UTCCollectionDateTime] on [ESXStatistics]([UTCCollectionDateTime])
END
ELSE
BEGIN
---upgrade to sqldm 8.5 (Gaurav Karwal): Fixed a bug in the script (START)
	IF (NOT EXISTS(select id from syscolumns where id=OBJECT_ID('ESXStatistics') and name='MemPagePerSec' collate database_default))
	BEGIN
		ALTER TABLE ESXStatistics ADD [MemPagePerSec] BIGINT NULL
	END
	IF (NOT EXISTS(select id from syscolumns where id=OBJECT_ID('ESXStatistics') and name='AvailableMemBytes' collate database_default))
	BEGIN
		ALTER TABLE ESXStatistics ADD [AvailableMemBytes] BIGINT NULL
	END
---upgrade to sqldm 8.5 (Gaurav Karwal): Fixed a bug in the script (END)
END

-------------------------------------------------------------------------------------

IF (OBJECT_ID('BaselineTemplates') IS NULL)
BEGIN

CREATE TABLE [BaselineTemplates]
	(
		[TemplateID]  [int] IDENTITY(1,1) NOT NULL,		
		[SQLServerID] [int] NOT NULL,
		[Template]    [nvarchar](1024) NOT NULL,
		[BaselineName] nvarchar(500) NOT NULL CONSTRAINT [DF_BaselineTemplates_BaselineName] DEFAULT 'Default', --[START] SQLdm 10.0 (Gaurav Karwal): for upgrade
		[Active] bit NOT NULL CONSTRAINT [DF_BaselineTemplates_Active] DEFAULT 0	--[START] SQLdm 10.0 (Gaurav Karwal): for upgrade		
		CONSTRAINT [PK_BaselineTemplates] PRIMARY KEY CLUSTERED 
			(
			[TemplateID] ASC
			),	
		CONSTRAINT [FKBaselineServersSQLServers] FOREIGN KEY 
			(
			[SQLServerID]
			)
		REFERENCES [MonitoredSQLServers] 
			(
			[SQLServerID]
			) on delete cascade
	)
	
	CREATE INDEX [IXBaselineTemplates] ON [BaselineTemplates]([SQLServerID]) 
END
ELSE
BEGIN
	--[START] SQLdm 10.0 (Gaurav Karwal): for upgrade
	IF (NOT EXISTS(select id from syscolumns where id = OBJECT_ID('BaselineTemplates') and name='BaselineName' collate database_default))
	BEGIN
		ALTER TABLE [BaselineTemplates] ADD BaselineName nvarchar(500) NOT NULL CONSTRAINT DF_BaselineTemplates_BaselineName DEFAULT 'Default'
	END
	
	IF (NOT EXISTS(select id from syscolumns where id = OBJECT_ID('BaselineTemplates') and name='Active' collate database_default))
	BEGIN
		ALTER TABLE [BaselineTemplates] ADD [Active] bit NOT NULL CONSTRAINT DF_BaselineTemplates_Active DEFAULT 0	
	END
	--[END] SQLdm 10.0 (Gaurav Karwal): for upgrade
END

-------------------------------------------------------------------------------------

IF (OBJECT_ID('BaselineStatistics') IS NULL)
BEGIN

CREATE TABLE [BaselineStatistics]
	(
		[UTCCalculation] [datetime] NOT NULL,
		[SQLServerID]  [int] NOT NULL,
		[TemplateID]   [int] NOT NULL,
		[MetricID]     [int] NOT NULL,
		[Mean]         [decimal] (38, 5) NOT NULL,
		[StdDeviation] [decimal] (38, 5) NOT NULL,
		[Min]          [decimal] (38, 5) NOT NULL,
		[Max]          [decimal] (38, 5) NOT NULL,
		[Count]        [bigint]  NOT NULL,		
		CONSTRAINT [PKBaselineStatistics] PRIMARY KEY CLUSTERED 
			(
				[SQLServerID],
				[UTCCalculation],
				[TemplateID],
				[MetricID]
			),	
		CONSTRAINT [FKBaselineStatisticsSQLServers] FOREIGN KEY 
			(
			[SQLServerID]
			)
		REFERENCES [MonitoredSQLServers] 
			(
			[SQLServerID]
			) on delete cascade	
	)
	
	CREATE INDEX [IXBaselineStatistics] ON [BaselineStatistics]([SQLServerID],[UTCCalculation]) 
END

-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------

IF (OBJECT_ID('DashboardLayouts') IS NULL)
BEGIN

CREATE TABLE [DashboardLayouts]
(
	[DashboardLayoutID] [int] IDENTITY(1,1) NOT NULL,
	[LoginName] [nvarchar](256) NULL,
	[Name] [nvarchar](128) NOT NULL,
	[LastUpdated] [datetime] NULL,
	[LastViewed] [datetime] NULL,
	[Configuration] [nvarchar](max) NOT NULL,
	[LayoutImage] [varbinary](max) NULL,
	CONSTRAINT [PKDashboardLayouts] PRIMARY KEY CLUSTERED 
	(
		[DashboardLayoutID] ASC
	)
)

	CREATE INDEX [IXDashboardLayouts] ON [DashboardLayouts]([LoginName],[Name]) 
END

-------------------------------------------------------------------------------------

IF (OBJECT_ID('DashboardDefaults') IS NULL)
BEGIN

CREATE TABLE [DashboardDefaults]
(
	[DashboardDefaultID] [int] IDENTITY(1,1) NOT NULL,
	[LoginName] [nvarchar](256) NOT NULL,
	[SQLServerID] [int] NULL,
	[DashboardLayoutID] [int] NOT NULL,
	CONSTRAINT [PKDashboardDefaults] PRIMARY KEY CLUSTERED 
	(
		[DashboardDefaultID] ASC
	)
)

	CREATE INDEX [IXDashboardDefaults] ON [DashboardDefaults]([LoginName],[SQLServerID],[DashboardLayoutID]) 
END

-------------------------------------------------------------------------------------

IF (OBJECT_ID('MetricThresholdInstances') IS NULL)
BEGIN
CREATE TABLE [dbo].[MetricThresholdInstances](
	[InstanceID] [int] IDENTITY(1,1) NOT NULL,
	[InstanceType] [int] NOT NULL,
	[ThresholdInstanceName] [nvarchar](255) NULL,
	[CreationDateTime] [datetime] NULL DEFAULT GETDATE(),
	 CONSTRAINT [PKMetricThresholdInstances] PRIMARY KEY CLUSTERED 
		(
		[InstanceID]
		)
	)

	CREATE INDEX [IXMetricThresholdInstances] ON [MetricThresholdInstances] ([InstanceType],[ThresholdInstanceName])
END

-------------------------------------------------------------------------------------
IF (OBJECT_ID('SQLsafeConnections') IS NULL)
BEGIN
create table SQLsafeConnections (
	RepositoryId		int Identity(1,1) not null,
	FriendlyName		nvarchar(256) null,
	InstanceName		nvarchar(256) not null,
	DatabaseName		nvarchar(128) not null,
	Active				bit not null default(1),
	Deleted				bit not null default(0),
	SecurityMode		bit not null,
	UserName			nvarchar(128) null,
	EncryptedPassword	nvarchar(128) null,
	RegisteredDate		datetime default(getutcdate()),
 CONSTRAINT [PKSQLsafeConnections] PRIMARY KEY ([RepositoryId])
)
END

-------------------------------------------------------------------------------------
IF (OBJECT_ID('MonitoredServerSQLsafeInstance') IS NULL)
BEGIN
	create table MonitoredServerSQLsafeInstance (
		SQLServerID int not null,
		RepositoryId int not null,
		RelatedInstanceId int not null,
		LastBackupActionId int not null,
		LastDefragActionId int not null
	 constraint [PKMonitoredServerSQLsafeInstance] PRIMARY KEY (SQLServerID),
	 constraint [FKMonitoredServerSQLsafeInstanceSQLServerId] foreign key (SQLServerID)
		references [MonitoredSQLServers] ([SQLServerID]) on delete cascade,
	 constraint [FKMonitoredServerSQLsafeInstanceRepositoryId] foreign key (RepositoryId)
		references [SQLsafeConnections] ([RepositoryId]) on delete cascade
	)	
END

-------------------------------------------------------------------------------------

IF  (OBJECT_ID(N'[dbo].[AuditableEvents]') IS NULL)
BEGIN
	CREATE TABLE [dbo].[AuditableEvents](
		[AuditableEventID] [bigint] identity(1,1) NOT NULL,
		[ActionID] [int] NOT NULL,
		[DateTime] [datetime] NOT NULL,
		[Workstation] [nvarchar](256) NOT NULL,
		[WorkstationUser] [nvarchar](256) NOT NULL,
		[SQLUser] [nvarchar](256) NOT NULL,
		[Name] [nvarchar](256) NOT NULL,
		[MetaData] [nvarchar](MAX) NULL,
		[Header] [nvarchar](500) NULL,
		CONSTRAINT [PK_AuditableEvents] PRIMARY KEY CLUSTERED ([AuditableEventID])
	 )
END

-------------------------------------------------------------------------------------

IF  (OBJECT_ID(N'[dbo].[AudtitableActions]') IS NOT NULL)
BEGIN
	drop table AudtitableActions
END

IF  (OBJECT_ID(N'[dbo].[AuditableActions]') IS NULL)
BEGIN
	CREATE TABLE [dbo].[AuditableActions](
		[ActionID] [int] NOT NULL,
		[Name] [nvarchar](128) NOT NULL,
		[SecurityRequired] [smallint] DEFAULT NULL,
		[HeaderTemplate] [nvarchar](256) NULL,
		CONSTRAINT [PK_AudtitableActions] PRIMARY KEY CLUSTERED ([ActionID])	 
	)
END

-------------------------------------------------------------------------------------

IF (OBJECT_ID(N'[dbo].[AlwaysOnAvailabilityGroups]') is null)
BEGIN
	CREATE TABLE [dbo].[AlwaysOnAvailabilityGroups](
        [GroupTopologyId] [bigint] IDENTITY(1,1) NOT NULL,
		[GroupId] [uniqueidentifier] NOT NULL,
		[GroupName] [sysname] NOT NULL,
        [ServerSourceName] [sysname] NOT NULL,
		[ListenerDnsName] [nvarchar](63) NOT NULL,
		[ListenerPort] [int] NOT NULL,
		[ListenerIpAddress] [nvarchar](48) NULL,
        [Active] [bit] NOT NULL DEFAULT 0,
        [Delete] [bit] NOT NULL DEFAULT 1
		CONSTRAINT [PK_AlwaysOnAvailabilityGroups] PRIMARY KEY CLUSTERED ([GroupTopologyId])
	)

END
-------------------------------------------------------------------------------------

IF (OBJECT_ID(N'[dbo].[AlwaysOnReplicas]') IS NULL)
BEGIN
	CREATE TABLE [dbo].[AlwaysOnReplicas](
        [ReplicaTopologyId] [bigint] IDENTITY(1,1) NOT NULL,
		[ReplicaId] [uniqueidentifier] NOT NULL,
		[GroupId] [uniqueidentifier] NOT NULL,
		[SQLServerID] [int] NOT NULL,
        [ServerSourceName] [sysname] NOT NULL,
		[ReplicaName] [nvarchar](256) NOT NULL,
        [ReplicaRole] [int] NOT NULL, -- TODO: Review if it is necesarry
		[FailoverMode] [int] NOT NULL,
		[AvailabilityMode] [int] NOT NULL,
		[PrimaryConnectionMode] [tinyint] NOT NULL,
		[SecondaryConnectionMode] [tinyint] NOT NULL,
        [Active] [bit] NOT NULL DEFAULT 0,
        [Delete] [bit] NOT NULL DEFAULT 1
		CONSTRAINT [PK_AlwaysOnReplicas] PRIMARY KEY CLUSTERED ([ReplicaTopologyId]),
	)
END

-------------------------------------------------------------------------------------

if (OBJECT_ID(N'[dbo].[AlwaysOnDatabases]') IS NULL)
BEGIN
	CREATE TABLE [dbo].[AlwaysOnDatabases](
		[AlwaysOnDatabasesID] [bigint] IDENTITY(1,1) NOT NULL,
		[ReplicaId] [uniqueidentifier] NOT NULL,
		[GroupId] [uniqueidentifier] NOT NULL,
		[GroupDatabaseId] [uniqueidentifier] NOT NULL,
        [ServerSourceName] [sysname] NOT NULL,
		[DatabaseID] [int] NULL,
		[DatabaseName] [sysname] NOT NULL,
        [Delete] [bit] NOT NULL DEFAULT 1
		CONSTRAINT [PK_AlwaysOnDatabases] PRIMARY KEY CLUSTERED ([AlwaysOnDatabasesID]),
	)
END

-------------------------------------------------------------------------------------
IF (OBJECT_ID(N'[dbo].[AlwaysOnStatistics]') IS NULL)
BEGIN
	CREATE TABLE [dbo].[AlwaysOnStatistics](
		[AlwaysOnStatisticsID] [bigint] IDENTITY(1,1) NOT NULL,
		[UTCCollectionDateTime] [datetime] NOT NULL,
		[ReplicaId] [uniqueidentifier] NOT NULL,
		[GroupId] [uniqueidentifier] NOT NULL,
        [GroupDatabaseId] [uniqueidentifier] NOT NULL,
		[DatabaseId] [int] NOT NULL,
		[SQLServerID] [int] NOT NULL,
		[IsFailoverReady] [bit] NOT NULL,
		[SynchronizationState] [tinyint] NOT NULL,
		[SynchronizationHealth] [tinyint] NOT NULL,
		[DatabaseState] [tinyint] NOT NULL,
		[IsSuspended] [bit] NOT NULL,
		[LastHardenedTime] [datetime] NULL,
		[LogSedQueueSize] [bigint] NOT NULL,
		[LogSendRate] [bigint] NOT NULL,
		[RedoQueueSize] [bigint] NOT NULL,
		[RedoRate] [bigint] NOT NULL,
		[ReplicaRole] [int] NULL,
		[OperationalState] [tinyint] NULL,
		[ConnectedState] [tinyint] NULL,
		[SynchronizationHealthAvailabilityReplica] [tinyint] NULL,
		[LastConnectErrorNumber] [int] NULL,
		[LastConnectErrorDescription] [nvarchar](1024) NULL,
		[LastConnectErrorTimestamp] [datetime] NULL,
		[EstimatedDataLossTime] [bigint] NULL,
		[SynchronizationPerformance] [int] NULL,
		[FilestreamSendRate] [bigint] NULL,
		[TimeDeltaInSeconds] [float] NULL,
        [EstimatedRecoveryTime] [int] NULL
		constraint [PK_AlwaysOnStatistics] primary key clustered ([AlwaysOnStatisticsID])
	)
END
-------------------------------------------------------------------------------------
IF (OBJECT_ID(N'[dbo].[DatabaseSizeDateTime]') IS NULL)
BEGIN
	CREATE TABLE  [DatabaseSizeDateTime] 
	(
		[DatabaseID] [int] NOT NULL ,
		[UTCCollectionDateTime] [datetime] NOT NULL,
		CONSTRAINT [PKDatabaseSizeTime] PRIMARY KEY NONCLUSTERED 
			(
			[DatabaseID],
			[UTCCollectionDateTime]
			), 
		CONSTRAINT [FKDatabaseSizeTimeSQLServerDatabaseNames] FOREIGN KEY 
			(
			[DatabaseID]
			) 
		REFERENCES  [SQLServerDatabaseNames] 
			(
			[DatabaseID]
			)  on delete cascade
		)

	insert into DatabaseSizeDateTime
	select DatabaseID, max(UTCCollectionDateTime)
	from DatabaseSize with (nolock)
	group by DatabaseID
END	

-- start -SQLdm 9.0 (Ankit Srivastava): Grooming Time out - creating new table for logging latest grooming status 
IF (OBJECT_ID('LatestGroomingStatus') IS NULL)
BEGIN
CREATE TABLE [dbo].[LatestGroomingStatus]
	(
		[SQLServerID] int NULL, 
		[GroomingRunID] uniqueidentifier NOT NULL, 
		[GroomingDateTimeUTC] DateTime, 
		[Status] smallint,-- failed =0 , succeeded =1, Hung=2
		[LastStatusMessage] nvarchar(250),
		[IsPrimary] bit
		CONSTRAINT [FKLatestGroomingStatusSqlServerID] FOREIGN KEY 
		(
			[SQLServerID]
		) 
		REFERENCES  [MonitoredSQLServers] 
		(
			[SQLServerID]
		) on delete cascade
	)
END
ELSE
BEGIN
	declare @objectID int
	select @objectID=object_id FROM sys.tables where name = 'LatestGroomingStatus'
	-- Drop the constraint IDENTITY for coulmn ID
	if exists(select name from sys.objects where name = 'PKLatestGroomingStatusID') 
	begin
		alter table [LatestGroomingStatus] drop constraint [PKLatestGroomingStatusID]		
	end
	-- Drop the column ID
	if exists(select * from sys.columns where object_id = @objectID and name = 'ID') 
	begin
		alter table [LatestGroomingStatus] drop column [ID]
	end
	
	alter table [LatestGroomingStatus] alter column [SQLServerID] int NULL
END

-------------------------------------------------------------------------------------------------
-- end -SQLdm 9.0 (Ankit Srivastava): Grooming Time out - creating new table for logging latest grooming status 

--START : SQLdm 9.0 (Abhishek Joshi): -CWF Integration  -- Created new table for Web Framework .
-------------------------------------------------------------------------------------
IF (OBJECT_ID('WebFramework') IS NULL)
BEGIN
CREATE TABLE [dbo].[WebFramework](
	[WebFrameworkID] int identity(1,1),
	[HostName] nvarchar(255) ,
	[Port] nvarchar(4),
	[UserName] nvarchar(100),
	[Password] nvarchar(100),
	[InstanceName] nvarchar(200),
	[ProductID] int,
	CONSTRAINT [PKWebFramework] PRIMARY KEY CLUSTERED 
		(
			[WebFrameworkID] ASC
		)
	)

END
ELSE
BEGIN
	IF NOT EXISTS(SELECT name FROM sys.columns WHERE LOWER(name) = LOWER('InstanceName') AND OBJECT_NAME(object_id) = 'WebFramework')
	BEGIN
		ALTER TABLE WebFramework ADD [InstanceName] nvarchar(200);
	END
END

------------------------------------------------------------------------------------------
--END : SQLdm 9.0 (Abhishek Joshi): -CWF Integration  -- Created new table for Web Framework .


--START : SQLdm 9.1 (Abhishek Joshi) -FileGroup Improvements --Created new tables for Disk Drive Statistics and filegroups 

IF (OBJECT_ID('DiskDriveStatistics') IS NULL)
	BEGIN
	CREATE TABLE [dbo].[DiskDriveStatistics] (
		[DiskDriveStatisticsID] int identity NOT NULL,
		[SQLServerID] int NOT NULL,
		[UTCCollectionDateTime] datetime NOT NULL ,
		[DriveName] nvarchar(256) NOT NULL,
		[UnusedSizeKB] dec(18,0),
		[TotalSizeKB] dec(18,0),
		[DiskIdlePercent] bigint,
		[AverageDiskQueueLength] bigint,
		[AverageDiskMillisecondsPerRead] bigint,
		[AverageDiskMillisecondsPerTransfer] bigint,
		[AverageDiskMillisecondsPerWrite] bigint,
		[DiskReadsPerSecond] bigint,
		[DiskTransfersPerSecond] bigint,
		[DiskWritesPerSecond] bigint,
		[DatabaseSizeTime] datetime null,
		CONSTRAINT [PK_DiskDriveStatistics] PRIMARY KEY CLUSTERED
		(
			[DiskDriveStatisticsID]
		)
	)
END


IF (OBJECT_ID('DatabaseFileStatistics') IS NULL)
BEGIN
	CREATE TABLE [dbo].[DatabaseFileStatistics] (
		[FileStatisticsID] int IDENTITY NOT NULL,
		[UTCCollectionDateTime] DateTime NOT NULL,
		[FileID] [int] NOT NULL ,
		[MaxSize] decimal,
		[InitialSize] decimal,
		[UsedSpace] decimal,
		[AvailableSpace] decimal,
		[FreeDiskSpace] decimal,
		[DriveName] nvarchar(256),
		CONSTRAINT [PK_DatabaseFileStatistics_ID] PRIMARY KEY  CLUSTERED 
		(
			[FileStatisticsID]
		), 
		CONSTRAINT [FK_DatabaseFileStatistics_FileID] FOREIGN KEY 
		(
			[FileID]
		) 
		REFERENCES  [DatabaseFiles] 
		(
			[FileID]
		) on delete cascade
	)
END
ELSE
BEGIN
--SQLdm 9.1 Added new Column
	IF (NOT EXISTS(select id from syscolumns where id=OBJECT_ID('DatabaseFileStatistics') and name='UTCCollectionDateTime' collate database_default))
	BEGIN
		ALTER TABLE DatabaseFileStatistics ADD [UTCCollectionDateTime] DateTime NOT NULL
	END
	--SQLdm 9.1.1 Increase the size of the varchar column(DriveName)
	IF (EXISTS(select id from syscolumns where id=OBJECT_ID('DatabaseFileStatistics') and name='DriveName' collate database_default))
	BEGIN
		ALTER TABLE DatabaseFileStatistics ALTER COLUMN [DriveName] nvarchar(256)
	END
END

--END : SQLdm 9.1 (Abhishek Joshi) -FileGroup Improvements --Created new tables for Disk Drive Statistics and filegroups

--START : SQLdm 10.0 (Srishti Purohit) -Custom DashBoard Implementation --Created new table for CustomDashboard 

IF (OBJECT_ID('CustomDashboard') IS NULL)
	BEGIN
		CREATE TABLE [dbo].[CustomDashboard](
		[CustomDashboardId] [bigint] NOT NULL
				 IDENTITY(1, 1),
		[CustomDashboardName] [nvarchar](500) NOT NULL,
		[IsDefaultOnUI] [bit] NULL,
		[UserSID] NVARCHAR(200) NULL,
		[Tags] [varchar](max) NULL,
		
		[RecordCreatedTimestamp] [datetime] NULL,
		[RecordUpdateDateTimestamp] [datetime] NULL
		
		 CONSTRAINT [PK_CustomDashboard] PRIMARY KEY CLUSTERED 
		(
			[CustomDashboardId] ASC
		)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
		) ON [PRIMARY]

	END

--END SQLdm 10.0 (Srishti Purohit) -Custom DashBoard Implementation --Created new table for CustomDashboard 
--START : SQLdm 10.0 (Srishti Purohit) -Custom DashBoard Implementation --Created new table for CustomDashboardWidgetTypes 

IF (OBJECT_ID('CustomDashboardWidgetTypes') IS NULL)
	BEGIN
	
	CREATE TABLE [dbo].[CustomDashboardWidgetTypes](
		[WidgetTypeID] [int] NOT NULL,
		[WidgetType] [nvarchar](250) NOT NULL,
	 CONSTRAINT [PK_dbo.CustomDashboardWidgetTypes] PRIMARY KEY CLUSTERED 
	(
		[WidgetTypeID] ASC
	)
	)

	
END

--END : SQLdm 10.0 (Srishti Purohit) -Custom DashBoard Implementation --Created new table for CustomDashboardWidgetTypes 

--START : SQLdm 10.0 (Srishti Purohit) -Custom DashBoard Implementation --Created new table for CustomDashboardMatchTypes 

IF (OBJECT_ID('CustomDashboardMatchTypes') IS NULL)
	BEGIN
		CREATE TABLE [dbo].[CustomDashboardMatchTypes](
			[MatchID] [int] NOT NULL,
			[MatchType] [nvarchar](250) NOT NULL,
		 CONSTRAINT [PK_dbo.CustomDashboardMatchTypes] PRIMARY KEY CLUSTERED 
		(
			[MatchID] ASC
		))

		
	END
--END : SQLdm 10.0 (Srishti Purohit) -Custom DashBoard Implementation --Created new table for CustomDashboardMatchTypes 

--START : SQLdm 10.0 (Srishti Purohit) -Custom DashBoard Implementation --Created new table for CustomDashboardWidget 

IF (OBJECT_ID('CustomDashboardWidgets') IS NULL)
	BEGIN
CREATE TABLE [dbo].[CustomDashboardWidgets](
	[WidgetID] [bigint] IDENTITY(1,1) NOT NULL,
	[DashboardID] [bigint] NOT NULL,
	[WidgetName] [nvarchar](500) NOT NULL,
	[WidgetTypeID] [int] NOT NULL,
	[MetricID] [int] NOT NULL,
	[MatchId] [int] NOT NULL,
	[RecordCreatedTimestamp] [datetime] NULL,
	[RecordUpdateDateTimestamp] [datetime] NULL,
 CONSTRAINT [PK_dbo.CustomDashboardWidgets] PRIMARY KEY CLUSTERED 
(
	[WidgetID] ASC
),
CONSTRAINT [fk_CustomDashboard] FOREIGN KEY([DashboardID])
REFERENCES [dbo].[CustomDashboard] ([CustomDashboardId]) on delete cascade
,CONSTRAINT [fk_Metric] FOREIGN KEY([MetricID])
REFERENCES [dbo].[MetricInfo] ([Metric]) on delete cascade
,CONSTRAINT [fk_Match] FOREIGN KEY([MatchId])
REFERENCES [dbo].[CustomDashboardMatchTypes] ([MatchID]) on delete cascade
,CONSTRAINT [fk_WidgetType] FOREIGN KEY([WidgetTypeID])
REFERENCES [dbo].[CustomDashboardWidgetTypes] ([WidgetTypeID]) on delete cascade)

END
--END SQLdm 10.0 (Srishti Purohit) -Custom DashBoard Implementation --Created new table for CustomDashboardWidget 

--START : SQLdm 10.0 (Srishti Purohit) -Custom DashBoard Implementation --Created new table for WidgetSourceMapping 

IF (OBJECT_ID('WidgetSourceMapping') IS NULL)
	BEGIN
	
		CREATE TABLE [dbo].[WidgetSourceMapping](
		[WidgetID] [bigint] NOT NULL,
		[SourceServerID] [int] NOT NULL,
		 CONSTRAINT [PK_WidgetSourceMapping] PRIMARY KEY CLUSTERED 
		(
			[WidgetID] ASC,
			[SourceServerID] ASC
		),
		CONSTRAINT [fk_Widget] FOREIGN KEY([WidgetID])
		REFERENCES [dbo].[CustomDashboardWidgets] ([WidgetID]) on delete cascade
		,CONSTRAINT [fk_Source] FOREIGN KEY([SourceServerID])
		REFERENCES [dbo].[MonitoredSQLServers] ([SQLServerID]) on delete cascade
		)
	END
--END : SQLdm 10.0 (Srishti Purohit) -Custom DashBoard Implementation --Created new table for WidgetSourceMapping


--START : SQLdm 10.0 (Srishti Purohit) -Custom DashBoard Implementation --Created new table for [WidgetTagMapping] 

IF (OBJECT_ID('WidgetTagMapping') IS NULL)
	BEGIN
	
		CREATE TABLE [dbo].[WidgetTagMapping](
		[WidgetID] [bigint] NOT NULL,
		[TagId] [int] NOT NULL,
		 CONSTRAINT [PK_WidgetTagMapping] PRIMARY KEY CLUSTERED 
		(
			[WidgetID] ASC,
			[TagId] ASC
		),
		CONSTRAINT [fk_WidgetTag] FOREIGN KEY([WidgetID])
		REFERENCES [dbo].[CustomDashboardWidgets] ([WidgetID]) on delete cascade
		,CONSTRAINT [fk_TagWidget] FOREIGN KEY([TagId])
		REFERENCES [dbo].[Tags] ([Id]) on delete cascade
		)
	END
--END : SQLdm 10.0 (Srishti Purohit) -Custom DashBoard Implementation --Created new table for [WidgetTagMapping]

--START 10.0 SQLdm srishti purohit -- Doctors Table

-- AnalysisConfiguration for Doctor

IF (OBJECT_ID('AnalysisConfiguration') IS NULL)
BEGIN
CREATE TABLE [AnalysisConfiguration](
	[ID] [int] identity(1,1) NOT NULL,
	[MonitoredServerID] [int] NOT NULL,
	[ProductionServer] [bit] NOT NULL,
	[OLTP] [bit] NOT NULL,
	[StartTime] [DATETIME] NULL,
	[Duration] [int] NULL,
	[ScheduledDays] smallint NOT NULL,
	[IncludeDatabase] [int] NULL,
	[IsActive] [bit] NOT NULL,
	[FilterApplication] nvarchar(max) NULL,
	[SchedulingStatus] bit NOT NULL DEFAULT(0) -- SQLDM 10.0 - Praveen Suhalka - Scheduling Status

	CONSTRAINT [ID] PRIMARY KEY CLUSTERED 
	(
		[ID] ASC
	)
)
END

-- AnalysisConfigCategories

IF (OBJECT_ID('AnalysisConfigCategories') IS NULL)
BEGIN
CREATE TABLE [AnalysisConfigCategories](
	[AnalysisConfigurationID] [int] NOT NULL,
	[CategoryID] [int] NOT NULL,

		CONSTRAINT [fk_AnalysisConfigurationIDForCategory] FOREIGN KEY([AnalysisConfigurationID])
		REFERENCES [dbo].[AnalysisConfiguration] ([ID]) on delete cascade,
		CONSTRAINT [fk_PrescriptiveRecommendationCategoryID] FOREIGN KEY([CategoryID])
		REFERENCES [dbo].PrescriptiveRecommendationCategory ([CategoryID]) on delete cascade
)
END

--AnalysisConfigBlockedDatabases
IF (OBJECT_ID('AnalysisConfigBlockedDatabases') IS NULL)
BEGIN
CREATE TABLE [AnalysisConfigBlockedDatabases](
	[AnalysisConfigurationID] [int] NOT NULL,
	[DatabaseID] [int] NOT NULL,

		CONSTRAINT [fk_AnalysisConfigurationIDForDB] FOREIGN KEY([AnalysisConfigurationID])
		REFERENCES [dbo].[AnalysisConfiguration] ([ID]) on delete cascade,
		CONSTRAINT [fk_DatabaseID] FOREIGN KEY([DatabaseID])
		
		REFERENCES  [SQLServerDatabaseNames] 
			(
			[DatabaseID]
			)  on delete cascade
)
END
-- AnalysisConfigBlockedRecommendation

IF (OBJECT_ID('AnalysisConfigBlockedRecommendation') IS NULL)
BEGIN
CREATE TABLE [AnalysisConfigBlockedRecommendation](
	[AnalysisConfigurationID] [int] NOT NULL,
	[RecommendationID] nvarchar(10) NOT NULL,

		CONSTRAINT [fk_AnalysisConfigurationIDForRecommendation] FOREIGN KEY([AnalysisConfigurationID])
		REFERENCES [dbo].[AnalysisConfiguration] ([ID]) on delete cascade,
		CONSTRAINT [fk_RecommendationIDForAnalysisConfigBlockedRecommendation] FOREIGN KEY([RecommendationID])
		
		REFERENCES  [PrescriptiveRecommendation] 
			(
			[RecommendationID]
			)  on delete cascade
)
END

--PrescriptiveRecommendationProperty
 
IF (OBJECT_ID('PrescriptiveRecommendationProperty') IS NULL)
BEGIN
	CREATE TABLE [PrescriptiveRecommendationProperty](
		 [ID] [int] identity(1,1) NOT NULL,
		 [RecommendationID] [nvarchar](10) NOT NULL,
		 [PropertyName] [nvarchar](200) NOT NULL,
		 
		CONSTRAINT [pk_PrescriptiveRecommendationPropertyID] PRIMARY KEY CLUSTERED 
		(
			[ID] ASC
		),

		CONSTRAINT [fk_PrescriptiveRecommendationPropertyRecommendation] FOREIGN KEY([RecommendationID])
		
		REFERENCES  [PrescriptiveRecommendation] 
			(
			[RecommendationID]
			)  on delete cascade)
END


--PrescriptiveAnalysisRecommendationProperty 
IF (OBJECT_ID('PrescriptiveAnalysisRecommendationProperty') IS NULL)
BEGIN
	CREATE TABLE [PrescriptiveAnalysisRecommendationProperty](
		 [ID] [int] identity(1,1) NOT NULL,
		 [AnalysisRecommendationID] [int] NOT NULL,
		 [PropertyID] [int] NOT NULL,
		 [Value] [nvarchar](max) NULL,
		 
		CONSTRAINT [pk_PrescriptiveAnalysisRecommendationPropertyID] PRIMARY KEY CLUSTERED 
		(
			[ID] ASC
		),

		CONSTRAINT [fk_PrescriptiveRecommendationPropertyID] FOREIGN KEY([PropertyID])
		
		REFERENCES  [PrescriptiveRecommendationProperty] 
			(
			[ID]
			)  on delete cascade,

		CONSTRAINT [fk_PrescriptiveAnalysisRecommendationID] FOREIGN KEY([AnalysisRecommendationID])
		
		REFERENCES  [PrescriptiveAnalysisRecommendation] 
			(
			[ID]
			)  on delete cascade)
END

--PrescriptiveAnalysisSnapshotValuesPrevious 
-- To support SDR-M16
IF (OBJECT_ID('PrescriptiveAnalysisSnapshotValuesPrevious') IS NULL)
BEGIN
	CREATE TABLE [PrescriptiveAnalysisSnapshotValuesPrevious](
		 [MonitoredServerID] [int] NOT NULL,
		 [ActiveNetworkCards] INT NOT NULL,
         [TotalNetworkBandwidth] BIGINT NOT NULL,
         [AllowedProcessorCount] INT NOT NULL,
         [TotalNumberOfLogicalProcessors] BIGINT NOT NULL,
         [TotalMaxClockSpeed] BIGINT NOT NULL,
         [TotalPhysicalMemory] BIGINT NOT NULL,
         [MaxServerMemory] BIGINT NOT NULL, 
		 [WindowsVersion] nvarchar(100) NULL,
		 [ProductVersion] nvarchar(100) NULL,
		 [SQLVersionString] nvarchar(100) NULL
		)
END


--END 10.0 SQLdm srishti purohit -- Doctors Table
 
GO 

---------- FN_CHECKDUPLICATECUSTOMDASHBOARDNAME.SQL

/****** Object:  Function [dbo].[fn_CheckDuplicateCustomDashboardName] 
Custom Dashboard functionality to check new custom dashboard name does not already exists
    Script Date: 26-May-15 11:35:58 AM ******/
if (object_id('fn_CheckDuplicateCustomDashboardName') is not null)
begin
drop function fn_CheckDuplicateCustomDashboardName
end
go


create function fn_CheckDuplicateCustomDashboardName(
	
	@CustomDashboardName nvarchar(500),
	@SID nvarchar(200)
	)
	RETURNS INT
begin
	declare @ret int
	select @ret = COUNT(CustomDashboardName) from dbo.[CustomDashboard] where CustomDashboardName = @CustomDashboardName AND UserSID = CONVERT(varbinary(85), @SID,1)
		
	return @ret
end
 

GO

 
GO 

---------- FN_COMPAREDATETIMERANGE.SQL
if (object_id('fn_CompareDateTimeRange') is not null)
begin
drop function fn_CompareDateTimeRange
end
go
create function fn_CompareDateTimeRange(
	@InputDateTime datetime,
	@StartDate datetime,
	@EndDate datetime,
	@StartTime datetime,
	@EndTime datetime,
	@Sun bit,
	@Mon bit,
	@Tue bit,
	@Wed bit,
	@Thu bit,
	@Fri bit,
	@Sat bit) RETURNS BIT
begin
	declare @ret bit
	declare @idt datetime
	declare @id datetime
	declare @it datetime
	declare @stt datetime
	declare @ett datetime

	select @idt = @InputDateTime
	select @id = dateadd(dd,0, datediff(dd,0,@idt))

	if (@StartDate is not null)
	begin
		if (@id < dateadd(dd,0, datediff(dd,0,@StartDate)))
			return 0
	end	

	if (@EndDate is not null)
	begin
		if (@id > dateadd(dd,0, datediff(dd,0,@EndDate)))
			return 0
	end	
	
	if (@StartTime is not null and @EndTime is not null)
	begin
		set @stt = dateadd(dd, -datediff(dd,0,@StartTime), @StartTime) 		
		set @ett = dateadd(dd, -datediff(dd,0,@EndTime), @EndTime)

		if (@stt <> @ett)
		begin
			set @it = @idt - @id
			if (@stt <= @ett)
			begin
				if (@it < @stt or @it > @ett)
					return 0
			end
			else
			begin
				if (@it > @ett and @it < @stt)
					return 0
			end
		end
	end	 
	
	if (@ret is null)
	begin
		set @ret = case datepart(dw,@idt)
			when 1 then @Sun
			when 2 then @Mon
			when 3 then @Tue
			when 4 then @Wed
			when 5 then @Thu
			when 6 then @Fri
			when 7 then @Sat
			else 1
		end
	end

	if (@ret is null)
		set @ret = 1

	return @ret;
end
 
GO 

---------- FN_GETCHARTSTARTANDENDTIMELABELS.SQL
--SQL DM 6.0 (Vineet Kumar)
--For defect fix DE41829. This function is created to avoid the overhead of creating a table with start and end time labels for charts.
--fn_GetChartTimeLabels exists but it gives only starttime. It enhanced performance

if (object_id('fn_GetChartStartAndEndTimeLabels') is not null)
begin
drop function [fn_GetChartStartAndEndTimeLabels]
end
go
CREATE function [fn_GetChartStartAndEndTimeLabels](@sampleTime datetime, @secondsInBucket int, @secondsInGraph int) 
returns @xAxisLabels table (labelStartTime datetime, labelEndTime datetime)
as
begin
declare @endOfGraphTime datetime
declare @startOfGraphTime datetime
declare @bucketTime datetime

set @endOfGraphTime = @sampleTime

select @startOfGraphTime= dateadd(s, -@secondsInGraph,@endOfGraphTime)
while @secondsInGraph > @secondsInBucket
begin
	select @bucketTime = dateadd(s, @secondsInGraph, @startOfGraphTime)
	if DATEPART(s,@bucketTime) % @secondsInBucket = 0
	begin
		insert @xAxisLabels
		select  dateadd(ms,-datepart(ms, @bucketTime)-@secondsInBucket*1000,@bucketTime), dateadd(ms,-datepart(ms, @bucketTime),@bucketTime)
		SET @secondsInGraph = @secondsInGraph - @secondsInBucket
	end
	ELSE
	BEGIN
	set @secondsInGraph = @secondsInGraph - 1
	END
end
RETURN

end
 
GO 

---------- FN_GETCHARTTIMELABELS.SQL
if (object_id('fn_GetChartTimeLabels') is not null)
begin
drop function fn_GetChartTimeLabels
end
go
CREATE function [fn_GetChartTimeLabels](@sampleTime datetime, @secondsInBucket int, @secondsInGraph int) 
returns @xAxisLabels table (labelTime datetime)
as
begin
declare @endOfGraphTime datetime
declare @startOfGraphTime datetime
declare @bucketTime datetime

set @endOfGraphTime = @sampleTime

select @startOfGraphTime= dateadd(s, -@secondsInGraph,@endOfGraphTime)

while @secondsInGraph > 0
begin
	select @bucketTime = dateadd(s, @secondsInGraph, @startOfGraphTime)
	if DATEPART(s,@bucketTime) % @secondsInBucket = 0
	begin
		insert @xAxisLabels
		select  dateadd(ms,-datepart(ms, @bucketTime),@bucketTime)
	end
	set @secondsInGraph = @secondsInGraph - 1
end
RETURN

end



GO

 
GO 

---------- FN_GETDATABASECREATIONDATE.SQL
if (object_id('fn_GetDatabaseCreationDate') is not null)
begin
drop function fn_GetDatabaseCreationDate
end
go
create function fn_GetDatabaseCreationDate()
	returns DateTime
begin
		return (Select create_date As crdate
		From master.sys.databases
		Where name = DB_NAME())
end
go
 
GO 

---------- FN_GETDATABASEVERSION.SQL
if (object_id('fn_GetDatabaseVersion') is not null)
begin
drop function fn_GetDatabaseVersion
end
go
create function fn_GetDatabaseVersion()
	returns nvarchar(16)
begin
	--For SQLdm internal use. Do not call this function directly.

	return ('10.0')
end
go
 
GO 

---------- FN_GETFORMATTEDTEMPLATE.SQL
if (object_id('fn_GetFormattedTemplate') is not null)
begin
drop function fn_GetFormattedTemplate
end
go

CREATE FUNCTION fn_GetFormattedTemplate(@template xml)
RETURNS @shredded table(Template nvarchar(1000))
AS
BEGIN

Declare @UseDefault varchar(5)
Declare @StartDateText varchar(50)
Declare @EndDateText varchar(50)
Declare @StartDate DateTime
Declare @EndDate DateTime
Declare @SelectedDays int
Declare @mon bit
Declare @tue bit
Declare @wed bit
Declare @thu bit
Declare @fri bit
Declare @sat bit
Declare @sun bit
Declare @templateString nvarchar(100)

SET @UseDefault =  @template.value('(/BaselineTemplate/UseDefault)[1]', 'varchar(5)');
SET @StartDateText =  @template.value('(/BaselineTemplate/StartDate)[1]', 'varchar(50)');
SET @EndDateText =  @template.value('(/BaselineTemplate/EndDate)[1]', 'varchar(50)');
SET @SelectedDays =  @template.value('(/BaselineTemplate/SelectedDays)[1]', 'int');

set @mon = case @SelectedDays & 4 when 4 then 1 else 0 end
set @tue = case @SelectedDays & 8 when 8 then 1 else 0 end
set @wed = case @SelectedDays & 16 when 16 then 1 else 0 end
set @thu = case @SelectedDays & 32 when 32 then 1 else 0 end
set @fri = case @SelectedDays & 64 when 64 then 1 else 0 end
set @sat = case @SelectedDays & 128 when 128 then 1 else 0 end
set @sun = case @SelectedDays & 1 when 1 then 1 else 0 end

SELECT @StartDate = CAST(LEFT(@StartDateText, 19) AS datetime)
SELECT @EndDate = CAST(LEFT(@EndDateText, 19) AS datetime)

select @templateString = case @UseDefault when 'true' then 'Last 7 Days ' else convert(nvarchar(30), @StartDate, 101) + ' to ' + convert(nvarchar(30), @EndDate, 101) + ' ' end
select @templateString = @templateString + 
		case @mon when 1 then ' Mon,' else '' end + 
		case @tue when 1 then ' Tue,' else '' end + 
		case @wed when 1 then ' Wed,' else '' end + 
		case @thu when 1 then ' Thu,' else '' end + 
		case @fri when 1 then ' Fri,' else '' end + 
		case @sat when 1 then ' Sat,' else '' end + 
		case @sun when 1 then ' Sun,' else '' end 
		
select @templateString = substring(@templateString,1,len(@templateString)-1)
select @templateString = @templateString + ' between ' + CONVERT(VARCHAR(28), @StartDate, 24) + ' and '+ CONVERT(VARCHAR(28), @EndDate, 24)

insert @shredded
select @templateString
return

END
 
GO 

---------- FN_GETSERVERNAME.SQL
if (object_id('fn_GetServerName') is not null)
begin
drop function fn_GetServerName
end
go
-- =============================================
-- Take the real server name which is replication uses and
-- Returns the name by which sqldm knows this server
-- return the registered name given the realname
-- if there are multiple entries with the same realname return the once where the instancename matches the realname (primary)
-- if there are no cases of instance equal real but rows were returned then the first instance name
-- if no rows were returned then return whatever registered name was passed in
-- =============================================
CREATE FUNCTION [dbo].[fn_GetServerName]
(
	-- Add the parameters for the function here
	@Server sysname
)
RETURNS sysname
AS
BEGIN
declare @returnString sysname

--return the default instance if it exists
Select @returnString = m.InstanceName
from MonitoredSQLServers m  (nolock)
where lower(RealServerName) = lower(@Server)
and lower(InstanceName) = lower(@Server)
and m.Active = 1
--if no default exists, there are only aliases
if @@RowCount = 0
 begin
	--return the last active server to be registered with this real name
	Select @returnString = m.InstanceName
	from MonitoredSQLServers m  (nolock)
	where lower(RealServerName) = lower(@Server) 
	and m.Active = 1
	if @@RowCount = 0
	--if no servers were found with this real name return the name the user passed in
	select @returnString = @Server
 end

return @returnString
END
GO
 
GO 

---------- FN_GETSERVERVERSIONSTRING.SQL
if (object_id('fn_GetServerVersionString') is not null)
begin
drop function fn_GetServerVersionString
end
go
create function fn_GetServerVersionString(
	@InputVersionString nvarchar(50)) 
	returns nvarchar(50)
begin

	declare 
		@ReturnVersionString nvarchar(50),
		@Major int,
		@Minor int,
		@Build int,
		@Rev int
	
	select @InputVersionString = rtrim(ltrim(@InputVersionString))

	select @Major = 0
	select @Minor = charindex('.',@InputVersionString,@Major + 1)
	select @Build = charindex('.',@InputVersionString,@Minor + 1)
	select @Rev = charindex('.',@InputVersionString,@Build + 1)

	select @Major = cast(substring(@InputVersionString,@Major,@Minor) as int)
	select @Minor = cast(substring(@InputVersionString,@Minor+1,@Build - @Minor - 1) as int)
	select @Build = case when @Rev > 0 then cast(substring(@InputVersionString,@Build+1,@Rev - @Build - 1) as int) 
					else cast(substring(@InputVersionString,@Build+1,len(@InputVersionString) - @Build) as int) end
	select @Rev = case when @Rev > 0 then cast(substring(@InputVersionString,@Rev+1,len(@InputVersionString) - @Rev) as int) 
					else 0 end
	
	select @ReturnVersionString = 'SQL Server ' +
		case 
			when @Major = 7 then '7 '
			when @Major = 8 then '2000 '
			when @Major = 9 then '2005 '
			when @Major = 10 and @Minor = 50 then '2008 R2 '
			when @Major = 10 then '2008 '
			when @Major = 11 then '2012 '
			when @Major = 12 then '2014 ' --added by Gaurav Karwal for SQL 2014 SQLdm 8.6
			when @Major > 12 then cast(@Major as nvarchar(4)) + ' '
		end +
		case 
			when @Major = 7 and @Build = 623 then '' 
			when @Major = 7 and @Build > 623 and @Build < 699 then 'RTM+'
			when @Major = 7 and @Build = 699 then 'SP1' 
			when @Major = 7 and @Build > 699 and @Build < 842 then 'SP1+'
			when @Major = 7 and @Build = 842 then 'SP2' 
			when @Major = 7 and @Build > 842 and @Build < 961 then 'SP2+'
			when @Major = 7 and @Build = 961 then 'SP3' 
			when @Major = 7 and @Build > 961 and @Build < 1063 then 'SP3+'
			when @Major = 7 and @Build = 1063 then 'SP4' 
			when @Major = 7 and @Build > 1063 then 'SP4+'
			when @Major = 8 and @Build = 194 then '' 
			when @Major = 8 and @Build > 194 and @Build < 384 then 'RTM+'
			when @Major = 8 and @Build = 384 then 'SP1' 
			when @Major = 8 and @Build > 384 and @Build < 534 then 'SP1+'
			when @Major = 8 and @Build = 534 then 'SP2' 
			when @Major = 8 and @Build > 534 and @Build < 760 then 'SP2+'
			when @Major = 8 and @Build = 760 then 'SP3' 
			when @Major = 8 and @Build > 760 and @Build < 2039 then 'SP3+'
			when @Major = 8 and @Build = 2039 then 'SP4' 
			when @Major = 8 and @Build > 2039 then 'SP4+'
			when @Major = 9 and @Build = 1314 then 'CTP' 
			when @Major = 9 and @Build > 1314 and @Build < 1399 then 'CTP+'
			when @Major = 9 and @Build = 1399 then '' 
			when @Major = 9 and @Build > 1399 and @Build < 2047 then 'RTM+'
			when @Major = 9 and @Build = 2047 then 'SP1' 
			when @Major = 9 and @Build > 2047 and @Build < 3042 then 'SP1+'
			when @Major = 9 and @Build = 3042 then 'SP2' 
			when @Major = 9 and @Build > 3042 and @Build < 4035 then 'SP2+'
			when @Major = 9 and @Build = 4035 then 'SP3' 
			when @Major = 9 and @Build = 4035 then 'SP3'
			when @Major = 9 and @Build > 4035 and @Build < 5000 then 'SP3+'
			when @Major = 9 and @Build = 5000 then 'SP4' 
			when @Major = 9 and @Build > 5000 then 'SP4+'
			when @Major = 10 and @Minor = 50 and @Build = 1092 then 'CTP'
			when @Major = 10 and @Minor = 50 and @Build between 1093 and 1599 then 'CTP+'
			when @Major = 10 and @Minor = 50 and @Build = 1600 then ''
			when @Major = 10 and @Minor = 50 and @Build between 1601 and 2499 then 'RTM+'
			when @Major = 10 and @Minor = 50 and @Build = 2500 then 'SP1'
			when @Major = 10 and @Minor = 50 and @Build = 4000 then 'SP2'
			when @Major = 10 and @Minor = 50 and @Build > 4000 then 'SP2+'
			when @Major = 10 and @Build = 1600 then '' 
			when @Major = 10 and @Build > 1600 and @Build < 2531 then 'RTM+'
			when @Major = 10 and @Build = 2531 then 'SP1' 
			when @Major = 10 and @Build > 2531 and @Build < 4000 then 'SP1+'
			when @Major = 10 and @Build = 4000 then 'SP2'
			when @Major = 10 and @Build > 4000 and @Build < 5500 then 'SP2+' 
			when @Major = 10 and @Build = 5500 then 'SP3'
			when @Major = 10 and @Build > 5500 then 'SP3+'
			when @Major = 11 and @Build = 1750 then 'RC0'
			when @Major = 11 and @Build > 1750 and @Build < 2100 then 'RC0+'						
			when @Major = 11 and @Build = 2100 then ''
			when @Major = 11 and @Build > 2100 then 'RTM+'
			--added by Gaurav Karal for SQL 2014
			when @Major = 12 and @Build = 2000 then 'RTM'
			when @Major = 12 and @Build = 2342 then 'SP1'
			when @Major = 12 and @Build = 2370 then 'SP2'
			when @Major = 12 and @Build = 2402 then 'SP3'
		end +
		' (' + @InputVersionString + ')'

	return @ReturnVersionString

end
 
GO 

---------- FN_GETSEVERITYBYMETRICVALUE.SQL
IF (OBJECT_ID('fn_GetSeverityByMetricValue') IS NOT NULL)
BEGIN
DROP FUNCTION [fn_GetSeverityByMetricValue]
END
GO
CREATE FUNCTION [dbo].[fn_GetSeverityByMetricValue]
(
	  @CriticalThreshold NUMERIC
	 ,@WarningThreshold NUMERIC
	 ,@InfoThreshold NUMERIC
	 ,@MetricValue NUMERIC
   	 ,@WarningState INT = 4
	 ,@CriticalState INT = 8
	 ,@InfoState INT = 2
	 ,@NormalState INT = 1
	 ,@NoneState INT = 0
)
RETURNS INT
AS
BEGIN
	DECLARE @retVal INT,@Direction INT;
	
	SELECT @Direction = CASE WHEN @CriticalThreshold = @WarningThreshold AND @InfoThreshold = @WarningThreshold THEN
							0
						ELSE
							CASE WHEN @CriticalThreshold < @WarningThreshold THEN
								-1
							ELSE
								CASE WHEN @CriticalThreshold = @WarningThreshold AND @WarningThreshold < @InfoThreshold THEN
									-1
								ELSE
									1
								END
							END
						
						END
	
	IF @Direction = 1 OR @Direction = 0 BEGIN
		SELECT @retVal = 
			CASE WHEN ISNUMERIC(@MetricValue) = 1 THEN
			  CASE WHEN (@MetricValue >= @InfoThreshold AND @MetricValue < @WarningThreshold) THEN @InfoState ELSE
				CASE WHEN (@MetricValue >= @WarningThreshold AND @MetricValue < @CriticalThreshold) THEN @WarningState ELSE
					CASE WHEN (@MetricValue >= @CriticalThreshold) THEN @CriticalState ELSE @NormalState END
				END
			  END
			ELSE
				@NoneState
			END;
	END
	ELSE BEGIN
		SELECT @retVal = 
			CASE WHEN ISNUMERIC(@MetricValue) = 1 THEN
			  CASE WHEN (@MetricValue <= @InfoThreshold AND @MetricValue > @WarningThreshold) THEN @InfoState ELSE
				CASE WHEN (@MetricValue <= @WarningThreshold AND @MetricValue > @CriticalThreshold) THEN @WarningState ELSE
					CASE WHEN (@MetricValue <= @CriticalThreshold) THEN @CriticalState ELSE @NormalState END
				END
			  END
			ELSE
				@NoneState
			END;
	END
	RETURN @retVal;
END
GO
--SELECT dbo.[fn_GetSeverityByMetricValue](85,90,95,100,default,default,default,default,default)
 
GO 

---------- FN_GROOMINGFRAGMENTATION.SQL

if (object_id('Grooming.fn_GroomingFragmentation') is not null)
begin
drop function Grooming.fn_GroomingFragmentation
end
go

create function Grooming.fn_GroomingFragmentation (
@database_id int,
@object_id int,
@index_id int)

returns @fragmentation table (
database_id smallint null, 
object_id int null, 
index_id int null, 
partition_number int null,
avg_fragmentation_in_percent float null)

begin

insert into @fragmentation 
select
database_id,
object_id,
index_id,
partition_number,
avg_fragmentation_in_percent
from
sys.dm_db_index_physical_stats (@database_id, @object_id, @index_id, null, 'limited')

return

end;
 
GO 

---------- FN_ROUNDDATETIME.SQL
if (object_id('fn_RoundDateTime') is not null)
begin
drop function fn_RoundDateTime
end
go
create function fn_RoundDateTime(
	@Interval int,
	@Time DateTime	
)
	returns DateTime
begin
	select @Time = Case
		When @Interval = 1 Then dateadd(hour, datediff(hour, 0, @Time), 0)
		When @Interval = 2 Then dateadd(day, datediff(day, 0, @Time), 0)
		When @Interval >= 3 Then dateadd(month, datediff(month, 0, @Time), 0) -- SQLdm9.1 (Ankit Srivastava) -- Rally Defect DE43423 -- added equal operator as well
		-- Always discard seconds and milliseconds.
		Else dateadd(minute, datediff(minute, 0, @Time), 0)
	End
	
	return @Time
end
go
 
GO 

---------- FN_SERVERVERSIONNVARCHARTOBIGINT.SQL
if (object_id('fn_ServerVersionnVarcharToBigInt') is not null)
begin
drop function fn_ServerVersionnVarcharToBigInt
end
go
create function [dbo].[fn_ServerVersionnVarcharToBigInt](
@ServerVersion nvarchar(30)) returns decimal(30,0)
begin
declare @major int
declare @minor int
declare @revision int
declare @build int
declare @points int
declare @strmajor nchar(5)
declare @strminor nchar(5)
declare @strbuild nchar(5)
declare @strrevision nchar(5)

select @points = 0
select @major = 0
select @minor = 0
select @build = 0
select @revision = 0

declare @tmpVersion nvarchar(30)
declare @leftOfPoint nvarchar(30)

select @tmpVersion = @ServerVersion

while charindex('.', @tmpVersion) > 1
begin
	if @points > 3 continue
	--take everything left of the first point
	select @leftOfPoint = left(@tmpVersion,charindex('.', @tmpVersion)-1)

	if @points = 0 	select @major = @leftOfPoint
	if @points = 1	select @minor = @leftOfPoint
	if @points = 2	select @build = @leftOfPoint
	if @points = 3	select @revision = @leftOfPoint
	
	--keep only the right portion of the version
	select @tmpVersion = right(@tmpVersion, Len(@tmpVersion) - charindex('.', @tmpVersion))
	select @points = @points + 1
end

--if there were no points the user wanted only to search on major
if @points = 0 	select @major = @tmpVersion
if @points = 1	select @minor = @tmpVersion
if @points = 2	select @build = @tmpVersion
if @points = 3	select @revision = @tmpVersion

if @major > 99999 select @major = 99999
if @minor > 99999 or @points = 0 select @minor = 99999
if @build > 99999 or @points = 0 or @points = 1 select @build = 99999
if @revision > 99999 or @points = 0 or @points = 1 or @points = 2 select @revision = 99999

SELECT @strmajor = REPLICATE('0', 5 - len(convert(nvarchar(5),@major))) + convert(nvarchar(5),@major)
SELECT @strminor = REPLICATE('0', 5 - len(convert(nvarchar(5),@minor))) + convert(nvarchar(5),@minor)
SELECT @strbuild = REPLICATE('0', 5 - len(convert(nvarchar(5),@build))) + convert(nvarchar(5),@build)
SELECT @strrevision = REPLICATE('0', 5 - len(convert(nvarchar(5),@revision))) + convert(nvarchar(5),@revision)

--select @strmajor + @strminor + @strbuild + @strrevision

return CONVERT(decimal(30,0), @strmajor+@strminor+@strbuild+@strrevision)
end
 
GO 

---------- FN_SPLIT.SQL
--Created by Gaurav Karwal - SQLdm 9.0
--Splits a passed string into a table
-- USAGE:SELECT * FROM fn_Split('t,e',',')
IF (object_id('fn_Split') IS NOT NULL)
BEGIN
DROP FUNCTION fn_Split
END
GO
CREATE FUNCTION fn_Split(@StringToBeSplit NVARCHAR(MAX), @CharToSplitFrom NVARCHAR(1))
RETURNS @Splitted TABLE(Value NVARCHAR(MAX),[Index] INT)
AS
BEGIN

DECLARE @Index INT;
DECLARE @CurrWord NVARCHAR(MAX),@ArgLen INT;
SELECT @Index = 1,@CurrWord = '',@ArgLen = LEN(@StringToBeSplit) ;
IF(@StringToBeSplit IS NULL OR @StringToBeSplit ='' OR @CharToSplitFrom IS NULL OR @CharToSplitFrom='') RETURN
	WHILE(@ArgLen +1 >= @Index)
	BEGIN
		DECLARE @CurrChar NVARCHAR(1);
		SELECT @CurrChar = SUBSTRING(@StringToBeSplit,@Index,@Index);
		
		IF(@CurrChar != @CharToSplitFrom)
		BEGIN
			SELECT @CurrWord = @CurrWord + @CurrChar;
			IF((@ArgLen + 1 = @Index)) INSERT INTO @Splitted SELECT @CurrWord, (SELECT COUNT(0) + 1 FROM @Splitted);
		END
		ELSE IF (@CurrChar = @CharToSplitFrom)
		BEGIN
			INSERT INTO @Splitted SELECT @CurrWord, (SELECT COUNT(0) + 1 FROM @Splitted);
			SELECT @CurrWord = '';
		END
		
		SELECT @Index = @Index + 1;
	END
	RETURN;
END
 
GO 

---------- SQL_SIGNATURE.SQL
if (object_id('SQL_Signature') is not null)
begin
drop function SQL_Signature
end
go
CREATE FUNCTION SQL_Signature 
	(@p1 ntext)
RETURNS nvarchar(3500)

--
-- This function is provided "AS IS" with no warranties, and confers no rights. 
-- Use of included script samples are subject to the terms specified at http://www.microsoft.com/info/cpyright.htm
-- 
-- Strips query strings in sysprocesses
AS
BEGIN 
	DECLARE @pos as INT
	DECLARE @mode as CHAR(10)
	DECLARE @maxlength as INT
	DECLARE @p2 as NCHAR(3500)
	DECLARE @currchar as CHAR(1), @nextchar as CHAR(1)
	DECLARE @p2len as INT


	SET @maxlength = len(rtrim(substring(@p1,1,3500)));
--	SET @maxlength = case when @maxlength > @parselength 
--			then @parselength else @maxlength end

	SET @pos = 1;
	SET @p2 = '';
	SET @p2len = 0;
	SET @currchar = ''
	set @nextchar = ''
	SET @mode = 'command';

	WHILE (@pos <= @maxlength) BEGIN
		SET @currchar = substring(@p1,@pos,1)
		SET @nextchar = substring(@p1,@pos+1,1)
		IF @mode = 'command' BEGIN
			SET @p2 = left(@p2,@p2len) + @currchar
			SET @p2len = @p2len + 1 
			IF @currchar in (',','(',' ','=','<','>','!') and
			   @nextchar between '0' and '9' BEGIN
				set @mode = 'number'
				SET @p2 = left(@p2,@p2len) + '#'
				SET @p2len = @p2len + 1
				END 
			IF @currchar = '''' BEGIN
				set @mode = 'literal'
				SET @p2 = left(@p2,@p2len) + '#'''
				SET @p2len = @p2len + 2 
				END
			END
		ELSE IF @mode = 'number' and @nextchar in (',',')',' ','=','<','>','!')
			SET @mode= 'command'
		ELSE IF @mode = 'literal' and @currchar = ''''
			SET @mode= 'command'

		SET @pos = @pos + 1
	END
	RETURN @p2 

END
GO

if exists (select id from syscolumns where id =  object_id('QueryMonitor') and name = 'StatementText' collate database_default and length = -1)
begin
	declare @cmd varchar(8000)
	select @cmd = replace(
				  replace(
				  replace( 
				  replace( 
				  replace( 
				  text, 
				  'nvarchar(3500)','nvarchar(max)'),
				  'NCHAR(3500)','nvarchar(max)'),
				  'SET @maxlength = len(rtrim(substring(@p1,1,3500)));','SET @maxlength = len(@p1)'),
				  '(@p1 ntext)','(@p1 nvarchar(max))'),
				  'CREATE FUNCTION SQL_Signature ','ALTER FUNCTION SQL_Signature ')
	from syscomments where id = object_id('SQL_Signature')
	execute( @cmd )
end

GO


 
GO 

---------- P_ADDALERT.SQL
if (object_id('p_AddAlert') is not null)
begin
drop procedure [p_AddAlert]
end
go

create procedure [p_AddAlert] 
	@UTCOccurrenceDateTime datetime,
	@ServerName nvarchar(256),
	@DatabaseName nvarchar(255),
	@TableName nvarchar(255),
	@Metric int,
	@Severity tinyint,
	@StateEvent tinyint,
	@Value float,
	@Heading nvarchar(256),
	@Message nvarchar(1024),
	@QualifierHash nvarchar(28),
	@LinkedData uniqueidentifier
as
begin
	DECLARE @err int
	DECLARE @alertid bigint
	DECLARE @active bit

	if (@Severity < 2)
		SELECT @active = 0
	else
		SELECT @active = 1

	if (@Metric = 56) 
		SELECT @active = 0

	-- dont actually insert the alert for metrics 
	--	34 - Long Running Agent Job
	--	35 - Bombed Agent Job
	if (@active = 0) and (@Metric in (34, 35)) 
	begin
--  old stuff to clear job alerts rather than adding an OK alert - no longer needed not that all alerts are added every refresh
--		UPDATE [Alerts] SET
--			[Active] = 0
--			WHERE
--				([Active] = 1 and [Metric] = @Metric) and
--				(@ServerName is null or [ServerName] = @ServerName) and
--				(@QualifierHash is null or [QualifierHash] = @QualifierHash)
--
--		SELECT @err = @@error
--
--		if (@err = 0)
--			COMMIT
--		else
--			ROLLBACK

		RETURN 0
	end

	BEGIN TRANSACTION

	INSERT	into Alerts WITH (TABLOCK) (
			[UTCOccurrenceDateTime],
			[ServerName],
			[DatabaseName],
			[TableName],
			[Active],
			[Metric],
			[Severity],
			[StateEvent],
			[Value],
			[Heading],
			[Message],
			[QualifierHash],
			[LinkedData]
		) VALUES (
			@UTCOccurrenceDateTime,
			@ServerName,
			@DatabaseName,
			@TableName,
			@active,
			@Metric,
			@Severity,
			@StateEvent,
			@Value,
			@Heading,
			@Message,
			@QualifierHash,
			@LinkedData)

	SELECT @err = @@error

--  This be old stuff to reset the active flag for all alerts matching the alert just added - it sucks the life out of an sql server
--	if (@err = 0)
--	begin
--		SELECT @alertid = SCOPE_IDENTITY()
--		print @alertid
--		
--		if ((@Metric = 48) or (@Metric = 12 AND @Value = 4)) 
--		begin
--			-- SQL Service Status is Undetermined
--			UPDATE [Alerts] SET
--				[Active] = 0
--			WHERE
--				([Active] = 1 and [AlertID] < @alertid) and
--				(@ServerName is null or [ServerName] = @ServerName)
--		end
--		else
--		begin
--			UPDATE [Alerts] SET
--				[Active] = 0
--			WHERE
--				([Active] = 1 and [Metric] = @Metric and [AlertID] < @alertid) and
--				(@ServerName is null or [ServerName] = @ServerName) and
--				(@DatabaseName is null or [DatabaseName] = @DatabaseName) and
--				(@TableName is null or [TableName] = @TableName) and 
--				(@QualifierHash is null or [QualifierHash] = @QualifierHash)
--		end
--		SELECT @err = @@error
--	end
	
	if (@err = 0)
		COMMIT
	else
		ROLLBACK

	RETURN @err
end
 
GO 

---------- P_ADDALERTTEMPLATE.SQL
if (object_id('p_AddAlertTemplate') is not null)
begin
drop procedure p_AddAlertTemplate
end
go

CREATE PROCEDURE [dbo].p_AddAlertTemplate(
	@SourceType int,
	@SourceID int,
	@Name nvarchar(256), 
	@Description nvarchar(1024),
--	@Default bit, 
	@templateID int output
)
AS
begin
	DECLARE @ID int
	declare @e int

	INSERT INTO [AlertTemplateLookup] values (@Name, @Description, 0)
	SET @e = @@error
	SELECT @ID = SCOPE_IDENTITY()
	
	IF (@e <> 0)
	BEGIN
		return @e
	END
	
	IF (@SourceType = 0)
	begin
		INSERT INTO [DefaultMetricThresholds] (
			[UserViewID],
			[Metric],
			[Enabled],
			[InfoThreshold],
			[WarningThreshold],
			[CriticalThreshold],
			[Data],
			[ThresholdInstanceID],
			[ThresholdEnabled],
			[IsBaselineEnabled],
			[BaselineCriticalThreshold]
				,[BaselineInfoThreshold],
				 [BaselineWarningThreshold]) 
			select 
				@ID,
				[Metric],
				[Enabled],
				[InfoThreshold],
				[WarningThreshold],
				[CriticalThreshold],
				[Data],
				[ThresholdInstanceID],
				[ThresholdEnabled],
				[IsBaselineEnabled],
				[BaselineCriticalThreshold]
				,[BaselineInfoThreshold],
				 [BaselineWarningThreshold]
				FROM 
					[DefaultMetricThresholds] 
				where 
					[UserViewID] = @SourceID
		
		SET @e = @@error	
	END
	ELSE
	BEGIN
		INSERT INTO [DefaultMetricThresholds] (
			[UserViewID],
			[Metric],
			[Enabled],
			[InfoThreshold],
			[WarningThreshold],
			[CriticalThreshold],
			[Data],
			[ThresholdInstanceID],
			[ThresholdEnabled],
			[IsBaselineEnabled],
			[BaselineCriticalThreshold]
				,[BaselineInfoThreshold],
				 [BaselineWarningThreshold]) 
			select 
				@ID,
				[Metric],
				[Enabled],
				[InfoThreshold],
				[WarningThreshold],
				[CriticalThreshold],
				[Data],
				[ThresholdInstanceID],
				[ThresholdEnabled],
				[IsBaselineEnabled],
				 [BaselineCriticalThreshold]
				,[BaselineInfoThreshold],
				 [BaselineWarningThreshold]
				FROM 
					[MetricThresholds]
				where 
					[SQLServerID] = @SourceID
		SET @e = @@error	
	END
	
	if (@e <> 0)
	BEGIN
		DELETE FROM [AlertTemplateLookup] WHERE [TemplateID] = @ID
	    return @e
	END
		
	SELECT @templateID = @ID 
	
	RETURN @e
END	
 
GO 

---------- P_ADDAUDITABLEEVENT.SQL
/****** Object:  StoredProcedure [dbo].[p_AddAuditableEvent]    Script Date: 02/07/2013 10:43:21 ******/
if (object_id('p_AddAuditableEvent') is not null)
begin
drop procedure p_AddAuditableEvent
end
go

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[p_AddAuditableEvent](
	@ActionID int,
	@Date datetime,
	@Workstation NVARCHAR(256),
	@WorkstationUser NVARCHAR(256),
	@SQLUser NVARCHAR(256),	
	@Name NVARCHAR(256),
	@MetaData NVARCHAR(4000),
	@Header NVARCHAR(500)
	)
AS
BEGIN
declare @e int

IF not EXISTS (SELECT * FROM AuditableActions WHERE ActionID=@ActionID)
BEGIN
  set  @e= @@error
END
else
begin
INSERT INTO [dbo].[AuditableEvents]
           ([ActionID]
           ,[DateTime]
           ,[Workstation]
           ,[WorkstationUser]
           ,[SQLUser]
           ,[Name]
           ,[MetaData]
           ,[Header])
     VALUES
           (@ActionID
            ,@Date
            ,@Workstation
            ,@WorkstationUser
            ,@SQLUser
            ,@Name
            ,@MetaData
            ,@Header)
                        
            
           SET @e = @@error                      
END
return @e
end
 
GO 

---------- P_ADDBASELINESTATISTICS.SQL

IF (object_id('p_AddBaselineStatistics') IS NOT NULL)
BEGIN
DROP PROCEDURE p_AddBaselineStatistics
END
GO

CREATE PROCEDURE [dbo].[p_AddBaselineStatistics]
(
	@UTCCalculation datetime,
	@SQLServerID  int,
	@TemplateID	  int,
	@MetricID     int,
	@Mean         decimal(38,5),
	@StdDeviation decimal(38,5),
	@Min          decimal(38,5),
	@Max          decimal(38,5),
	@Count        bigint
)
AS
BEGIN

	INSERT INTO BaselineStatistics VALUES (@UTCCalculation, @SQLServerID, @TemplateID, @MetricID, @Mean, @StdDeviation, @Min, @Max, @Count)

END
 
GO 

---------- P_ADDBASELINETEMPLATE.SQL

IF (object_id('p_AddBaselineTemplate') IS NOT NULL)
BEGIN
DROP PROCEDURE p_AddBaselineTemplate
END
GO

CREATE PROCEDURE [dbo].[p_AddBaselineTemplate]
(
	@SQLServerID  int,
	@Template     nvarchar(1024)
)
AS
BEGIN

DECLARE @oldtemmplateid int
SELECT @oldtemmplateid = TemplateID FROM BaselineTemplates WHERE SQLServerID = @SQLServerID and BaselineName='Default' and Active='1'

	IF @Template IS NOT NULL
	BEGIN
	
		IF @oldtemmplateid IS NULL OR NOT EXISTS (SELECT TemplateID FROM BaselineTemplates WHERE TemplateID = @oldtemmplateid AND Template = @Template AND BaselineName='Default' AND Active='1')
		BEGIN
		UPDATE [dbo].[BaselineTemplates]
			SET [Active] = '0'
			WHERE TemplateID =(select TemplateID from BaselineTemplates (NOLOCK) where SQLServerID = @SQLServerID and BaselineName = 'Default' and Active='1')
	
			INSERT INTO [dbo].[BaselineTemplates] ([SQLServerID]
           ,[Template]
           ,[BaselineName]
           ,[Active])
		   VALUES (@SQLServerID, @Template,'Default','1')					
		END
	
	END

END
 
 
GO 

---------- P_ADDCOLLECTIONSERVICES.SQL
if (object_id('p_AddCollectionServices') is not null)
begin
drop procedure p_AddCollectionServices
end
go
CREATE PROCEDURE [dbo].[p_AddCollectionServices](
	@InstanceName NVARCHAR(15),
	@MachineName NVARCHAR(15),
	@Address NVARCHAR(256),
	@Port int,
	@Enabled bit,
	@ManagementServiceId UNIQUEIDENTIFIER,
	@ReturnServiceId UNIQUEIDENTIFIER OUTPUT
)
AS
BEGIN
	DECLARE @id UNIQUEIDENTIFIER
	DECLARE @e INT

	BEGIN TRANSACTION

	-- see if this collection service is already registered (possible upgrade)
	SELECT @id = [CollectionServiceID] from CollectionServices
		WHERE [InstanceName] = @InstanceName and
			[MachineName] = @MachineName
	
	SELECT @e = @@error

	if (@id is null)
	begin
		-- does not exist so mark others not enabled and add the new collection service
		SELECT @id = NEWID()

		UPDATE [CollectionServices] SET [Enabled] = 0

		INSERT INTO [CollectionServices] ([CollectionServiceID],[InstanceName],[MachineName],[Address],[Port],[Enabled],[ManagementServiceID])
			VALUES (@id, @InstanceName, @MachineName, @Address, @Port, @Enabled, @ManagementServiceId)

		SELECT @e = @@error
	end
	else
	begin
		-- make sure this collection service is the only one enabled
		UPDATE [CollectionServices] SET [Enabled] = 0
			WHERE [CollectionServiceID] <> @id
		UPDATE [CollectionServices] SET [Enabled] = 1
			WHERE [CollectionServiceID] = @id
	end
	-- set return collection service id
	SELECT @ReturnServiceId = @id	

	IF (@e = 0)
	BEGIN
		-- make this the default collection service
		exec [p_SetDefaultCollectionService] @ManagementServiceId, @id
	END

	COMMIT		

	RETURN @e
END
 
GO 

---------- P_ADDCOUNTER.SQL
if (object_id('p_AddCounter') is not null)
begin
drop procedure p_AddCounter
end
go

CREATE PROCEDURE [dbo].p_AddCounter(
	@Name nvarchar(128),
	@Category nvarchar(64),	
	@Description nvarchar(512),
	@Class int, 
	@Flags int,
	@Scale float,
	@MinValue int,
	@MaxValue bigint,
	@DefaultInfoValue bigint,
	@DefaultWarningValue bigint,
	@DefaultCriticalValue bigint,
	@DoNotifications bit,
	@EventCategory int,
	@DefaultMessageID int,
	@AlertEnabledDefault bit, 
	@ValueComparison int,	
	@ValueType nvarchar(128),
	@Rank int,
	@MetricType int,
	@CalculationType int,
	@CounterEnabled bit,
	@ObjectName	nvarchar(256),
	@CounterName nvarchar(256),
	@InstanceName nvarchar(256),
	@Batch	nvarchar(max),
	@ServerType nvarchar(256),
	@AlertOnCollectionFailure bit,
	@ReturnMetricID int output
)
AS
begin
	declare @e int
	declare @MetricID int
	declare @InfoThresholdXML nvarchar(256)
	declare @WarningThresholdXML nvarchar(256)
	declare @CriticalThresholdXML nvarchar(256)
	declare @ComparisonText nvarchar(16)
	declare @Data nvarchar(256)
	declare @DisableInfoThreshold bit
	
	declare @CurrTemplateID int
	
	set @DisableInfoThreshold = 0
	
	if (@DefaultInfoValue < @MinValue) 
	begin
		set @DisableInfoThreshold = 1
		
		if (@ValueComparison = 0)
		begin
			set @DefaultInfoValue = @DefaultWarningValue - (@DefaultCriticalValue - @DefaultWarningValue)
			if (@DefaultInfoValue < @MinValue)
				set @DefaultInfoValue = @MinValue
		end
		else begin
			set @DefaultInfoValue = @DefaultWarningValue + (@DefaultWarningValue - @DefaultCriticalValue)
			if (@DefaultInfoValue > @MaxValue)
				set @DefaultInfoValue = @MaxValue
		end
	end

	INSERT INTO CustomCounterDefinition (
		[MetricType],
		[CalculationType],
		[Enabled],
		[Scale],
		[Object],
		[Counter],
		[Instance],
		[Batch],
		[ServerType]
	) VALUES (
		@MetricType,
		@CalculationType,
		1,
		@Scale,
		@ObjectName,
		@CounterName,
		@InstanceName,
		@Batch,
		@ServerType
	)
	
	SET @e = @@error
	IF (@e = 0)
	begin
		SELECT @MetricID = SCOPE_IDENTITY()
		
		INSERT INTO MetricMetaData(
			[Metric],
			[Class],
			[Flags],
			[MinValue],
			[MaxValue],
			[DefaultWarningValue],
			[DefaultCriticalValue],
			[DoNotifications],
			[EventCategory],
			[DefaultMessageID],
			[AlertEnabledDefault],
			[ValueComparison],
			[ValueType],
			[Rank],
			[DefaultInfoValue],
			[TableName],
			[ColumnName],
			[BaselineMaxValue], --10.0 SQLdm srishti purohit adding baseline default meta data
			[BaselineDefaultWarningValue],
			[BaselineDefaultCriticalValue],
			[BaselineDefaultInfoValue]
		) VALUES (
			@MetricID,
			@Class,
			@Flags,
			@MinValue,
			@MaxValue,
			@DefaultWarningValue,
			@DefaultCriticalValue,
			@DoNotifications,
			@EventCategory,
			@DefaultMessageID,
			@AlertEnabledDefault,
			@ValueComparison,
			@ValueType,
			@Rank,
			@DefaultInfoValue,
			'CustomCounterStatistics',
			'RawValue',
			300,
			100,
			case when @ValueComparison = 0 then 120 else 50 end,
			case when @ValueComparison = 0 then 50 else 120 end
		)	
		SET @e = @@error
		IF (@e = 0)
		begin
			INSERT INTO MetricInfo (
				[Metric],
				[Rank],
				[Category],
				[Name],
				[Description]
			) VALUES (
				@MetricID,
				@Rank,
				@Category,
				@Name,
				@Description
			)

			SET @e = @@error
		end
	end
	if (@e = 0)
	begin
		-- insert default alert configuration row
		set @WarningThresholdXML = 
			'<?xml version="1.0" encoding="utf-16"?><Threshold xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" Op="' 
		set @CriticalThresholdXML = @WarningThresholdXML
		set @InfoThresholdXML = @WarningThresholdXML
		
	    -- append comparison type
		if (@ValueComparison = 0)
			set @ComparisonText = 'GE'
		else
			set @ComparisonText = 'LE'
			

		set @InfoThresholdXML = @InfoThresholdXML + @ComparisonText + '" Enabled="'+ case when @DisableInfoThreshold = 1 then 'false' else 'true' end + '"><Value xsi:type="xsd:long">'
		set @WarningThresholdXML = @WarningThresholdXML + @ComparisonText + '" Enabled="true"><Value xsi:type="xsd:long">'
		set @CriticalThresholdXML = @CriticalThresholdXML + @ComparisonText + '" Enabled="true"><Value xsi:type="xsd:long">'

		-- append value

		set @InfoThresholdXML = @InfoThresholdXML + CAST(@DefaultInfoValue AS nvarchar(32)) + '</Value></Threshold>'
		set @WarningThresholdXML = @WarningThresholdXML + CAST(@DefaultWarningValue AS nvarchar(32)) + '</Value></Threshold>'
		set @CriticalThresholdXML = @CriticalThresholdXML + CAST(@DefaultCriticalValue AS nvarchar(32)) + '</Value></Threshold>'

			
		if (@AlertOnCollectionFailure = 1)
			set @Data = '<?xml version="1.0" encoding="utf-16"?><ObjectWrapper xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><Value xsi:type="xsd:boolean">true</Value></ObjectWrapper>'

		set @CurrTemplateID = -1
		
		select @CurrTemplateID = MIN(TemplateID) from AlertTemplateLookup where TemplateID > @CurrTemplateID
		
		while (@CurrTemplateID is not null)
		begin
		
			exec p_AddDefaultMetricThreshold 
				@CurrTemplateID, 
				@MetricID, 
				@AlertEnabledDefault, 
				@WarningThresholdXML, 
				@CriticalThresholdXML, 
				@Data,
				@InfoThresholdXML
				
			select @CurrTemplateID = MIN(TemplateID) from AlertTemplateLookup where TemplateID > @CurrTemplateID
			
		end
	end

	if (@e = 0) 
	begin
		SET @ReturnMetricID = @MetricID 
	end

	RETURN @e
END	
 
GO 

---------- P_ADDDASHBOARDLAYOUT.SQL
if (object_id('p_AddDashboardLayout') is not null)
begin
drop procedure [p_AddDashboardLayout]
end
go

create procedure [p_AddDashboardLayout] 
	@LoginName nvarchar(256),
	@Name nvarchar(128),
	@Configuration nvarchar(max),
	@Image image,
	@UseAsDefault bit,
	@newID int output
as
begin

	declare @ID int

	insert into [DashboardLayouts]
			(LoginName,
			Name,
			LastUpdated,
			LastViewed,
			Configuration,
			LayoutImage
			)
		values (@LoginName,
				@Name,
				GETUTCDATE(),
				GETUTCDATE(),
				@Configuration,
				@Image
			)

	select @ID = SCOPE_IDENTITY()

	if (@UseAsDefault = 1)
		exec p_SetDefaultDashboardLayout @LoginName, null, @ID

	select @newID = @ID
end	
 
GO 

---------- P_ADDDATABASEFILEINFORMATION.SQL
-- SQLdm 9.1 (Abhishek Joshi)

-- Filegroup Improvements
-- insert the database files information

-- exec p_AddDatabaseFileInformation @MaxSize = 45,
-- 								     @InitialSize = 64,
--								     @UsedSpace = 47,
--								     @AvailableSpace = 43,
--								     @FreeDiskSpace = 65,
--								     @DriveName = 'C'

IF (OBJECT_ID('p_AddDatabaseFileInformation') is not null)
BEGIN
	DROP PROCEDURE [p_AddDatabaseFileInformation]
END

GO

CREATE PROCEDURE [dbo].[p_AddDatabaseFileInformation]
	@MaxSize DECIMAL,
	@InitialSize DECIMAL,
	@UsedSpace DECIMAL,
	@AvailableSpace DECIMAL,
	@FreeDiskSpace DECIMAL,
	@DriveName NVARCHAR(256),
	@FileName NVARCHAR(256),
	@FilePath NVARCHAR(max),
	@FileGroupName NVARCHAR(4000),
	@FileType BIT,
	@DatabaseName NVARCHAR(256),
	@SQLServerID INT,
	@UTCCollectionDateTime DATETIME
AS
BEGIN
	
	DECLARE @DatabaseID INT;
	SELECT @DatabaseID = (SELECT DatabaseID FROM SQLServerDatabaseNames WITH(NOLOCK) WHERE DatabaseName = @DatabaseName and SQLServerID = @SQLServerID);

	IF EXISTS(SELECT FileID FROM DatabaseFiles WITH(NOLOCK) WHERE [FileName] = @FileName  and [DatabaseID] = @DatabaseID)
	BEGIN
		UPDATE DatabaseFiles 
								SET [DriveName] = @DriveName, 
									[FileGroupName] = @FileGroupName 
								WHERE [FileName] = @FileName and [DatabaseID] = @DatabaseID
	END
	ELSE
	BEGIN
		INSERT INTO DatabaseFiles(DatabaseID,[FileName],FileType,FilePath,DriveName,FileGroupName)
		SELECT @DatabaseID,@FileName,@FileType,@FilePath,@DriveName,@FileGroupName
	END

	IF NOT EXISTS(SELECT FileID FROM DatabaseFiles WITH(NOLOCK) WHERE [FileName] = @FileName and [FileGroupName] =@FileGroupName and [DatabaseID] = @DatabaseID)
	BEGIN
		INSERT INTO DatabaseFiles(DatabaseID,[FileName],[FileGroupName],[DriveName],[FilePath],FileType)
		SELECT DatabaseID,@FileName,@FileGroupName,@DriveName,@FilePath,@FileType  FROM SQLServerDatabaseNames SSDN WITH(NOLOCK) 
		WHERE SSDN.SQLServerID=@SQLServerID and SSDN.DatabaseName=@DatabaseName 
	END

	INSERT INTO [DatabaseFileStatistics]( [UTCCollectionDateTime],FileID, MaxSize, InitialSize, UsedSpace, AvailableSpace, FreeDiskSpace, DriveName)
	SELECT @UTCCollectionDateTime,DF.FileID, @MaxSize, @InitialSize, @UsedSpace, @AvailableSpace, @FreeDiskSpace, @DriveName
	FROM  DatabaseFiles DF WITH(NOLOCK)
	JOIN SQLServerDatabaseNames SSDN WITH(NOLOCK) ON DF.DatabaseID=SSDN.DatabaseID 
	WHERE SSDN.SQLServerID=@SQLServerID and SSDN.DatabaseName=@DatabaseName
	and DF.[FileName]=@FileName
END
GO
 
GO 

---------- P_ADDDEFAULTALERTTEMPLATE.SQL
if (object_id('p_AddDefaultAlertTemplate') is not null)
begin
drop procedure [p_AddDefaultAlertTemplate]
end
go

create procedure [p_AddDefaultAlertTemplate]
	@templateID int output
as
begin
	DECLARE @defaultID int
	DECLARE @err int
	set @err = 0

	IF (not exists(SELECT [TemplateID] FROM AlertTemplateLookup where [Default] = 1))
	BEGIN
			INSERT INTO AlertTemplateLookup (
				[Name],
				[Description],
				[Default]) 
			VALUES (
				'Default Template', 
				'SQLdm Default Template created by Management Services', 
				1)
			
			set @err = @@error
			
			SELECT @templateID = SCOPE_IDENTITY()
	END

	RETURN @err
end
 
GO 

---------- P_ADDDEFAULTMETRICTHRESHOLD.SQL
if (object_id('p_AddDefaultMetricThreshold') is not null)
begin
drop procedure [p_AddDefaultMetricThreshold]
end
go

create procedure [p_AddDefaultMetricThreshold]
	@UserViewID int,
	@Metric int,
	@Enabled bit,
	@WarningThreshold nvarchar(1024),
	@CriticalThreshold nvarchar(1024),
	@Data nvarchar(max),
	@InfoThreshold nvarchar(1024)
as
begin
	DECLARE @defaultID int
	DECLARE @err int
	declare @tempID int
	-- adding default baseline values to defaultmetricthreshold
	-- 10.0 SQLdm srishti purohit
	DECLARE @BaselineWarningThreshold nvarchar(1024)
	DECLARE @BaselineCriticalThreshold nvarchar(1024)
	DECLARE @BaselineInfoThreshold nvarchar(1024)
	DECLARE @xmlValueForBaselineToCastWarning xml
	DECLARE @xmlValueForBaselineToCastCritical xml
	DECLARE @xmlValueForBaselineToCastInfo xml
	DECLARE @WarningThresholdXML10 nvarchar(512),
				@CriticalThresholdXML10 nvarchar(512),
				@InfoThresholdXML10 nvarchar(512),
				@BaselineDefaultWarningValue10 nvarchar(256),
				@BaselineDefaultCriticalValue10 nvarchar(256),
				@BaselineDefaultInfoValue10 nvarchar(256),
				@xmSignature nvarchar(256)
	set @err = 0

	select @tempID = MIN(TemplateID)-1 from AlertTemplateLookup
	
	while (Select MAX(TemplateID) from AlertTemplateLookup) > @tempID
	begin
		select @tempID = MIN(TemplateID) from AlertTemplateLookup where TemplateID > @tempID

		if not exists (select [Metric] from [DefaultMetricThresholds] where [UserViewID] = @tempID and [Metric] = @Metric)
		begin
		--10.0 SQLdm 
		-- START Baseline support
		
				--To get operation type from xml of thresholds
				select @xmlValueForBaselineToCastWarning = CAST(@WarningThreshold as XML) ,
				 @xmlValueForBaselineToCastCritical = CAST(@CriticalThreshold as XML) ,
				@xmlValueForBaselineToCastInfo = CAST(@InfoThreshold as XML)
				-- append value			
				select @BaselineDefaultWarningValue10 = [BaselineDefaultWarningValue],
						@BaselineDefaultCriticalValue10 = [BaselineDefaultCriticalValue],
						@BaselineDefaultInfoValue10 = [BaselineDefaultInfoValue]
				from [dbo].[MetricMetaData] 
				where Metric = @Metric
				
			--ANSI_WARNINGS is not honored when passing parameters in a stored procedure , so setting it on	
				SET @WarningThresholdXML10 = CONVERT( nvarchar(512), @xmlValueForBaselineToCastWarning.query('data(//@Op)'))
				SET @CriticalThresholdXML10 = CONVERT(nvarchar(512), @xmlValueForBaselineToCastCritical.query('data(//@Op)'))
				SET @InfoThresholdXML10 = CONVERT(nvarchar(512), @xmlValueForBaselineToCastInfo.query('data(//@Op)'))
	
				-- START --Srishti Purohit -- To accomadate baseline alert feature
				
				SET @xmSignature ='<?xml version="1.0" encoding="utf-16"?><Threshold xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" Op="'

				SET @xmSignature = @xmSignature 
			
				set	@BaselineWarningThreshold = @xmSignature + @WarningThresholdXML10 + '" Enabled="true"><Value xsi:type="xsd:float">' + @BaselineDefaultWarningValue10 + '</Value></Threshold>'
				set	@BaselineCriticalThreshold = @xmSignature + @CriticalThresholdXML10 + '" Enabled="true"><Value xsi:type="xsd:float">' +  @BaselineDefaultCriticalValue10 + '</Value></Threshold>'
				set	@BaselineInfoThreshold = @xmSignature + @InfoThresholdXML10 + '" Enabled="true"><Value xsi:type="xsd:float">' +  @BaselineDefaultInfoValue10 + '</Value></Threshold>'
				-- END --Srishti Purohit -- To accomadate baseline alert feature
		--END Baseline support
			INSERT	into DefaultMetricThresholds (UserViewID, Metric, Enabled, WarningThreshold, CriticalThreshold, Data, InfoThreshold, IsBaselineEnabled, [BaselineWarningThreshold] ,[BaselineCriticalThreshold], [BaselineInfoThreshold]) 
				VALUES (@tempID, @Metric, @Enabled, @WarningThreshold, @CriticalThreshold, @Data, @InfoThreshold, 0, @BaselineWarningThreshold ,@BaselineCriticalThreshold ,@BaselineInfoThreshold)

			SELECT @err = @@error
		
			if (@err = 0)
			begin
				-- add the metric to all defined servers
				insert into MetricThresholds (SQLServerID, Metric, Enabled, WarningThreshold, CriticalThreshold, Data, InfoThreshold , [IsBaselineEnabled], [BaselineWarningThreshold] ,[BaselineCriticalThreshold], [BaselineInfoThreshold]) 
					select S.SQLServerID, D.Metric, D.Enabled, D.WarningThreshold, D.CriticalThreshold, D.Data, D.InfoThreshold, D.IsBaselineEnabled,  D.BaselineWarningThreshold , D.BaselineCriticalThreshold , D.BaselineInfoThreshold			
						from MonitoredSQLServers S, DefaultMetricThresholds D
							where D.UserViewID = @tempID
								and D.Metric = @Metric 
								and D.Metric not in (select T.Metric from MetricThresholds T where T.SQLServerID = S.SQLServerID)
								and D.Metric not in (select Metric from CustomCounterDefinition)

				SELECT @err = @@error
			end
		end
	end

	RETURN @err
end
 
GO 

---------- P_ADDDISKDRIVEINFORMATION.SQL
-- SQLdm 9.1 (Abhishek Joshi)

-- Filegroup Improvements
-- insert the disk drives information

-- exec p_AddDiskDriveInformation   @SQLServerID = 1,
--									@UTCCollectionDateTime = '2014-07-14 16:04:52.283',
--									@DriveName = 'C',
--									@UnusedSizeKB = 89,
--									@TotalSizeKB = 56,
--									@DiskIdlePercent = 46,
--									@AverageDiskQueueLength = 45,
--									@AverageDiskMillisecondsPerRead = 56,
--									@AverageDiskMillisecondsPerTransfer = 34,
--									@AverageDiskMillisecondsPerWrite = 89,
--									@DiskReadsPerSecond = 34,
--									@DiskTransfersPerSecond = 89,
--									@DiskWritesPerSecond = 23,
--									@DatabaseSizeTime = '2014-07-14 16:04:52.283'

if (object_id('p_AddDiskDriveInformation') is not null)
begin
	drop procedure [p_AddDiskDriveInformation]
end
go

create procedure [dbo].[p_AddDiskDriveInformation]
	@SQLServerID int,
	@UTCCollectionDateTime datetime,
	@DriveName nvarchar(256),
	@UnusedSizeKB dec(18,0),
	@TotalSizeKB dec(18,0),
	@DiskReadsPerSecond bigint,
	@DiskWritesPerSecond bigint
as
begin
	insert into [DiskDriveStatistics]
	(
		SQLServerID, 
		UTCCollectionDateTime, 
		DriveName, 
		UnusedSizeKB, 
		TotalSizeKB, 
		DiskReadsPerSecond,
		DiskWritesPerSecond
	)
	values
	(
		@SQLServerID,
		@UTCCollectionDateTime,
		@DriveName,
		@UnusedSizeKB,
		@TotalSizeKB,
		@DiskReadsPerSecond,
		@DiskWritesPerSecond
	)
end
go
 
GO 

---------- P_ADDLATESTGROOMINGSTATUS.SQL
--SQLdm 9.0 (Ankit Srivastava) -- Added new procedure for inserting data into the LatestGroomingStatus table
--declare @currDate datetime,@id uniqueidentifier
--Select @currDate=getutcdate()
--select @id=newid()
--EXEC exec [dbo].[p_AddLatestGroomingStatus] 37,@id,@currDate,0,'Timeout',1
IF (object_id('p_AddLatestGroomingStatus') IS NOT NULL)
BEGIN
DROP PROCEDURE p_AddLatestGroomingStatus
END
GO

CREATE PROCEDURE [dbo].[p_AddLatestGroomingStatus]
(
	@SQLServerID INT, 
	@GroomingRunID uniqueidentifier, 
	@GroomingDateTimeUTC DateTime, 
	@Status smallint,-- failed =0 , succeeded =1, Hung=2
	@LastStatusMessage nvarchar(250),
	@IsPrimary bit
)
AS
BEGIN
	declare @updatecmd nvarchar(1000)
	declare @parms nvarchar(1000)

	Set @updatecmd = 'UPDATE [LatestGroomingStatus]	set 
				GroomingRunID = @GroomingRunID, 
				GroomingDateTimeUTC = @GroomingDateTimeUTC,
				[Status] = @Status,
				LastStatusMessage=@LastStatusMessage,
				[IsPrimary]=@IsPrimary ' +
				Case When @SQLServerID IS NULL Then 'where SQLServerID IS NULL;'
				Else 'where SQLServerID = @SQLServerID;' END ;
				
	Set @parms = '@SQLServerID INT, @GroomingRunID uniqueidentifier, @GroomingDateTimeUTC DateTime, @Status smallint, @LastStatusMessage nvarchar(250), @IsPrimary bit';

	IF (NOT EXISTS(Select * from [LatestGroomingStatus] where SQLServerID = @SQLServerID) AND @SQLServerID IS NOT NULL) OR
	   (NOT EXISTS(Select * from [LatestGroomingStatus] where SQLServerID IS NULL) AND @SQLServerID IS NULL)
	BEGIN
		INSERT INTO [LatestGroomingStatus] (SQLServerID, GroomingRunID, GroomingDateTimeUTC, [Status], LastStatusMessage,[IsPrimary])
			VALUES(@SQLServerID,  @GroomingRunID, @GroomingDateTimeUTC, @Status, @LastStatusMessage,@IsPrimary)
	END
	ELSE
	BEGIN
		exec sp_executesql 
						@updatecmd, 
						@parms, 
						@SQLServerID = @SQLServerID, 
						@GroomingRunID = @GroomingRunID, 
						@GroomingDateTimeUTC = @GroomingDateTimeUTC, 
						@Status = @Status, 
						@LastStatusMessage = @LastStatusMessage, 
						@IsPrimary = @IsPrimary;
	END
END
 
GO 

---------- P_ADDLICENSEKEY.SQL
if (object_id('p_AddLicenseKey') is not null)
begin
drop procedure p_AddLicenseKey
end
go
CREATE PROCEDURE [dbo].[p_AddLicenseKey](
	@LicenseKey nvarchar(255),
	@ReturnLicenseID uniqueidentifier output
)
as 
begin
	declare @e int
	declare @id uniqueidentifier

	select @id = NEWID()

	INSERT INTO [LicenseKeys]
           ([LicenseID]
           ,[LicenseKey]
           ,[DateAddedUtc])
     VALUES
           (@id,
           @LicenseKey,
           GETUTCDATE())

	select @e = @@error

	IF (@e = 0)
	begin
		select @ReturnLicenseID = @id 
	end

	return @e
end



 
GO 

---------- P_ADDLOGIN.SQL
if (object_id('p_AddLogin') is not null)
begin
drop procedure [p_AddLogin]
end
go

create procedure [p_AddLogin]
	@Login nvarchar(256),
	@IsSQLLogin bit,
	@Password nvarchar(256),
	@Database nvarchar(256),
	@LoginSID varbinary(85) output
as
begin
	DECLARE @err int
	DECLARE @sid varbinary(85)
	DECLARE @sidstr nvarchar(512)
	DECLARE @SQL nvarchar(1000);
	
	-- Check if the login exists.
	if @IsSQLLogin = 1
	begin
		Select @sid = sid
		From sys.server_principals
		Where UPPER(name) = UPPER(@Login)
		And type = 'S'; -- SQL login
	end
	else
	begin
		Select @sid = sid
		From sys.server_principals
		Where UPPER(name) = UPPER(@Login)
		And type In ('U', 'G'); -- Windows user or group
	end

	-- If login does not exist then create it.
	if @sid is null
	begin
		if @IsSQLLogin = 1
		begin
			Set @SQL = N'Create Login ' + QUOTENAME(@Login) + 
							' With Password = ''' + @Password + ''';';
			Exec sp_executesql @SQL;
			
			Select @sid = sid
			From sys.server_principals
			Where UPPER(name) = UPPER(@Login)
			And type = 'S'; -- SQL login
		end
		else
		begin
			Set @SQL = N'Create Login ' + QUOTENAME(@Login) + 
							' From Windows;';
			Exec sp_executesql @SQL;
			
			Select @sid = sid
			From sys.server_principals
			Where UPPER(name) = UPPER(@Login)
			And type In ('U', 'G'); -- Windows user or group
		end
	end

	-- Create user in SQLdm database and assign the DM console user role.
	if @sid is not null
	begin
		-- add user if one does not exist
		select @sidstr = master.dbo.fn_varbintohexstr(@sid)
		Set @SQL = 'Use ' + QUOTENAME(@Database) + ';
					If Not Exists (Select 1 From sys.database_principals
								Where sid = ' + @sidstr + ')
						Create User ' + QUOTENAME(@Login) + ' For Login ' + QUOTENAME(@Login) + ';';
		Exec sp_executesql @SQL;

		-- add user to role if the user is not a dbo.
		-- no check needed if member already exists, does not cause an error
		Set @SQL = 'Use ' + QUOTENAME(@Database) + ';
					If Exists (Select 1 From sys.database_principals
								Where name <> ''dbo''
								And sid = ' + @sidstr + ')
						Exec sp_addrolemember ''SQLdmConsoleUser'', ''' + @Login + ''';';
		Exec sp_executesql @SQL;


		-- set the return param value to sid.
		set @LoginSID = @sid
	end

	SELECT @err = @@error
	RETURN @err
end
 
GO 

---------- P_ADDMANAGEMENTSERVICE.SQL
if (object_id('p_AddManagementService') is not null)
begin
drop procedure p_AddManagementService
end
go
CREATE PROCEDURE [dbo].[p_AddManagementService](
	@InstanceName NVARCHAR(15),
	@MachineName NVARCHAR(15),
	@Address NVARCHAR(256),
	@Port int,
	@ReturnServiceId UNIQUEIDENTIFIER OUTPUT
)
AS
BEGIN
	DECLARE @e int
	DECLARE @id uniqueidentifier

	BEGIN TRANSACTION

	-- see if we are already registered (possible we are doing an upgrade)
	SELECT @id = [ManagementServiceID] from ManagementServices 
			where [InstanceName] = @InstanceName and
				  [MachineName] = @MachineName
	
	SELECT @e = @@error

	if (@id is null)
	begin
		-- assign a new id to the management service
		SELECT @id = NEWID()
		-- remove existing management service records
		DELETE FROM [ManagementServices]
		-- add the new management service record
		INSERT INTO [ManagementServices] ([ManagementServiceID],[InstanceName],[MachineName],[Address],[Port])
			VALUES (@id, @InstanceName, @MachineName, @Address, @Port)
	
		SELECT @e = @@error

		if (@e = 0)
		begin
			declare @c int
			select @c=count(*) from CollectionServices 
			if @c = 0
			begin
				update MonitoredSQLServers set CollectionServiceID=null
			end
		end
	end


	SELECT @ReturnServiceId = @id
	
	IF (@e = 0)
	begin
		-- make sure this is the default management service
		exec p_SetDefaultManagementService @id output
		COMMIT
	END
	else
	begin
		ROLLBACK
	end

	RETURN @e
END
 
GO 

---------- P_ADDMETRICTHRESHOLDINSTANCE.SQL
if (object_id('p_AddMetricThresholdInstance') is not null)
begin
drop procedure [p_AddMetricThresholdInstance]
end
go

create procedure [p_AddMetricThresholdInstance]
	@UserViewID int,
	@SQLServerID int,
	@Metric int,
	@Enabled bit,
	@WarningThreshold nvarchar(1024),
	@CriticalThreshold nvarchar(1024),
	@Data nvarchar(max),
	@InfoThreshold nvarchar(1024),
	@ThresholdInstanceType int,
	@ThresholdInstanceName nvarchar(256),
	@ThresholdEnabled bit,
	@IsBaselineEnabled bit,
	@BaselineWarningThreshold nvarchar(1024),
	@BaselineCriticalThreshold nvarchar(1024),
	@BaselineInfoThreshold nvarchar(1024)
as
begin
	DECLARE @ThresholdInstanceID int
	DECLARE @err int
	set @err = 0

	exec p_AddThresholdInstance 
		@ThresholdInstanceType, 
		@ThresholdInstanceName, 
		@ThresholdInstanceID output 
	
	select @err = @@ERROR
	
	if (@err > 0)
	begin
		RAISERROR('Error generating instance ID in AddMetricThresholdInstance',10,1,-1)
		return (-1)
	end
	
	
	if (@SQLServerID is NULL)
	begin
		if (@UserViewID is NULL)
		begin
			RAISERROR('@SQLServerID or @UserViewID is required.', 10, 1, -1)
			RETURN -1
		END    
		ELSE
		BEGIN
			set @err = 0
			
			if (exists (select InfoThreshold from DefaultMetricThresholds 
							where UserViewID = @UserViewID and 
								  Metric = @Metric and 
								  ThresholdInstanceID = @ThresholdInstanceID))
			BEGIN
				RAISERROR('Threshold Instance already exists',10,1,-1)
				return -1
			END
			ELSE
			BEGIN
				insert into DefaultMetricThresholds (
					UserViewID,
					Metric,
					Enabled,
					InfoThreshold,
					WarningThreshold,
					CriticalThreshold,
					Data,
					ThresholdInstanceID,
					ThresholdEnabled,
					[IsBaselineEnabled],					
					[BaselineWarningThreshold],
					[BaselineCriticalThreshold],
					[BaselineInfoThreshold] )
				values (
					@UserViewID,
					@Metric,
					@Enabled,
					@InfoThreshold,
					@WarningThreshold,
					@CriticalThreshold,
					@Data,
					@ThresholdInstanceID,
					@ThresholdEnabled,
					@IsBaselineEnabled,
					@BaselineWarningThreshold ,
					@BaselineCriticalThreshold ,
					@BaselineInfoThreshold)
					
				select @err = @@ERROR
				IF @err <> 0 
				BEGIN
					RAISERROR('An error occurred while adding a new DefaultMetricThreshold instance', 10, 1, @err)
					RETURN(@err)
				END
			END
		END
	END
	ELSE
	BEGIN
		IF (@UserViewID IS NOT NULL)
		BEGIN
			RAISERROR('@SQLServerID and @UserViewID are mutually exclusive.', 10, 1, -1)
			RETURN -1
		END
		ELSE
		BEGIN
			set @err = 0
			
			if (exists (select InfoThreshold from MetricThresholds 
							where SQLServerID = @SQLServerID and 
								  Metric = @Metric and 
								  ThresholdInstanceID = @ThresholdInstanceID))
			BEGIN
				RAISERROR('Threshold Instance already exists',10,1,-1)
				return -1
			END
			ELSE
			BEGIN
				insert into MetricThresholds (
					SQLServerID, 
					Metric, 
					Enabled, 
					InfoThreshold, 
					WarningThreshold, 
					CriticalThreshold, 
					Data, 
					ThresholdInstanceID,
					ThresholdEnabled,
					IsBaselineEnabled,
					[BaselineWarningThreshold],
					[BaselineCriticalThreshold],
					[BaselineInfoThreshold] 
				)
					values(
					@SQLServerID, 
					@Metric, 
					@Enabled, 
					@InfoThreshold, 
					@WarningThreshold, 
					@CriticalThreshold, 
					@Data, 
					@ThresholdInstanceID,
					@ThresholdEnabled,
					@IsBaselineEnabled,
					@BaselineWarningThreshold,
					@BaselineCriticalThreshold,
					@BaselineInfoThreshold
				)
					
				select @err = @@ERROR
				
				IF @err <> 0 BEGIN
					RAISERROR('An error occurred while inserting a threshold instance.', 10, 1, @err)
					RETURN(@err)
				END
			
				RETURN (0)
			end
		END
	end
end
 
GO 

---------- P_ADDMONITOREDSQLSERVER.SQL
if (object_id('p_AddMonitoredSqlServer') is not null)
begin
drop procedure p_AddMonitoredSqlServer
end
go
CREATE PROCEDURE [dbo].[p_AddMonitoredSqlServer](
	@InstanceName nvarchar(256),
	@CollectionServiceID uniqueidentifier = NULL,
	@UseIntegratedSecurity bit = 1,
	@Username nvarchar(128) = NULL,
	@Password nvarchar(128) = NULL,
	@ScheduledCollectionIntervalInSeconds int = 360,
	@QueryMonitorEnabled bit = 0,
	@QueryMonitorSqlBatchEventsEnabled bit = 0,
	@QueryMonitorSqlStatementEventsEnabled bit = 0,
	@QueryMonitorStoredProcedureEventsEnabled bit = 0,
	@ActivityMonitorDeadlockEventsEnabled bit = 0,
	@QueryMonitorDurationFilterInMilliseconds int = 5000,
	@QueryMonitorCpuUsageFilterInMilliseconds int = 0,
	@QueryMonitorLogicalDiskReadsFilter int = 0,
	@QueryMonitorPhysicalDiskWritesFilter int = 0,
	@QueryMonitorTraceFileSizeKB int = 1024,
	@QueryMonitorTraceFileRollovers int = 2,
	@QueryMonitorTraceRecordsPerRefresh int = 1000,
	@GrowthStatisticsStartTime datetime = '1900-01-01 3:00:00 AM',
	@ReorgStatisticsStartTime datetime = '1900-01-01 3:00:00 AM',
	@GrowthStatisticsDays tinyint = 124,
	@ReorgStatisticsDays tinyint = 124,
	@TableStatisticsExcludedDatabases nvarchar(max) = null,
	@EncryptData bit = 0,
	@TrustServerCert bit = 0,
	@ReorgMinTableSizeKB int = 200,
	@DisableReplicationMonitoring bit = 0,
	@QueryMonitorAdvancedConfiguration nvarchar(max) = NULL,
	@DisableExtendedHistoryCollection bit = 0,
	@DisableOleAutomation bit = 0,
	@DiskCollectionSettings nvarchar(max) = NULL,
	@QueryMonitorStopTimeUTC datetime = null,
	@InputBufferLimiter int = 500,
	@InputBufferLimited bit = 0,
	@ActiveWaitCollectorStartTimeRelative datetime = null,
	@ActiveWaitCollectorRunTimeSeconds int = 0, 
	@ActiveWaitCollectorCollectionTimeSeconds int = 30,
	@ActiveWaitCollectorEnabled bit = 0,
	@ActiveWaitLoopTimeMilliseconds int = 500,
	@ActiveWaitAdvancedConfiguration nvarchar(max) = null,
	@ActiveWaitXEEnable bit = 0,
	@ActiveWaitXEFileSizeMB int = 5,
	@ActiveWaitXEFilesRollover int = 1,
	@ActiveWaitXERecordsPerRefresh int = 1000,
	@ActiveWaitXEMaxMemoryMB int = 4,
	@ActiveWaitXEEventRetentionMode tinyint = 1,
	@ActiveWaitXEMaxDispatchLatencySecs int = 300,
	@ActiveWaitXEMaxEventSizeMB int = 8,
	@ActiveWaitXEMemoryPartitionMode int = 0,
	@ActiveWaitXETrackCausality bit = 0,
	@ActiveWaitXEStartupState bit = 0,
	@ActiveWaitsXEFileName nvarchar(1024) = 'dm7SessionOut.xel',
	@ServerPingInterval int = 30,
	@AlertTemplateID int = -1,
	@VHostID int = null,
	@VmUID nvarchar(256) = null,
	@VmName nvarchar(256) = null,
	@VmDomainName nvarchar(256) = null,
	@BaselineTemplate nvarchar(1024) = null,
	@DatabaseStatisticsRefreshIntervalInSeconds int = 3600,
	@WmiCollectionEnabled bit = 0,
	@WmiConnectAsService bit = 0,
	@WmiUserName nvarchar(256) = null,
	@WmiPassword nvarchar(256) = null,
	@ActivityMonitorEnabled bit = 1,
	@ActivityMonitorAutogrowEventsEnabled bit = 0,
	@ActivityMonitorBlockingEventsEnabled bit = 1,
	@ActivityMonitorBlockedProcessThreshold int = 30,
	--SQLdm 9.0 (Ankit Srivastava): Query Monitoring with Extended Event Session  -- Added two newly added parameters
	@QueryMonitorTraceMonitoringEnabled bit,
	@QueryMonitorCollectQueryPlan bit,

	--START SQLdm 9.1 (Ankit Srivastava): Activity Monitoring with Extended Event Session  -- Added new parameters
	@ActivityMonitorTraceMonitoringEnabled bit,
	@ActivityMonitorXEFileSizeMB int =1,
	@ActivityMonitorXEFilesRollover int =3,
	@ActivityMonitorXERecordsPerRefresh int =1000,
	@ActivityMonitorXEMaxMemoryMB int =1,
	@ActivityMonitorXEEventRetentionMode int =1,
	@ActivityMonitorXEMaxDispatchLatencySecs int =300,
	@ActivityMonitorXEMaxEventSizeMB int =1,
	@ActivityMonitorXEMemoryPartitionMode int =0,
	@ActivityMonitorXETrackCausality bit =0,
	@ActivityMonitorXEStartupState bit =0,
	@ActivityMonitorXEFileName nvarchar(1024)= 'AMExtendedEventLog.xel',
	 --END SQLdm 9.1 (Ankit Srivastava): Activity Monitoring with Extended Event Session  -- Added new parameters
	 
	--START SQLdm 9.1 (Ankit Srivastava): Query Monitor 9.0 Improvement feedback -adding new parameters for uery monitoring extended event session configuration
	@QueryMonitorXEFileSizeMB int=20,
	@QueryMonitorXEFilesRollover int=5
	--END SQLdm 9.1 (Ankit Srivastava): Query Monitor 9.0 Improvement feedback - adding new parameters for uery monitoring extended event session configuration
-- START 10.0 (srishti purohit) : To handle analysis configuration
	
	,@productionServer bit =0,
	@OLTP bit =0,
	@analysisStartTime DATETIME = NULL,
	@duration INT = 10,
	@scheduledDays smallint = 253,
	@isActive bit = 1,
	@includeDatabase int = 0,
	@filterApplication nvarchar(max) = NULL,
	@categoryID xml = '<Category></Category>',
	@databaseID xml = '<Database></Database>',
	@recommendationID xml = '<Recommendation></Recommendation>',
	-- END 10.0 (srishti purohit) : To handle analysis configuration
	@cloudProviderId int = null,--SQLdm 10.0 (Tarun Sapra)-Minimal Cloud Support
	@schedulingStatus bit = 0, --SQLdm 10.0 (Praveen Suhalka)-Scheduling Status	
	@QueryMonitorCollectEstimatedQueryPlan bit = 1 --10.0 SQLdm Srishti Purohit Fixing defect DE46150. Setting Estimated query plan on by default.
)
as 
begin
	declare @error int
	declare @ExistingSQLServerID int
	declare @CollectionServiceIDTemp uniqueidentifier
	declare @ManagementServiceIDTemp uniqueidentifier

	select @CollectionServiceIDTemp = @CollectionServiceID

	if @CollectionServiceIDTemp is null
	begin
		select @ManagementServiceIDTemp = null
		exec p_GetDefaultManagementServiceID @ManagementServiceIDTemp output
		if @ManagementServiceIDTemp is not null
		    exec p_SetDefaultCollectionService @ManagementServiceIDTemp, @CollectionServiceIDTemp output 
	end

	SELECT @ExistingSQLServerID = SQLServerID
	FROM MonitoredSQLServers
	WHERE lower(InstanceName) = lower(@InstanceName)

	IF @@rowcount > 0 BEGIN
		UPDATE [dbo].[MonitoredSQLServers]
		SET
			[Deleted] = 0,
			[Active] = 1,
			[CollectionServiceID] = @CollectionServiceIDTemp,
			[UseIntegratedSecurity] = @UseIntegratedSecurity,
			[Username] = @Username,
			[Password] = @Password,
			[ScheduledCollectionIntervalInSeconds] = @ScheduledCollectionIntervalInSeconds,
			[QueryMonitorEnabled] = @QueryMonitorEnabled,
			[QueryMonitorSqlBatchEventsEnabled] = @QueryMonitorSqlBatchEventsEnabled,
			[QueryMonitorSqlStatementEventsEnabled] = @QueryMonitorSqlStatementEventsEnabled,
			[QueryMonitorStoredProcedureEventsEnabled] = @QueryMonitorStoredProcedureEventsEnabled,
			[QueryMonitorDurationFilterInMilliseconds] = @QueryMonitorDurationFilterInMilliseconds,
			[QueryMonitorCpuUsageFilterInMilliseconds] = @QueryMonitorCpuUsageFilterInMilliseconds,
			[QueryMonitorLogicalDiskReadsFilter] = @QueryMonitorLogicalDiskReadsFilter,
			[QueryMonitorPhysicalDiskWritesFilter] = @QueryMonitorPhysicalDiskWritesFilter,
			[QueryMonitorTraceFileSizeKB] = @QueryMonitorTraceFileSizeKB,
			[QueryMonitorTraceFileRollovers] = @QueryMonitorTraceFileRollovers,
			[QueryMonitorTraceRecordsPerRefresh] = @QueryMonitorTraceRecordsPerRefresh,
			[ActivityMonitorEnabled] = @ActivityMonitorEnabled,
			[ActivityMonitorDeadlockEventsEnabled] = @ActivityMonitorDeadlockEventsEnabled,
			[ActivityMonitorBlockingEventsEnabled] = @ActivityMonitorBlockingEventsEnabled,
			[ActivityMonitorAutoGrowEventsEnabled] = @ActivityMonitorAutogrowEventsEnabled,
			[ActivityMonitorBlockedProcessThreshold] = @ActivityMonitorBlockedProcessThreshold,
			[GrowthStatisticsStartTime] = @GrowthStatisticsStartTime,
			[ReorgStatisticsStartTime] = @ReorgStatisticsStartTime,
			[GrowthStatisticsDays] = @GrowthStatisticsDays,
			[ReorgStatisticsDays] = @ReorgStatisticsDays,
			[TableStatisticsExcludedDatabases] = @TableStatisticsExcludedDatabases,
			[EncryptData] = @EncryptData,
			[TrustServerCert] = @TrustServerCert,
			[ReorgMinTableSizeKB] = @ReorgMinTableSizeKB,
			[DisableReplicationMonitoring] = @DisableReplicationMonitoring,
			[QueryMonitorAdvancedConfiguration] = @QueryMonitorAdvancedConfiguration,
			[DisableExtendedHistoryCollection] = @DisableExtendedHistoryCollection,
			[DisableOleAutomation] = @DisableOleAutomation,
			[DiskCollectionSettings] = @DiskCollectionSettings,
			[QueryMonitorStopTimeUTC] = @QueryMonitorStopTimeUTC,
			[InputBufferLimiter] = @InputBufferLimiter,
			[InputBufferLimited] = @InputBufferLimited,
			[ActiveWaitCollectorStartTimeRelative] = @ActiveWaitCollectorStartTimeRelative,
			[ActiveWaitCollectorRunTimeSeconds] = @ActiveWaitCollectorRunTimeSeconds,
			[ActiveWaitCollectorCollectionTimeSeconds] = @ActiveWaitCollectorCollectionTimeSeconds,
			[ActiveWaitCollectorEnabled] = @ActiveWaitCollectorEnabled,
			[ActiveWaitLoopTimeMilliseconds] = @ActiveWaitLoopTimeMilliseconds,
			[ActiveWaitAdvancedConfiguration] = @ActiveWaitAdvancedConfiguration,
			[ActiveWaitXEEnable] = @ActiveWaitXEEnable,
			[ActiveWaitXEFileSizeMB] = @ActiveWaitXEFileSizeMB,
			[ActiveWaitXEFilesRollover] = @ActiveWaitXEFilesRollover,
			[ActiveWaitXERecordsPerRefresh] = @ActiveWaitXERecordsPerRefresh,
			[ActiveWaitXEMaxMemoryMB] = @ActiveWaitXEMaxMemoryMB,
			[ActiveWaitXEEventRetentionMode] = @ActiveWaitXEEventRetentionMode,
			[ActiveWaitXEMaxDispatchLatencySecs] = @ActiveWaitXEMaxDispatchLatencySecs,
			[ActiveWaitXEMaxEventSizeMB] = @ActiveWaitXEMaxEventSizeMB,
			[ActiveWaitXEMemoryPartitionMode] = @ActiveWaitXEMemoryPartitionMode,
			[ActiveWaitXETrackCausality] = @ActiveWaitXETrackCausality,
			[ActiveWaitXEStartupState] = @ActiveWaitXEStartupState,
			[ActiveWaitsXEFileName] = @ActiveWaitsXEFileName,
			[ServerPingInterval] = @ServerPingInterval,
			[VHostID] = @VHostID,
			[VmUID] = @VmUID,
			[VmName] = @VmName,
			[VmDomainName] = @VmDomainName,
			[DatabaseStatisticsRefreshIntervalInSeconds] = @DatabaseStatisticsRefreshIntervalInSeconds,
			[WmiCollectionEnabled] = @WmiCollectionEnabled,
			[WmiConnectAsService] = @WmiConnectAsService,
			[WmiUserName] = @WmiUserName,
			[WmiPassword] = @WmiPassword,
			--SQLdm 9.0 (Ankit Srivastava): Query Monitoring with Extended Event Session  -- Added two newly added column and values
			[QueryMonitorTraceMonitoringEnabled] =@QueryMonitorTraceMonitoringEnabled,
			[QueryMonitorCollectQueryPlan]=@QueryMonitorCollectQueryPlan,
			[QueryMonitorCollectEstimatedQueryPlan]=@QueryMonitorCollectEstimatedQueryPlan,
			--START SQLdm 9.1 (Ankit Srivastava): Activity Monitoring with Extended Event Session  -- Added new columns and values 
			[ActivityMonitorTraceMonitoringEnabled]=@ActivityMonitorTraceMonitoringEnabled,
			[ActivityMonitorXEFileSizeMB]=@ActivityMonitorXEFileSizeMB,
			[ActivityMonitorXEFilesRollover]=@ActivityMonitorXEFilesRollover,
			[ActivityMonitorXERecordsPerRefresh]=@ActivityMonitorXERecordsPerRefresh,
			[ActivityMonitorXEMaxMemoryMB]=@ActivityMonitorXEMaxMemoryMB,
			[ActivityMonitorXEEventRetentionMode]=@ActivityMonitorXEEventRetentionMode,
			[ActivityMonitorXEMaxDispatchLatencySecs]=@ActivityMonitorXEEventRetentionMode,
			[ActivityMonitorXEMaxEventSizeMB]=@ActivityMonitorXEMaxEventSizeMB,
			[ActivityMonitorXEMemoryPartitionMode]=@ActivityMonitorXEMemoryPartitionMode,
			[ActivityMonitorXETrackCausality]=@ActivityMonitorXETrackCausality,
			[ActivityMonitorXEStartupState]=@ActivityMonitorXEStartupState,
			[ActivityMonitorXEFileName]=@ActivityMonitorXEFileName,
			 --END SQLdm 9.1 (Ankit Srivastava): Activity Monitoring with Extended Event Session  -- Added new columns and values 
	--START SQLdm 9.1 (Ankit Srivastava): Query Monitor 9.0 Improvement feedback - adding new column values for uery monitoring extended event session configuration
			[QueryMonitorXEFileSizeMB] =@QueryMonitorXEFileSizeMB,
			[QueryMonitorXEFilesRollover]=@QueryMonitorXEFilesRollover,
	--END SQLdm 9.1 (Ankit Srivastava): Query Monitor 9.0 Improvement feedback - adding new column values for uery monitoring extended event session configuration
			[CloudProviderId] = @cloudProviderId
		WHERE
			[SQLServerID] = @ExistingSQLServerID

		SELECT @error = @@error

		SELECT 
			[SQLServerID],
			[RegisteredDate],
			[CollectionServiceID],
			[OutOfProcOleAutomation]
		FROM [dbo].[MonitoredSQLServers]
		WHERE [SQLServerID] = @ExistingSQLServerID
	END
	ELSE BEGIN
		INSERT INTO [dbo].[MonitoredSQLServers]
			([InstanceName]
			,[CollectionServiceID]
			,[UseIntegratedSecurity]
			,[Username]
			,[Password]
			,[ScheduledCollectionIntervalInSeconds]
			,[QueryMonitorEnabled]
			,[QueryMonitorSqlBatchEventsEnabled]
			,[QueryMonitorSqlStatementEventsEnabled]
			,[QueryMonitorStoredProcedureEventsEnabled]
			,[QueryMonitorDurationFilterInMilliseconds]
			,[QueryMonitorCpuUsageFilterInMilliseconds]
			,[QueryMonitorLogicalDiskReadsFilter]
			,[QueryMonitorPhysicalDiskWritesFilter]
			,[QueryMonitorTraceFileSizeKB]
			,[QueryMonitorTraceFileRollovers]
			,[QueryMonitorTraceRecordsPerRefresh]
			,[ActivityMonitorEnabled]
			,[ActivityMonitorDeadlockEventsEnabled]
			,[ActivityMonitorBlockingEventsEnabled]
			,[ActivityMonitorAutoGrowEventsEnabled]
			,[ActivityMonitorBlockedProcessThreshold]
			,[GrowthStatisticsStartTime]
			,[ReorgStatisticsStartTime]
			,[GrowthStatisticsDays]
			,[ReorgStatisticsDays]
			,[TableStatisticsExcludedDatabases]
			,[EncryptData]
			,[TrustServerCert]
			,[ReorgMinTableSizeKB]
			,[DisableReplicationMonitoring]
			,[QueryMonitorAdvancedConfiguration]
			,[DisableExtendedHistoryCollection]
			,[DisableOleAutomation]
			,[DiskCollectionSettings]
			,[QueryMonitorStopTimeUTC]
			,[InputBufferLimiter]
			,[InputBufferLimited]
			,[ActiveWaitCollectorStartTimeRelative]
			,[ActiveWaitCollectorRunTimeSeconds]
			,[ActiveWaitCollectorCollectionTimeSeconds]
			,[ActiveWaitCollectorEnabled]
			,[ActiveWaitLoopTimeMilliseconds]
			,[ActiveWaitAdvancedConfiguration]
			,[ActiveWaitXEEnable]
			,[ActiveWaitXEFileSizeMB]
			,[ActiveWaitXEFilesRollover]
			,[ActiveWaitXERecordsPerRefresh]
			,[ActiveWaitXEMaxMemoryMB]
			,[ActiveWaitXEEventRetentionMode]
			,[ActiveWaitXEMaxDispatchLatencySecs]
			,[ActiveWaitXEMaxEventSizeMB]
			,[ActiveWaitXEMemoryPartitionMode]
			,[ActiveWaitXETrackCausality]
			,[ActiveWaitXEStartupState]
			,[ActiveWaitsXEFileName]
			,[ServerPingInterval]
			,[VHostID]
			,[VmUID]
			,[VmName]
			,[VmDomainName]
			,[DatabaseStatisticsRefreshIntervalInSeconds]
			,[WmiCollectionEnabled]
			,[WmiConnectAsService]
			,[WmiUserName]
			,[WmiPassword]
			--SQLdm 9.0 (Ankit Srivastava): Query Monitoring with Extended Event Session -- Added two newly added columns
			,[QueryMonitorTraceMonitoringEnabled]
			,[QueryMonitorCollectQueryPlan]
			,[QueryMonitorCollectEstimatedQueryPlan]
			--START SQLdm 9.1 (Ankit Srivastava): Activity Monitoring with Extended Event Session  -- Added new columns 
			,[ActivityMonitorTraceMonitoringEnabled]
			,[ActivityMonitorXEFileSizeMB]
			,[ActivityMonitorXEFilesRollover]
			,[ActivityMonitorXERecordsPerRefresh]
			,[ActivityMonitorXEMaxMemoryMB]
			,[ActivityMonitorXEEventRetentionMode]
			,[ActivityMonitorXEMaxDispatchLatencySecs]
			,[ActivityMonitorXEMaxEventSizeMB]
			,[ActivityMonitorXEMemoryPartitionMode]
			,[ActivityMonitorXETrackCausality]
			,[ActivityMonitorXEStartupState]
			,[ActivityMonitorXEFileName]
			 --END SQLdm 9.1 (Ankit Srivastava): Activity Monitoring with Extended Event Session  -- Added new columns  
			 
			--START SQLdm 9.1 (Ankit Srivastava): Query Monitor 9.0 Improvement feedback - adding new column values for uery monitoring extended event session configuration
			,[QueryMonitorXEFileSizeMB]
			,[QueryMonitorXEFilesRollover]
			--END SQLdm 9.1 (Ankit Srivastava): Query Monitor 9.0 Improvement feedback - adding new column values for uery monitoring extended event session configuration
			,[CloudProviderId])
		VALUES
			(@InstanceName,
			@CollectionServiceIDTemp,
			@UseIntegratedSecurity,
			@Username,
			@Password,
			@ScheduledCollectionIntervalInSeconds,
			@QueryMonitorEnabled,
			@QueryMonitorSqlBatchEventsEnabled,
			@QueryMonitorSqlStatementEventsEnabled,
			@QueryMonitorStoredProcedureEventsEnabled,
			@QueryMonitorDurationFilterInMilliseconds,
			@QueryMonitorCpuUsageFilterInMilliseconds,
			@QueryMonitorLogicalDiskReadsFilter,
			@QueryMonitorPhysicalDiskWritesFilter,
			@QueryMonitorTraceFileSizeKB,
			@QueryMonitorTraceFileRollovers,
			@QueryMonitorTraceRecordsPerRefresh,
			@ActivityMonitorEnabled,
			@ActivityMonitorDeadlockEventsEnabled,
			@ActivityMonitorBlockingEventsEnabled,
			@ActivityMonitorAutogrowEventsEnabled,
			@ActivityMonitorBlockedProcessThreshold,
			@GrowthStatisticsStartTime,
			@ReorgStatisticsStartTime,
			@GrowthStatisticsDays,
			@ReorgStatisticsDays,
			@TableStatisticsExcludedDatabases,
			@EncryptData,
			@TrustServerCert,
			@ReorgMinTableSizeKB,
			@DisableReplicationMonitoring,
			@QueryMonitorAdvancedConfiguration,
			@DisableExtendedHistoryCollection,
			@DisableOleAutomation,
			@DiskCollectionSettings,
			@QueryMonitorStopTimeUTC,
			@InputBufferLimiter,
			@InputBufferLimited,
			@ActiveWaitCollectorStartTimeRelative,
			@ActiveWaitCollectorRunTimeSeconds, 
			@ActiveWaitCollectorCollectionTimeSeconds,
			@ActiveWaitCollectorEnabled,
			@ActiveWaitLoopTimeMilliseconds,
			@ActiveWaitAdvancedConfiguration,
			@ActiveWaitXEEnable,
			@ActiveWaitXEFileSizeMB,
			@ActiveWaitXEFilesRollover,
			@ActiveWaitXERecordsPerRefresh,
			@ActiveWaitXEMaxMemoryMB,
			@ActiveWaitXEEventRetentionMode,
			@ActiveWaitXEMaxDispatchLatencySecs,
			@ActiveWaitXEMaxEventSizeMB,
			@ActiveWaitXEMemoryPartitionMode,
			@ActiveWaitXETrackCausality,
			@ActiveWaitXEStartupState,
			@ActiveWaitsXEFileName,
			@ServerPingInterval,
			@VHostID,
			@VmUID,
			@VmName,
			@VmDomainName,
			@DatabaseStatisticsRefreshIntervalInSeconds,
			@WmiCollectionEnabled,
			@WmiConnectAsService,
			@WmiUserName,
			@WmiPassword,
			--SQLdm 9.0 (Ankit Srivastava): Query Monitoring with Extended Event Session  -- Added two new column values
			@QueryMonitorTraceMonitoringEnabled,
			@QueryMonitorCollectQueryPlan,
			@QueryMonitorCollectEstimatedQueryPlan,
			--START SQLdm 9.1 (Ankit Srivastava): Activity Monitoring with Extended Event Session  -- Added new column values
			@ActivityMonitorTraceMonitoringEnabled,
			@ActivityMonitorXEFileSizeMB,
			@ActivityMonitorXEFilesRollover,
			@ActivityMonitorXERecordsPerRefresh,
			@ActivityMonitorXEMaxMemoryMB,
			@ActivityMonitorXEEventRetentionMode,
			@ActivityMonitorXEMaxDispatchLatencySecs,
			@ActivityMonitorXEMaxEventSizeMB,
			@ActivityMonitorXEMemoryPartitionMode,
			@ActivityMonitorXETrackCausality,
			@ActivityMonitorXEStartupState,
			@ActivityMonitorXEFileName,
			--END SQLdm 9.1 (Ankit Srivastava): Activity Monitoring with Extended Event Session  -- Added new column values
	 
			--START SQLdm 9.1 (Ankit Srivastava): Query Monitor 9.0 Improvement feedback - adding new column values for uery monitoring extended event session configuration
			@QueryMonitorXEFileSizeMB,
			@QueryMonitorXEFilesRollover
			--END SQLdm 9.1 (Ankit Srivastava): Query Monitor 9.0 Improvement feedback - adding new column values for uery monitoring extended event session configuration
			,@cloudProviderId)
		SELECT @error = @@error

		if (@error = 0)
		BEGIN
			--DECLARE @defaultID int

			SELECT @ExistingSQLServerID = scope_identity()	
			if (@AlertTemplateID < 0)
			begin		
				SELECT @AlertTemplateID = [TemplateID] FROM [AlertTemplateLookup] where [Default] = 1
			end

			insert into MetricThresholds (SQLServerID, Metric, Enabled, InfoThreshold, WarningThreshold, CriticalThreshold, Data, ThresholdInstanceID, IsBaselineEnabled, BaselineWarningThreshold , BaselineCriticalThreshold , BaselineInfoThreshold)
				select @ExistingSQLServerID, Metric, Enabled, InfoThreshold, WarningThreshold, CriticalThreshold, Data, ThresholdInstanceID,  IsBaselineEnabled, BaselineWarningThreshold , BaselineCriticalThreshold , BaselineInfoThreshold 			
					from DefaultMetricThresholds
					where UserViewID = @AlertTemplateID
						and Metric not in 
							(select Metric from CustomCounterDefinition)

			SELECT 
				[SQLServerID],
				[RegisteredDate],
				[CollectionServiceID],
				[OutOfProcOleAutomation],
				[DisableOleAutomation]
			FROM [dbo].[MonitoredSQLServers]
			WHERE [SQLServerID] = @ExistingSQLServerID
		END
	END
	
	IF @error = 0 AND @BaselineTemplate IS NOT NULL
	BEGIN		
		exec p_AddBaselineTemplate @ExistingSQLServerID, @BaselineTemplate

		IF @error <> 0 BEGIN
			RAISERROR('An error occurred while add the new instance.', 10, 1, @error)
			RETURN(@error)
		END
	END

	IF @error = 0
	BEGIN	
	-- START 10.0 (srishti purohit) : To handle analysis configuration
	exec p_SaveAnalysisConfiguration @ExistingSQLServerID,@productionServer,@OLTP,
	@analysisStartTime ,
	@duration ,@scheduledDays ,@isActive ,
	@includeDatabase ,
	@filterApplication ,
	@categoryID ,
	@databaseID ,
	@recommendationID,
	@schedulingStatus --SQLdm 10.0 (Praveen Suhalka)-Scheduling Status

	IF @error != 0 --GOTO HANDLE_ERROR
	BEGIN
	RAISERROR('An error occurred while updating instance ANALYSIS %d.', 10, 1, @error)
        RETURN(@error)
		END
		END

	-- END 10.0 (srishti purohit) : To handle analysis configuration

	RETURN(0)
end



 
GO 

---------- P_ADDMULTIPLEBASELINETEMPLATE.SQL
IF (object_id('[p_AddMultipleBaselineTemplate]') IS NOT NULL)
BEGIN
DROP PROCEDURE [p_AddMultipleBaselineTemplate]
END
GO

CREATE PROCEDURE [dbo].[p_AddMultipleBaselineTemplate]
	@SQLServerId int,
	@AllConfigs XML
AS
BEGIN
	UPDATE BaselineTemplates SET Active = 0 WHERE SQLServerID = @SQLServerId 

	INSERT INTO BaselineTemplates ([SQLServerID], [Template] ,[BaselineName], [Active])
	SELECT @SQLServerId AS SQLServerID,'<?xml version="1.0" encoding="utf-16"?>'+CAST(mb.Template AS VARCHAR(1024)) AS Template,mb.BaselineName,1 AS Active FROM (SELECT B.value('(Name)[1]','nvarchar(500)') AS BaselineName,B.query('./BaselineTemplate') AS Template FROM @AllConfigs.nodes('/*/*') AS A(B)) AS mb
END

GO
 
GO 

---------- P_ADDNOTIFICATIONPROVIDER.SQL
if (object_id('p_AddNotificationProvider') is not null)
begin
drop procedure [p_AddNotificationProvider]
end
go

create procedure [p_AddNotificationProvider] 
	@SerializedType nvarchar(64),
	@SerializedObject nvarchar(max),
	@ReturnProviderId uniqueidentifier output
as
begin
	DECLARE @err int
	DECLARE @id uniqueidentifier
	DECLARE @xmlobject xml
	
	-- there are certain conditions where we need to insert a 
	-- provider with a well-known id rather than assigning one.
	
	SELECT @id = @ReturnProviderId
	if (@id IS NULL)
	begin
		SELECT @id = NEWID()
		
		select @xmlobject = cast(@SerializedObject as xml)
		
		set @xmlobject.modify('replace value of (//@Id)[1] with sql:variable("@id")')
		
		select @SerializedObject = convert(nvarchar(max),@xmlobject)
	end

	INSERT	into NotificationProviders (ProviderId, SerializedType, SerializedObject) VALUES (@id, @SerializedType, @SerializedObject)

	SELECT @err = @@error

	if (@err = 0)
	BEGIN	
		SELECT @ReturnProviderId = @id
	END

	RETURN @err
end
 
GO 

---------- P_ADDNOTIFICATIONRULE.SQL
if (object_id('p_AddNotificationRule') is not null)
begin
drop procedure [p_AddNotificationRule]
end
go

create procedure [p_AddNotificationRule] 
	@SerializedObject nvarchar(max),
	@ReturnRuleID uniqueidentifier output
as
begin
	DECLARE @err int
	DECLARE @id uniqueidentifier
	
	SELECT @id = NEWID()
	INSERT	into NotificationRules (RuleID, SerializedObject) VALUES (@id, @SerializedObject)

	SELECT @err = @@error

	if (@err = 0)
	BEGIN	
		SELECT @ReturnRuleID = @id
	END

	RETURN @err
end
 
GO 

---------- P_ADDPERMISSION.SQL
if (object_id('p_AddPermission') is not null)
begin
drop procedure [p_AddPermission]
end
go

create procedure [p_AddPermission]
	@LoginSID varbinary(256),
	@Permission int,
	@TagsXML nvarchar(max),
	@ServerXML nvarchar(max),
	@Comment nvarchar(1024),
	@WebAppPermission bit-- SQLdm 8.5 <Ankit Srivastava> added new columns
as
begin
	declare @err int
	declare @ruleid int
	declare @xmlDoc int
	
	-- Add entry to permission table and get the rule ID.
	insert into [dbo].[Permission] (LoginSID, Permission, Enabled, Comment, WebAppPermission)
	values (@LoginSID, @Permission, 1, @Comment, @WebAppPermission)
	select @ruleid = @@identity

	-- Add tags to permission
	exec p_UpdatePermissionTags @ruleid, @TagsXML
	
	-- Add all servers to the permission server table for the rule ID.
	exec sp_xml_preparedocument @xmlDoc output, @ServerXML

	insert into [dbo].[PermissionServers] (PermissionID, SQLServerID)
	select @ruleid, SQLServerID
		from openxml(@xmlDoc, '//Server', 1) with (SQLServerID int) 

	exec sp_xml_removedocument @xmlDoc
	

	select @err = @@error
	return @err
end
 
GO 

---------- P_ADDPREDICTIVEFORECAST.SQL

IF (OBJECT_ID('p_AddPredictiveForecast') IS NOT NULL)
BEGIN
	DROP PROCEDURE [p_AddPredictiveForecast]
END
GO

CREATE PROCEDURE [dbo].[p_AddPredictiveForecast] 
	@SQLServerID int,
	@Metric      int,
	@Severity    int,
	@Timeframe   int,
	@Forecast    int,
	@Accuracy	 decimal(5,2),
	@Expiration  datetime
AS
BEGIN	
	
	IF NOT EXISTS(SELECT SQLServerID FROM PredictiveForecasts WHERE SQLServerID = @SQLServerID AND Metric = @Metric AND Severity = @Severity AND Timeframe = @Timeframe)
	BEGIN
	
		INSERT INTO PredictiveForecasts VALUES (@SQLServerID, @Metric, @Severity, @Timeframe, @Forecast, @Accuracy, @Expiration)
	
	END
	ELSE
	BEGIN
		
		UPDATE PredictiveForecasts SET Forecast = @Forecast, Accuracy = @Accuracy, Expiration = @Expiration WHERE SQLServerID = @SQLServerID AND Metric = @Metric AND Severity = @Severity AND Timeframe = @Timeframe
		
	END	

	DECLARE @err INT
	SELECT  @err = @@error
	RETURN  @err
	
END
 
GO 

---------- P_ADDPREDICTIVEMODEL.SQL

IF (OBJECT_ID('p_AddPredictiveModel') IS NOT NULL)
BEGIN
	DROP PROCEDURE [p_AddPredictiveModel]
END
GO

CREATE PROCEDURE [dbo].[p_AddPredictiveModel] 
	@SQLServerID int,
	@Metric      int,
	@Severity    int,
	@Timeframe   int,
	@Model       image
AS
BEGIN	
	
	IF NOT EXISTS(SELECT SQLServerID FROM PredictiveModels WHERE SQLServerID = @SQLServerID AND Metric = @Metric AND Severity = @Severity AND Timeframe = @Timeframe)
	BEGIN
	
		INSERT INTO PredictiveModels VALUES (@SQLServerID, @Metric, @Severity, @Timeframe, @Model)
	
	END
	ELSE
	BEGIN
		
		UPDATE PredictiveModels SET Model = @Model WHERE SQLServerID = @SQLServerID AND Metric = @Metric AND Severity = @Severity AND Timeframe = @Timeframe
		
	END	

	DECLARE @err INT
	SELECT  @err = @@error
	RETURN  @err
	
END
 
GO 

---------- P_ADDSQLSAFEREFERENCELINK.SQL

IF (object_id('p_AddSQLsafeReferenceLink') IS NOT NULL)
BEGIN
DROP PROCEDURE p_AddSQLsafeReferenceLink
END
GO

CREATE PROCEDURE [dbo].[p_AddSQLsafeReferenceLink]
(
	@Id	INT,
	@RepositoryId INT,
	@SQLSafeInstanceId INT,
	@BackupActionId INT,
	@DefragActionId INT
)
AS
BEGIN
	IF NOT EXISTS(Select LastBackupActionId from MonitoredServerSQLsafeInstance where SQLServerID = @Id)
	BEGIN
		INSERT INTO MonitoredServerSQLsafeInstance (SQLServerID, RepositoryId, RelatedInstanceId, LastBackupActionId, LastDefragActionId)
			VALUES(@Id, @RepositoryId, @SQLSafeInstanceId, @BackupActionId, @DefragActionId)
	END
	ELSE
	BEGIN
		UPDATE MonitoredServerSQLsafeInstance 
			set RepositoryId = @RepositoryId, RelatedInstanceId = @SQLSafeInstanceId, 
				LastBackupActionId = @BackupActionId, LastDefragActionId = @DefragActionId
			where SQLServerID = @Id
	End
END
 
GO 

---------- P_ADDSQLSAFEREPOSITORY.SQL

IF (object_id('p_AddSQLsafeRepository') IS NOT NULL)
BEGIN
DROP PROCEDURE p_AddSQLsafeRepository
END
GO

CREATE PROCEDURE [dbo].[p_AddSQLsafeRepository]
(
	@InstanceName nvarchar(256),
	@DatabaseName nvarchar(128),
	@SecurityMode bit,
	@UserName nvarchar(128),
	@EncryptedPassword nvarchar(128),
	@FriendlyName nvarchar(256),
	@Id int out
)
AS
BEGIN
	
	select @Id = -1

	IF NOT EXISTS(select RepositoryId from SQLsafeConnections where InstanceName = @InstanceName)
	BEGIN
		INSERT INTO SQLsafeConnections (FriendlyName, InstanceName, DatabaseName, Active, Deleted, SecurityMode, UserName, EncryptedPassword)
			values(@FriendlyName, @InstanceName, @DatabaseName, 1, 0, @SecurityMode, @UserName, @EncryptedPassword)

		select @Id = @@IDENTITY
	END
END
 
GO 

---------- P_ADDTAG.SQL
IF (object_id('p_AddTag') IS NOT NULL)
BEGIN
DROP PROCEDURE p_AddTag
END
GO

CREATE PROCEDURE [dbo].[p_AddTag]
(
	@Name NVARCHAR(50),
	@Id INT OUTPUT
)
AS
BEGIN
	DECLARE @LookupId INT

	SELECT @LookupId = [Id] 
	FROM [Tags]
	WHERE LOWER([Name]) = LOWER(@Name)

	IF (@LookupId IS NULL)
	BEGIN
		INSERT INTO [Tags]
		   ([Name])
		VALUES
		   (@Name)

		SELECT @LookupId = SCOPE_IDENTITY()
	END

	SELECT @Id = @LookupId
END
 
GO 

---------- P_ADDTASK.SQL
if (object_id('p_AddTask') is not null)
begin
drop procedure [p_AddTask]
end
go

create procedure [p_AddTask]
	@ServerName nvarchar(256),
	@Subject nvarchar(256),
	@Message nvarchar(1024),
	@Comments nvarchar(1024),
	@Owner nvarchar(256),
	@CreatedOn datetime,
	@CompletedOn datetime,
	@Status tinyint,
	@Metric int,
	@Severity tinyint,
	@Value float,
	@EventID int,
	@DatabaseName nvarchar(255),
	@ReturnTaskID int output
as
begin
	DECLARE @err int
	DECLARE @created datetime

	-- if no create date is specified then set one
	SELECT @created = @CreatedOn
	if @created is null
		SELECT @created = GetUTCDate()

	INSERT	into Tasks WITH (TABLOCK) (
			[ServerName],
			[Subject],
			[Message],
			[Comments],
			[Owner],
			[CreatedOn],
			[CompletedOn],
			[Status],
			[Metric],
			[Severity],
			[Value],
			[EventID],
			[DatabaseName]
		) VALUES (
			@ServerName,
			@Subject,
			@Message,
			@Comments,
			@Owner,
			@created,
			@CompletedOn,
			@Status,
			@Metric,
			@Severity,
			@Value,
			@EventID,
			@DatabaseName)

	SELECT @err = @@error
	
	if (@err = 0)
	begin
		SELECT @ReturnTaskID = SCOPE_IDENTITY()
	end

	RETURN @err
end
 
GO 

---------- P_ADDTHEPRODUCTREGISTRATIONINFORMATION.SQL
-- SQLdm 9.0 (Abhishek Joshi)

-- CWF Registration
-- insert the product's web framework registration information, if it's registered for the first time,
-- else, update the registration information

-- exec p_AddTheProductRegistrationInformation @HostName = 'QA-LOVEJOY',
--                                             @Port = '9292',
--                                             @UserName = 'QA-LOVEJOY\Administrator',
--                                             @Password = 'control*88',
--                                             @ProductID = 2

if (object_id('p_AddTheProductRegistrationInformation') is not null)
begin
	drop procedure [p_AddTheProductRegistrationInformation]
end
go

create procedure [dbo].[p_AddTheProductRegistrationInformation]
	@HostName nvarchar(255),
	@Port nvarchar(4),
	@UserName nvarchar(100),
	@Password nvarchar(100),
	@InstanceName nvarchar(200),
	@ProductID int
as
begin
	if exists (select top 1 HostName from [WebFramework] where ProductID = @ProductID)
		update [WebFramework]
		set HostName = @HostName,
			Port =  @Port,
			UserName = @UserName,
			Password = @Password,
			InstanceName = @InstanceName
		where ProductID = @ProductID
	else
		delete from WebFramework;
		insert into [WebFramework](HostName, Port, UserName, Password,InstanceName, ProductID)
		values(@HostName, @Port, @UserName, @Password, @InstanceName,@ProductID)
end
go
 
GO 

---------- P_ADDTHRESHOLDINSTANCE.SQL

if (object_id('p_AddThresholdInstance') is not null)
begin
drop procedure p_AddThresholdInstance
end
go

CREATE PROCEDURE [dbo].p_AddThresholdInstance(
	@InstanceType int,
	@InstanceName nvarchar(256) = null,
	@InstanceID int out
)
AS
BEGIN
	IF (@InstanceName is null OR @InstanceName = '')
	BEGIN
		select @InstanceID = -1
		RETURN 
	END
	
	if (not exists(select InstanceID from MetricThresholdInstances where InstanceType = @InstanceType and ThresholdInstanceName = @InstanceName))
	begin
		insert into MetricThresholdInstances (InstanceType, ThresholdInstanceName) values(@InstanceType, @InstanceName)
		
		select @InstanceID = SCOPE_IDENTITY()
	end
	else
	begin
		select @InstanceID = InstanceID from MetricThresholdInstances where InstanceType = @InstanceType and ThresholdInstanceName = @InstanceName
	end

END	
 
GO 

---------- P_ADDUPDATEVIRTUALHOST.SQL

if (object_id('p_AddUpdateVirtualHost') is not null)
begin
drop procedure p_AddUpdateVirtualHost
end
go

create procedure [dbo].[p_AddUpdateVirtualHost]
	@VhName nvarchar(256),
	@VhAddress nvarchar(256),
	@VhUser nvarchar(256),
	@VhPassword nvarchar(256),
	@VhServerType nvarchar(256),
	@VhHostID int output
as
begin
	DECLARE @err int
	declare @vhid int 

    -- Check if Virtual Host already exists
    select @vhid = VHostID from [dbo].[VirtualHostServers] where [VHostAddress] = @VhAddress
    
    if @vhid is null
    begin
		insert into [dbo].[VirtualHostServers] ([VHostName],[VHostAddress],[Username],[Password],[ServerType])
			values(@VhName, @VhAddress, @VhUser, @VhPassword, @VhServerType)

		Select @err = @@ERROR, @vhid = @@IDENTITY
		if @err != 0 GOTO HANDLE_ADD_ERROR
	end
	else
	begin
		update [dbo].[VirtualHostServers] Set [VHostName] = @VhName, [VHostAddress] = @VhAddress, [Username] = @VhUser, [Password] = @VhPassword, [ServerType] = @VhServerType
			where [VHostID] = @vhid
			
		select @err = @@ERROR
		if @err != 0 GOTO HANDLE_UPDATE_ERROR
	end
		
	select @VhHostID = @vhid
	
	return(0)
	
	HANDLE_ADD_ERROR:
		RAISERROR('An error occured while adding the virtual host %s to the repository', 10, 1, @VhAddress)
		RETURN(@err)

	HANDLE_UPDATE_ERROR:
		RAISERROR('An error occurred while updating the virtual host %s in the repository', 10, 1, @VhAddress)
		RETURN(@err)
end

GO

 
GO 

---------- P_ADDVMTOMONITOREDSERVER.SQL

if (object_id('p_AddVMToMonitoredServer') is not null)
begin
drop procedure p_AddVMToMonitoredServer
end
go

CREATE PROCEDURE [dbo].[p_AddVMToMonitoredServer]
	@SQLServerID int,
	@HostServerID int,
	@VMUid nvarchar(256)
AS
BEGIN
	DECLARE @count int
	declare @err int
	
	select @count = COUNT(SQLServerID) from [dbo].[MonitoredSQLServers] where [SQLServerID] = @SQLServerID 
	select @err = @@ERROR

	if (@count > 0 OR @err = 0)
	begin
		update [dbo].[MonitoredSQLServers] set [VHostID] = @HostServerID, [VmUID] = @VMUid where [SQLServerID] = @SQLServerID 
		
		select @err = @@ERROR 
	end

	if @err > 0
	begin
		RAISERROR('There was an error associating the VM with is [%s] with SQL Server ID %d', 10, 1, @VMUid, @SQLServerID)
		return(@err)
	END

	return(0)

END
GO
 
GO 

---------- P_AGGREGATEQUERYDATA.SQL
if (object_id('p_AggregateQueryData') is not null)
begin
drop procedure p_AggregateQueryData
end
go

create procedure p_AggregateQueryData
as
begin
set nocount on
set ansi_warnings off


declare @ActivityCutoff datetime,
		@Now datetime, 
		@SQLServerID int, 
		@InstanceName nvarchar(256), 
		@AggregateQueryMonitorDays int,
		@RC int,
		@RowsAffected int,
		@run_id uniqueidentifier,
		@Sequence int,
		@TimeoutTime datetime,
		@RecordsToDelete int

set @Now = getdate()
set @TimeoutTime = dateadd(mi,120,getutcdate())
set @run_id = newid()
set @RecordsToDelete = 1000
set @Sequence = 0


exec Grooming.p_LogGroomingAction @run_id, @Sequence out, 'Starting Aggregation', 0, null

declare @LoopServers 
table
(SQLServerID int)

insert into @LoopServers
select SQLServerID from MonitoredSQLServers where isnull(Deleted,0) = 0

select @SQLServerID = min(SQLServerID) from @LoopServers
	
select @AggregateQueryMonitorDays = Internal_Value
from RepositoryInfo where Name = 'GroomQueryAggregation'

if (@AggregateQueryMonitorDays is null)
	set @AggregateQueryMonitorDays = 14

while isnull(@SQLServerID,0) > 0
begin

	set ansi_warnings off
	
	select @ActivityCutoff = cast(floor(cast(dateadd(day, -(@AggregateQueryMonitorDays), @Now) as float)) as datetime)

	----------------------------------------------
	-- Begin Signature Mode
	----------------------------------------------
	if (object_id('QuerySignatureAggregationStep1' )) is null
	begin
		create table QuerySignatureAggregationStep1  
		(
			SQLServerID int,
			EventUTCStartTime datetime,	
			QueryMonitorOccurrences dec(38,0),
			WaitOcurrences dec(38,0),
			BlockingOcurrences dec(38,0),
			DeadlockOcurrences dec(38,0),
			TotalDurationMilliseconds dec(38,0),
			MaxDurationMilliseconds dec(38,0),
			TotalCPUMilliseconds dec(38,0),
			MaxCPUMilliseconds dec(38,0),
			TotalReads dec(38,0),
			MaxReads dec(38,0),	
			TotalWrites dec(38,0),
			MaxWrites dec(38,0),
			StatementType int,
			TotalBlockingDurationMilliseconds dec(38,0),
			MaxBlockingDurationMilliseconds dec(38,0),
			TotalWaitDuration dec(38,0),
			MaxWaitDuration dec(38,0),
			ApplicationNameID bigint,
			DatabaseID bigint,
			SQLSignatureID  bigint
		)
	end
	else
	begin
		truncate table QuerySignatureAggregationStep1
	end		

	insert into QuerySignatureAggregationStep1
	(
		SQLServerID,
		EventUTCStartTime,	
		QueryMonitorOccurrences,
		TotalDurationMilliseconds,
		MaxDurationMilliseconds,
		TotalCPUMilliseconds,
		MaxCPUMilliseconds,
		TotalReads,
		MaxReads,	
		TotalWrites,
		MaxWrites,
		ApplicationNameID,
		DatabaseID,
		StatementType,
		SQLSignatureID
	)

	-- Query Monitor
	select
		SQLServerID,
		EventUTCStartTime = cast(floor(cast(isnull(StatementLocalStartTime,StatementUTCStartTime) as float)) as datetime),	
		QueryMonitorOccurrences = count(SQLServerID),
		TotalDurationMilliseconds = sum(cast(DurationMilliseconds as dec(38,0))),
		MaxDurationMilliseconds = max(DurationMilliseconds),
		TotalCPUMilliseconds = sum(cast(CPUMilliseconds as dec(38,0))),
		MaxCPUMilliseconds = max(CPUMilliseconds),
		TotalReads = sum(cast(Reads as dec(38,0))),
		MaxReads = max(Reads),	
		TotalWrites = sum(cast(Writes as dec(38,0))),
		MaxWrites = max(Writes),
		ApplicationNameID,
		DatabaseID,
		StatementType,
		qm.SQLSignatureID
	from 
		QueryMonitorStatistics qm 
		inner join AllSQLSignatures s
		on qm.SQLSignatureID = s.SQLSignatureID
	where
		SQLServerID = @SQLServerID
		and StatementUTCStartTime <= @ActivityCutoff
		and isnull(s.DoNotAggregate,0) = 0
	group by
		SQLServerID,
		cast(floor(cast(isnull(StatementLocalStartTime,StatementUTCStartTime) as float)) as datetime),
		ApplicationNameID,
		DatabaseID,
		StatementType,
		qm.SQLSignatureID
		
		


	insert into QuerySignatureAggregationStep1
	(
		SQLServerID,
		EventUTCStartTime,	
		BlockingOcurrences,
		TotalBlockingDurationMilliseconds,
		MaxBlockingDurationMilliseconds,
		ApplicationNameID,
		DatabaseID,
		SQLSignatureID
	)	
	select
		SQLServerID,
		EventUTCStartTime =  cast(floor(cast(isnull(BlockingLocalStartTime,BlockingUTCStartTime) as float)) as datetime),
		BlockingOcurrences = count(SQLServerID),
		TotalBlockingDurationMilliseconds = sum(cast(BlockingDurationMilliseconds as dec(38,0))),
		MaxBlockingDurationMilliseconds = max(BlockingDurationMilliseconds),
		ApplicationNameID,
		DatabaseID,
		b.SQLSignatureID
	from
		BlockingSessionStatistics b
		inner join AllSQLSignatures s
		on b.SQLSignatureID = s.SQLSignatureID
	where
		SQLServerID = @SQLServerID
		and BlockingUTCStartTime <= @ActivityCutoff
		and isnull(s.DoNotAggregate,0) = 0
	group by
		SQLServerID,
		cast(floor(cast(isnull(BlockingLocalStartTime,BlockingUTCStartTime) as float)) as datetime),
		ApplicationNameID,
		DatabaseID,
		b.SQLSignatureID

	-- Waits
	insert into QuerySignatureAggregationStep1
	(
		SQLServerID,
		EventUTCStartTime,	
		BlockingOcurrences,
		TotalWaitDuration,
		MaxWaitDuration,
		ApplicationNameID,
		DatabaseID,
		SQLSignatureID
	)	
	select
		SQLServerID,
		EventUTCStartTime =  cast(floor(cast(isnull(StatementLocalStartTime,StatementUTCStartTime) as float)) as datetime),
		WaitOcurrences = count(SQLServerID),
		TotalWaitDuration = sum(cast(WaitDuration as dec(38,0))),
		MaxWaitDuration = max(WaitDuration),
		ApplicationNameID,
		DatabaseID,
		a.SQLSignatureID
	from
		ActiveWaitStatistics a (nolock)
		inner join AllSQLSignatures s (nolock)
		on a.SQLSignatureID = s.SQLSignatureID
	where
		SQLServerID = @SQLServerID
		and StatementUTCStartTime <= @ActivityCutoff
		and isnull(s.DoNotAggregate,0) = 0
	group by
		SQLServerID,
		cast(floor(cast(isnull(StatementLocalStartTime,StatementUTCStartTime) as float)) as datetime),
		ApplicationNameID,
		DatabaseID,
		a.SQLSignatureID

	insert into QuerySignatureAggregationStep1
	(
		SQLServerID,
		EventUTCStartTime,	
		DeadlockOcurrences,
		ApplicationNameID,
		DatabaseID,
		SQLSignatureID
	)	
	-- Deadlocks
	select 
		SQLServerID,
		UTCOccurrenceDateTime =  cast(floor(cast(isnull(LocalOccurrenceDateTime,UTCOccurrenceDateTime) as float)) as datetime),
		Occurrences = count(SQLServerID),
		ApplicationNameID,
		DatabaseID,
		d.SQLSignatureID
	from
		DeadlockProcesses d
		inner join AllSQLSignatures s
		on d.SQLSignatureID = s.SQLSignatureID
	where
		SQLServerID = @SQLServerID
		and UTCOccurrenceDateTime <= @ActivityCutoff
		and isnull(s.DoNotAggregate,0) = 0
	group by
		SQLServerID,
		cast(floor(cast(isnull(LocalOccurrenceDateTime,UTCOccurrenceDateTime) as float)) as datetime),
		ApplicationNameID,
		DatabaseID,
		d.SQLSignatureID


	----------------------------------------------
	if (object_id('QuerySignatureAggregationStep2' )) is null
	begin
		create table QuerySignatureAggregationStep2  
		(
			SQLServerID int,
			EventUTCStartTime datetime,	
			QueryMonitorOccurrences dec(38,0),
			WaitOcurrences dec(38,0),
			BlockingOcurrences dec(38,0),
			DeadlockOcurrences dec(38,0),
			TotalDurationMilliseconds dec(38,0),
			MaxDurationMilliseconds dec(38,0),
			TotalCPUMilliseconds dec(38,0),
			MaxCPUMilliseconds dec(38,0),
			TotalReads dec(38,0),
			MaxReads dec(38,0),	
			TotalWrites dec(38,0),
			MaxWrites dec(38,0),
			StatementType int,
			TotalBlockingDurationMilliseconds dec(38,0),
			MaxBlockingDurationMilliseconds dec(38,0),
			TotalWaitDuration dec(38,0),
			MaxWaitDuration dec(38,0),
			ApplicationNameID bigint,
			DatabaseID bigint,
			SQLSignatureID  bigint
		)
		
		create index qs2SQLServerID on QuerySignatureAggregationStep2(SQLServerID)
		create index qs2EventUTCStartTime on QuerySignatureAggregationStep2(EventUTCStartTime)
		create index qs2ApplicationNameID on QuerySignatureAggregationStep2(ApplicationNameID)
		create index qs2DatabaseID on QuerySignatureAggregationStep2(DatabaseID)
		create index qs2SQLSignatureID on QuerySignatureAggregationStep2(SQLSignatureID)
	end
	else
	begin
		truncate table QuerySignatureAggregationStep2
	end
	
	insert into 
	QuerySignatureAggregationStep2
	(
		SQLServerID,
		EventUTCStartTime,	
		QueryMonitorOccurrences,
		WaitOcurrences,
		BlockingOcurrences,
		DeadlockOcurrences,
		TotalDurationMilliseconds,
		MaxDurationMilliseconds,
		TotalCPUMilliseconds,
		MaxCPUMilliseconds,
		TotalReads,
		MaxReads,	
		TotalWrites,
		MaxWrites,
		StatementType,
		TotalBlockingDurationMilliseconds,
		MaxBlockingDurationMilliseconds,
		TotalWaitDuration,
		MaxWaitDuration,
		ApplicationNameID,
		DatabaseID,
		SQLSignatureID 
	)
	select
		qs1.SQLServerID,
		qs1.EventUTCStartTime,	
		max(qs1.QueryMonitorOccurrences),
		max(qs1.WaitOcurrences),
		max(qs1.BlockingOcurrences),
		max(qs1.DeadlockOcurrences),
		max(qs1.TotalDurationMilliseconds),
		max(qs1.MaxDurationMilliseconds),
		max(qs1.TotalCPUMilliseconds),
		max(qs1.MaxCPUMilliseconds),
		max(qs1.TotalReads),
		max(qs1.MaxReads),	
		max(qs1.TotalWrites),
		max(qs1.MaxWrites),
		max(qs1.StatementType),
		max(qs1.TotalBlockingDurationMilliseconds),
		max(qs1.MaxBlockingDurationMilliseconds),
		max(qs1.TotalWaitDuration),
		max(qs1.MaxWaitDuration),
		qs1.ApplicationNameID,
		qs1.DatabaseID,
		qs1.SQLSignatureID 
	from QuerySignatureAggregationStep1 qs1
	group by
		qs1.SQLServerID,
		qs1.EventUTCStartTime,	
		qs1.ApplicationNameID,
		qs1.DatabaseID,
		qs1.SQLSignatureID 
		


	update
	QuerySignatureAggregation
	set
		SQLServerID                                = case when qs2.SQLServerID                       > qsa.SQLServerID                       then qs2.SQLServerID                       else qsa.SQLServerID                       end,
		EventUTCStartTime                          = case when qs2.EventUTCStartTime                 > qsa.EventUTCStartTime                 then qs2.EventUTCStartTime                 else qsa.EventUTCStartTime                 end,
		QueryMonitorOccurrences                    = case when qs2.QueryMonitorOccurrences           > qsa.QueryMonitorOccurrences           then qs2.QueryMonitorOccurrences           else qsa.QueryMonitorOccurrences           end,
		WaitOcurrences                             = case when qs2.WaitOcurrences                    > qsa.WaitOcurrences                    then qs2.WaitOcurrences                    else qsa.WaitOcurrences                    end,
		BlockingOcurrences                         = case when qs2.BlockingOcurrences                > qsa.BlockingOcurrences                then qs2.BlockingOcurrences                else qsa.BlockingOcurrences                end,
		DeadlockOcurrences                         = case when qs2.DeadlockOcurrences                > qsa.DeadlockOcurrences                then qs2.DeadlockOcurrences                else qsa.DeadlockOcurrences                end,
		TotalDurationMilliseconds                  = case when qs2.TotalDurationMilliseconds         > qsa.TotalDurationMilliseconds         then qs2.TotalDurationMilliseconds         else qsa.TotalDurationMilliseconds         end,
		MaxDurationMilliseconds                    = case when qs2.MaxDurationMilliseconds           > qsa.MaxDurationMilliseconds           then qs2.MaxDurationMilliseconds           else qsa.MaxDurationMilliseconds           end,
		TotalCPUMilliseconds                       = case when qs2.TotalCPUMilliseconds              > qsa.TotalCPUMilliseconds              then qs2.TotalCPUMilliseconds              else qsa.TotalCPUMilliseconds              end,
		MaxCPUMilliseconds                         = case when qs2.MaxCPUMilliseconds                > qsa.MaxCPUMilliseconds                then qs2.MaxCPUMilliseconds                else qsa.MaxCPUMilliseconds                end,
		TotalReads                                 = case when qs2.TotalReads                        > qsa.TotalReads                        then qs2.TotalReads                        else qsa.TotalReads                        end,
		MaxReads                                   = case when qs2.MaxReads                          > qsa.MaxReads                          then qs2.MaxReads                          else qsa.MaxReads                          end,
		TotalWrites                                = case when qs2.TotalWrites                       > qsa.TotalWrites                       then qs2.TotalWrites                       else qsa.TotalWrites                       end,
		MaxWrites                                  = case when qs2.MaxWrites                         > qsa.MaxWrites                         then qs2.MaxWrites                         else qsa.MaxWrites                         end,
		StatementType                              = case when qs2.StatementType                     > qsa.StatementType                     then qs2.StatementType                     else qsa.StatementType                     end,
		TotalBlockingDurationMilliseconds          = case when qs2.TotalBlockingDurationMilliseconds > qsa.TotalBlockingDurationMilliseconds then qs2.TotalBlockingDurationMilliseconds else qsa.TotalBlockingDurationMilliseconds end,
		MaxBlockingDurationMilliseconds            = case when qs2.MaxBlockingDurationMilliseconds   > qsa.MaxBlockingDurationMilliseconds   then qs2.MaxBlockingDurationMilliseconds   else qsa.MaxBlockingDurationMilliseconds   end,
		TotalWaitDuration                          = case when qs2.TotalWaitDuration                 > qsa.TotalWaitDuration                 then qs2.TotalWaitDuration                 else qsa.TotalWaitDuration                 end,
		MaxWaitDuration                            = case when qs2.MaxWaitDuration                   > qsa.MaxWaitDuration                   then qs2.MaxWaitDuration                   else qsa.MaxWaitDuration                   end,
		ApplicationNameID                          = case when qs2.ApplicationNameID                 > qsa.ApplicationNameID                 then qs2.ApplicationNameID                 else qsa.ApplicationNameID                 end,
		DatabaseID                                 = case when qs2.DatabaseID                        > qsa.DatabaseID                        then qs2.DatabaseID                        else qsa.DatabaseID                        end,
		SQLSignatureID                             = case when qs2.SQLSignatureID                    > qsa.SQLSignatureID                    then qs2.SQLSignatureID                    else qsa.SQLSignatureID                    end
	from QuerySignatureAggregationStep2 qs2
	inner join QuerySignatureAggregation qsa
	on 
		qs2.SQLServerID = qsa.SQLServerID
		and qs2.EventUTCStartTime = qsa.EventUTCStartTime
		and qs2.ApplicationNameID = qsa.ApplicationNameID
		and qs2.DatabaseID = qsa.DatabaseID
		and qs2.SQLSignatureID = qsa.SQLSignatureID 
	where
		qsa.SQLServerID is not null


	insert into 
	QuerySignatureAggregation
	(
		SQLServerID,
		EventUTCStartTime,	
		QueryMonitorOccurrences,
		WaitOcurrences,
		BlockingOcurrences,
		DeadlockOcurrences,
		TotalDurationMilliseconds,
		MaxDurationMilliseconds,
		TotalCPUMilliseconds,
		MaxCPUMilliseconds,
		TotalReads,
		MaxReads,	
		TotalWrites,
		MaxWrites,
		StatementType,
		TotalBlockingDurationMilliseconds,
		MaxBlockingDurationMilliseconds,
		TotalWaitDuration,
		MaxWaitDuration,
		ApplicationNameID,
		DatabaseID,
		SQLSignatureID 
	)
	select
		qs2.SQLServerID,
		qs2.EventUTCStartTime,	
		qs2.QueryMonitorOccurrences,
		qs2.WaitOcurrences,
		qs2.BlockingOcurrences,
		qs2.DeadlockOcurrences,
		qs2.TotalDurationMilliseconds,
		qs2.MaxDurationMilliseconds,
		qs2.TotalCPUMilliseconds,
		qs2.MaxCPUMilliseconds,
		qs2.TotalReads,
		qs2.MaxReads,	
		qs2.TotalWrites,
		qs2.MaxWrites,
		qs2.StatementType,
		qs2.TotalBlockingDurationMilliseconds,
		qs2.MaxBlockingDurationMilliseconds,
		qs2.TotalWaitDuration,
		qs2.MaxWaitDuration,
		qs2.ApplicationNameID,
		qs2.DatabaseID,
		qs2.SQLSignatureID 
	from QuerySignatureAggregationStep2 qs2
	left join QuerySignatureAggregation qsa
	on 
		qs2.SQLServerID = qsa.SQLServerID
		and qs2.EventUTCStartTime = qsa.EventUTCStartTime
		and qs2.ApplicationNameID = qsa.ApplicationNameID
		and qs2.DatabaseID = qsa.DatabaseID
		and qs2.SQLSignatureID = qsa.SQLSignatureID 
	where
		qsa.SQLServerID is null

	
	set @RC = 0

	select @InstanceName = InstanceName from MonitoredSQLServers where SQLServerID = @SQLServerID
	
	set ansi_warnings ON
	
	exec Grooming.p_GroomQueryMonitorStatistics 
		@run_id = @run_id,
		@Sequence = @Sequence out,
		@TimeoutTime = @TimeoutTime,
		@RecordsToDelete = @RecordsToDelete,
		@CutoffDateTime = @ActivityCutoff,
		@SQLServerID = @SQLServerID,
		@InstanceName = @InstanceName,
		@Deleted = 0

	


	----------------------------------------------
	-- End Signature Mode
	----------------------------------------------


	delete from @LoopServers where SQLServerID = @SQLServerID
	select @SQLServerID = min(SQLServerID) from @LoopServers
end	

	if (object_id('QuerySignatureAggregationStep1' )) is not null
	begin
		exec ('drop table QuerySignatureAggregationStep1')
	end
	
	if (object_id('QuerySignatureAggregationStep2' )) is not null
	begin
		exec ('drop table QuerySignatureAggregationStep2')
	end
	
	
exec Grooming.p_LogGroomingAction @run_id, @Sequence out, 'Finished with Aggregation', 0, null	

end
 
GO 

---------- P_APPENDTOMETRICTHRESHOLD.SQL
if (object_id('p_AppendToMetricThreshold') is not null)
begin
drop procedure p_AppendToMetricThreshold
end
go


CREATE PROCEDURE p_AppendToMetricThreshold
	@XmlText nvarchar(max),
	@Value nvarchar(256),
	@ValueType nvarchar(256),
	@Result nvarchar(4000) output
AS
BEGIN
declare @xmlDoc int,
		@OP nvarchar(256),
		@Enabled nvarchar(256),
		@valueArray nvarchar(4000),
		@serviceState nvarchar(256),
		@stateFound bit

		SET @OP = 'EQ'
		SET @Enabled = 'true'
		SET @valueArray = ''
		SET @stateFound = 0

		if (@XmlText is not null)
		begin
			exec sp_xml_preparedocument @xmlDoc output, @XmlText
	
			select @OP = [Op], @Enabled = [Enabled] from openxml(@xmlDoc, '/Threshold', 3) with (Op nvarchar(256), Enabled nvarchar(256))

			declare read_threshold_entry cursor
			for
				select servicestate from openxml(@xmlDoc, '//anyType', 2) with (servicestate nvarchar(256) 'text()')

			open read_threshold_entry
			fetch read_threshold_entry into @serviceState
			while @@fetch_status = 0
			begin
				if (@serviceState = @Value)
					set @stateFound = 1
				set @valueArray = @valueArray + '<anyType xsi:type="' + @ValueType + '">'
				set @valueArray = @valueArray + @serviceState
				set @valueArray = @valueArray + '</anyType>'

				fetch read_threshold_entry into @serviceState
			end
	
			Close read_threshold_entry
			deallocate read_threshold_entry
	
			exec sp_xml_removedocument @xmlDoc
		end

		-- We don't want to add a value that already exists
		if @stateFound <> 1
		begin
			set @valueArray = @valueArray + '<anyType xsi:type="' + @ValueType + '">'
			set @valueArray = @valueArray + @Value
			set @valueArray = @valueArray + '</anyType>'
		end

		set @Result = '<?xml version="1.0" encoding="utf-16"?><Threshold xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XmlSchema" Op="'
		set @Result = @Result + @OP
		set @Result = @Result + '" Enabled="'
		set @Result = @Result + @Enabled
		set @Result = @Result + '"><Value xsi:type="ArrayOfAnyType">'
		set @Result = @Result + @valueArray
		set @Result = @Result + '</Value></Threshold>'
END
 
GO 

---------- P_APPSECDISABLE.SQL
IF (object_id('p_AppSecDisable') is not null)
BEGIN
drop procedure p_AppSecDisable
END
GO

CREATE PROCEDURE [dbo].[p_AppSecDisable]
AS
BEGIN
	declare @e int

	-- set security enabled flag
	-- if ApplicationSecurityEnabled flag is in the table then clear it.
	-- else create one and set it to 0.
	if ((select count([Internal_Value]) from dbo.[RepositoryInfo] where [Name] = 'ApplicationSecurityEnabled') = 1)
	begin
		update dbo.[RepositoryInfo]
		set [Internal_Value] = 0
		where [Name] = 'ApplicationSecurityEnabled'
	end
	else
	begin
		insert into dbo.[RepositoryInfo]
		values ('ApplicationSecurityEnabled',0,'')
	end
	
	-- disable all permission rules.
	update dbo.[Permission]
	set [Enabled] = 0

	select @e = @@error
	return @e
END
GO
 
GO 

---------- P_APPSECENABLE.SQL
IF (object_id('p_AppSecEnable') is not null)
BEGIN
drop procedure p_AppSecEnable
END
GO

CREATE PROCEDURE [dbo].[p_AppSecEnable]
AS
BEGIN
	declare @e int

	-- set security enabled flag
	-- if ApplicationSecurityEnabled flag is in the table then set it.
	-- else create one and set it to 1.
	if ((select count([Internal_Value]) from dbo.[RepositoryInfo] where [Name] = 'ApplicationSecurityEnabled') = 1)
	begin
		update dbo.[RepositoryInfo]
		set [Internal_Value] = 1
		where [Name] = 'ApplicationSecurityEnabled'
	end
	else
	begin
		insert into dbo.[RepositoryInfo]
		values ('ApplicationSecurityEnabled',1,'')
	end

	select @e = @@error
	return @e
END
GO
 
GO 

---------- P_ASSIGNCOUNTERSTOSERVER.SQL
if (object_id('p_AssignCountersToServer') is not null)
begin
drop procedure [p_AssignCountersToServer]
end
go

create procedure [p_AssignCountersToServer]
	@SQLServerID int,
	@MetricXML nvarchar(max),
	@SynchronizeToList bit
as
begin
	DECLARE @err int
	declare @xmlDoc int
	declare @Metrics table(
		Metric int
	) 
	declare @InstanceName nvarchar(256)


	exec sp_xml_preparedocument @xmlDoc output, @MetricXML

	insert into @Metrics	
	select distinct MetricID
		from openxml(@xmlDoc, '//Metric', 1) with (MetricID int) 

	exec sp_xml_removedocument @xmlDoc

	-- map the new counter to the instance
	insert into CustomCounterMap
		select @SQLServerID, Metric from @Metrics
			where Metric not in 
				(select Metric from CustomCounterMap where SQLServerID = @SQLServerID)

	if (@SynchronizeToList = 1) 
	begin
		-- remove mappings for metrics not in the new list
		delete from CustomCounterMap 
			where SQLServerID = @SQLServerID and
				Metric not in (select Metric from @Metrics)
	end

	-- add all custom counters assigned by tag
	insert into @Metrics 
		select distinct CCT.Metric from CustomCounterTags CCT
			join ServerTags ST on ST.TagId = CCT.TagId
			where ST.SQLServerId = @SQLServerID and
				CCT.Metric not in (select Metric from @Metrics)

	if (@SynchronizeToList = 1) 
	begin
		-- remove thresholds for custom counters not mapped to the server
		delete from MetricThresholds 
			where SQLServerID = @SQLServerID and
				Metric in (select Metric from CustomCounterDefinition) and
				Metric not in (select Metric from @Metrics)
		-- deactivate alerts for custom counters not mapped to the server
		select @InstanceName = InstanceName from MonitoredSQLServers where SQLServerID = @SQLServerID
		if (@InstanceName is not null) 
		begin
			update Alerts set Active = 0
				where Active = 1 and
					ServerName = @InstanceName and
					Metric in (select Metric from CustomCounterDefinition) and
					Metric not in (select Metric from @Metrics)
		end			
	end

	-- remove metrics already mapped from the new list
	delete from @Metrics 
		where Metric in (select Metric from MetricThresholds where SQLServerID = @SQLServerID)

	--lookup the default alert template
	DECLARE @defaultID int
	SELECT @defaultID = [TemplateID] FROM [AlertTemplateLookup] where [Default] = 1
		
	-- create a threshold entry from the default for all newly mapped instances
	insert into MetricThresholds 
		select @SQLServerID, M.Metric, [Enabled], WarningThreshold, CriticalThreshold, Data, null, null, null, null, InfoThreshold,ThresholdInstanceID,ThresholdEnabled, DMT.IsBaselineEnabled, DMT.[BaselineWarningThreshold],
		DMT.[BaselineCriticalThreshold], DMT.[BaselineInfoThreshold]
			from @Metrics M left join DefaultMetricThresholds DMT on 
				UserViewID = @defaultID and M.Metric = DMT.Metric
			where DMT.Metric is not null

	-- return a list of all metric IDs mapped to the server
	select Metric from CustomCounterMap where SQLServerID = @SQLServerID

	SELECT @err = @@error
	RETURN @err
end
 
GO 

---------- P_ASSIGNCOUNTERTOSERVERS.SQL
if (object_id('p_AssignCounterToServers') is not null)
begin
drop procedure [p_AssignCounterToServers]
end
go

create procedure [p_AssignCounterToServers]
	@Metric int,
	@TagsXML nvarchar(max),
	@ServerXML nvarchar(max),
	@SynchronizeToList bit
as
begin
	DECLARE @err int
	declare @xmlDoc int
	declare @Servers table(
		SQLServerID int,
		InstanceName nvarchar(256),
		LastAlertRefreshTime datetime
	) 

	exec p_UpdateCustomCounterTags @Metric, @TagsXML

	exec sp_xml_preparedocument @xmlDoc output, @ServerXML

	insert into @Servers
		select ms.SQLServerID, ms.InstanceName, ms.LastAlertRefreshTime
			from openxml(@xmlDoc, '//SQLServer', 1) with (SQLServerID int) x
			join MonitoredSQLServers ms (NOLOCK) on ms.SQLServerID = x.SQLServerID
			where ms.Active = 1	

	exec sp_xml_removedocument @xmlDoc

	if (@SynchronizeToList = 1)
	begin
		-- remove mapping of server->counter mapping
		delete from CustomCounterMap 
			where Metric = @Metric and
				SQLServerID not in (select SQLServerID from @Servers)
	end

	-- map counter to instance for statically linked servers
	insert into CustomCounterMap
		select SQLServerID, @Metric from @Servers
			where SQLServerID not in 
					(select SQLServerID from CustomCounterMap (nolock) where Metric = @Metric)

	-- add in servers associated with tags that are linked by tag
	insert into @Servers 
		select distinct MS.SQLServerID, MS.InstanceName, MS.LastAlertRefreshTime 
			from ServerTags ST 
			join CustomCounterTags CCT (nolock) on ST.TagId = CCT.TagId and CCT.Metric = @Metric
			join MonitoredSQLServers MS (nolock) on ST.SQLServerId = MS.SQLServerID
			where ST.SQLServerId not in (select SQLServerID from @Servers)

	if (@SynchronizeToList = 1)
	begin
		-- remove the alert configuration
		delete from MetricThresholds 
			where Metric = @Metric and
				SQLServerID not in (select SQLServerID from @Servers)

		-- deactivate alerts
		update Alerts with (UPDLOCK) set Active = 0
		from Alerts A 
		Where Exists (Select 1 From dbo.MonitoredSQLServers with(nolock)
					Where InstanceName = A.ServerName
					And LastAlertRefreshTime = A.UTCOccurrenceDateTime
					And SQLServerID not in (select SQLServerID from @Servers))
		And A.Metric = @Metric 
		And A.Active = 1
	end

	-- remove counters already mapped from the temp table
	delete from @Servers
		where SQLServerID in (select SQLServerID from MetricThresholds (nolock) where Metric = @Metric)

	-- create a threshold entry from the default for all newly mapped instances
	insert into MetricThresholds 
		select SQLServerID, Metric, [Enabled], WarningThreshold, CriticalThreshold, Data, null, null, null, null, InfoThreshold,[ThresholdInstanceID], [ThresholdEnabled], [IsBaselineEnabled], [BaselineWarningThreshold],
		[BaselineCriticalThreshold], [BaselineInfoThreshold]
			from @Servers left join DefaultMetricThresholds (nolock) on 
				UserViewID = 0 and Metric = @Metric
			where Metric is not null

	SELECT @err = @@error
	RETURN @err
end
 
GO 

---------- P_AUTHENTICATEWEBCONSOLEUSERAPPSECON.SQL
IF (OBJECT_ID('p_AuthenticateWebConsoleUserAppSecOn') IS NOT NULL)
BEGIN
DROP PROCEDURE p_AuthenticateWebConsoleUserAppSecOn
END
GO
CREATE PROC p_AuthenticateWebConsoleUserAppSecOn
AS
DECLARE @IsSysAdmin INT,@SID VARBINARY(MAX),@WebAppSecurityEnabled INT
SELECT @IsSysAdmin = IS_SRVROLEMEMBER ('sysadmin'),@SID = SUSER_SID();
--SELECT @IsSysAdmin = 0,@SID = SUSER_SID();

IF(@IsSysAdmin = 0)
BEGIN
	IF((SELECT COUNT(0) FROM Permission WHERE LoginSID = @SID ) > 0)
	BEGIN
		SELECT @WebAppSecurityEnabled = ISNULL(WebAppPermission,0) FROM Permission (NOLOCK) WHERE 
		LoginSID = @SID AND [Enabled] = 1
	END
	ELSE
	BEGIN
		SELECT @WebAppSecurityEnabled = 0
	END
END

IF @IsSysAdmin = 1
BEGIN
	SELECT 1 IsAuthentic;
END
ELSE IF (@WebAppSecurityEnabled = 1)
BEGIN
	SELECT 1 IsAuthentic;
END
ELSE
BEGIN 
	SELECT 0 IsAuthentic;
END


Go

grant EXECUTE on [p_AuthenticateWebConsoleUserAppSecOn] to [SQLdmConsoleUser]
 
GO 

---------- P_CHECKDASHBOARDEXISTS.SQL
/****** Object:  Function [dbo].[p_CheckDashboardExists] 
Custom Dashboard functionality to check if custom dashboard already exists
    Script Date: 26-May-15 11:35:58 AM ******/

if (object_id('p_CheckDashboardExists') is not null)
begin
drop procedure p_CheckDashboardExists
end
go

-- To Delete record from CustomDashboard for specific CustomDashboardId
CREATE PROCEDURE p_CheckDashboardExists(
	@CustomDashboardId BIGINT,
	@isRecordFound BIT OUTPUT
)
AS
BEGIN
	DECLARE @ret INT;
	SELECT @ret = COUNT(CustomDashboardName) FROM dbo.[CustomDashboard] WHERE CustomDashboardId = @CustomDashboardId;
	SELECT @ret;
		IF(@ret > 0) SELECT @isRecordFound = 1;
		ELSE SELECT @isRecordFound = 0;
END
 

GO
 
GO 

---------- P_CHECKDUPLICATECUSTOMDASHBOARDNAME.SQL
/****** Object:  Function [dbo].[fn_CheckDuplicateCustomDashboardName] 
Custom Dashboard functionality to check new custom dashboard name does not already exists
    Script Date: 26-May-15 11:35:58 AM ******/

if (object_id('p_CheckDuplicateCustomDashboardName') is not null)
begin
drop procedure p_CheckDuplicateCustomDashboardName
end
go

-- To Delete record from CustomDashboard for specific CustomDashboardId
CREATE PROCEDURE p_CheckDuplicateCustomDashboardName(
	@CustomDashboardName nvarchar(500) ,
	@userSID nvarchar(400),
	@isRecordFound bit out
)
AS
begin
	declare @ret int
	select @ret = COUNT(CustomDashboardName) from dbo.[CustomDashboard] where LOWER(CustomDashboardName) = LOWER(@CustomDashboardName) AND LOWER(UserSID) = LOWER(@userSID)
		if(@ret != 0)
		
			SET @isRecordFound = 1
		
		else
			SET @isRecordFound = 0
	return @ret
end
 

GO
 
GO 

---------- P_CLEARALERTS.SQL
if (object_id('p_ClearAlerts') is not null)
begin
drop procedure [p_ClearAlerts]
end
go

create procedure [p_ClearAlerts] 
	@ServerName nvarchar(256),
	@HighestAlertID bigint,
	@ClearAll bit,
	@Metric int,
	@AlertID bigint
as
begin
	
declare @hash nvarchar(28)
declare @server nvarchar(256)
declare @database nvarchar(256)
declare @table nvarchar(256)
declare @msid int
declare @dbid int
declare @tbid int
declare @type int
declare @e int


	if (@AlertID is not null)
	begin
		-- @Metric is not allowed if @AlertID is specified
		if (@Metric is not null)
		begin
			RAISERROR('@Metric is not allowed when @AlertID is specified.', 10, 1);
			RETURN -1;
		end
		-- get server name, metric and hash using the alert id
		select @server = [ServerName],
			   @database = [DatabaseName],
			   @table = [TableName],
			   @type = [Metric],
			   @hash = [QualifierHash]
		from Alerts where [AlertID] = @AlertID

		if (@@ROWCOUNT = 0)
		begin
			RAISERROR('Alert not found to clear.', 10, 1);
			RETURN -2;
		end
		
		select @msid = [SQLServerID] from MonitoredSQLServers where [InstanceName] = @server

		if (@ClearAll = 1) 
		begin
			-- clear all alerts
			update Alerts set [Active] = 0
				where [Active] = 1 
					and [ServerName] = @server 
					and [Metric] = @type
		end
		else
		begin
			-- clear single alert
			update Alerts set [Active] = 0
				where [AlertID] = @AlertID			
		end

		select @msid, @type, @server, @database, @hash

		select @e = @@error
		return @e
	end

	
	if (@ClearAll = 1) 
	begin
		-- clear all alerts
		update Alerts set Active = 0
			where [Active] = 1
				and not ([AlertID] > @HighestAlertID) 
				and [ServerName] = @ServerName 
				and (@Metric is null or @Metric = [Metric])
		select @e = @@error
	end
	else
	begin
		-- clear matching alerts
		update Alerts set Active = 0 
			where [AlertID] in 
				(select S.[AlertID] from Alerts P
					left join Alerts S  
					on  S.[ServerName] = P.[ServerName]
					and S.[Metric] = P.[Metric]
					and (S.[DatabaseName] = P.[DatabaseName] or (S.[DatabaseName] is null and P.[DatabaseName] is null))
					and (S.[TableName] = P.[TableName] or (S.[TableName] is null and P.[TableName] is null))
					and (S.[QualifierHash] = P.[QualifierHash] or (S.[QualifierHash] is null and P.[QualifierHash] is null))
					where P.[AlertID] > @HighestAlertID
						and P.[ServerName] = @ServerName
						and not S.[AlertID] > @HighestAlertID 
						and S.[Active] = 1
				)	
		select @e = @@error			
	end

	return @e
end
 
GO 

---------- P_CREATEAGGREGATIONJOB.SQL
if (object_id('p_CreateAggregationJob') is not null)
begin
drop procedure p_CreateAggregationJob
end
go

create procedure [dbo].[p_CreateAggregationJob] (
	@ForceRecreate bit = 0 -- Should the job be deleted and recreated even if it already exists?
)
as
begin
	DECLARE @JobName nvarchar(256)
	DECLARE @DBName nvarchar(256)
	DECLARE @SA nvarchar(256)
	DECLARE @JobExists bit
	DECLARE @jobId BINARY(16)

	SELECT @JobName = 'Aggregate Data ' + DB_NAME() -- Name used for job and schedule.
	SELECT @DBName = DB_NAME()
	SELECT @SA = suser_sname(0x1)	

	SELECT @jobId=job_id FROM msdb.dbo.sysjobs WHERE name = @JobName
	IF (@jobId is not null)
	begin
		SELECT @JobExists = 1
		-- if the job definition needs updating then add logic here
	end
	else
	begin
		-- make sure the uncategorized local category exists
		IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'[Uncategorized (Local)]' AND category_class=1)
			EXEC msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'[Uncategorized (Local)]'

		EXEC msdb.dbo.sp_add_job 
				@job_name=@JobName, 
				@enabled=1, 
				@notify_level_eventlog=0, 
				@notify_level_email=0, 
				@notify_level_netsend=0, 
				@notify_level_page=0, 
				@delete_level=0, 
				@description=N'Aggregate query data into day-length records.', 
				@category_name=N'[Uncategorized (Local)]', 
				@owner_login_name=@SA, 
				@job_id = @jobId OUTPUT
	end

	-- create or update the jobstep
	IF (@JobExists=1 AND EXISTS(SELECT step_name FROM msdb.dbo.sysjobsteps WHERE job_id=@jobId AND step_id = 1))
	begin -- update the jobstep
		EXEC msdb.dbo.sp_update_jobstep 
				@job_id=@jobId, 
				@step_name=N'Call SP', 
				@step_id=1, 
				@cmdexec_success_code=0, 
				@on_success_action=1, 
				@on_success_step_id=0, 
				@on_fail_action=2, 
				@on_fail_step_id=0, 
				@retry_attempts=0, 
				@retry_interval=0, 
				@os_run_priority=0, 
				@subsystem=N'TSQL', 
				@command=N'EXEC [p_AggregateQueryData]',
				@database_name=@DBName, 
				@flags=0
	end
	else
	begin  -- add the jobstep
		EXEC msdb.dbo.sp_add_jobstep 
				@job_id=@jobId, 
				@step_name=N'Call SP', 
				@step_id=1, 
				@cmdexec_success_code=0, 
				@on_success_action=1, 
				@on_success_step_id=0, 
				@on_fail_action=2, 
				@on_fail_step_id=0, 
				@retry_attempts=0, 
				@retry_interval=0, 
				@os_run_priority=0, @subsystem=N'TSQL', 
				@command=N'EXEC [p_AggregateQueryData]',
				@database_name=@DBName, 
				@flags=0
	end
	-- make step 1 the first jobstep
	EXEC msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1


	-- sp_add_jobschedule is deprecated in SQL Server 2005,
	-- but used for compatibility with SQL Server 2000.
	IF (@JobExists=0 OR NOT EXISTS(SELECT [job_id] FROM msdb.dbo.sysjobschedules WHERE job_id=@jobId AND schedule_id is not null))
	begin -- create the jobstep
		EXEC msdb.dbo.sp_add_jobschedule 
			@job_id=@jobId, 
			@name=@JobName, 
			@enabled=1, 
			@freq_type=4, 
			@freq_interval=1, 
			@freq_subday_type=1, 
			@freq_subday_interval=0, 
			@freq_relative_interval=0, 
			@freq_recurrence_factor=0, 
			@active_start_date=20070511, 
			@active_end_date=99991231, 
			@active_start_time=20000, 
			@active_end_time=235959
	end
	
	if (NOT EXISTS(select server_id from msdb.dbo.sysjobservers where job_id = @jobId))
		EXEC msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
end

-- These two lines create the job when the repository is installed.
go
EXEC [p_CreateAggregationJob] @ForceRecreate = 1
 
GO 

---------- P_CREATECOPYOFCUSTOMDASHBOARD.SQL
if (object_id('p_CreateCopyOfCustomDashboard') is not null)
begin
drop procedure [p_CreateCopyOfCustomDashboard]
end
go

create procedure [p_CreateCopyOfCustomDashboard] 
@sourceCustomDashboardID INT,
@copyCustomDashboardID INT OUT

AS
begin
DECLARE @countCustomDashboard INT

BEGIN TRY
   -- Start A Transaction
BEGIN TRANSACTION




-- check if for record for given dashboard ID
	select @countCustomDashboard = count(CustomDashboardName) 
		FROM CustomDashboard WITH(NOLOCK)
		WHERE CustomDashboardId = @sourceCustomDashboardID
	
	
	--set @@RecordTimestamp= CURRENT_TIMESTAMP
	-- update if permission exists.
	if (@countCustomDashboard != 0 )
		begin

			-- insert existing record in new row of table
			-- insert new record in table
			INSERT INTO [dbo].[CustomDashboard] WITH(TABLOCK)
				   ([CustomDashboardName]
				   ,[IsDefaultOnUI]
				   ,[UserSID]
				   ,[Tags]
				   ,[RecordCreatedTimestamp]
				   ,[RecordUpdateDateTimestamp])
			 (-- get record for dashboard ID
			 SELECT 'Copy of '+[CustomDashboardName],0
			  ,UserSID
			  ,Tags
			  ,CURRENT_TIMESTAMP,CURRENT_TIMESTAMP
			FROM CustomDashboard WITH (NOLOCK)
			WHERE CustomDashboardId = @sourceCustomDashboardID)
	
			
			SET @copyCustomDashboardID = SCOPE_IDENTITY()

			INSERT INTO [dbo].[CustomDashboardWidgets]
					([DashboardID]
				   ,[WidgetName]
				   ,[WidgetTypeID]
				   ,[MetricID]
				   ,[MatchId] 
				   ,[RecordCreatedTimestamp]
				   ,[RecordUpdateDateTimestamp])
			 SELECT @copyCustomDashboardID
				   ,[WidgetName]
				   ,[WidgetTypeID]
				   ,[MetricID]
				   ,[MatchId]
				   ,CURRENT_TIMESTAMP,CURRENT_TIMESTAMP FROM [CustomDashboardWidgets] WITH (NOLOCK) WHERE [DashboardID] = @sourceCustomDashboardID
					--TODO: pass the timestamps from the code
				   INSERT INTO [dbo].[WidgetTagMapping](WidgetID, TagId)			
					(SELECT CDW2.[WidgetID],WTM.TagId 
					FROM [WidgetTagMapping] WTM WITH (NOLOCK)
					JOIN [CustomDashboardWidgets] CDW WITH (NOLOCK) ON CDW.[WidgetID] = WTM.[WidgetID]
					JOIN [CustomDashboardWidgets] CDW2 WITH (NOLOCK) ON CDW.[WidgetName] = CDW2.[WidgetName]	
					WHERE CDW.DashboardID = @sourceCustomDashboardID AND CDW2.DashboardID = @copyCustomDashboardID)

					INSERT INTO [dbo].[WidgetSourceMapping](WidgetID, SourceServerID)			
					(SELECT CDW2.[WidgetID],WSM.SourceServerID 
					FROM [WidgetSourceMapping] WSM WITH (NOLOCK)
					JOIN [CustomDashboardWidgets] CDW WITH (NOLOCK) ON CDW.[WidgetID] = WSM.[WidgetID]
					JOIN [CustomDashboardWidgets] CDW2 WITH (NOLOCK) ON CDW.[WidgetName] = CDW2.[WidgetName]	
					WHERE CDW.DashboardID = @sourceCustomDashboardID AND CDW2.DashboardID = @copyCustomDashboardID)


		end
	else
		begin
			SET @copyCustomDashboardID = 0
		   end
	

	COMMIT

END TRY
BEGIN CATCH
 Print 'Transaction Failed - Will Rollback'
  -- Any Error Occurred during Transaction. Rollback
  ROLLBACK  -- Roll back
END CATCH

RETURN @copyCustomDashboardID;
end
 
GO 
 
GO 

---------- P_CREATEGROOMJOB.SQL
if (object_id('p_CreateGroomJob') is not null)
begin
drop procedure p_CreateGroomJob
end
go

create procedure [dbo].[p_CreateGroomJob] (
	@ForceRecreate bit = 0 -- Should the job be deleted and recreated even if it already exists?
)
as
begin
	DECLARE @JobName nvarchar(256)
	DECLARE @DBName nvarchar(256)
	DECLARE @SA nvarchar(256)
	DECLARE @JobExists bit
	DECLARE @jobId BINARY(16)

	SELECT @JobName = 'Groom ' + DB_NAME() -- Name used for job and schedule.
	SELECT @DBName = DB_NAME()
	SELECT @SA = suser_sname(0x1)	

	SELECT @jobId=job_id FROM msdb.dbo.sysjobs WHERE name = @JobName
	IF (@jobId is not null)
	begin
		SELECT @JobExists = 1
		-- if the job definition needs updating then add logic here
	end
	else
	begin
		-- make sure the uncategorized local category exists
		IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'[Uncategorized (Local)]' AND category_class=1)
			EXEC msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'[Uncategorized (Local)]'

		EXEC msdb.dbo.sp_add_job 
				@job_name=@JobName, 
				@enabled=1, 
				@notify_level_eventlog=0, 
				@notify_level_email=0, 
				@notify_level_netsend=0, 
				@notify_level_page=0, 
				@delete_level=0, 
				@description=N'Groom the SQLdm repository by deleting monitored servers that have been flagged for deletion and removing old alerts, tasks, and metrics.', 
				@category_name=N'[Uncategorized (Local)]', 
				@owner_login_name=@SA, 
				@job_id = @jobId OUTPUT
	end

	-- create or update the jobstep
	IF (@JobExists=1 AND EXISTS(SELECT step_name FROM msdb.dbo.sysjobsteps WHERE job_id=@jobId AND step_id = 1))
	begin -- update the jobstep
				
		EXEC msdb.dbo.sp_update_jobstep 
			@job_id=@jobId, 
			@step_name=N'Groom Data', 
			@step_id=1, 
			@cmdexec_success_code=0, 
			@on_success_action=3, 
			@on_fail_action=3, 
			@retry_attempts=0, 
			@retry_interval=0, 
			@os_run_priority=0, 
			@subsystem=N'TSQL', 
			@command=N'exec Grooming.p_GroomRepositoryData', 
			@database_name=@DBName, 
			@flags=0
									
	end
	else
	begin  -- add the jobstep
		EXEC msdb.dbo.sp_add_jobstep 
			@job_id=@jobId, 
			@step_name=N'Groom Data', 
			@step_id=1, 
			@cmdexec_success_code=0, 
			@on_success_action=3, 
			@on_fail_action=3, 
			@retry_attempts=0, 
			@retry_interval=0, 
			@os_run_priority=0, 
			@subsystem=N'TSQL', 
			@command=N'exec Grooming.p_GroomRepositoryData', 
			@database_name=@DBName, 
			@flags=0
	end
	-- make step 1 the first jobstep
	EXEC msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
	
	
	-- create or update the jobstep
	IF (@JobExists=1 AND EXISTS(SELECT step_name FROM msdb.dbo.sysjobsteps WHERE job_id=@jobId AND step_id = 2))
	begin -- update the jobstep
				
		EXEC msdb.dbo.sp_update_jobstep 
			@job_id=@jobId, 
			@step_name=N'Groom Data', 
			@step_id=1, 
			@cmdexec_success_code=0, 
			@on_success_action=3, 
			@on_fail_action=3, 
			@retry_attempts=0, 
			@retry_interval=0, 
			@os_run_priority=0, 
			@subsystem=N'TSQL', 
			@command=N'exec Grooming.p_GroomRepositoryData', 
			@database_name=@DBName, 
			@flags=0
									
	end
	else
	begin  -- add the jobstep
		EXEC msdb.dbo.sp_add_jobstep 
			@job_id=@jobId,  
			@step_name=N'Groom orphan data', 
			@step_id=2, 
			@cmdexec_success_code=0, 
			@on_success_action=3, 
			@on_fail_action=3, 
			@retry_attempts=0, 
			@retry_interval=0, 
			@os_run_priority=0, 
			@subsystem=N'TSQL', 
			@command=N'exec Grooming.p_GroomRepositoryOrphanData', 
			@database_name=@DBName, 
			@flags=0
	end
	
		
	-- create or update the jobstep
	IF (@JobExists=1 AND EXISTS(SELECT step_name FROM msdb.dbo.sysjobsteps WHERE job_id=@jobId AND step_id = 3))
	begin -- update the jobstep
				
		EXEC msdb.dbo.sp_update_jobstep 
			@job_id=@jobId, 
			@step_name=N'Index Maintenance', 
			@step_id=3, 
			@cmdexec_success_code=0, 
			@on_success_action=1, 
			@on_fail_action=2, 
			@retry_attempts=0, 
			@retry_interval=0, 
			@os_run_priority=0, @subsystem=N'TSQL', 
			@command=N'exec Grooming.p_GroomJobMaintenance', 
			@database_name=@DBName, 
			@flags=0
									
	end
	else
	begin  -- add the jobstep
		EXEC msdb.dbo.sp_add_jobstep 
			@job_id=@jobId,  
			@step_name=N'Index Maintenance', 
			@step_id=3, 
			@cmdexec_success_code=0, 
			@on_success_action=1, 
			@on_fail_action=2, 
			@retry_attempts=0, 
			@retry_interval=0, 
			@os_run_priority=0, @subsystem=N'TSQL', 
			@command=N'exec Grooming.p_GroomJobMaintenance', 
			@database_name=@DBName, 
			@flags=0
	end



	-- sp_add_jobschedule is deprecated in SQL Server 2005,
	-- but used for compatibility with SQL Server 2000.
	IF (@JobExists=0 OR NOT EXISTS(SELECT [job_id] FROM msdb.dbo.sysjobschedules WHERE job_id=@jobId AND schedule_id is not null))
	begin -- create the jobstep
		EXEC msdb.dbo.sp_add_jobschedule 
			@job_id=@jobId, 
			@name=@JobName, 
			@enabled=1, 
			@freq_type=4, 
			@freq_interval=1, 
			@freq_subday_type=1, 
			@freq_subday_interval=0, 
			@freq_relative_interval=0, 
			@freq_recurrence_factor=0, 
			@active_start_date=20070511, 
			@active_end_date=99991231, 
			@active_start_time=30000, 
			@active_end_time=235959
	end
	
	if (NOT EXISTS(select server_id from msdb.dbo.sysjobservers where job_id = @jobId))
		EXEC msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
end

-- These two lines create the job when the repository is installed.
go
EXEC [p_CreateGroomJob] @ForceRecreate = 1
 
GO 

---------- P_DATABASEGROWTHFORECAST.SQL
if (object_id('p_DatabaseGrowthForecast') is not null)
begin
drop procedure p_DatabaseGrowthForecast
end
go
CREATE PROCEDURE [dbo].[p_DatabaseGrowthForecast]
			@DatabaseXML nvarchar(4000),
			@ServerId int,
			@UTCStart DateTime,
			@UTCEnd DateTime,
			@UTCOffset int,
			@Interval tinyint
AS
BEGIN
declare @xmlDoc int
set ansi_warnings off

declare @Databases table(
		DatabaseName nvarchar(255)
) 

-- Prepare XML document
exec sp_xml_preparedocument @xmlDoc output, @DatabaseXML

-- Extract the server IDs from the SML doc.
insert into @Databases	
select
	DatabaseName 
from openxml(@xmlDoc, '//Database', 1)
	with (DatabaseName nvarchar(255))

exec sp_xml_removedocument @xmlDoc

select 
	[DatabaseName],
	dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime]))) as [LastCollectioninInterval],
	(sum(DataFileSizeInKilobytes * TimeDeltaInSeconds) / nullif(sum(TimeDeltaInSeconds),0)) / 1024 as DataFileSizeMb,
	(sum((DataSizeInKilobytes + IndexSizeInKilobytes + TextSizeInKilobytes)* TimeDeltaInSeconds) / nullif(sum(TimeDeltaInSeconds),0)) / 1024 as TotalSizeMb,
	(sum((DataFileSizeInKilobytes + DataExpansionInKilobytes) * TimeDeltaInSeconds) / nullif(sum(TimeDeltaInSeconds),0)) / 1024 as AvailableDataSizeMb,
	0 as ForecastFileSize,
	0 as ForecastDBSize
from
	[SQLServerDatabaseNames] names (nolock)
	join [DatabaseSize] ds (nolock)
	on names.[DatabaseID] = ds.[DatabaseID]
where 
	-- Filter for SQL Server		
	names.[SQLServerID] = @ServerId
	and
	-- Filter databases		
	names.[DatabaseName] collate database_default in (select DatabaseName collate database_default from @Databases)
	and 
	dbo.fn_RoundDateTime(@Interval, ds.[UTCCollectionDateTime]) BETWEEN @UTCStart and @UTCEnd
group by
	[DatabaseName]
	-- Always group by year at the least
	,datepart(yy, dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime]))
	-- Group by all intervals greater than or equal to the selected interval
	,case when @Interval <= 3 then datepart(mm,dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])) end
	,case when @Interval <= 2 then datepart(dd,dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])) end
	,case when @Interval <= 1 then datepart(hh,dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])) end
	,case when @Interval =  0 then datepart(mi,dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])) end
order by
	DatabaseName
	,[LastCollectioninInterval]
END
 
 
GO 

---------- P_DATABASESTATISTICSFROMSTAGING.SQL
if (object_id('p_DatabaseStatisticsFromStaging') is not null)
begin
drop procedure [p_DatabaseStatisticsFromStaging]
end
go

create proc p_DatabaseStatisticsFromStaging(@sourceID uniqueidentifier) 
as
begin
	declare @dbSizeTime table (DatabaseID int, maxTime datetime)
	declare @dbNames table (ServerID int, DatabaseName nvarchar(255), SystemDatabase bit, CreationDateTime datetime)

	--get all new database names for this server
	insert @dbNames
	select dbs.ServerID, dbs.DatabaseName, dbs.SystemDatabase, dbs.DatabaseCreateDate
	from [dbo].[stageDatabaseStatistics] dbs with (nolock)
	where dbs.SourceID = @sourceID 
	and not exists (select 1 from SQLServerDatabaseNames names 
						where names.SQLServerID = dbs.ServerID 
						and names.DatabaseName = dbs.DatabaseName collate database_default)

	--get all databases that are staged but not in SQLServerDatabaseNames
	--insert the new ones into SQLServerDatabaseNames
	insert SQLServerDatabaseNames
			([SQLServerID]
		   ,[DatabaseName]
		   ,[SystemDatabase]
		   ,[CreationDateTime])
	select dbs.ServerID, dbs.DatabaseName, dbs.SystemDatabase, dbs.CreationDateTime
	from @dbNames dbs

	--get the most recent collection per database
	--insert @dbSizeTime
	--select DatabaseID, max(UTCCollectionDateTime)
	--from DatabaseSize with (nolock)
	--group by DatabaseID

	--insert set into database statistics
	INSERT INTO [dbo].[DatabaseStatistics]
			   ([DatabaseID]
			   ,[UTCCollectionDateTime]
			   ,[DatabaseStatus]
			   ,[Transactions]
			   ,[LogFlushWaits]
			   ,[LogFlushes]
			   ,[LogKilobytesFlushed]
			   ,[LogCacheReads]
			   ,[LogCacheHitRatio]
			   ,[TimeDeltaInSeconds]
			   ,[NumberReads]
			   ,[NumberWrites]
			   ,[BytesRead]
			   ,[BytesWritten]
			   ,[IoStallMS]
			   ,[DatabaseSizeTime]
			   ,[LastBackupDateTime]) -- SQLdm 10.0 (Vandana Gogna) - Database backup alerts
	select names.DatabaseID, s.UTCCollectionDateTime, s.DatabaseStatus, s.[Transactions] ,s.[LogFlushWaits],s.[LogFlushes],s.[LogKilobytesFlushed]
			   ,s.[LogCacheReads]
			   ,s.[LogCacheHitRatio]
			   ,s.[TimeDeltaInSeconds]
			   ,s.[NumberReads]
			   ,s.[NumberWrites]
			   ,s.[BytesRead]
			   ,s.[BytesWritten]
			   ,s.[IoStallMS]
			   ,size.UTCCollectionDateTime
			   ,s.LastBackupDateTime -- SQLdm 10.0 (Vandana Gogna) - Database backup alerts
	from [dbo].[stageDatabaseStatistics] s with (nolock)
	inner join SQLServerDatabaseNames names on s.ServerID = names.SQLServerID and s.DatabaseName = names.DatabaseName
	inner join DatabaseSizeDateTime size on size.DatabaseID = names.DatabaseID
	where s.SourceID = @sourceID
	and not exists(select 1 from [DatabaseStatistics] stat where stat.UTCCollectionDateTime = s.UTCCollectionDateTime and stat.DatabaseID = names.DatabaseID);
	--return the new databases with their new id's
	select db.DatabaseName, db.DatabaseID
	from stageDatabaseStatistics sdb with (nolock)
	inner join SQLServerDatabaseNames db on sdb.ServerID = db.SQLServerID and sdb.DatabaseName = db.DatabaseName collate database_default
	where sdb.SourceID = @sourceID

	--delete from staging for this process
	delete from [dbo].[stageDatabaseStatistics]
	where SourceID = @sourceID;

end
 
GO 

---------- P_DEACTIVATEMONITOREDSQLSERVER.SQL
IF (object_id('p_DeactivateMonitoredSqlServer') IS NOT NULL)
BEGIN
DROP PROCEDURE p_DeactivateMonitoredSqlServer
END
GO

CREATE PROCEDURE [dbo].[p_DeactivateMonitoredSqlServer]
(
	@SqlServerId INT
)
AS
BEGIN
	UPDATE MonitoredSQLServers 
	SET Active = 0, FriendlyServerName=''
	WHERE SQLServerID = @SqlServerId

	IF @@error != 0 GOTO HANDLE_ERROR

	DELETE FROM CustomCounterMap
		WHERE SQLServerID = @SqlServerId

	DELETE FROM ServerTags
		WHERE SQLServerId = @SqlServerId

	-- delete alerts 
--	DELETE FROM Alerts
--		WHERE ServerName in (SELECT InstanceName from MonitoredSQLServers 
--						      WHERE SQLServerID = @SqlServerId
--						     )
	-- delete todos
--	DELETE FROM Tasks
--		WHERE ServerName in (SELECT InstanceName from MonitoredSQLServers 
--						      WHERE SQLServerID = @SqlServerId
--						     )

	RETURN(0)

	HANDLE_ERROR:
		RAISERROR('An error occurred while deactivating instance %d.', 10, 1, @SqlServerId)
        RETURN(@@error)
END
 
GO 

---------- P_DELETEALERTTEMPLATE.SQL
if (object_id('p_DeleteAlertTemplate') is not null)
begin
drop procedure p_DeleteAlertTemplate
end
go

CREATE PROCEDURE [dbo].p_DeleteAlertTemplate(
	@templateID int
)
AS
begin
	IF (@templateID IS NULL)
	BEGIN
		DELETE FROM [AlertTemplateLookup] where [Default] <> 1
	END
	ELSE
	BEGIN
		DECLARE @DefaultTemplate int
		select @DefaultTemplate = TemplateID from [AlertTemplateLookup] where [Default] = 1

		if (@DefaultTemplate <> @templateID)
		BEGIN
			DELETE FROM [AlertTemplateLookup] where @templateID = [TemplateID]
		END
		ELSE
		BEGIN
			RAISERROR('Cannot delete the default template', 15, 0)
		END
	END
END	
 
GO 

---------- P_DELETECOUNTER.SQL
if (object_id('p_DeleteCounter') is not null)
begin
drop procedure p_DeleteCounter
end
go

CREATE PROCEDURE [dbo].p_DeleteCounter(
	@Metric int
)
AS
begin
	declare @e int

	BEGIN TRANSACTION

	-- mark the custom counter deleted
	UPDATE [MetricMetaData] 
		SET [Deleted] = 1
		WHERE Metric = @Metric

	SET @e = @@error
	IF (@e = 0)
	BEGIN
		-- mark the custom counter disabled
		UPDATE [CustomCounterDefinition] 
			SET [Enabled] = 0
			WHERE Metric = @Metric

		SET @e = @@error
		IF (@e = 0)
		BEGIN
			-- unmap the counter from instance
			DELETE FROM [CustomCounterMap]
				WHERE Metric = @Metric
		
			SET @e = @@error
		
			if (@e = 0)
			BEGIN
				DELETE FROM DefaultMetricThresholds 
					WHERE Metric = @Metric

				SET @e = @@error	
			END			
			if (@e = 0)
			BEGIN
				DELETE FROM MetricThresholds 
					WHERE Metric = @Metric
	
				SET @e = @@error	
			END
			
			if (@e = 0)			
			BEGIN
				UPDATE Alerts SET Active = 0
					WHERE AlertID in (
						SELECT AlertID FROM MonitoredSQLServers M (NOLOCK)
							join Alerts A (NOLOCK) on A.ServerName = M.InstanceName and
								A.UTCOccurrenceDateTime = M.LastScheduledCollectionTime and
								A.Active = 1 
						WHERE M.Active = 1 and
							  A.Metric = @Metric)
				
				SET @e = @@error		
			END
		END
	END

	IF (@e = 0)
		COMMIT
	ELSE
		ROLLBACK		

	return @e
END	
 
GO 

---------- P_DELETECOUNTERSFROMCUSTOMREPORT.SQL
if (object_id('[p_DeleteCountersFromCustomReport]') is not null)
begin
drop procedure [p_DeleteCountersFromCustomReport]
end
go

create proc p_DeleteCountersFromCustomReport( @reportName nvarchar(255))
as
begin
delete from crc
from CustomReportsCounters crc inner join CustomReports cr on  cr.ID = crc.ID
where lower(cr.reportName) = lower(@reportName)
end
 
GO 

---------- P_DELETECUSTOMDASHBOARDRECORD.SQL
if (object_id('p_DeleteCustomDashboardRecord') is not null)
begin
drop procedure p_DeleteCustomDashboardRecord
end
go

-- To Delete record from CustomDashboard for specific CustomDashboardId
CREATE PROCEDURE p_DeleteCustomDashboardRecord(
	@customDashboardId int,
	@customDashboardName nvarchar(500) out,
	@isDefaultOnUI bit out,
	@userSID nvarchar(200) out,
	@errorCode INT OUT
)
AS
begin

BEGIN TRY
   -- Start A Transaction

	BEGIN TRANSACTION

	
		
			SELECT @customDashboardName=[CustomDashboardName],
			@isDefaultOnUI =[IsDefaultOnUI],
			@userSID =[UserSID]
			FROM [CustomDashboard]
			WHERE CustomDashboardId = @customDashboardId
			
			-- TO DO REMOVE WIDGET MAPS FOR THE SAME CUSTOMDASHBOARDID
			--Removing Records
			--From Widget for respective Dashboard
			DELETE FROM [WidgetSourceMapping] WHERE WidgetID IN (SELECT WidgetID FROM [CustomDashboardWidgets] WHERE DashboardID = @customDashboardId)
			DELETE FROM [WidgetTagMapping] WHERE WidgetID IN (SELECT WidgetID FROM [CustomDashboardWidgets] WHERE DashboardID = @customDashboardId)
			
			DELETE FROM [CustomDashboardWidgets] WHERE DashboardID = @customDashboardId
			DELETE FROM [CustomDashboard]
			WHERE CustomDashboardId = @customDashboardId
	 
	COMMIT TRANSACTION
	

END TRY
BEGIN CATCH
 Print 'Transaction Failed - Will Rollback'
 SET @errorCode = @@error
  -- Any Error Occurred during Transaction. Rollback
  ROLLBACK  -- Roll back
END CATCH

END	
 
GO 
 
GO 

---------- P_DELETECUSTOMDASHBOARDWIDGETRECORD.SQL
if (object_id('p_DeleteCustomDashboardWidgetRecord') is not null)
begin
drop procedure p_DeleteCustomDashboardWidgetRecord
end
go

-- To Delete record from CustomDashboard for specific CustomDashboardId
CREATE PROCEDURE p_DeleteCustomDashboardWidgetRecord(
	@widgetID int,
	@isRecordDeleted bit OUT
)
AS
begin
BEGIN TRY
   -- Start A Transaction
BEGIN TRANSACTION

DECLARE @countRecord int 

SELECT @countRecord = 0;

	SELECT @isRecordDeleted = 0;
	BEGIN
		
			SELECT @countRecord = COUNT(WidgetID) from [CustomDashboardWidgets] WHERE WidgetID = @widgetID
			-- TO DO REMOVE WIDGET MAPS FOR THE SAME WIDGET
			--Removing Records
			--From Widget for respective WidgetID
			if(@countRecord > 0)
			BEGIN
				DELETE from [WidgetSourceMapping] WHERE WidgetID = @widgetID
				DELETE from [WidgetTagMapping] WHERE WidgetID = @widgetID
			
				DELETE from [CustomDashboardWidgets] WHERE WidgetID = @widgetID
				SELECT @isRecordDeleted = 1;
			END
			ELSE
			BEGIN
				SELECT @isRecordDeleted = 0
			END
			
	END

	COMMIT
END TRY
BEGIN CATCH
 Print 'Transaction Failed - Will Rollback'
  -- Any Error Occurred during Transaction. Rollback
  ROLLBACK  -- Roll back
END CATCH

RETURN @isRecordDeleted
END	
 
GO 
 
GO 

---------- P_DELETECUSTOMREPORT.SQL
if (object_id('p_DeleteCustomReport') is not null)
begin
drop procedure p_DeleteCustomReport
end
go

create proc p_DeleteCustomReport(@id int)
as
begin
	delete from CustomReports where ID = @id
end
 
GO 

---------- P_DELETEDASHBOARDLAYOUT.SQL
if (object_id('p_DeleteDashboardLayout') is not null)
begin
drop procedure [p_DeleteDashboardLayout]
end
go

create procedure [p_DeleteDashboardLayout] 
	@DashboardLayoutID int
as
begin

	if exists (select 1 from [DashboardLayouts] where DashboardLayoutID = @DashboardLayoutID)
	begin
		delete [DashboardDefaults]
			where DashboardLayoutID = @DashboardLayoutID

		delete [DashboardLayouts]
			where DashboardLayoutID = @DashboardLayoutID
	end
	else
		raiserror ('The dashboard layout id was not found for deletion.', 1, 0)

end
 
GO 

---------- P_DELETELICENSEKEY.SQL
if (object_id('p_DeleteLicenseKey') is not null)
begin
drop procedure p_DeleteLicenseKey
end
go
CREATE PROCEDURE [dbo].[p_DeleteLicenseKey](
	@LicenseKey nvarchar(255)
)
AS
BEGIN
	DECLARE @e INT

	if (@LicenseKey IS NULL)
	BEGIN
		-- delete em all
		DELETE FROM [LicenseKeys]
	END
	ELSE
	BEGIN
		-- delete a specific key
		DELETE FROM [LicenseKeys] WHERE ([LicenseKey] = @LicenseKey)
	END


	SELECT @e = @@error
	RETURN @e
END
 
GO 

---------- P_DELETEMETRICTHRESHOLDINSTANCE.SQL
if (object_id('p_DeleteMetricThresholdInstance') is not null)
begin
drop procedure [p_DeleteMetricThresholdInstance]
end
go

create procedure [p_DeleteMetricThresholdInstance]
	@UserViewID int,
	@SQLServerID int,
	@Metric int,
	@ThresholdInstanceName nvarchar(256),
	@ThresholdInstanceType int
as
BEGIN
	declare @InstanceID int 
	declare @err int

	-- check to see if trying to delete the default instance
	if (@ThresholdInstanceName is null or @ThresholdInstanceName = '')
	BEGIN
		RAISERROR('Cannot delete the Default Threshold Instance', 10,1,-1)
		return (-1)
	END
	
	if (exists 
			(select 
				InstanceID 
			 from 
				MetricThresholdInstances 
			 where 
				InstanceType = @ThresholdInstanceType and 
				ThresholdInstanceName = @ThresholdInstanceName
			)
		)
		begin
			select 
				@InstanceID = InstanceID 
			from 
				MetricThresholdInstances 
			where 
				InstanceType = @ThresholdInstanceType and 
				ThresholdInstanceName = @ThresholdInstanceName
				
			select @err = @@ERROR
		END
	else
	begin
		select @err = 666
		RAISERROR('An instanceID for the specified Threshold Instance does not exist', 10, 1, @err)
		return (@err)
	end

	-- determine if we are deleting an Template Threshold or a Server Threshold
	if (@SQLServerID IS NULL) 
	BEGIN
		IF (@UserViewID IS NULL)
		BEGIN
			RAISERROR('@SQLServerID or @UserViewID is required.', 10, 1, -1)
			RETURN -1
		END    
		ELSE
		BEGIN
			set @err = 0
			
			delete from DefaultMetricThresholds 
				where 
					UserViewID = @UserViewID and 
					Metric = @Metric and 
					ThresholdInstanceID = @InstanceID

			select @err = @@ERROR
			
			IF @err <> 0 BEGIN
				RAISERROR('An error occurred while deleting a threshold instance from an Alert Template', 10, 1, @err)
				RETURN(@err)
			END
			
			RETURN (0)
		end
	end
	else
	begin
		IF (@UserViewID IS NOT NULL)
		BEGIN
			RAISERROR('@SQLServerID and @UserViewID are mutually exclusive.', 10, 1, -1)
			RETURN -1
		END
		ELSE
		BEGIN
			DELETE FROM MetricThresholds 
				where
					[SQLServerID] = @SQLServerID AND 
					[Metric] = @Metric AND 
					[ThresholdInstanceID] = @InstanceID

			select @err = @@ERROR
			
			IF @err <> 0 BEGIN
				RAISERROR('An error occurred while deleting a threshold instance from an Alert Template', 10, 1, @err)
				RETURN(@err)
			END
			
			RETURN (0)
		end
	end
END					
 
GO 

---------- P_DELETEMIRRORINGPREFERREDCONFIG.SQL
if (object_id('p_DeleteMirroringPreferredConfig') is not null)
begin
drop procedure [p_DeleteMirroringPreferredConfig]
end
go

CREATE PROCEDURE p_DeleteMirroringPreferredConfig 
	-- Add the parameters for the stored procedure here
	@MirroringGuid uniqueidentifier
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	delete from MirroringPreferredConfig 
	where MirroringGuid = @MirroringGuid
END
GO
 
GO 

---------- P_DELETEMIRRORINGSESSIONFROMSERVER.SQL
if (object_id('p_DeleteMirroringSessionFromServer') is not null)
begin
drop procedure [p_DeleteMirroringSessionFromServer]
end
go

Create procedure p_DeleteMirroringSessionFromServer
@serverID int,
@guid uniqueidentifier
as

begin
delete from MirroringParticipants
where @serverID = case role when 1 then principal_instanceID else mirror_instanceID end
and mirroring_guid = @guid
end
 
GO 

---------- P_DELETEMONITOREDSQLSERVER.SQL
IF (object_id('p_DeleteMonitoredSqlServer') IS NOT NULL)
BEGIN
DROP PROCEDURE p_DeleteMonitoredSqlServer
END
GO

CREATE PROCEDURE [dbo].[p_DeleteMonitoredSqlServer]
(
	@SqlServerId INT
)
AS
BEGIN
	-- This just flags a server for deletion.  
	-- p_GroomRepository does the actual deletion on a scheduled basis.

	UPDATE MonitoredSQLServers 
	SET Active = 0, Deleted = 1, FriendlyServerName=''
	WHERE SQLServerID = @SqlServerId

	IF @@error != 0 GOTO HANDLE_ERROR
	
	UPDATE AlwaysOnReplicas
	SET SQLServerID = -1
	WHERE SQLServerID = @SqlServerId
    
	DELETE FROM CustomCounterMap
		WHERE SQLServerID = @SqlServerId

	DELETE FROM ServerTags
		WHERE SQLServerId = @SqlServerId

	-- delete alerts 
--	DELETE FROM Alerts
--		WHERE ServerName in (SELECT InstanceName from MonitoredSQLServers 
--						      WHERE SQLServerID = @SqlServerId
--						     )
	-- delete todos
--	DELETE FROM Tasks
--		WHERE ServerName in (SELECT InstanceName from MonitoredSQLServers 
--						      WHERE SQLServerID = @SqlServerId
--						     )

	RETURN(0)

	HANDLE_ERROR:
		RAISERROR('An error occurred while deleting instance %d.', 10, 1, @SqlServerId)
        RETURN(@@error)
END
 
GO 

---------- P_DELETENOTIFICATIONPROVIDER.SQL
if (object_id('p_DeleteNotificationProvider') is not null)
begin
drop procedure [p_DeleteNotificationProvider]
end
go

create procedure [p_DeleteNotificationProvider] 
	@ProviderID uniqueidentifier
as
begin
	DECLARE @err int
	DECLARE @id uniqueidentifier
	
	DELETE FROM [NotificationProviders] 
		WHERE [ProviderId] = @ProviderID 

	SELECT @err = @@error

	RETURN @err
end
 
GO 

---------- P_DELETENOTIFICATIONRULE.SQL
if (object_id('p_DeleteNotificationRule') is not null)
begin
drop procedure [p_DeleteNotificationRule]
end
go

create procedure [p_DeleteNotificationRule] 
	@RuleID uniqueidentifier
as
begin
	DECLARE @err int
	DECLARE @id uniqueidentifier
	
	DELETE FROM [NotificationRules] 
		WHERE [RuleID] = @RuleID 

	SELECT @err = @@error

	RETURN @err
end
 
GO 

---------- P_DELETEPERMISSION.SQL
if (object_id('p_DeletePermission') is not null)
begin
drop procedure [p_DeletePermission]
end
go

create procedure [p_DeletePermission]
	@PermissionID int
as
begin
	DECLARE @err int
	
	-- delete from Permission table
	delete from [dbo].[Permission]
	where PermissionID = @PermissionID
	
	SELECT @err = @@error
	RETURN @err
end
 
GO 

---------- P_DELETEREPLICATIONSESSIONFROMSERVER.SQL
if (object_id('p_DeleteReplicationSessionFromServer') is not null)
begin
drop procedure [p_DeleteReplicationSessionFromServer]
end
go

Create procedure p_DeleteReplicationSessionFromServer
@publisher nvarchar(255),
@publisherdb nvarchar(255),
@publication nvarchar(255),
@subscriberInstance nvarchar(255) = null,
@subscriberDB nvarchar(255) = null
as

begin
delete from ReplicationTopology with (tablockx)
where lower([dbo].[fn_GetServerName](PublisherInstance)) = lower([dbo].[fn_GetServerName](@publisher))
and PublisherDB = @publisherdb 
and Publication = @publication
and (lower([dbo].[fn_GetServerName](SubscriberInstance)) = isnull(lower([dbo].[fn_GetServerName](@subscriberInstance)), lower([dbo].[fn_GetServerName](SubscriberInstance))) or SubscriberDBID is null)
and (SubscriberDB = isnull(@subscriberDB,SubscriberDB))
end
 
GO 

---------- P_DELETERUNQUERYSCRIPT.SQL
if (object_id('p_DeleteRunQueryScript') is not null)
begin
drop procedure [p_DeleteRunQueryScript]
end
go

create procedure [p_DeleteRunQueryScript]
	@ScriptID INT
as
begin
	DELETE FROM RunQueryScripts
	WHERE ScriptID = @ScriptID
end
 
GO 

---------- P_DELETESQLSAFEREPOSITORY.SQL

IF (object_id('p_DeleteSQLsafeRepository') IS NOT NULL)
BEGIN
DROP PROCEDURE p_DeleteSQLsafeRepository
END
GO

CREATE PROCEDURE [dbo].[p_DeleteSQLsafeRepository]
(
	@Id INT
)
AS
BEGIN
	IF EXISTS(SELECT RepositoryId from SQLsafeConnections where RepositoryId = @Id)
	BEGIN
		UPDATE SQLsafeConnections set Active = 0, Deleted = 1 where RepositoryId = @Id
	END
END
 
GO 

---------- P_DELETETAGSBYID.SQL
IF (object_id('p_DeleteTagsById') IS NOT NULL)
BEGIN
DROP PROCEDURE p_DeleteTagsById
END
GO

CREATE PROCEDURE [dbo].[p_DeleteTagsById]
(
	@XmlDocument nvarchar(max)
)
AS
BEGIN
DECLARE @TagsToDelete TABLE(TagId INT) 
DECLARE @xmlDoc INT

IF @XmlDocument IS NOT NULL
BEGIN
	EXEC sp_xml_preparedocument @xmlDoc OUTPUT, @XmlDocument

	INSERT INTO @TagsToDelete
	SELECT
		TagId
	FROM OPENXML(@xmlDoc, '//Tag', 1)
		WITH (TagId INT)

	EXEC sp_xml_removedocument @xmlDoc
END

DELETE FROM [Tags] WHERE [Id] IN (SELECT [TagId] FROM @TagsToDelete)

exec p_SyncCustomCounterThresholds

RETURN @@error
END
 
GO 

---------- P_DELETETASKS.SQL
if (object_id('p_DeleteTasks') is not null)
begin
drop procedure p_DeleteTasks
end
go

create procedure [dbo].[p_DeleteTasks]
	@XmlDocument nvarchar(max) = null,
	@TaskID int = null
as
begin

declare @TasksToDelete table(TaskID int) 
declare @xmlDoc int
declare @e int

if @XmlDocument is not null 
begin
	-- Prepare XML document if there is one
	exec sp_xml_preparedocument @xmlDoc output, @XmlDocument

	insert into @TasksToDelete
	select
		TaskID 
	from openxml(@xmlDoc, '//Task', 1)
		with (TaskID int)

	exec sp_xml_removedocument @xmlDoc
end

if @TaskID is not null
	insert into @TasksToDelete values(@TaskID)

if (@TaskID is null and @XmlDocument is null)
	delete from [Tasks]
else
	delete from [Tasks] where [TaskID] in (select [TaskID] from @TasksToDelete)

select @e = @@error

return @e

end
 
 
GO 

---------- P_DELETEVIRTUALHOST.SQL
if (object_id('p_DeleteVirtualHost') is not null)
begin
drop procedure [p_DeleteVirtualHost]
end
go

create procedure [dbo].[p_DeleteVirtualHost]
	@VhAddress nvarchar(256)
as
begin
	DECLARE @err int
	declare @vhid int 

	-- Check if host exists and if so, get the Host ID
    select @vhid = VHostID from [dbo].[VirtualHostServers] where [VHostAddress] = @VhAddress

	if @vhid is not null
	begin
		update [dbo].[MonitoredSQLServers] set [VHostID] = null, [VmUID] = null, [VmName] = null, [VmDomainName] = null where [VHostID] = @vhid
		
		select @err = @@ERROR
		if @err != 0 GOTO HANDLE_UPDATE_ERROR
		
		delete from [dbo].[VirtualHostServers] where [VHostID] = @vhid
				select @err = @@ERROR
		if @err != 0 GOTO HANDLE_DELETE_ERROR
	end

	return (0)

	HANDLE_UPDATE_ERROR:
		RAISERROR('An error occurred while removing the host associations from the monitored SQL Servers', 10, 1)
		RETURN (@err)
		
	HANDLE_DELETE_ERROR:
		RAISERROR('An error occurred while deleting the virtual host server', 10, 1)
		RETURN (@err)
		
END	
 
GO 

---------- P_DISKDETAILSREPORT.SQL
if (object_id('p_DiskDetailsReport') is not null)
begin
drop procedure p_DiskDetailsReport
end
go
CREATE PROCEDURE [dbo].[p_DiskDetailsReport]
		@ServerID int,
		@UTCStart DateTime,
		@UTCEnd DateTime,
		@UTCOffset int,
		@Interval tinyint,
		@DriveName nvarchar(256) = null,
		@Average bit
AS
BEGIN			

declare @ReplaceString NVARCHAR(MAX)
declare @ParmDefinition NVARCHAR(MAX)
declare @QueryString NVARCHAR(MAX)
if (@Average=1)
	begin		
		set @ReplaceString='avg'
	end
	else
	begin
		set @ReplaceString='max'
	end

set @QueryString= 'SELECT	
		count(*) as [Records],
		dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, dd.[UTCCollectionDateTime]))) as [LastCollectioninInterval],
		dd.DriveName,
		{chartType}(dd.AverageDiskMillisecondsPerRead) as AverageDiskMillisecondsPerRead,
		{chartType}(dd.AverageDiskMillisecondsPerTransfer) as AverageDiskMillisecondsPerTransfer,
		{chartType}(dd.AverageDiskMillisecondsPerWrite) as AverageDiskMillisecondsPerWrite,
		{chartType}(dd.DiskReadsPerSecond) as DiskReadsPerSecond,
		{chartType}(dd.DiskTransfersPerSecond) as DiskTransfersPerSecond,
		{chartType}(dd.DiskWritesPerSecond) as DiskWritesPerSecond,
		ms.InstanceName
 FROM DiskDrives dd (nolock)
	JOIN MonitoredSQLServers ms (nolock) on dd.SQLServerID = ms.SQLServerID
	WHERE dbo.fn_RoundDateTime(@Interval, dd.[UTCCollectionDateTime]) between @UTCStart and @UTCEnd
		and @ServerID = dd.SQLServerID
		and dd.DriveName = coalesce(@DriveName, dd.DriveName)
		and dd.DriveName <> ''No Drives Configured''
	GROUP BY
			ms.InstanceName,
			dd.DriveName
			-- Always group by year at the least
			,datepart(yy, dateadd(mi, @UTCOffset, dd.[UTCCollectionDateTime]))
			-- Group by all intervals greater than or equal to the selected interval
			,case when @Interval <= 3 then datepart(mm,dateadd(mi, @UTCOffset, dd.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, dd.[UTCCollectionDateTime])) end
			,case when @Interval <= 2 then datepart(dd,dateadd(mi, @UTCOffset, dd.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, dd.[UTCCollectionDateTime])) end
			,case when @Interval <= 1 then datepart(hh,dateadd(mi, @UTCOffset, dd.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, dd.[UTCCollectionDateTime])) end
			,case when @Interval =  0 then datepart(mi,dateadd(mi, @UTCOffset, dd.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, dd.[UTCCollectionDateTime])) end
		ORDER BY
			dd.DriveName
			,max(dd.[UTCCollectionDateTime])'
		
		SELECT @QueryString = REPLACE(@QueryString, '{chartType}', @ReplaceString)
		
		SET @ParmDefinition = N'
		@ServerID int,
		@UTCStart DateTime,
		@UTCEnd DateTime,
		@UTCOffset int,
		@Interval tinyint,
		@DriveName nvarchar(256)';

EXECUTE sp_executesql @QueryString, 
					  @ParmDefinition, 
					  @ServerID = @ServerID, 
					  @UTCOffset = @UTCOffset, 
					  @UTCStart = @UTCStart,
					  @UTCEnd = @UTCEnd, 
					  @Interval = @Interval,
					  @DriveName = @DriveName
					  
END
 
 
GO 

---------- P_DISKUSAGEFORECAST.SQL
if (object_id('p_DiskUsageForecast') is not null)
begin
drop procedure p_DiskUsageForecast
end
go
CREATE PROCEDURE [dbo].[p_DiskUsageForecast]
		@ServerID int,
		@UTCStart DateTime,
		@UTCEnd DateTime,
		@UTCOffset int,
		@Interval tinyint,
		@DriveName nvarchar(256) = null
AS
BEGIN
	select	
		count(*) as [Records],
		dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, dd.[UTCCollectionDateTime]))) as [LastCollectioninInterval],
		dd.DriveName,
		max((dd.TotalSizeKB - dd.UnusedSizeKB) / 1024) /1024 as TotalUsedGB,
		max((dd.TotalSizeKB / 1024)) / 1024 as TotalSizeGB
	from DiskDrives dd (nolock)
	where dd.[UTCCollectionDateTime] between @UTCStart and @UTCEnd
		and @ServerID = dd.SQLServerID
		and dd.DriveName = coalesce(@DriveName, dd.DriveName)
		and dd.DriveName <> 'No Drives Configured'
	group by
			dd.DriveName
			-- Always group by year at the least
			,datepart(yy, dateadd(mi, @UTCOffset, dd.[UTCCollectionDateTime]))
			-- Group by all intervals greater than or equal to the selected interval
			,case when @Interval <= 3 then datepart(mm,dateadd(mi, @UTCOffset, dd.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, dd.[UTCCollectionDateTime])) end
			,case when @Interval <= 2 then datepart(dd,dateadd(mi, @UTCOffset, dd.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, dd.[UTCCollectionDateTime])) end
			,case when @Interval <= 1 then datepart(hh,dateadd(mi, @UTCOffset, dd.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, dd.[UTCCollectionDateTime])) end
			,case when @Interval =  0 then datepart(mi,dateadd(mi, @UTCOffset, dd.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, dd.[UTCCollectionDateTime])) end
		order by
			dd.DriveName
			,max(dd.[UTCCollectionDateTime])
END
 
 
GO 

---------- P_GETACTIVEALERTS.SQL
if (object_id('p_GetActiveAlerts') is not null)
begin
drop procedure [p_GetActiveAlerts]
end
go
create procedure [dbo].[p_GetActiveAlerts]
				@SQLServerIDs nvarchar(max) = null
as
begin
	declare @xmlDoc int
	declare @now datetime

	select @now = DateAdd(second,10,GetUTCDate())

	create table #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

	insert into #SecureMonitoredSQLServers
	exec [p_GetReportServers]
	

		declare @SQLServers table(
				SQLServerID int,
				InstanceName nvarchar(256),
				LastScheduledCollectionTime datetime,
				LastDatabaseCollectionTime datetime,
				IsMaintenanceMode bit ) 

		if @SQLServerIDs is not null 
		begin
			exec sp_xml_preparedocument @xmlDoc output, @SQLServerIDs

			insert into @SQLServers
				select ID, smss.InstanceName, LastScheduledCollectionTime, LastDatabaseCollectionTime,0
				from openxml(@xmlDoc, '//Srvr', 1) with (ID int)
					join MonitoredSQLServers mss (nolock) on mss.SQLServerID = ID
					inner join #SecureMonitoredSQLServers smss on mss.SQLServerID = smss.SQLServerID

			exec sp_xml_removedocument @xmlDoc
		end
		else
		begin
			insert into @SQLServers
				select smss.SQLServerID, smss.InstanceName, LastScheduledCollectionTime, LastDatabaseCollectionTime,0
				from MonitoredSQLServers mss (nolock)
					inner join #SecureMonitoredSQLServers smss on mss.SQLServerID = smss.SQLServerID
				where Active = 1
		end
		
		
		update @SQLServers
		set IsMaintenanceMode = 1
		from
		@SQLServers S inner join Alerts A (NOLOCK) on A.ServerName collate database_default = S.InstanceName collate database_default 
		where A.Metric = 48 and S.LastScheduledCollectionTime = A.UTCOccurrenceDateTime
			
		
		select	distinct A.ServerName as InstanceName
				,A.Severity as Status
				,A.Heading as Title
				,A.Message as Description
				,S.SQLServerID
		from 
			@SQLServers S
			left join Alerts A (NOLOCK) on A.ServerName collate database_default = S.InstanceName collate database_default 
			And (S.LastScheduledCollectionTime = A.UTCOccurrenceDateTime
			Or S.LastDatabaseCollectionTime = A.UTCOccurrenceDateTime)
			left join MetricThresholds T (nolock) on
				S.[SQLServerID] = T.[SQLServerID] and
				A.[Metric] = T.[Metric] 	
		where 
		(S.IsMaintenanceMode = 0 or A.Metric = 48)
		and (T.[UTCSnoozeEnd] is null or T.[UTCSnoozeEnd] < @now)	
		and (
			((A.Metric not in (select MetricID from DBMetrics) and S.LastScheduledCollectionTime = A.UTCOccurrenceDateTime) -- Add in scheduled refresh
			or (A.Metric  in (select MetricID from DBMetrics) and S.LastDatabaseCollectionTime = A.UTCOccurrenceDateTime)) -- Add in database refresh
			) 

end
 
GO 

---------- P_GETACTIVEWAITS.SQL
if (object_id('p_GetActiveWaits') is not null)
begin
drop procedure p_GetActiveWaits
end
go
create procedure p_GetActiveWaits
	@SQLServerID int,
	@UTCSnapshotCollectionDateTime datetime = null,
	@HistoryInMinutes int = null,
	@CategoryName varchar(120) = null,
	--START SQLdm 10.0 (Sanjali Makkar) : To Add filters of IDs of various parameters
	@WaitTypeID int = null,
	@CategoryID int = null,
	@SQLStatementID int = null,
	@ApplicationNameID int = null,
	@DatabaseID int = null,
	@HostNameID int = null,
	@SessionID  int = null,
	@LoginNameID  int = null,
	--END SQLdm 10.0 (Sanjali Makkar) : To Add filters of IDs of various parameters
	@BeginDateTime datetime = null
as

begin
set transaction isolation level read uncommitted
declare @err int
--declare @BeginDateTime datetime
declare @EndDateTime datetime
declare @secondsPerBucket int
--declare @HistoryInMinutes int

-- Start : SQLdm 8.6(Ankit Srivastava) - Fixing defect for Query Wait Statistics which has DBNULL to string conversion error which occurs when the result contains unnecessary wait_types. 
select @secondsPerBucket = ms.ActiveWaitCollectorCollectionTimeSeconds from MonitoredSQLServers ms (NOLOCK) --where [SQLServerID] = @SQLServerID

if (@UTCSnapshotCollectionDateTime is null)
	select @EndDateTime = (select max(dateadd(ss,CONVERT(DECIMAL(16,4),CONVERT(DECIMAL(16,4),ISNULL([WaitDuration],0))/1000),[StatementUTCStartTime])) from [ActiveWaitStatistics] (NOLOCK) where [SQLServerID] = @SQLServerID)
else
	select @EndDateTime = @UTCSnapshotCollectionDateTime

--print CONVERT(VARCHAR,@EndDateTime,114)
--SQLdm 10.0 (Sanjali Makkar) 
--Commenting out the following code as HistoryInMinutes is not given as input parameter to stored proc now
/*if (@HistoryInMinutes is null)
	select @BeginDateTime = @EndDateTime
else
	select @BeginDateTime = dateadd(n, -@HistoryInMinutes, @EndDateTime)*/

if(@BeginDateTime is null)
	SELECT @BeginDateTime = CAST(CONVERT(NVARCHAR(100),@EndDateTime,102) AS DATETIME)

IF(@HistoryInMinutes IS NULL)
BEGIN
	SELECT @HistoryInMinutes = DATEDIFF(n, @BeginDateTime, @EndDateTime);
END

-- Start : SQL DM 8.6(Vineet Kumar) - Fixing defect DE41829. This code decides the @secondsPerBucket at runtime depending on the amount of data to be fetched. 
		-- @secondsPerBucket is decided on runtime to limit the no of records to fetch so that they can be displayed on graph in readable form.
if(@HistoryInMinutes=24*60)
	select @secondsPerBucket = 600 --If data is required for one day (i.e. 24*60 minutes), It will override the default value of @secondsPerBucket to 600 (i.e. 10 minutes)
else if(@HistoryInMinutes=12*60)
	select @secondsPerBucket = 300 -- For 12 hours, @secondsPerBucket=300 (i.e. 5 minutes)
else if(@HistoryInMinutes=8*60)
	select @secondsPerBucket = 180 -- For 8 hours, @secondsPerBucket=180 (i.e. 3 minutes)
else if(@HistoryInMinutes=4*60)
	select @secondsPerBucket = 120 -- For 4 hours, @secondsPerBucket=120 (i.e. 2 minutes)
else if(@HistoryInMinutes=2*60)
	select @secondsPerBucket = 60 -- For 2 hours, @secondsPerBucket=60 (i.e. 1 minutes)
if(@HistoryInMinutes*60/@secondsPerBucket > 200)
	select @secondsPerBucket = @HistoryInMinutes * 60/600; -- If data is being retrieved for different time period than the above mentioned. If no of distinct time durations is greater than 2000,  @secondsPerBucket will be set to 10 minutes. Otherwise will use the default  @secondsPerBucket
-- End : SQL DM 8.6(Vineet Kumar) - Fixing defect DE41829.
;with 
idr2 as (
select d2.labelStartTime as start, d2.labelEndTime as endtime
 from dbo.fn_GetChartStartAndEndTimeLabels --SQL DM 8.6(Vineet Kumar) - Fixing defect DE41829 - Using this function to get start and end time labels in one function. It reduces the no of CTEs used from two to one.
(@EndDateTime, @secondsPerBucket, datediff(s,@BeginDateTime, @EndDateTime)) d2 ),
 waits as(
select
	idr2.start/* dbo.GetChartBucket([StatementUTCStartTime]) */ as StatementUTCStartTime
	,dateadd(ss, CONVERT(DECIMAL(16,4),CONVERT(DECIMAL(16,4),ISNULL([WaitDuration],0))/1000), [StatementUTCStartTime]) as endtime
	,aw.[WaitTypeID]
	,[WaitType]
	,wt.[CategoryID]
	,[Category]
	,[WaitDuration] = case when WaitDuration is null then 0 
	when aw.StatementUTCStartTime >= idr2.start and dateadd(ss,CONVERT(DECIMAL(16,4),CONVERT(DECIMAL(16,4),ISNULL(aw.[WaitDuration],0))/1000),aw.[StatementUTCStartTime]) <= idr2.endtime then WaitDuration 
		when (aw.StatementUTCStartTime <= idr2.start and dateadd(ss,CONVERT(DECIMAL(16,4),CONVERT(DECIMAL(16,4),ISNULL(aw.[WaitDuration],0))/1000),aw.[StatementUTCStartTime]) >= idr2.endtime) 
			then DATEDIFF(ss,idr2.start,idr2.endtime)*1000
		when (aw.StatementUTCStartTime <= idr2.start and  (dateadd(ss,CONVERT(DECIMAL(16,4),CONVERT(DECIMAL(16,4),ISNULL(aw.[WaitDuration],0))/1000),aw.[StatementUTCStartTime]) > idr2.start and 
			dateadd(ss,CONVERT(DECIMAL(16,4),CONVERT(DECIMAL(16,4),ISNULL(aw.[WaitDuration],0))/1000),aw.[StatementUTCStartTime]) < idr2.endtime)) 
			then DATEDIFF(ss,idr2.start,dateadd(ss,CONVERT(DECIMAL(16,4),CONVERT(DECIMAL(16,4),ISNULL(aw.[WaitDuration],0))/1000),aw.[StatementUTCStartTime]))*1000
		when ((aw.StatementUTCStartTime >= idr2.start and aw.StatementUTCStartTime < idr2.endtime) and 
			dateadd(ss,CONVERT(DECIMAL(16,4),CONVERT(DECIMAL(16,4),ISNULL(aw.[WaitDuration],0))/1000),aw.[StatementUTCStartTime]) > idr2.endtime) 
			then  DATEDIFF(ss,aw.StatementUTCStartTime, idr2.endtime)*1000
		else 0 
		end
	,[SessionID]
	,aw.[HostNameID]
	,[HostName]
	,aw.[ApplicationNameID]
	,[ApplicationName]
	,aw.[LoginNameID]
	,[LoginName]
	,aw.DatabaseID
	,[DatabaseName]
	,aw.[SQLStatementID]
	,[SQLStatement]
from idr2 left join [ActiveWaitStatistics] aw  (NOLOCK) on aw.StatementUTCStartTime >= idr2.start 
and dateadd(ss,CONVERT(DECIMAL(16,4),CONVERT(DECIMAL(16,4),ISNULL(aw.[WaitDuration],0))/1000),aw.[StatementUTCStartTime]) < idr2.endtime -- no brainer fit in the range
			or (aw.StatementUTCStartTime <= idr2.start and dateadd(ss,CONVERT(DECIMAL(16,4),CONVERT(DECIMAL(16,4),ISNULL(aw.[WaitDuration],0))/1000),aw.[StatementUTCStartTime]) >= idr2.endtime) -- starts before this bucket so whole bucket in this bucket (bucket start to bucket end)
			or (aw.StatementUTCStartTime <= idr2.start and  (dateadd(ss,CONVERT(DECIMAL(16,4),CONVERT(DECIMAL(16,4),ISNULL(aw.[WaitDuration],0))/1000),aw.[StatementUTCStartTime]) > idr2.start and dateadd(ss,CONVERT(DECIMAL(16,4),CONVERT(DECIMAL(16,4),ISNULL(aw.[WaitDuration],0))/1000),aw.[StatementUTCStartTime]) < idr2.endtime)) -- starts before this bucket but ends in the bucket (start of bucket to endtime)
			or ((aw.StatementUTCStartTime >= idr2.start and aw.StatementUTCStartTime < idr2.endtime) and dateadd(ss,CONVERT(DECIMAL(16,4),CONVERT(DECIMAL(16,4),ISNULL(aw.[WaitDuration],0))/1000),aw.[StatementUTCStartTime]) >= idr2.endtime) -- starts in this bucket but ends after the bucket (some time in bucket till end of bucket)
			or aw.WaitDuration is null
	inner join [WaitTypes] wt (NOLOCK)
	on aw.[WaitTypeID] = wt.[WaitTypeID] inner join [WaitCategories] wc
	on wt.[CategoryID] = wc.[CategoryID] inner join [HostNames] hn
	on aw.[HostNameID] = hn.[HostNameID] inner join [ApplicationNames] an
	on aw.[ApplicationNameID] = an.[ApplicationNameID] inner join [LoginNames] ln
	on aw.[LoginNameID] = ln.[LoginNameID] left join [SQLServerDatabaseNames] dn
	on aw.DatabaseID = dn.DatabaseID left join [AllSQLStatements] sq
	on aw.[SQLStatementID] = sq.[SQLStatementID] 
where aw.[SQLServerID] = @SQLServerID --or aw.SQLServerID is null or aw.SQLServerID = ''
	and (dateadd(ss,CONVERT(DECIMAL(16,4),CONVERT(DECIMAL(16,4),ISNULL(aw.[WaitDuration],0))/1000),aw.[StatementUTCStartTime]) >= @BeginDateTime 
	and aw.[StatementUTCStartTime] <= @EndDateTime) --or aw.[WaitDuration] is null
	and wc.[Category] = isnull(@CategoryName,wc.[Category])
	and aw.[WaitTypeID] = isnull(@WaitTypeID,aw.[WaitTypeID])
	and wt.[CategoryID] = isnull(@CategoryID,wt.[CategoryID])
	and aw.[SessionID] = isnull(@SessionID,aw.[SessionID])
	and aw.[HostNameID] = isnull(@HostNameID,aw.[HostNameID])
	and aw.[ApplicationNameID] = isnull(@ApplicationNameID,aw.[ApplicationNameID])
	and aw.[LoginNameID] = isnull(@LoginNameID,aw.[LoginNameID])
	and aw.[DatabaseID] = isnull(@DatabaseID,aw.[DatabaseID])
	and aw.[SQLStatementID] = isnull(@SQLStatementID,aw.[SQLStatementID])
	
	and wc.ExcludeFromCollection =0 -- Start : SQLdm 8.6(Ankit Srivastava) - Fixing defect -Excluding the wait_types which belong to Excluded wait_category
	)
	--select * from waits order by 1 asc
select w.StatementUTCStartTime as StatementUTCStartTime
--START SQLdm 10.0 (Sanjali Makkar) : To Add filters of IDs of various parameters
	,isnull([WaitTypeID],'na') as WaitTypeID
	,isnull([WaitType],'na') as WaitType
	,isnull([CategoryID],'na') as CategoryID
	,isnull([Category],'na') as Category
	,isnull([SQLStatementID],'na') as SQLStatementID
	,isnull([SQLStatement],'na') as SQLStatement
	,isnull([ApplicationNameID],'na') as ApplicationNameID
	,isnull([ApplicationName],'na') as ApplicationName
	,isnull([DatabaseID],'na') as DatabaseID
	,isnull([DatabaseName],'na') as DatabaseName
	,isnull([HostNameID],'na') as HostNameID
	,isnull([HostName],'na') as HostName
	,isnull([SessionID],0) as SessionID
	,isnull([LoginNameID],'na') as LoginNameID
	,isnull([LoginName],'na') as LoginName
	--END SQLdm 10.0 (Sanjali Makkar) : To Add filters of IDs of various parameters
	,CONVERT(DECIMAL(16,4),CONVERT(DECIMAL(16,4),isnull(w.[WaitDuration],0))/@secondsPerBucket) as WaitDuration
	 from waits w (NOLOCK)
	order by w.StatementUTCStartTime  asc
select @err = @@error
return @err
end


 
GO 

---------- P_GETALERT.SQL
-- SQLDM 8.5:Mahesh : Added for Rest service consumption
if (object_id('p_GetAlert') is not null)
begin
drop procedure p_GetAlert
end
go

CREATE PROCEDURE [dbo].[p_GetAlert](
	@AlertID bigint	
)
AS
begin
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	declare @e int
	
	SELECT	A.[AlertID],A.[UTCOccurrenceDateTime],A.[ServerName],A.[DatabaseName],A.[TableName],
					A.[Active],A.[Metric],A.[Severity],A.[StateEvent],A.[Value],A.[Heading],A.[Message], mss.SQLServerID
			FROM [Alerts] A (NOLOCK)
			LEFT OUTER JOIN MonitoredSQLServers mss (NOLOCK) ON A.ServerName = mss.InstanceName
			WHERE A.AlertID = @AlertID
	SELECT @e = @@error

	RETURN @e

END	 

GO

 
GO 

---------- P_GETALERTHISTORY.SQL
if (object_id('p_GetAlertHistory') is not null)
begin
drop procedure [p_GetAlertHistory]
end
go
create procedure [dbo].[p_GetAlertHistory]
				@SQLServerIDs nvarchar(max) = null,
				@UTCStart DateTime,
				@UTCEnd DateTime,
				@UTCOffset int
as
begin
		declare @xmlDoc int
		declare @SQLServers table(
					SQLServerID int,
					InstanceName nvarchar(256)) 

		create table #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

		insert into #SecureMonitoredSQLServers
		exec [p_GetReportServers]
		

		if @SQLServerIDs is not null 
		begin
			-- Prepare XML document if there is one
			exec sp_xml_preparedocument @xmlDoc output, @SQLServerIDs

			insert into @SQLServers
			select
				ID, InstanceName
			from openxml(@xmlDoc, '//Srvr', 1) with (ID int)
				join #SecureMonitoredSQLServers (nolock) on ID = SQLServerID

			if @SQLServerIDs is not null
				exec sp_xml_removedocument @xmlDoc
		end
		else
		begin
			insert into @SQLServers
			select SQLServerID, InstanceName 
				from #SecureMonitoredSQLServers (nolock)
		end

		select	ms.InstanceName
				,max(ms.SQLServerID) as SQLServerID
				,max(a.Severity) as Status
				,min(dateadd(mi, @UTCOffset, a.UTCOccurrenceDateTime)) as Occurred
				,a.Heading as Title
		from @SQLServers ms 
			join Alerts a (NOLOCK) on a.[ServerName] collate database_default = ms.[InstanceName] collate database_default
		where dateadd(minute, datediff(minute, 0, a.[UTCOccurrenceDateTime]), 0) between @UTCStart and @UTCEnd
		group by
			ms.InstanceName,
			a.Heading
		order by
			ms.InstanceName,
			Occurred asc
end
 
GO 

---------- P_GETALERTS.SQL
if (object_id('p_GetAlerts') is not null)
begin
drop procedure p_GetAlerts
end
go

CREATE PROCEDURE [dbo].p_GetAlerts(
	@StartingAlertID bigint,
	@StartDate datetime,
	@EndDate datetime,
	@ServerXML nvarchar(max),
	@DatabaseName nvarchar(256),
	@TableName varchar(256),
	@Severity tinyint,
	@Metric int,
	@category nvarchar(128) = null, -- SQLDM 8.5 Mahesh - Added new param for rest service comsumption
	@Active bit,
	@MaxRows int = 0
)
AS
begin
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	declare @starting datetime
	declare @e int
	declare @incop bit
	create table #IntermediateTable (InstanceName nvarchar(255) collate database_default, 
									 Metric int, 
									 LastScheduledCollectionTime datetime, 
									 LastDatabaseCollectionTime datetime, 
									 LastAlertRefreshTime datetime,
									 IsSnoozed bit,
									 IsMaintenanceMode bit)
	declare @xmlDoc int
	declare @now datetime
	
	select @now = DateAdd(second,10,GetUTCDate())
	select @starting = coalesce(@StartDate, DATEADD(year, -10, GETUTCDATE()))
	set @incop = 0

	exec sp_xml_preparedocument @xmlDoc output, @ServerXML
	
	-- create filtered table of selected servers and metrics to include
	insert into #IntermediateTable
	select
			O.InstanceName,
			M.Metric, 
			MS.LastScheduledCollectionTime, 
			MS.LastDatabaseCollectionTime,
			MS.LastAlertRefreshTime,
			case when T.UTCSnoozeEnd > @now then 1 else 0 end,
			0
		from MetricMetaData M (NOLOCK)
		cross join openxml(@xmlDoc, '//Server', 1) with (InstanceName nvarchar(255)) as O
		join MonitoredSQLServers MS (nolock) on MS.InstanceName = O.InstanceName
		join MetricInfo as MI on M.Metric = MI.Metric
		left outer join MetricThresholds T (NOLOCK) on
				MS.[SQLServerID] = T.[SQLServerID] and
				M.[Metric] = T.[Metric] 	
			WHERE 
				MS.Active = 1 and M.Deleted = 0 and
				--Commented for DE3186 
	 			--(T.Enabled = 1 or T.Enabled is null) and
				(@Metric is null or M.[Metric] = @Metric) and
				(@category is null or MI.Category = @category) and
				(@Active is null 
				    or @Active = 0 
					or (T.[UTCSnoozeEnd] is null or T.[UTCSnoozeEnd] < @now)
				)  

	-- if an empty server node exists then set flag used to include operational alerts (servername is null)
	if (exists(select InstanceName from openxml(@xmlDoc, '//Server', 1) with (InstanceName nvarchar(255)) where InstanceName is null))
		set @incop = 1

	exec sp_xml_removedocument @xmlDoc


	update #IntermediateTable
	set IsMaintenanceMode = 1
	from
	#IntermediateTable I inner join Alerts A (NOLOCK) on A.ServerName collate database_default = I.InstanceName collate database_default 
	where A.Metric = 48 and I.LastScheduledCollectionTime = A.UTCOccurrenceDateTime
		
		
	if (@Active is null or @Active = 0)
	begin -- return all alerts that match the filter
		if (@MaxRows is not null)
			set rowcount @MaxRows

		if (@EndDate is null)
		begin
			SELECT	A.[AlertID],A.[UTCOccurrenceDateTime],A.[ServerName],A.[DatabaseName],A.[TableName],
					case 
						when I.IsMaintenanceMode = 1 and A.Metric = 48
							then 1
						when I.IsMaintenanceMode = 0 and A.[Active] = 1 and 
							 A.[UTCOccurrenceDateTime] = I.[LastScheduledCollectionTime] and
							 A.Metric not in (select MetricID from DBMetrics) and
							 I.IsSnoozed = 0
						then 1
						 when I.IsMaintenanceMode = 0 and A.[Active] = 1 and 
							 A.[UTCOccurrenceDateTime] = I.[LastDatabaseCollectionTime] and
							 A.Metric in (select MetricID from DBMetrics) and
							 I.IsSnoozed = 0
						then 1							 
						else 0 
					end,
					A.[Metric],A.[Severity],A.[StateEvent],A.[Value],A.[Heading],A.[Message]
			FROM #IntermediateTable I 
				left join [Alerts] A (NOLOCK) 
					on A.ServerName = I.InstanceName
						and A.Metric = I.Metric
			WHERE 
				not (A.[UTCOccurrenceDateTime] < @starting) 
				and (@StartingAlertID is null or A.[AlertID] > @StartingAlertID) 
				and (@Severity is null or A.[Severity] = @Severity) 
				and (@DatabaseName is null or A.[TableName] = @DatabaseName) 
				and (@TableName is null or A.[TableName] = @TableName) 
			UNION
			-- pick up operational alerts (server name is null)
			SELECT	A.[AlertID],A.[UTCOccurrenceDateTime],A.[ServerName],A.[DatabaseName],A.[TableName],
					A.[Active],A.[Metric],A.[Severity],A.[StateEvent],A.[Value],A.[Heading],A.[Message]
			FROM [Alerts] A (NOLOCK) 
			join MetricInfo as MI (NOLOCK) on A.Metric = MI.Metric
			WHERE 
				(@incop = 1) and
				(A.ServerName is null) and
				(A.[UTCOccurrenceDateTime] between @starting and @EndDate) and
				(@StartingAlertID is null or A.[AlertID] > @StartingAlertID) and
				(@Metric is null or A.[Metric] = @Metric) and
				(@category is null or MI.Category = @category) and
				(@Severity is null or A.[Severity] = @Severity)
			ORDER BY A.[UTCOccurrenceDateTime] DESC
		end
		else
		begin
			SELECT	A.[AlertID],A.[UTCOccurrenceDateTime],A.[ServerName],A.[DatabaseName],A.[TableName],
					case 
						when I.IsMaintenanceMode = 1 and A.Metric = 48
							then 1
						when I.IsMaintenanceMode = 0 and A.[Active] = 1 and 
							 A.[UTCOccurrenceDateTime] = I.[LastScheduledCollectionTime] and
							 A.Metric not in (select MetricID from DBMetrics) and
							 I.IsSnoozed = 0
						then 1
						 when I.IsMaintenanceMode = 0 and A.[Active] = 1 and 
							 A.[UTCOccurrenceDateTime] = I.[LastDatabaseCollectionTime] and
							 A.Metric in (select MetricID from DBMetrics) and
							 I.IsSnoozed = 0
						then 1							 
						else 0 
					end,
					A.[Metric],A.[Severity],A.[StateEvent],A.[Value],A.[Heading],A.[Message]
			FROM #IntermediateTable I 
				left join [Alerts] A (NOLOCK) 
					on A.ServerName = I.InstanceName and
					   A.Metric = I.Metric
			WHERE 
				(A.[UTCOccurrenceDateTime] between @starting and @EndDate) and
				(@StartingAlertID is null or A.[AlertID] > @StartingAlertID) and
				(@DatabaseName is null or A.[TableName] = @DatabaseName) and
				(@TableName is null or A.[TableName] = @TableName) and
				(@Severity is null or A.[Severity] = @Severity)
			UNION
			-- pick up operational alerts (server name is null)
			SELECT	A.[AlertID],A.[UTCOccurrenceDateTime],A.[ServerName],A.[DatabaseName],A.[TableName],
					A.[Active],A.[Metric],A.[Severity],A.[StateEvent],A.[Value],A.[Heading],A.[Message]
			FROM [Alerts] A (NOLOCK) 
			Join MetricInfo MI (NOLOCK) on A.Metric = MI.Metric
			WHERE 
				(@incop = 1) and
				(A.ServerName is null) and
				(A.[UTCOccurrenceDateTime] between @starting and @EndDate) and
				(@StartingAlertID is null or A.[AlertID] > @StartingAlertID) and
				(@Metric is null or A.[Metric] = @Metric) and
				(@category is null or MI.Category = @category) and
				(@Severity is null or A.[Severity] = @Severity)
			ORDER BY A.[UTCOccurrenceDateTime] DESC
		end
	end
	else
	begin -- only return the last active alerts (relies on AlertID being sequentially assigned)
	
	if (@MaxRows is not null) -- -- SQLDM 8.5:Mahesh : Setting Maxrows for Active Alerts as well
			set rowcount @MaxRows

			SELECT A.[AlertID],A.[UTCOccurrenceDateTime],A.[ServerName],A.[DatabaseName],A.[TableName],A.[Active],A.[Metric],A.[Severity],A.[StateEvent],A.[Value],A.[Heading],A.[Message]
				from #IntermediateTable I
					inner join Alerts A (nolock) on 
						A.[ServerName] = I.InstanceName and
						A.UTCOccurrenceDateTime = I.LastScheduledCollectionTime and
						A.Metric = I.Metric	
				where
					(A.Metric = 48 or I.IsMaintenanceMode = 0)
					and A.[Active] = 1
					and I.IsSnoozed = 0
					and A.Metric not in (select MetricID from DBMetrics)
					and (@StartingAlertID is null or A.[AlertID] > @StartingAlertID) 
					and (@DatabaseName is null or A.[TableName] = @DatabaseName) 
					and (@TableName is null or A.[TableName] = @TableName) 
					and (@Severity is null or A.[Severity] = @Severity) 
		union	
			SELECT A.[AlertID],A.[UTCOccurrenceDateTime],A.[ServerName],A.[DatabaseName],A.[TableName],A.[Active],A.[Metric],A.[Severity],A.[StateEvent],A.[Value],A.[Heading],A.[Message]
					from #IntermediateTable I (NOLOCK)
						inner join Alerts A (nolock) on 
							A.[ServerName] = I.InstanceName and
							A.UTCOccurrenceDateTime = I.LastDatabaseCollectionTime and
							A.Metric = I.Metric	
					where
						(A.Metric = 48 or I.IsMaintenanceMode = 0)
						and A.[Active] = 1
						and I.IsSnoozed = 0
						and A.Metric in (select MetricID from DBMetrics)
						and (@StartingAlertID is null or A.[AlertID] > @StartingAlertID) 
						and (@DatabaseName is null or A.[TableName] = @DatabaseName) 
						and (@TableName is null or A.[TableName] = @TableName) 
						and (@Severity is null or A.[Severity] = @Severity) 

	end

	SELECT @e = @@error
	RETURN @e
END	
 
GO 

---------- P_GETALERTSCOUNTPERCATEGORY.SQL
if (object_id('p_GetAlertsCountPerCategory') is not null)
begin
drop procedure p_GetAlertsCountPerCategory
end
go
CREATE PROCEDURE [dbo].[p_GetAlertsCountPerCategory] (@AllowedSQLServers NVARCHAR(1000),@PerInstance int = 0)
AS
BEGIN

IF @PerInstance = 1
BEGIN
	--START: SQLdm 9.0 (Abhishek Joshi) --Web Console Improvements -send all the categories in the response, irrespective of numOfAlerts
	SELECT
		AllCategories.Category,
		AD.SQLServerID,
		AD.NumOfAlerts
	FROM
		( SELECT distinct Category 
		  from MetricInfo (NOLOCK) ) as AllCategories
		  left join
	--END: SQLdm 9.0 (Abhishek Joshi) --Web Console Improvements -send all the categories in the response, irrespective of numOfAlerts	
		( SELECT mi.Category, mss.SQLServerID, COUNT(1) AS NumOfAlerts
		  from MetricInfo mi (NOLOCK)
		  LEFT OUTER JOIN Alerts a (NOLOCK)
			ON mi.Metric = a.Metric
		  left outer join DBMetrics DBM (NOLOCK) on DBM.MetricID = mi.[Metric]
		  LEFT OUTER JOIN (SELECT SQLServerID,InstanceName,LastScheduledCollectionTime, LastDatabaseCollectionTime, Active FROM MonitoredSQLServers (NOLOCK) JOIN fn_Split(@AllowedSQLServers,',') allowedServers ON allowedServers.Value = MonitoredSQLServers.SQLServerID) AS mss 
			ON mss.InstanceName = a.ServerName
			   and (
	       			(DBM.MetricID is NULL AND mss.LastScheduledCollectionTime = a.UTCOccurrenceDateTime)
					or 
					(DBM.MetricID is NOT NULL AND mss.LastDatabaseCollectionTime = a.UTCOccurrenceDateTime))
			WHERE a.Active = 1
					and mss.Active = 1
			GROUP BY mi.Category, mss.SQLServerID) as AD
			on AllCategories.Category = AD.Category  --SQLdm 9.0 (Abhishek Joshi) --Web Console Improvements -send all the categories in the response, irrespective of numOfAlerts
END
ELSE
BEGIN
	--START: SQLdm 9.0 (Abhishek Joshi) --Web Console Improvements -send all the categories in the response, irrespective of numOfAlerts
	SELECT
		AllCategories.Category,
		AD.NumOfAlerts
	FROM
		( SELECT distinct Category 
		  from MetricInfo (NOLOCK) ) as AllCategories
		  left join
	--END: SQLdm 9.0 (Abhishek Joshi) --Web Console Improvements -send all the categories in the response, irrespective of numOfAlerts
		( SELECT mi.Category, COUNT(1) AS NumOfAlerts 
		  from MetricInfo mi (NOLOCK)
	      LEFT OUTER JOIN Alerts a (NOLOCK)
	      ON mi.Metric = a.Metric
	      left outer join DBMetrics DBM on DBM.MetricID = mi.[Metric]
	      LEFT OUTER JOIN (SELECT SQLServerID,InstanceName,LastScheduledCollectionTime, LastDatabaseCollectionTime, Active FROM MonitoredSQLServers (NOLOCK) JOIN fn_Split(@AllowedSQLServers,',') allowedServers ON allowedServers.Value = MonitoredSQLServers.SQLServerID) AS mss 
	      ON mss.InstanceName = a.ServerName
	       and (
	       		(DBM.MetricID is NULL AND mss.LastScheduledCollectionTime = a.UTCOccurrenceDateTime)
	            or 
	            (DBM.MetricID is NOT NULL AND mss.LastDatabaseCollectionTime = a.UTCOccurrenceDateTime))
	      WHERE a.Active = 1
	            and mss.Active = 1 
	      GROUP BY mi.Category) as AD
		  on AllCategories.Category = AD.Category  --SQLdm 9.0 (Abhishek Joshi) --Web Console Improvements -send all the categories in the response, irrespective of numOfAlerts
		  order by AD.NumOfAlerts desc
END

END
 
GO 

---------- P_GETALERTSCOUNTPERDATABASE.SQL
if (object_id('p_GetAlertsCountPerDatabase') is not null)
begin
drop procedure p_GetAlertsCountPerDatabase
end
go
CREATE PROCEDURE [dbo].[p_GetAlertsCountPerDatabase]
AS
BEGIN
SELECT mss.SQLServerID, a.ServerName, a.DatabaseName, COUNT(1) AS NumOfAlerts 
FROM Alerts a (NOLOCK)
INNER join MonitoredSQLServers mss (NOLOCK) ON a.ServerName = mss.InstanceName	
WHERE a.Active = 1 
GROUP BY mss.SQLServerID, a.ServerName, a.DatabaseName
END
 
GO 

---------- P_GETALERTSFORWEBCONSOLE.SQL
if (object_id('p_GetAlertsForWebConsole') is not null)
begin
drop procedure p_GetAlertsForWebConsole
end
go

CREATE PROCEDURE [dbo].[p_GetAlertsForWebConsole](
	@StartDate datetime,
	@EndDate datetime,
	@InstanceId int,
	@Severity tinyint,
	@Metric int,
	@Category nvarchar(64),
	@OrderBy nvarchar(256),
	@OrderType nvarchar(4),
	@Limit int ,
	@ActiveOnly bit = 1
)
AS
begin
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	declare @now datetime
	Select @now= DateAdd(second,10,GetUTCDate())

	declare @starting datetime 
	select @starting =coalesce(@StartDate, DATEADD(year, -10, GETUTCDATE()))
	
	declare @ending datetime
	select @ending= coalesce(@EndDate, @now)
	
	select @OrderType = coalesce(@OrderType, 'ASC')
	declare @e int
	DECLARE @SQLString nvarchar(MAX)
	
	--[START]SQLdm 10.0 (Gaurav Karwal): for implementing sub categories of resources and finding the previous alert severity
	DECLARE @ResourceMappingList TABLE(Metric INT,Category NVARCHAR(128))
	DECLARE @CPUCategoryLiteral VARCHAR(10),@MemoryCategoryLiteral VARCHAR(10),@IOCategoryLiteral VARCHAR(10),@ResoucesCatLiteral VARCHAR(10);
	
	SELECT @CPUCategoryLiteral = 'CPU',@MemoryCategoryLiteral = 'Memory', @IOCategoryLiteral = 'IO',@ResoucesCatLiteral = 'Resources';
	
	
	
	INSERT INTO @ResourceMappingList VALUES(0,@CPUCategoryLiteral);
	INSERT INTO @ResourceMappingList VALUES(26,@CPUCategoryLiteral);
	INSERT INTO @ResourceMappingList VALUES(27,@CPUCategoryLiteral);
	INSERT INTO @ResourceMappingList VALUES(28,@CPUCategoryLiteral);
	INSERT INTO @ResourceMappingList VALUES(29,@CPUCategoryLiteral);
	INSERT INTO @ResourceMappingList VALUES(30,@CPUCategoryLiteral);
	
	INSERT INTO @ResourceMappingList VALUES(25,@IOCategoryLiteral);
	INSERT INTO @ResourceMappingList VALUES(30,@IOCategoryLiteral);
	INSERT INTO @ResourceMappingList VALUES(31,@IOCategoryLiteral);
	INSERT INTO @ResourceMappingList VALUES(62,@IOCategoryLiteral);
	INSERT INTO @ResourceMappingList VALUES(63,@IOCategoryLiteral);
	INSERT INTO @ResourceMappingList VALUES(74,@IOCategoryLiteral);
	INSERT INTO @ResourceMappingList VALUES(76,@IOCategoryLiteral);
	INSERT INTO @ResourceMappingList VALUES(81,@IOCategoryLiteral);
	INSERT INTO @ResourceMappingList VALUES(82,@IOCategoryLiteral);
	INSERT INTO @ResourceMappingList VALUES(83,@IOCategoryLiteral);
	INSERT INTO @ResourceMappingList VALUES(84,@IOCategoryLiteral);
	INSERT INTO @ResourceMappingList VALUES(85,@IOCategoryLiteral);
	INSERT INTO @ResourceMappingList VALUES(86,@IOCategoryLiteral);
	INSERT INTO @ResourceMappingList VALUES(87,@IOCategoryLiteral);
	INSERT INTO @ResourceMappingList VALUES(87,@IOCategoryLiteral);
	INSERT INTO @ResourceMappingList VALUES(111,@IOCategoryLiteral);
	
	INSERT INTO @ResourceMappingList VALUES(13,@IOCategoryLiteral);
	INSERT INTO @ResourceMappingList VALUES(24,@IOCategoryLiteral);
	
	--[END]SQLdm 10.0 (Gaurav Karwal): for implementing sub categories of resources and finding the previous alert severity


	--Changes for Limit not passed by user send all record not only top 100
	DECLARE @checkLimit nvarchar(100)
	SELECT @checkLimit = '';

	if(@Limit is NOT Null AND @Limit != 0) --SQLdm 8.6 -(Ankit Srivastava) - Fixed for automation testing -- Setting the limit variable to the default
		Select @checkLimit=' TOP ('+CAST(@Limit as nvarchar(20))+') ';
	ELSE
		SELECT @checkLimit = '';

	if(@ActiveOnly is null) --SQLdm 8.6 -(Ankit Srivastava) - Fixed for automation testing -- Setting the ActiveOnly variable to the default
		Select @ActiveOnly = 1 

	--Commenting Out the following Code as Ending is getting delayed by 1 day
/*	if(@ending <> @now) --SQLdm 8.6 -(Ankit Srivastava) - Fixed for automation testing -- Setting the time to 23:59:59 if not mentioned 
	 begin
		declare @newEnd datetime;
		select @newEnd = CONVERT(datetime,@ending,104);
		if( @ending = @newEnd)
		select @ending=DATEADD(MILLISECOND,-2,(DATEADD(DAY,1,@ending)))
	end
*/

	create table #IntermediateTable (InstanceId int, 
									InstanceName nvarchar(255) collate database_default, 
									 Metric int, 
									 LastScheduledCollectionTime datetime, 
									 LastDatabaseCollectionTime datetime, 
									 LastAlertRefreshTime datetime,
									 IsSnoozed bit,
									 Category nvarchar(64) collate database_default,
									 IsDBNetric bit,
									 SubCategory nvarchar(64) collate database_default)
	
	-- create filtered table of selected servers and metrics to include
	insert into #IntermediateTable
	select
			MS.SQLServerID, 
			MS.InstanceName,
			M.Metric, 
			MS.LastScheduledCollectionTime, 
			MS.LastDatabaseCollectionTime,
			MS.LastAlertRefreshTime,
			case when T.UTCSnoozeEnd > @now then 1 else 0 end,
			MI.Category,
			case
				when DBM.MetricID is null then
					0
				else
					1
			end,
			CASE WHEN (LOWER(MI.Category) = LOWER(@ResoucesCatLiteral) AND M.Metric IN (SELECT Metric FROM @ResourceMappingList temp WHERE LOWER(temp.Category) = LOWER(@CPUCategoryLiteral) )) THEN LOWER(@CPUCategoryLiteral) 
			ELSE 
			CASE WHEN (LOWER(MI.Category) = LOWER(@ResoucesCatLiteral) AND M.Metric IN (SELECT Metric FROM @ResourceMappingList temp WHERE LOWER(temp.Category) = LOWER(@CPUCategoryLiteral))) THEN LOWER(@IOCategoryLiteral) ELSE
				CASE WHEN (LOWER(MI.Category) = LOWER(@ResoucesCatLiteral) AND M.Metric IN (SELECT Metric FROM @ResourceMappingList temp WHERE LOWER(temp.Category) = LOWER(@CPUCategoryLiteral))) THEN LOWER(@MemoryCategoryLiteral) 
				ELSE
				MI.Category
				END
			END
		
		END
		SubCategory
		FROM MetricMetaData M (NOLOCK)
		cross join MonitoredSQLServers MS (NOLOCK)
		join MetricInfo as MI on M.Metric = MI.Metric
		left outer join MetricThresholds T (NOLOCK) on
				MS.[SQLServerID] = T.[SQLServerID] and
				M.[Metric] = T.[Metric] 	
		left outer join DBMetrics DBM (NOLOCK) on
				DBM.MetricID = M.[Metric]
			WHERE 
				MS.Active = 1 and M.Deleted = 0 and
				(@Metric is null or M.[Metric] = @Metric) and
				(@Category is null or MI.Category = @Category) and
				(T.[UTCSnoozeEnd] is null or T.[UTCSnoozeEnd] < @now)
				and (@InstanceId is null or MS.[SQLServerID] = @InstanceId)

				--select * from #IntermediateTable where Metric = 52

	create index IDX_TEMP ON #IntermediateTable (InstanceName, Metric)
	--set rowcount @Limit
	

	--START SQldm srishti purohit --To provide previous severity
	
	CREATE TABLE #PreviousAlertSEVERITY (Severity TINYINT,
	Category NVARCHAR(128) collate database_default,SubCategory NVARCHAR(128) collate database_default)

	INSERT INTO #PreviousAlertSEVERITY 
	SELECT T.Severity, 
		T.Category, T.SubCategory
		FROM(SELECT Severity,M.Category,
		CASE WHEN (LOWER(M.Category) = LOWER(@ResoucesCatLiteral) AND A.Metric IN (SELECT Metric FROM @ResourceMappingList temp WHERE LOWER(temp.Category) = LOWER(@CPUCategoryLiteral) )) THEN LOWER(@CPUCategoryLiteral) 
			ELSE 
			CASE WHEN (LOWER(M.Category) = LOWER(@ResoucesCatLiteral) AND A.Metric IN (SELECT Metric FROM @ResourceMappingList temp WHERE LOWER(temp.Category) = LOWER(@CPUCategoryLiteral))) THEN LOWER(@IOCategoryLiteral) ELSE
				CASE WHEN (LOWER(M.Category) = LOWER(@ResoucesCatLiteral) AND A.Metric IN (SELECT Metric FROM @ResourceMappingList temp WHERE LOWER(temp.Category) = LOWER(@CPUCategoryLiteral))) THEN LOWER(@MemoryCategoryLiteral) 
				ELSE
				M.Category
				END
			END
		
		END
		SubCategory, 
		ROW_NUMBER() 
			OVER(PARTITION BY 
				CASE WHEN (LOWER(M.Category) = LOWER(@ResoucesCatLiteral) AND A.Metric IN (SELECT Metric FROM @ResourceMappingList temp WHERE LOWER(temp.Category) = LOWER(@CPUCategoryLiteral) )) THEN LOWER(@CPUCategoryLiteral) 
				ELSE 
					CASE WHEN (LOWER(M.Category) = LOWER(@ResoucesCatLiteral) AND A.Metric IN (SELECT Metric FROM @ResourceMappingList temp WHERE LOWER(temp.Category) = LOWER(@IOCategoryLiteral))) THEN LOWER(@IOCategoryLiteral) 
					ELSE
						CASE WHEN (LOWER(M.Category) = LOWER(@ResoucesCatLiteral)AND A.Metric IN (SELECT Metric FROM @ResourceMappingList temp WHERE LOWER(temp.Category) = LOWER(@MemoryCategoryLiteral))) THEN LOWER(@MemoryCategoryLiteral) 
						ELSE
						M.Category
						END
					END
				END
				ORDER BY A.UTCOccurrenceDateTime DESC)  RowNum 
		
		FROM Alerts A JOIN MetricInfo M ON A.Metric = M.Metric WHERE A.UTCOccurrenceDateTime < @starting) T WHERE T.RowNum = 1
	
	
	if @ActiveOnly = 1
		select @SQLString = 'SELECT '+@checkLimit+' A.[AlertID],A.[UTCOccurrenceDateTime],I.[InstanceId],A.[ServerName],A.[DatabaseName],A.[TableName],A.[Active],A.[Metric],A.[Severity],ISNULL(PAD.[Severity],1) PreviousAlertSeverity,A.[StateEvent],A.[Value],A.[Heading],A.[Message]
				
				from #IntermediateTable I				
					inner join Alerts A (nolock) on 
						A.[ServerName] = I.InstanceName and
						((A.UTCOccurrenceDateTime = I.LastScheduledCollectionTime and I.IsDBNetric = 0) or (A.UTCOccurrenceDateTime = I.LastDatabaseCollectionTime and I.IsDBNetric = 1)) and
						A.Metric = I.Metric	
						LEFT OUTER JOIN #PreviousAlertSEVERITY PAD ON  I.SubCategory = PAD.SubCategory
				where
					(A.Metric = 48 or A.[Active] = 1)
					and I.IsSnoozed = 0
					and (A.[UTCOccurrenceDateTime] between @starting and @ending)' -- --SQLdm 8.6 -(Ankit Srivastava) - Fixed for automation testing -- Setting the end and start date filters for ActiveOnly case too
	else
		select @SQLString = 'SELECT '+@checkLimit+' A.[AlertID],A.[UTCOccurrenceDateTime],I.[InstanceId],A.[ServerName],A.[DatabaseName],A.[TableName],
				case 
					when A.Metric = 48 and I.LastScheduledCollectionTime = A.UTCOccurrenceDateTime
						then 1
					when A.[Active] = 1 and 
							A.[UTCOccurrenceDateTime] = I.[LastScheduledCollectionTime] and
							I.IsDBNetric = 0 and
							I.IsSnoozed = 0
					then 1
						when A.[Active] = 1 and 
							A.[UTCOccurrenceDateTime] = I.[LastDatabaseCollectionTime] and
							I.IsDBNetric = 1 and
							I.IsSnoozed = 0
					then 1							 
					else 0 
				end AS Active,
				A.[Metric],A.[Severity],ISNULL(PAD.[Severity],1) PreviousAlertSeverity,A.[StateEvent],A.[Value],A.[Heading],A.[Message]
		FROM #IntermediateTable I 
			left join [Alerts] A (NOLOCK) 
				on I.InstanceName = A.ServerName
					and I.Metric = A.Metric
					LEFT OUTER JOIN #PreviousAlertSEVERITY PAD ON  I.SubCategory = PAD.SubCategory
		WHERE 
			(A.[UTCOccurrenceDateTime] between @starting and @ending)'
	
	
	SELECT @SQLString = @SQLString + 
		case when @Severity is not null then ' and A.[Severity] = @Severity ' else ' ' end + 
		case when @OrderBy is not null then ' ORDER BY '+ @OrderBy + ' ' + @OrderType else ' ' end;
		

	if @ActiveOnly = 1
		EXEC sp_executesql @SQLString, N'@Limit int, @starting datetime, @ending datetime, @Severity tinyint', @Limit, @starting, @ending, @Severity --SQLdm 8.6 -(Ankit Srivastava) - Fixed for automation testing -- Added new parameter
	else 
		EXEC sp_executesql @SQLString, N'@Limit int, @starting datetime, @ending datetime, @Severity tinyint', @Limit, @starting, @ending, @Severity
	
	SELECT @e = @@error
	RETURN @e
END

-- set statistics time off

-- active
/**
select GETDATE()
exec p_GetAlertsForWebConsole null, null, null, null, null,null, 'Severity', 'desc', 1000, 1
select GETDATE()
exec p_GetAlertsForWebConsole null, null, null, null, null,null,  'DatabaseName', 'desc', 1000, 1
select GETDATE()										 
exec p_GetAlertsForWebConsole null, null, null, null, null,null,  'UTCOccurrenceDateTime', 'desc', 1000, 1
select GETDATE()										  
exec p_GetAlertsForWebConsole null, null, null, null, null,null,  'ServerName', 'desc', 1000, 1
select GETDATE()									
exec p_GetAlertsForWebConsole null, null, null, null, null,null,  'Category', 'desc', 1000, 1
select GETDATE()
*/
-- all
/**
select GETDATE()
exec p_GetAlertsForWebConsole null, null, null, null, null, 'Severity', 'desc', 100, 0
--select GETDATE()
exec p_GetAlertsForWebConsole null, null, null, null, null, 'DatabaseName', 'desc', 100, 0
--select GETDATE()
exec p_GetAlertsForWebConsole null, null, null, null, null, 'UTCOccurrenceDateTime', 'desc', 100, 0
--select GETDATE()
exec p_GetAlertsForWebConsole null, null, null, null, null, 'ServerName', 'desc', 100, 0
--select GETDATE()
exec p_GetAlertsForWebConsole null, null, null, null, null, 'Category', 'desc', 100, 0
select GETDATE()
*/
 
 
GO 

---------- P_GETALERTSHISTORY.SQL
if (object_id('p_GetAlertsHistory') is not null)
begin
drop procedure p_GetAlertsHistory
end
go
CREATE PROCEDURE [dbo].[p_GetAlertsHistory] (@AlertId INT,@StartDate DATETIME, @EndDate DATETIME, @Top INT = 20 )
AS
BEGIN
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

SELECT @StartDate = CASE WHEN ISDATE(@StartDate) = 1 THEN @StartDate ELSE (GETDATE()-4) END, 
	   @EndDate = CASE WHEN ISDATE(@EndDate) = 1 THEN @EndDate ELSE (GETDATE()-4) END

SELECT TOP(@Top) a.AlertID, a.UTCOccurrenceDateTime, a.Metric, a.Severity, a.ServerName, a.Active, a.Value
FROM Alerts a (NOLOCK)
INNER JOIN Alerts a1 (NOLOCK) ON a.Metric = a1.Metric 
	AND ((a.ServerName is NULL AND a1.ServerName IS NULL) OR a.ServerName collate database_default = a1.ServerName collate database_default) 
	AND ((a.DatabaseName is NULL AND a1.DatabaseName IS NULL) OR a.DatabaseName collate database_default  = a1.DatabaseName collate database_default) 
WHERE a1.AlertID = @AlertId AND a.UTCOccurrenceDateTime <= a1.UTCOccurrenceDateTime AND DATEDIFF(d,a.UTCOccurrenceDateTime, @StartDate) <=0
    AND DATEDIFF(d,a.UTCOccurrenceDateTime,@EndDate) >=0
ORDER BY UTCOccurrenceDateTime DESC
END


 
 
GO 

---------- P_GETALERTTEMPLATES.SQL
if (object_id('p_GetAlertTemplates') is not null)
begin
drop procedure p_GetAlertTemplates
end
go

CREATE PROCEDURE [dbo].p_GetAlertTemplates(
	@templateID int
)
AS
begin
	IF (@templateID IS NULL)
	BEGIN
		SELECT [TemplateID], [Name], [Description], [Default] FROM [AlertTemplateLookup] 
	END
	ELSE
	BEGIN
		SELECT [TemplateID], [Name], [Description], [Default]  FROM [AlertTemplateLookup] where @templateID = [TemplateID]
	END
END	
 
GO 

---------- P_GETALERTTHRESHOLDSFORENUMS.SQL
if (object_id('[p_GetAlertThresholdsForEnums]') is not null)
begin
drop procedure [p_GetAlertThresholdsForEnums]
end
go

CREATE proc [dbo].[p_GetAlertThresholdsForEnums] 
@Metric int,
@Server int = null
as
begin
--script for getting enum metric thresholds
declare @SQLServerID int, @ThresholdEnabled bit, @InfoThresholdXML nvarchar(1024), @WarningThresholdXML nvarchar(1024), @CriticalThresholdXML nvarchar(1024)
declare @AlertThresholds table(SQLServerID int, InfoThreshold nvarchar(1024), WarningThreshold nvarchar(1024), CriticalThreshold nvarchar(1024)) 
declare @InfoThresholdValue nvarchar(1024), @WarningThresholdValue nvarchar(1024), @CriticalThresholdValue nvarchar(1024)
declare @InfoThresholdEnabled bit, @WarningThresholdEnabled bit, @CriticalThresholdEnabled bit
declare @xmlDoc int
declare @Now datetime

-- build a table containing metric threshold values for each server
declare read_threshold_entry insensitive cursor 
for
	select 
		SQLServerID, 
		Enabled,
		InfoThreshold, 
		WarningThreshold,
		CriticalThreshold
	from 
		MetricThresholds MT (nolock)
	where Metric = @Metric and SQLServerID=isnull(@Server,SQLServerID)
--		)
for read only
set nocount on 
open read_threshold_entry 
fetch read_threshold_entry into @SQLServerID, @ThresholdEnabled, @InfoThresholdXML, @WarningThresholdXML, @CriticalThresholdXML
while @@fetch_status = 0 
begin
	--print @SQLServerID
	if @ThresholdEnabled <> 0 
	begin
		exec sp_xml_preparedocument @xmlDoc output, @InfoThresholdXML
		select 
			@InfoThresholdValue = Value,  
			@InfoThresholdEnabled = case when UPPER(Enabled) = N'TRUE' then 1 else 0 end  
			from openxml(@xmlDoc, '/Threshold', 3)
			with (Value nvarchar(1024), Enabled nvarchar(16))
		exec sp_xml_removedocument @xmlDoc
		exec sp_xml_preparedocument @xmlDoc output, @WarningThresholdXML
		select 
			@WarningThresholdValue = Value,  
			@WarningThresholdEnabled = case when UPPER(Enabled) = N'TRUE' then 1 else 0 end  
			from openxml(@xmlDoc, '/Threshold', 3)
			with (Value nvarchar(1024), Enabled nvarchar(16))
		exec sp_xml_removedocument @xmlDoc
		exec sp_xml_preparedocument @xmlDoc output, @CriticalThresholdXML
		select 
			@CriticalThresholdValue = Value,
			@CriticalThresholdEnabled = case when UPPER(Enabled) = N'TRUE' then 1 else 0 end  
			from openxml(@xmlDoc, '/Threshold', 3)
			with (Value nvarchar(1024), Enabled nvarchar(16))
		exec sp_xml_removedocument @xmlDoc

		if @InfoThresholdEnabled = 0
			select @InfoThresholdValue = ''
		if @WarningThresholdEnabled = 0
			select @WarningThresholdValue = ''
		if @CriticalThresholdEnabled = 0
			select @CriticalThresholdValue = ''

		if (@InfoThresholdEnabled <> 0 or @WarningThresholdEnabled <> 0 or @CriticalThresholdEnabled <> 0)
			insert into @AlertThresholds (SQLServerID,InfoThreshold,WarningThreshold,CriticalThreshold)
				values(@SQLServerID, @InfoThresholdValue, @WarningThresholdValue, @CriticalThresholdValue)
	end

	fetch read_threshold_entry into @SQLServerID, @ThresholdEnabled, @InfoThresholdXML, @WarningThresholdXML, @CriticalThresholdXML
end
Close read_threshold_entry 
deallocate read_threshold_entry 

select @Metric as 'MetricID',SQLServerID,InfoThreshold,WarningThreshold,CriticalThreshold  from @AlertThresholds

end
 
GO 

---------- P_GETALERTTHRESHOLDSFORNUMERICS.SQL
if (object_id('[p_GetAlertThresholdsForNumerics]') is not null)
begin
drop procedure [p_GetAlertThresholdsForNumerics]
end
go

CREATE proc [dbo].[p_GetAlertThresholdsForNumerics] 
@Metric int,
@Server int = null
as
begin
--script for getting numeric metric thresholds
declare @SQLServerID int, @ThresholdEnabled bit, @InfoThresholdXML nvarchar(1024), @WarningThresholdXML nvarchar(1024), @CriticalThresholdXML nvarchar(1024)
declare @AlertThresholds table(SQLServerID int, Op nvarchar(16), InfoThreshold int, WarningThreshold int, CriticalThreshold int) 
declare @InfoThresholdValue float, @WarningThresholdValue float, @CriticalThresholdValue float
declare @InfoThresholdEnabled bit, @WarningThresholdEnabled bit, @CriticalThresholdEnabled bit
declare @xmlDoc int
declare @Now datetime
declare @Op nvarchar(16)

-- build a table containing metric threshold values for each server that 
-- has a reorg alert (Metric)
declare read_threshold_entry insensitive cursor 
for
	select 
		SQLServerID, 
		Enabled, 
		InfoThreshold,
		WarningThreshold,
		CriticalThreshold
	from 
		MetricThresholds MT (nolock)
	where Metric = @Metric and SQLServerID=isnull(@Server,SQLServerID)
--		)
for read only
set nocount on 
open read_threshold_entry 
fetch read_threshold_entry into @SQLServerID, @ThresholdEnabled, @InfoThresholdXML, @WarningThresholdXML, @CriticalThresholdXML
while @@fetch_status = 0 
begin
	--print @SQLServerID
	if @ThresholdEnabled <> 0 
	begin
		exec sp_xml_preparedocument @xmlDoc output, @InfoThresholdXML
		select 
			@Op = Op,
			@InfoThresholdValue = Value,  
			@InfoThresholdEnabled = case when UPPER(Enabled) = N'TRUE' then 1 else 0 end  
			from openxml(@xmlDoc, '/Threshold', 3)
			with (Op nvarchar(16), Value float, Enabled nvarchar(16))
		exec sp_xml_removedocument @xmlDoc
		exec sp_xml_preparedocument @xmlDoc output, @WarningThresholdXML
		select 
			@Op = Op,
			@WarningThresholdValue = Value,  
			@WarningThresholdEnabled = case when UPPER(Enabled) = N'TRUE' then 1 else 0 end  
			from openxml(@xmlDoc, '/Threshold', 3)
			with (Op nvarchar(16), Value float, Enabled nvarchar(16))
		exec sp_xml_removedocument @xmlDoc
		exec sp_xml_preparedocument @xmlDoc output, @CriticalThresholdXML
		select
			@Op = Op,
			@CriticalThresholdValue = Value,
			@CriticalThresholdEnabled = case when UPPER(Enabled) = N'TRUE' then 1 else 0 end  
			from openxml(@xmlDoc, '/Threshold', 3)
			with (Op nvarchar(16), Value float, Enabled nvarchar(16))
		exec sp_xml_removedocument @xmlDoc

		if @InfoThresholdEnabled = 0
			select @InfoThresholdValue = 9999
		if @WarningThresholdEnabled = 0
			select @WarningThresholdValue = 9999
		if @CriticalThresholdEnabled = 0
			select @CriticalThresholdValue = 9999

		if (@InfoThresholdEnabled <> 0 or @WarningThresholdEnabled <> 0 or @CriticalThresholdEnabled <> 0)
			insert into @AlertThresholds (SQLServerID, Op, InfoThreshold, WarningThreshold, CriticalThreshold)
				values(@SQLServerID, @Op, @InfoThresholdValue, @WarningThresholdValue, @CriticalThresholdValue)
	end

	fetch read_threshold_entry into @SQLServerID, @ThresholdEnabled, @InfoThresholdXML, @WarningThresholdXML, @CriticalThresholdXML
end
Close read_threshold_entry 
deallocate read_threshold_entry 

select @Metric as 'MetricID', SQLServerID, Op, InfoThreshold, WarningThreshold, CriticalThreshold from @AlertThresholds
end
 
GO 

---------- P_GETALLAUDITABLEEVENTS.SQL
/****** Object:  StoredProcedure [dbo].[p_GetAllAuditableEvents]    Script Date: 02/07/2013 10:44:04 ******/
if (object_id('p_GetAllAuditableEvents') is not null)
begin
drop procedure p_GetAllAuditableEvents
end
go

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [dbo].[p_GetAllAuditableEvents]
	@UTCStart DateTime,
	@UTCEnd DateTime
AS
BEGIN
  SELECT TOP 1000
	  [AuditableEventID]
	  ,AE.[ActionID]
	  ,[Action] = AA.Name
      ,[DateTime]
      ,[Workstation]
      ,[WorkstationUser]
      ,[SQLUser]
      ,AE.[Name]
      ,[MetaData]
      ,[Header]
  FROM [dbo].[AuditableEvents] AE, [dbo].[AuditableActions] AA
  WHERE AE.ActionID = AA.ActionID 
  AND  [DateTime] BETWEEN @UTCStart and @UTCEnd
  ORDER BY [DateTime] desc
  
end
 
GO 

---------- P_GETALLBASELINESDATA.SQL
IF (object_id('p_GetAllBaselinesData') IS NOT NULL)
BEGIN
DROP PROCEDURE p_GetAllBaselinesData
END
GO

CREATE PROCEDURE [dbo].p_GetAllBaselinesData
	@SQLServerId INT,
	@endTime DATETIME,
	@HistoryInSeconds INT
AS
BEGIN
	
	DECLARE @startTime DATETIME 
	SET @startTime = DATEADD(SECOND,@HistoryInSeconds*-1,@endTime)
	
	SELECT MetricID,Value,UTCCalculation FROM 
	(
	SELECT MetricID,(Mean+StdDeviation) AS Value,@startTime AS UTCCalculation FROM (SELECT MetricID, Mean,StdDeviation,UTCCalculation,ROW_NUMBER() OVER(PARTITION BY MetricID ORDER BY UTCCalculation DESC) RowNum
	FROM BaselineStatistics WHERE SQLServerID = @SQLServerId AND MetricID IN (-1003,-127,-126,-125,-124,-116,-112,-111,-110,-109,-71,-70,0,13,25,26,27,28,29,30,31,76,81,98) AND UTCCalculation <=@startTime) T WHERE T.RowNum = 1
	UNION
	SELECT MetricID,(Mean+StdDeviation) AS Value,UTCCalculation FROM BaselineStatistics WHERE SQLServerID = @SQLServerId AND MetricID IN (-1003,-127,-126,-125,-124,-116,-112,-111,-110,-109,-71,-70,0,13,25,26,27,28,29,30,31,76,81,98) AND UTCCalculation BETWEEN @startTime AND @endTime
	UNION
	SELECT MetricID,(Mean+StdDeviation) AS Value,@endTime AS UTCCalculation FROM (SELECT MetricID, Mean,StdDeviation,UTCCalculation,ROW_NUMBER() OVER(PARTITION BY MetricID ORDER BY UTCCalculation DESC) RowNum
	FROM BaselineStatistics WHERE SQLServerID = @SQLServerId AND MetricID IN (-1003,-127,-126,-125,-124,-116,-112,-111,-110,-109,-71,-70,0,13,25,26,27,28,29,30,31,76,81,98) AND UTCCalculation <=@endTime) T WHERE T.RowNum = 1
	) Final 
	ORDER BY MetricID,UTCCalculation


END
 
GO 

---------- P_GETALLCATEGORIES.SQL
if (object_id('p_GetAllCategories') is not null)
begin
drop procedure [p_GetAllCategories]
end
go

-- SQLdm 10.0 Srishti Purohit Doctor implementation in DM
create procedure [p_GetAllCategories] 

AS
BEGIN
-- Get real categories count
SELECT ((SELECT count (*) FROM PrescriptiveRecommendationCategory)- COUNT(DISTINCT(category1.ParentCategory) )) AS categoryCount
FROM PrescriptiveRecommendationCategory category1, PrescriptiveRecommendationCategory category2  WHERE category1.ParentCategory = category2.CategoryID

	
		-- check if records for recommendation

		
SELECT category1.CategoryID, category1.Name, category2.Name AS Parent, category1.Description 
FROM PrescriptiveRecommendationCategory category1, PrescriptiveRecommendationCategory category2  WHERE category1.ParentCategory = category2.CategoryID 

UNION
SELECT CategoryID, Name , NULL AS Parent, category1.Description 
FROM PrescriptiveRecommendationCategory category1 WHERE category1.ParentCategory IS NULL

ORDER BY Parent ASC
		
if(@@ERROR <> 0)
BEGIN
	 Print 'Error occured while getting categories.'
	  -- Any Error Occurred during Transaction. Rollback
	   RAISERROR ('Error occured while getting categories.',
             16,
             1)
END

END
 
GO 
 
GO 

---------- P_GETALLDISKS.SQL
-- SQLdm 9.1 (Abhishek Joshi)

-- Filegroup and Mountpoint Monitoring Improvements
-- retrieves all the disks corresponding to a SQL Server

-- exec p_GetAllDisks  @SQLServerID = 14

if (object_id('p_GetAllDisks') is not null)
begin
	drop procedure [p_GetAllDisks]
end
go

create procedure [dbo].[p_GetAllDisks]
	@SQLServerID int = null
as
begin
	
	select 
		distinct SQLServerID,
		DriveName
	from 
		DiskDriveStatistics
	where
		SQLServerID = (case when @SQLServerID is null then SQLServerID else @SQLServerID end)

end
go
 
GO 

---------- P_GETALLMETRICSALERTSNAME.SQL
if (object_id('p_GetAllMetricsAlertsName') is not null)
begin
drop procedure [p_GetAllMetricsAlertsName]
end
go

CREATE procedure [dbo].[p_GetAllMetricsAlertsName]
(
	@SQLServerListID nvarchar(MAX)
)
AS
BEGIN
	DECLARE @err INT
	DECLARE @Now datetime
	DECLARE @ServerList TABLE(ServerId INT)
	DECLARE @xmlDoc INT 

	IF (@SQLServerListID IS NOT NULL)
	BEGIN
		EXEC sp_xml_preparedocument @xmlDoc OUTPUT, @SQLServerListID

		INSERT INTO @ServerList	
		SELECT ServerId
			FROM openxml(@xmlDoc, '//Server', 1) WITH (ServerId INT) 

		EXEC sp_xml_removedocument @xmlDoc
	END
	
	SET @Now = GetUTCDate()
	
	SELECT DISTINCT MT.[Metric],MI.[Name] 
		FROM MetricThresholds MT (nolock) 
		INNER JOIN MetricInfo MI (nolock) ON MI.[Metric] = MT.[Metric]
	WHERE
	(MT.SQLServerID IN(SELECT ServerId FROM @ServerList)) AND
	(UTCSnoozeEnd > @Now)
	
	SELECT @err = @@error

	RETURN @err
END
 
 
GO 

---------- P_GETALWAYSONAGBASEDACTIVESERVERS.SQL
------------------------------------------------------------------------------
-- <copyright file="p_GetAlwaysOnAGBasedActiveServers" company="Idera, Inc.">
--     Copyright (c) Idera, Inc. All rights reserved.
-- </copyright>
------------------------------------------------------------------------------

IF (object_id('p_GetAlwaysOnAGBasedActiveServers') is not null)
BEGIN
DROP PROCEDURE [p_GetAlwaysOnAGBasedActiveServers]
END
GO
CREATE PROCEDURE [dbo].[p_GetAlwaysOnAGBasedActiveServers]
				@tagId int = 0
AS
BEGIN
	
	SET NOCOUNT ON;
	
	IF (object_id('#SecureMonitoredSQLServers') IS NOT NULL)
	BEGIN
	    DROP TABLE #SecureMonitoredSQLServers
	END
	CREATE TABLE #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

	INSERT INTO #SecureMonitoredSQLServers
	EXEC [p_GetReportServers]
	
	DECLARE @AvailabilityGroup TABLE (GroupName nvarchar(510), GroupId uniqueidentifier)
	
	IF @tagId = 0
	BEGIN
		INSERT @AvailabilityGroup
		
			SELECT		DISTINCT
							AOG.[GroupName],
							AOG.[GroupId]
						FROM 
							AlwaysOnAvailabilityGroups AS AOG (nolock)
							INNER JOIN AlwaysOnReplicas AS AOR (nolock) on AOG.[GroupId] = AOR.[GroupId]
							INNER JOIN #SecureMonitoredSQLServers AS mss on mss.[SQLServerID] = AOR.[SQLServerID]
						WHERE
							AOG.[Active] = 1 
							AND AOR.[Delete] = 0
	END
	ELSE
	BEGIN
		INSERT @AvailabilityGroup
		
			SELECT		DISTINCT
							AOG.[GroupName],
							AOG.[GroupId]
						FROM 
							AlwaysOnAvailabilityGroups AS AOG (nolock)
							INNER JOIN AlwaysOnReplicas AS AOR (nolock) on AOG.[GroupId] = AOR.[GroupId]
							INNER JOIN #SecureMonitoredSQLServers AS mss on mss.[SQLServerID] = AOR.[SQLServerID]
							INNER JOIN ServerTags AS st (nolock) ON AOR.SQLServerID=st.SQLServerId
						WHERE
							AOG.[Active] = 1 
							AND AOR.[Delete] = 0
							AND @tagId = st.TagId
	END
				    
    IF @@rowcount = 0
		SELECT '< No Availability Groups >' AS GroupName, '00000000-0000-0000-0000-000000000000' AS GroupId
	ELSE
		SELECT GroupName, GroupId FROM @AvailabilityGroup
END
 
GO 

---------- P_GETALWAYSONAVAILABILITYREPLICA.SQL
------------------------------------------------------------------------------
-- <copyright file="p_GetAlwaysOnAvailabilityReplica" company="Idera, Inc.">
--     Copyright (c) Idera, Inc. All rights reserved.
-- </copyright>
------------------------------------------------------------------------------
IF (object_id('p_GetAlwaysOnAvailabilityReplica') is not null)
BEGIN
DROP PROCEDURE [p_GetAlwaysOnAvailabilityReplica]
END
GO
CREATE PROCEDURE [dbo].[p_GetAlwaysOnAvailabilityReplica]
				@AvailabilityGroup nvarchar(128)
AS
BEGIN

    -- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	IF (object_id('#SecureMonitoredSQLServers') IS NOT NULL)
	BEGIN
	    DROP TABLE #SecureMonitoredSQLServers
	END
	CREATE TABLE #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

	INSERT INTO #SecureMonitoredSQLServers
	EXEC [p_GetReportServers]
	
	IF @AvailabilityGroup='< All >'
	BEGIN
	
		SELECT DISTINCT	[AOG].[GroupName] AS GroupName,
						[AOR].[ReplicaName] AS RepliclaName,
						[AOR].[FailoverMode] AS FailoverMode,
						[AOR].[AvailabilityMode] AS AvailabilityMode,
						[AOR].[SecondaryConnectionMode] AS SecondConnMode,
						[AOR].[ReplicaRole] as ReplicaRole
						
			FROM		AlwaysOnAvailabilityGroups AS AOG (nolock)
						INNER JOIN AlwaysOnReplicas AS AOR (nolock) on [AOG].[GroupId]=[AOR].[GroupId]
						INNER JOIN #SecureMonitoredSQLServers AS smss on AOR.[SQLServerID] = smss.[SQLServerID]
			
			WHERE		AOR.[Delete] = 0
			
	END
	ELSE
	BEGIN
		SELECT DISTINCT [AOG].[GroupName] AS GroupName,
						[AOR].[ReplicaName] AS RepliclaName,
						[AOR].[FailoverMode] AS FailoverMode,
						[AOR].[AvailabilityMode] AS AvailabilityMode,
						[AOR].[SecondaryConnectionMode] AS SecondConnMode,
						[AOR].[ReplicaRole] as ReplicaRole
						
			FROM		AlwaysOnAvailabilityGroups AS AOG (nolock)
						INNER JOIN AlwaysOnReplicas AS AOR (nolock) on [AOG].[GroupId]=[AOR].[GroupId]
						INNER JOIN #SecureMonitoredSQLServers AS smss on AOR.[SQLServerID] = smss.[SQLServerID]
						
			WHERE		@AvailabilityGroup=[AOG].[GroupName]
						AND AOR.[Delete] = 0
			  
	END
END
 
GO 

---------- P_GETALWAYSONDATABASES.SQL
------------------------------------------------------------------------------
-- <copyright file="p_GetAlwaysOnDatabases.sql" company="Idera, Inc.">
--     Copyright (c) Idera, Inc. All rights reserved.
-- </copyright>
------------------------------------------------------------------------------

IF (object_id('p_GetAlwaysOnDatabases') is not null)
BEGIN
DROP PROCEDURE [p_GetAlwaysOnDatabases]
END
GO
CREATE PROCEDURE [dbo].[p_GetAlwaysOnDatabases]
				@AvailabilityGroup nvarchar(256)
AS
BEGIN

    -- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	IF (object_id('#SecureMonitoredSQLServers') IS NOT NULL)
	BEGIN
	    DROP TABLE #SecureMonitoredSQLServers
	END
	CREATE TABLE #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

	INSERT INTO #SecureMonitoredSQLServers
	EXEC [p_GetReportServers]

	DECLARE @GroupReplicaLastUpdate table(
				GroupName sysname
				,ReplicaName nvarchar(256)
				,UTCCollectionDateTime datetime)
				
	INSERT INTO @GroupReplicaLastUpdate

		SELECT			[AOG].[GroupName] AS GroupName,
						[AOR].[ReplicaName] AS RepliclaName,
						
						MAX([AOS].[UTCCollectionDateTime])
						
			FROM		AlwaysOnAvailabilityGroups AS AOG (nolock)
						INNER JOIN AlwaysOnReplicas AS AOR (nolock) on [AOG].[GroupId]=[AOR].[GroupId]
						INNER JOIN AlwaysOnStatistics AS AOS (nolock) on [AOG].[GroupId]=[AOS].[GroupId] AND [AOR].[ReplicaId] = [AOS].[ReplicaId]
			
			GROUP BY	GroupName,
						ReplicaName
						
	IF @AvailabilityGroup='< All >'
	BEGIN
		SELECT DISTINCT [AOR].[ReplicaName] AS RepliclaName,
						[AOD].[DatabaseName] AS DatabaseName,
						[AOS].[IsFailoverReady] AS FailoverReady,
						[AOS].[SynchronizationState] AS SynchronizationState
						
			FROM		AlwaysOnReplicas AS AOR (nolock)
						INNER JOIN AlwaysOnDatabases AS AOD (nolock) on [AOR].[ReplicaId]=[AOD].[ReplicaId]
						INNER JOIN AlwaysOnStatistics AS AOS (nolock) on [AOD].[ReplicaId]=[AOS].[ReplicaId]
																	AND [AOD].[GroupId]=[AOS].[GroupId]
																	AND [AOD].[DatabaseID]=[AOS].[DatabaseId]
						INNER JOIN AlwaysOnAvailabilityGroups AS AOG (nolock) on [AOG].[GroupId] = [AOS].[GroupId]
						INNER JOIN #SecureMonitoredSQLServers AS smss (nolock) on smss.[SQLServerID] = AOR.[SQLServerID]
						JOIN @GroupReplicaLastUpdate AS grlu on grlu.[UTCCollectionDateTime] = [AOS].[UTCCollectionDateTime]
						
			WHERE		AOR.[Delete] = 0
		  
	END
	ELSE
	BEGIN
		SELECT DISTINCT [AOR].[ReplicaName] AS RepliclaName,
						[AOD].[DatabaseName] AS DatabaseName,
						[AOS].[IsFailoverReady] AS FailoverReady,
						[AOS].[SynchronizationState] AS SynchronizationState
						
			FROM		AlwaysOnReplicas AS AOR (nolock)
						INNER JOIN AlwaysOnDatabases AS AOD (nolock) on [AOR].[ReplicaId]=[AOD].[ReplicaId]
						INNER JOIN AlwaysOnStatistics AS AOS (nolock) on [AOD].[ReplicaId]=[AOS].[ReplicaId]
																	AND [AOD].[GroupId]=[AOS].[GroupId]
																	AND [AOD].[DatabaseID]=[AOS].[DatabaseId]
						INNER JOIN AlwaysOnAvailabilityGroups AS AOG (nolock) on [AOG].[GroupId] = [AOS].[GroupId]
						INNER JOIN #SecureMonitoredSQLServers AS smss (nolock) on smss.[SQLServerID] = AOR.[SQLServerID]
						JOIN @GroupReplicaLastUpdate AS grlu on grlu.[UTCCollectionDateTime] = [AOS].[UTCCollectionDateTime]
		
		WHERE			[AOG].[GroupName] = @AvailabilityGroup
						AND AOR.[Delete] = 0
	END

END
 
GO 

---------- P_GETALWAYSONDATABASESTATISTICS.SQL
------------------------------------------------------------------------------
-- <copyright file="p_GetAlwaysOnDatabaseStatistics" company="Idera, Inc.">
--     Copyright (c) Idera, Inc. All rights reserved.
-- </copyright>
------------------------------------------------------------------------------

IF (object_id('p_GetAlwaysOnDatabaseStatistics') is not null)
BEGIN
DROP PROCEDURE [p_GetAlwaysOnDatabaseStatistics]
END
GO
CREATE PROCEDURE [dbo].[p_GetAlwaysOnDatabaseStatistics]
				@AvailabilityGroup nvarchar(128),
				@ReplicaName nvarchar(256),
				@FailoverReadiness bit,
				@UTCStart DateTime,
				@UTCEnd DateTime,
				@UTCOffset int,
				@Interval tinyint
-- @Interval - Granularity of calculation:
--	0 - Minutes
--	1 - Hours
--	2 - Days
--	3 - Months
--	4 - Years
AS
BEGIN

    DECLARE @GroupId AS uniqueidentifier
    DECLARE @ReplicaId AS uniqueidentifier
    
    SELECT @GroupId = GroupId
            FROM [AlwaysOnAvailabilityGroups]
            WHERE @AvailabilityGroup = GroupName
    
    SELECT @ReplicaId = ReplicaId
            FROM [AlwaysOnReplicas]
            WHERE @GroupId = GroupId AND @ReplicaName = ReplicaName
	
		SELECT		DISTINCT 
					dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, AOS.[UTCCollectionDateTime]))) AS [DateTime]
					,AOD.DatabaseName AS [DatabaseName]
					,AOS.GroupId AS [GroupId]
					,AOS.ReplicaId AS [ReplicaId]
					,AOS.GroupDatabaseId AS [GroupDatabaseId]
					,sum(AOS.[RedoRate] * TimeDeltaInSeconds) / nullif(sum(case when AOS.[RedoRate] is not null then TimeDeltaInSeconds else 0 end),0) as [RedoRate]
					,sum(AOS.[RedoQueueSize] * TimeDeltaInSeconds)/nullif(sum(case when AOS.[RedoQueueSize]is not null then TimeDeltaInSeconds else 0 end),0) AS [RedoQueue]
					,sum(AOS.[LogSendRate] * TimeDeltaInSeconds) / nullif(sum(case when AOS.[LogSendRate] is not null then TimeDeltaInSeconds else 0 end),0) as [LogSendRate]
					,sum(AOS.[LogSedQueueSize] * TimeDeltaInSeconds) / nullif(sum(case when AOS.[LogSedQueueSize] is not null then TimeDeltaInSeconds else 0 end),0) as [LogSendQueue]
				FROM 
					[AlwaysOnStatistics] AS AOS (NOLOCK) 
					INNER JOIN [AlwaysOnDatabases] AS AOD (NOLOCK) on AOS.GroupId = AOD.GroupId 
                        AND AOS.ReplicaId = AOD.ReplicaId
						AND AOS.GroupDatabaseId = AOD.GroupDatabaseId
												
				WHERE dateadd(mi, @UTCOffset, AOS.[UTCCollectionDateTime]) BETWEEN @UTCStart AND @UTCEnd
				    AND @GroupId = AOS.GroupId
					AND @ReplicaId = AOS.ReplicaId
					AND @FailoverReadiness = AOS.IsFailoverReady

		GROUP BY
		AOD.DatabaseName
		,AOS.GroupId
		,AOS.ReplicaId
		,AOS.GroupDatabaseId		
END
 
GO 

---------- P_GETALWAYSONSTATISTICS.SQL
------------------------------------------------------------------------------
-- <copyright file="p_GetAlwaysOnStatistics.sql" company="Idera, Inc.">
--     Copyright (c) Idera, Inc. All rights reserved.
-- </copyright>
------------------------------------------------------------------------------

IF (object_id('p_GetAlwaysOnStatistics') is not null)
BEGIN
DROP PROCEDURE [p_GetAlwaysOnStatistics]
END
GO
CREATE PROCEDURE [dbo].[p_GetAlwaysOnStatistics]
				@SQLServerIDs nvarchar(max) = null,
				@AvailabilityGroup nvarchar(128),
				@UTCStart DateTime,
				@UTCEnd DateTime,
				@UTCOffset int,
				@Interval tinyint
-- @Interval - Granularity of calculation:
--	0 - Minutes
--	1 - Hours
--	2 - Days
--	3 - Months
--	4 - Years
AS
BEGIN
	DECLARE @xmlDoc int

	IF @SQLServerIDs is not null 
	BEGIN
		DECLARE @SQLServers table(
				SQLServerID int) 

		-- Prepare XML document if there is one
		EXEC sp_xml_preparedocument @xmlDoc output, @SQLServerIDs

		INSERT INTO @SQLServers
		SELECT ID 
		FROM openxml(@xmlDoc, '//Srvr', 1)
			with (ID int)
	END
	
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	IF (object_id('#SecureMonitoredSQLServers') IS NOT NULL)
	BEGIN
	    DROP TABLE #SecureMonitoredSQLServers
	END
	CREATE TABLE #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

	INSERT INTO #SecureMonitoredSQLServers
	EXEC [p_GetReportServers]
	
	SELECT		DISTINCT 
					dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, AOS.[UTCCollectionDateTime]))) AS [DateTime]
					,AOG.GroupName AS [AvailabilityGroups]
					,MS.InstanceName AS [Name]
					,AOR.ReplicaName AS [Replica]
					,AOS.IsFailoverReady AS [FailoverReadiness]
					,sum(AOS.[RedoRate] * TimeDeltaInSeconds) / nullif(sum(case when AOS.[RedoRate] is not null then TimeDeltaInSeconds else 0 end),0) as [RedoRate]
					,sum(AOS.[RedoQueueSize] * TimeDeltaInSeconds)/nullif(sum(case when AOS.[RedoQueueSize]is not null then TimeDeltaInSeconds else 0 end),0) AS [RedoQueue]
					,sum(AOS.[LogSendRate] * TimeDeltaInSeconds) / nullif(sum(case when AOS.[LogSendRate] is not null then TimeDeltaInSeconds else 0 end),0) as [LogSendRate]
					,sum(AOS.[LogSedQueueSize] * TimeDeltaInSeconds) / nullif(sum(case when AOS.[LogSedQueueSize] is not null then TimeDeltaInSeconds else 0 end),0) as [LogSendQueue]
				FROM 
						@SQLServers S 
						INNER JOIN [AlwaysOnReplicas] AS AOR on S.[SQLServerID] = [AOR].[SQLServerID]
						INNER JOIN [AlwaysOnStatistics] AS AOS on [AOR].[ReplicaId] = [AOS].[ReplicaId]
						INNER JOIN [AlwaysOnDatabases] AS AOD on [AOR].[ReplicaId] = [AOD].[ReplicaId]
															AND [AOR].[GroupId] = [AOD].[GroupId]
						INNER JOIN [AlwaysOnAvailabilityGroups] AS AOG on AOS.[GroupId] = [AOG].GroupId
						INNER JOIN #SecureMonitoredSQLServers AS MS on S.SQLServerID = MS.SQLServerID
						
				WHERE AOS.[UTCCollectionDateTime] BETWEEN @UTCStart AND @UTCEnd
						  AND @AvailabilityGroup = AOG.GroupName
						  AND dbo.fn_RoundDateTime(@Interval, AOS.[UTCCollectionDateTime]) between @UTCStart and @UTCEnd
		GROUP BY
		AOG.GroupName
		,MS.InstanceName
		,AOR.ReplicaName
		,AOS.IsFailoverReady
		-- Always group by year at the least
		,datepart(yy, dateadd(mi, @UTCOffset, AOS.[UTCCollectionDateTime]))
		-- Group by all intervals greater than or equal to the selected interval
		,case when @Interval <= 3 then datepart(mm,dateadd(mi, @UTCOffset, AOS.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, AOS.[UTCCollectionDateTime])) end
		,case when @Interval <= 2 then datepart(dd,dateadd(mi, @UTCOffset, AOS.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, AOS.[UTCCollectionDateTime])) end
		,case when @Interval <= 1 then datepart(hh,dateadd(mi, @UTCOffset, AOS.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, AOS.[UTCCollectionDateTime])) end
		,case when @Interval =  0 then datepart(mi,dateadd(mi, @UTCOffset, AOS.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, AOS.[UTCCollectionDateTime])) end
END
				
 
GO 

---------- P_GETANALYSISACTIVITY.SQL
if (object_id('p_GetAnalysisActivity') is not null)
begin
drop procedure p_GetAnalysisActivity
end
go
create procedure p_GetAnalysisActivity
	@SQLServerID int,
	@StartDateTime datetime = null,
	@EndDateTime datetime = null,
	--@ColumnBitMask int = 7, -- SQLServerID + UTCCollectionDateTime + StateOverview 
	@RefreshType int = 0
as
begin

-- column bit mask
-- 1   = SQLServerID (always returned)
-- 2   = UTCCollectionDateTime (always returned)
-- 4   = StateOverview
-- 8   = SystemProcesses
-- 16  = SessionList
-- 32  = LockStatistics
-- 64  = LockList
-- 128 = ResponseTime

declare @err int
declare @start datetime
declare @end datetime

select @start = @StartDateTime
if (@start is null)
	select @start = min(UTCAnalysisCompleteTime) from PrescriptiveAnalysis (NOLOCK) where [SQLServerID] = @SQLServerID

select @end = @EndDateTime
if (@end is null)
	select @end = max(UTCAnalysisCompleteTime) from PrescriptiveAnalysis (NOLOCK)  where [SQLServerID] = @SQLServerID

-- if no timestamp is supplied then return list of available snapshots
--if (@ColumnBitMask & 128 = 0)
begin
	SELECT 
		[SQLServerID],
		UTCAnalysisCompleteTime,
		null
	FROM PrescriptiveAnalysis (NOLOCK)
	WHERE [SQLServerID] = @SQLServerID and 
		UTCAnalysisCompleteTime >= @start and
		UTCAnalysisCompleteTime <= @end
	ORDER BY UTCAnalysisCompleteTime
end
--else
--begin
--	SELECT 
--		[ServerActivity].[SQLServerID],
--		[ServerActivity].[UTCCollectionDateTime],
--		case when @ColumnBitMask & 4 <> 0 then [ServerActivity].[StateOverview] else null end,
--		case when @ColumnBitMask & 8 <> 0 then [ServerActivity].[SystemProcesses] else null end,
--		case when @ColumnBitMask & 16 <> 0 then [ServerActivity].[SessionList] else null end,
--		case when @ColumnBitMask & 32 <> 0 then [ServerActivity].[LockStatistics] else null end,
--		case when @ColumnBitMask & 64 <> 0 then [ServerActivity].[LockList] else null end,
--		[ServerStatistics].[ResponseTimeInMilliseconds]
--	FROM [ServerActivity] (NOLOCK)
--	LEFT JOIN [ServerStatistics] (NOLOCK) ON 
--		[ServerStatistics].[SQLServerID] = [ServerActivity].[SQLServerID] and
--		[ServerStatistics].[UTCCollectionDateTime] = [ServerActivity].[UTCCollectionDateTime]
--	WHERE [ServerActivity].[SQLServerID] = @SQLServerID and 
--		isnull([RefreshType],0) = @RefreshType and
--		[ServerActivity].[UTCCollectionDateTime] >= @start and
--		[ServerActivity].[UTCCollectionDateTime] <= @end
--	ORDER BY [ServerActivity].[UTCCollectionDateTime]
--end

SELECT @err = @@error
	
RETURN @err

end
 
GO 

---------- P_GETAPPLICATIONSFORSERVER.SQL
--retrieves those applications which fired at least 
-- one query on the given instance

-- @SQLServerID is the Instance ID
-- @StartIndex is the index from where applications needs to be retrieved
-- @RecordsCount is the number of applications to be retrieved

-- exec p_GetApplicationsForServer 9,2,3

if (object_id('p_GetApplicationsForServer') is not null)
begin
	drop procedure [p_GetApplicationsForServer]
end
go

create procedure [dbo].[p_GetApplicationsForServer]
	@SQLServerID int,
	@StartIndex int = 1,
	@RecordsCount int = -1
as
begin
	IF (@RecordsCount = -1)
		SELECT
			DISTINCT QMS.ApplicationNameID,
			AN.ApplicationName
		FROM
			[QueryMonitorStatistics] AS QMS 
			INNER JOIN 
			[ApplicationNames] AS AN 
			ON QMS.ApplicationNameID = AN.ApplicationNameID
		WHERE
			QMS.SQLServerID = @SQLServerID
		ORDER BY
			AN.ApplicationName
	ELSE
		begin
			WITH AppNames AS
			(
				SELECT
					DISTINCT QMS.ApplicationNameID,
					AN.ApplicationName,
					DENSE_RANK() OVER (ORDER BY AN.ApplicationName) AS RecordRank
				FROM
					[QueryMonitorStatistics] AS QMS 
					INNER JOIN 
					[ApplicationNames] AS AN 
					ON QMS.ApplicationNameID = AN.ApplicationNameID
				WHERE
					QMS.SQLServerID = @SQLServerID
				
			)

			SELECT
				ApplicationNameID,
				ApplicationName
			FROM
				AppNames
			WHERE
				RecordRank BETWEEN @StartIndex AND (@StartIndex + @RecordsCount - 1)
				ORDER BY
					ApplicationName
		end
end
go
 
GO 

---------- P_GETAVAILBILITYGROUPS.SQL
if (object_id('p_GetAvailbilityGroups') is not null)
begin
drop procedure p_GetAvailbilityGroups
end
go
--Ankit Nagpal SQLDM 10.0.0 
CREATE PROCEDURE [dbo].[p_GetAvailbilityGroups]
@SQLServerId int,
@StartTime datetime , 
@EndTime datetime

AS
BEGIN

declare @BeginDateTime datetime
declare @EndDateTime datetime

select @EndDateTime = @EndTime

select @BeginDateTime = @StartTime;

WITH AVGs (GroupId, GroupName , ServerSourceName ,ListenerDnsName ,ListenerIpAddress , ListenerPort) AS 
(SELECT DISTINCT aog.GroupId, aog.GroupName , aog.ServerSourceName , aog.ListenerDnsName , aog.ListenerIpAddress , aog.ListenerPort
	FROM AlwaysOnAvailabilityGroups aog WITH(NOLOCK)
	INNER JOIN AlwaysOnReplicas aor  WITH(NOLOCK) ON aor.GroupId = aog.GroupId
	WHERE aor.SQLServerID = @SQLServerId AND aor.Active = 1 AND aor.[Delete] = 0 AND aog.Active = 1 AND aog.[Delete] = 0)

SELECT		DISTINCT 			
			AOG.GroupName,
			AOG.GroupId , 
			AOG.ServerSourceName ,
			AOG.ListenerDnsName ,
			AOG.ListenerIpAddress ,
			AOG.ListenerPort    
			,aor.ReplicaName
			,aor.ReplicaRole
			,aor.ReplicaId
			,aor.SQLServerID
			,aor.FailoverMode
			,aor.AvailabilityMode
			,aor.PrimaryConnectionMode
			,aor.SecondaryConnectionMode
			,AOS.SynchronizationHealth
			,isnull(AOS.DatabaseState,0) AS [DatabaseState]
			,sum(AOS.[RedoRate] * TimeDeltaInSeconds) / nullif(sum(case when AOS.[RedoRate] is not null then TimeDeltaInSeconds else 0 end),0) as [RedoRate]
			,sum(AOS.[RedoQueueSize] * TimeDeltaInSeconds)/nullif(sum(case when AOS.[RedoQueueSize]is not null then TimeDeltaInSeconds else 0 end),0) AS [RedoQueue]
			,sum(AOS.[LogSendRate] * TimeDeltaInSeconds) / nullif(sum(case when AOS.[LogSendRate] is not null then TimeDeltaInSeconds else 0 end),0) as [LogSendRate]
			,sum(AOS.[LogSedQueueSize] * TimeDeltaInSeconds) / nullif(sum(case when AOS.[LogSedQueueSize] is not null then TimeDeltaInSeconds else 0 end),0) as [LogSendQueue]
			,AOS.UTCCollectionDateTime
			,AOS.AlwaysOnStatisticsID
			,AOS.DatabaseId
			,AOS.IsFailoverReady
			,AOS.SynchronizationState
			,AOS.SynchronizationHealth
			,AOS.DatabaseState
			,AOS.IsSuspended
			,AOS.LastHardenedTime
			,AOS.OperationalState
			,AOS.ConnectedState
			,AOS.SynchronizationHealthAvailabilityReplica
			,AOS.LastConnectErrorNumber
			,AOS.LastConnectErrorDescription
			,AOS.LastConnectErrorTimestamp
			,AOS.EstimatedDataLossTime
			,AOS.SynchronizationPerformance
			,AOS.FilestreamSendRate
			,AOS.EstimatedRecoveryTime
			,AOS.GroupDatabaseId
			,AOD.AlwaysOnDatabasesID
			,AOD.DatabaseName
			,AOD.ServerSourceName
		FROM 
			AlwaysOnReplicas aor 			
			INNER JOIN AVGs AS AOG (NOLOCK)
			ON AOG.GroupId = aor.GroupId
			INNER JOIN [AlwaysOnDatabases] AS AOD (NOLOCK) ON AOG.GroupId = AOD.GroupId AND aor.ReplicaId = AOD.ReplicaId
			LEFT OUTER JOIN [AlwaysOnStatistics] AS AOS (NOLOCK) 
				on AOS.GroupId = AOG.GroupId AND AOS.ReplicaId = aor.ReplicaId
		WHERE (AOS.UTCCollectionDateTime IS NULL  OR AOS.UTCCollectionDateTime between @BeginDateTime and @EndDateTime)
		GROUP BY
			AOG.GroupName,
			AOG.GroupId,AOG.ServerSourceName ,
			AOG.ListenerDnsName ,
			AOG.ListenerIpAddress ,
			AOG.ListenerPort 
			,aor.ReplicaId 
			,aor.ReplicaName
			,aor.ReplicaRole
			,aor.SQLServerID
			,aor.FailoverMode
			,aor.AvailabilityMode
			,aor.PrimaryConnectionMode
			,aor.SecondaryConnectionMode
			,AOS.AlwaysOnStatisticsID
			,AOS.SynchronizationHealth
			,AOS.DatabaseState	
			,AOS.UTCCollectionDateTime
			,AOS.DatabaseId
			,AOS.IsFailoverReady
			,AOS.SynchronizationState
			,AOS.SynchronizationHealth
			,AOS.DatabaseState
			,AOS.IsSuspended
			,AOS.LastHardenedTime
			,AOS.OperationalState
			,AOS.ConnectedState
			,AOS.SynchronizationHealthAvailabilityReplica
			,AOS.LastConnectErrorNumber
			,AOS.LastConnectErrorDescription
			,AOS.LastConnectErrorTimestamp
			,AOS.EstimatedDataLossTime
			,AOS.SynchronizationPerformance
			,AOS.FilestreamSendRate
			,AOS.EstimatedRecoveryTime
			,AOS.GroupDatabaseId
			,AOD.AlwaysOnDatabasesID
			,AOD.DatabaseName
			,AOD.ServerSourceName
			ORDER BY AOS.UTCCollectionDateTime DESC
END
 


GO
 
GO 

---------- P_GETBASELINECHECKTHRESHOLDDEVIATION.SQL
-- SQLdm 10.0 (Srishti Purohit)

-- Get Baseline Stddeviation and mean to calculated difference from base line threshold
-- retrieves the Baseline by Instance ID
-- according to the set filters

-- exec p_GetBaselineCheckThresholdDeviation		        @InstanceID = '1'

IF (object_id('p_GetBaselineCheckThresholdDeviation') is not null)
BEGIN
	DROP PROCEDURE [p_GetBaselineCheckThresholdDeviation]
END
GO


CREATE PROCEDURE [dbo].[p_GetBaselineCheckThresholdDeviation] (@InstanceID INT)
AS

BEGIN

SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	
-- Read metric data from MetricInfo table.
-- Read MetricMetaData to determine info where Metric is stored.

;WITH BaselineDataRankWise(Mean, StdDeviation, MetricID,  UTCCalculation,RankMetric)
AS (select Mean, StdDeviation, MetricID,  UTCCalculation,Rank() over (Partition BY MetricID order by UTCCalculation DESC) as RankMetric
from 
BaselineStatistics WHERE SQLServerID = @InstanceID)

SELECT  
	M.Metric AS MetricID, 
	M.Name AS MetricName,
	BD.Mean + BD.StdDeviation AS Mean,
	ISNULL(BD.UTCCalculation, GETDATE()) AS UTCCalculation

FROM BaselineMetaData B 
	JOIN MetricInfo M ON B.MetricID = M.Metric
	LEFT OUTER JOIN BaselineDataRankWise BD ON M.Metric = BD.MetricID
	 
WHERE RankMetric = 1 OR RankMetric IS NULL

END
 
GO
 
GO 

---------- P_GETBASELINEDATAFORONEWEEK.SQL
IF (object_id('p_GetBaselineDataForOneWeek') IS NOT NULL)
BEGIN
DROP PROCEDURE [p_GetBaselineDataForOneWeek]
END
GO

CREATE PROCEDURE [dbo].[p_GetBaselineDataForOneWeek]
	@SQLServerId int,
	@ItemId int, 
	@StartDate datetime,
	@EndDate datetime
AS
BEGIN
	DECLARE @tableName nvarchar(256)
	DECLARE @columnName nvarchar(256)

	SELECT @tableName=StatisticTable,@columnName=MetricValue FROM BaselineMetaData WHERE ItemID = @ItemId

	DECLARE @sqlQuery nvarchar(512)
	SET @sqlQuery = 'SELECT '+@columnName+' AS Value,UTCCollectionDateTime FROM '+@tableName+' WHERE SQLServerID = '+CONVERT(nvarchar(10),@SQLServerId)+' and UTCCollectionDateTime > '''+Convert(nvarchar(20),@StartDate,120)+''' and UTCCollectionDateTime <= '''+Convert(nvarchar(20),@EndDate,120)+''' and '+@columnName+' IS NOT NULL ORDER BY UTCCollectionDateTime'
	
	EXECUTE sp_executesql @sqlQuery
END

GO
 
GO 

---------- P_GETBASELINEMETADATA.SQL
if (object_id('[p_GetBaselineMetaData]') is not null)
begin
drop procedure p_GetBaselineMetaData
end
go

create procedure [dbo].p_GetBaselineMetaData
as
begin
	declare @err int

select 
	 [ItemID]
	,[Name]
	,[Description]
	,[Category]
	,[Unit]
	,[Format]
	,[NullFormat]
	,[MetricID]
	,[StatisticTable]
	,[MetricValue]
	,[Decimals]
	,[LLimit]
	,[ULimit]
	,[Scale]
	from
		[BaselineMetaData]
	where [Name] is not null
union
select 
	CCD.Metric
	,MI.Name
	,MI.Description
	,MI.Category
	,NULL
	,'{0:G;0} - {1:G;0} {2}'
	,'0 {2}'
	,CCD.Metric
	,'@CustomCounters S left outer join [CustomCounterStatistics] CCS 
		on S.SQLServerID = CCS.SQLServerID and S.Metric = CCS.MetricID' 
--	,'[CustomCounterMap] S left outer join [CustomCounterStatistics] CCS 
--		on S.SQLServerID = CCS.SQLServerID and S.Metric = CCS.MetricID'
	,case when CCD.CalculationType = 0 then 'RawValue' else 'DeltaValue' end
	,2
	,NULL
	,NULL
	,Convert(dec(31,9),CCD.Scale)
	from 
		CustomCounterDefinition CCD, MetricInfo MI
	where  CCD.Metric = MI.Metric 
		   and CCD.Enabled = 1
	order by [StatisticTable],[ItemID]

	select @err = @@ERROR

	return @err 
end
 
GO 

---------- P_GETBASELINEMETRICS.SQL
if (object_id('p_GetBaselineMetrics') is not null)
begin
drop procedure p_GetBaselineMetrics
end
go
CREATE PROCEDURE [dbo].[p_GetBaselineMetrics]
	@SendDefault tinyint = 1-- 0 No, 1 Yes
AS
BEGIN
--We need to match the UNIT of BaselineMetaData with UNIT on p_GetBaselineStatisticsReport (KB to MB, MB to GB)
DECLARE @UpdatedMetricUnit TABLE(
    [Name] nvarchar(128),
    [MetricValue] nvarchar(128),
    [Unit] nvarchar(32),
	[MetricID] int
);
IF(@SendDefault = 1)
BEGIN
	INSERT INTO @UpdatedMetricUnit VALUES('< Select a Value >',NULL,NULL,-1)
END;
INSERT @UpdatedMetricUnit
SELECT Name, 
		MetricValue,
		Unit = (SELECT CASE [Unit]
					When 'KB' THEN 'MB'
					When 'MB' THEN 'GB'
					When 'Milliseconds' THEN CASE When [MetricID] = 22 OR [MetricID] = -93 OR [MetricID] = -100 OR [MetricID] = -101 THEN 'Milliseconds' ELSE 'Seconds' END -- We need to add Response Time, VM CPU Swap Wait, VM CPU Ready to the exception
					When 'Seconds' THEN CASE When [MetricID] = 76 OR [MetricID] = 17 THEN 'Seconds' ELSE 'Minutes' END -- We need to add PageLifeExpectancy and Replication Latency to the exception
					ELSE [Unit]
					END),
		MetricID FROM BaselineMetaData
--Now we concat the metric name and unit to avoid display duplicated metric names
SELECT [MetricID], isnull([Name], [MetricValue]) + isnull(' ('+[Unit]+ ')', '') AS Name
	FROM @UpdatedMetricUnit
	WHERE [MetricID] IS NOT NULL
	ORDER BY [Name] ASC
END
 
 
GO 

---------- P_GETBASELINEPARAMETERS.SQL
if (object_id('p_GetBaselineParameters') is not null)
begin
drop procedure p_GetBaselineParameters
end
go
CREATE PROCEDURE [dbo].[p_GetBaselineParameters](
	@SQLServerID int,
	@UseDefaults bit output,
	@StartDate datetime output,
	@EndDate datetime output,
	@Days tinyint output,
	@EarliestStatisticsAvailable datetime output
)
AS
BEGIN
	declare @RefRangeUseDefaults bit,
			@RefRangeStartTimeUTC datetime,
			@RefRangeEndTimeUTC datetime,
			@RefRangeDays tinyint,
			@EarliestData datetime,
			@err int

	select  @RefRangeUseDefaults = [RefRangeUseDefaults],
  			@RefRangeStartTimeUTC = [RefRangeStartTimeUTC],
			@RefRangeEndTimeUTC = [RefRangeEndTimeUTC],
			@RefRangeDays = [RefRangeDays]
	from [MonitoredSQLServers] 
	where [SQLServerID] = @SQLServerID

	select @err = @@error
	if (@err = 0)
	begin
		select top 1 @EarliestData = [UTCCollectionDateTime] 
		from ServerStatistics
		where [SQLServerID] = @SQLServerID
		order by [UTCCollectionDateTime] ASC
	
		select @err = @@error
	end

	if (@err = 0)
	begin
		select @UseDefaults = case when @RefRangeUseDefaults is null then 1 else @RefRangeUseDefaults end
		select @StartDate = @RefRangeStartTimeUTC
		select @EndDate = @RefRangeEndTimeUTC
		select @Days = @RefRangeDays
		select @EarliestStatisticsAvailable = @EarliestData
	end

	return @err
END
		
 
GO 

---------- P_GETBASELINESFORMETRIC.SQL
IF (object_id('p_GetBaselinesForMetric') IS NOT NULL)
BEGIN
DROP PROCEDURE p_GetBaselinesForMetric
END
GO

CREATE PROCEDURE [dbo].p_GetBaselinesForMetric
	@SQLServerId INT,
	@MetricId INT,
	@EndDate DATETIME,
	@HistoryInSeconds INT
AS
BEGIN
	
	DECLARE @startTime DATETIME 
	SET @startTime = DATEADD(SECOND,@HistoryInSeconds*-1,@EndDate)
	DECLARE @endTime DATETIME 
	SET @startTime = @EndDate

	SELECT final.value,final.utcdate FROM (SELECT temp1.value,temp1.utcdate FROM (SELECT TOP 1 (Mean+StdDeviation) as value,@startTime as utcdate FROM BaselineStatistics WHERE UTCCalculation<=@startTime AND SQLServerID=@SQLServerId AND MetricID=@MetricId ORDER BY UTCCalculation DESC) temp1
	UNION 
	SELECT (Mean+StdDeviation) as value,UTCCalculation as utcdate FROM BaselineStatistics WHERE UTCCalculation BETWEEN @startTime AND @endTime AND SQLServerID=@SQLServerId AND MetricID=@MetricId
	UNION 
	SELECT temp3.value,temp3.utcdate FROM (SELECT TOP 1 (Mean+StdDeviation) as value,@endTime as utcdate FROM BaselineStatistics WHERE UTCCalculation<=@endTime AND SQLServerID=@SQLServerId AND MetricID=@MetricId ORDER BY UTCCalculation DESC) temp3) final 

END
 
GO 

---------- P_GETBASELINESTATISTICS.SQL
-- SQLdm 9.1 (Sanjali Makkar)

-- Get Baseline For A Particular Metric
-- retrieves the Baseline by Metric ID and Instance ID
-- according to the set filters

-- exec p_GetBaselineStatistics		        @InstanceID = '1',
--											@MetricID = '81',
--											@NumHistoryMin = '4320'

IF (object_id('p_GetBaselineStatistics') is not null)
BEGIN
	DROP PROCEDURE [p_GetBaselineStatistics]
END
GO


CREATE PROCEDURE [dbo].[p_GetBaselineStatistics] (@InstanceID INT, @MetricID INT = NULL, @NumHistoryMin INT = 60)
AS

BEGIN

IF(@NumHistoryMin = -1)
BEGIN
	SET @NumHistoryMin = 60;
END
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @EndTime DateTime 
	SELECT @EndTime = MAX(UTCCalculation) FROM BaselineStatistics;
	
	DECLARE @StartTime DateTime 
	SELECT @StartTime = DATEADD(MINUTE,-@NumHistoryMin, @EndTime)
	
-- Read metric data from MetricInfo table.
-- Read MetricMetaData to determine info where Metric is stored.

;WITH BaselineData(UTCCalculation,
SQLServerID,
TemplateID,
MetricID,
Mean,
StdDeviation,
Min,
Max,
Count)
AS ((SELECT TOP 1 UTCCalculation,
SQLServerID,
TemplateID,
MetricID,
Mean,
StdDeviation,
Min,
Max,
Count FROM BaselineStatistics WHERE UTCCalculation<=@StartTime AND BaselineStatistics.SQLServerID = @InstanceID AND (@MetricID IS NULL OR BaselineStatistics.MetricID = @MetricID) ORDER BY UTCCalculation DESC)
UNION
SELECT UTCCalculation,
SQLServerID,
TemplateID,
MetricID,
Mean,
StdDeviation,
Min,
Max,
Count FROM BaselineStatistics WHERE UTCCalculation BETWEEN @StartTime AND @EndTime)

SELECT 
	BD.SQLServerID AS ServerID, 
	MSS.InstanceName AS ServerName, 
	BD.MetricID AS MetricID, 
	MI.Name AS MetricName, 
	BD.UTCCalculation AS UTCCalculation,
	BD.Mean AS Mean,
	BD.StdDeviation AS StandardDeviation,
	BD.Min AS Min,
	BD.Max AS Max,
	BD.Count AS Count
	
FROM 
	BaselineData BD LEFT OUTER JOIN MetricInfo MI ON 
	BD.MetricID = MI.Metric INNER JOIN 
	MonitoredSQLServers MSS ON BD.SQLServerID = MSS.SQLServerID
	 
WHERE BD.SQLServerID = @InstanceID AND (@MetricID IS NULL OR BD.MetricID = @MetricID)
ORDER BY BD.UTCCalculation ASC;

END
 
GO
 
GO 

---------- P_GETBASELINESTATISTICSREPORT.SQL

if (object_id('p_GetBaselineStatisticsReport') is not null)
begin
drop procedure p_GetBaselineStatisticsReport
end
go
CREATE PROCEDURE [dbo].[p_GetBaselineStatisticsReport]
			@ServerID int,
			@UTCStart DateTime = NULL,
			@UTCEnd DateTime = NULL,
			@MetricID int,
			@CompareSQLServerID int,
			@CompareStartRange DateTime = NULL,
			@CompareEndRange DateTime = NULL,
			@CompareMetricID int,
			@UTCOffset int = 0,
			@Interval tinyint
AS
BEGIN

DECLARE @ParmDefinition nvarchar(500); -- Param definition for EXECUTE sp_executesql 

DECLARE @SQLString NVARCHAR(MAX) -- String that will contain the main SQL to be executed
DECLARE @tableName NVARCHAR(256) -- Table that contains the Metric value refenced in BaselineMetadata (OSStatistics or ServerStatistics)
DECLARE @columnName NVARCHAR(256) -- Column inside OSStatistics or ServerStatistics with the metric value
DECLARE @compareTableName NVARCHAR(256) -- Table that contains the Metric value refenced in BaselineMetadata (OSStatistics or ServerStatistics)
DECLARE @compareColumnName NVARCHAR(256) -- Column inside OSStatistics or ServerStatistics with the metric value
DECLARE @regex NVARCHAR(10)
DECLARE @Today bit -- Tells if period is today. Case it is 1 then the Period is Today. Whenever Period = Today was entered, then the MetricValue calculation will be done against all data from today.
DECLARE @CompareToday bit -- Tells if period is today. Case it is 1 then the Period is Today. Whenever Period = Today was entered, then the MetricValue calculation will be done against all data from today.

SET @regex = '%[-/()*]%'
SET @CompareStartRange = isnull(@CompareStartRange, @UTCStart)
SET @Today = CASE WHEN (dbo.fn_RoundDateTime(2, @UTCStart) = dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, GETDATE()))) THEN 1 ELSE 0 END
SET @CompareToday = CASE WHEN (dbo.fn_RoundDateTime(2, @CompareStartRange) = dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, GETDATE()))) THEN 1 ELSE 0 END

-- Base tablename and columnname.
SELECT @tableName = StatisticTable, @columnName = MetricValue
FROM BaselineMetaData
WHERE MetricID = @MetricID
-- Compare tablename and columnname.
SELECT @compareTableName = StatisticTable, @compareColumnName = MetricValue
FROM BaselineMetaData
WHERE MetricID = @CompareMetricID

DECLARE @BStatistics TABLE(
	[UTCCollectionDateTime] datetime,    
	[ServerName] nvarchar(256),
    [MetricName] nvarchar(128),
    [Unit] nvarchar(32),
    [Mean] decimal(38, 5),
    [MetricValue] decimal(38, 5) ,
    [StdDeviation] decimal(38, 5),
    [Min] decimal(38, 5),
    [Max] decimal(38, 5),
	[Count] decimal(38, 5),
	Template nvarchar(1024),
	[MetricID] int
) 

SELECT @SQLString = '
						   
;with BaselineStatisticsBase(UTCCalculation,[Template], [Mean],[StdDeviation],[Min],[Max],[Count])
as (
 select 
	UTCCalculation,
	s.Template,	
	[Mean],
	[StdDeviation],
	[Min],
	[Max],
	[Count]
 from 		
	BaselineStatistics bs INNER JOIN   
	BaselineTemplates bt ON bt.TemplateID = bs.TemplateID AND bt.SQLServerID = bs.SQLServerID 
	cross apply dbo.fn_GetFormattedTemplate(bt.Template) s'

Select @SQLString = @SQLString + 
	case @Today when 0 then ' where bs.MetricID = @MetricID and bs.SQLServerID = @ServerID and UTCCalculation BETWEEN @UTCStart AND @UTCEnd )  '
					   else ' where bs.MetricID = @MetricID and bs.SQLServerID = @ServerID and dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, UTCCalculation)) = dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, getdate())))
					   ' end
					   
Select @SQLString = @SQLString + '
SELECT 			
	[UTCCollectionDateTime] = dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, S.[UTCCollectionDateTime]))),	
	[ServerName] = MAX(
		case 
			when @ServerID = @CompareSQLServerID
		then 
			ms.InstanceName + '' (Base)''
		else ms.InstanceName end),			
	[MetricName] = (Select Name from BaselineMetaData where MetricID = @MetricID),		
	[Unit] = (Select Unit from BaselineMetaData where MetricID = @MetricID),
	[Mean] = (Select top 1 Mean from BaselineStatisticsBase bs where dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, UTCCalculation)) =  dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, MAX(UTCCollectionDateTime))) order by UTCCalculation desc),
	[MetricValue] = AVG({columnName}),		
	[StdDeviation] = (Select top 1 StdDeviation from BaselineStatisticsBase bs where dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, UTCCalculation)) =  dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, MAX(UTCCollectionDateTime))) order by UTCCalculation desc),
	[Min] = (Select top 1 [Min] from BaselineStatisticsBase bs where dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, UTCCalculation)) =  dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, MAX(UTCCollectionDateTime))) order by UTCCalculation desc),
	[Max] = (Select top 1 [Max] from BaselineStatisticsBase bs where dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, UTCCalculation)) =  dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, MAX(UTCCollectionDateTime))) order by UTCCalculation desc),	
	[Count] = (Select top 1 [Count] from BaselineStatisticsBase bs where dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, UTCCalculation)) =  dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, MAX(UTCCollectionDateTime))) order by UTCCalculation desc),
	[Template] = (Select top 1 [Template] from BaselineStatisticsBase bs where dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, UTCCalculation)) =  dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, MAX(UTCCollectionDateTime))) order by UTCCalculation desc),
	MetricID = @MetricID
	
FROM MonitoredSQLServers ms INNER JOIN
{tableName} on ms.SQLServerID = S.SQLServerID

WHERE ms.SQLServerID = @ServerID AND UTCCollectionDateTime BETWEEN @UTCStart AND @UTCEnd
group by
	case when isnull(@Interval,5) <= 4 then datepart(yy, dateadd(mi, @UTCOffset, UTCCollectionDateTime)) else 1 end
	,case when isnull(@Interval,5) <= 3 then datepart(mm,dateadd(mi, @UTCOffset, UTCCollectionDateTime)) else datepart(yy,dateadd(mi, @UTCOffset, UTCCollectionDateTime)) end
	,case when isnull(@Interval,5) <= 2 then datepart(dd,dateadd(mi, @UTCOffset, UTCCollectionDateTime)) else datepart(yy,dateadd(mi, @UTCOffset, UTCCollectionDateTime)) end
	,case when isnull(@Interval,5) <= 1 then datepart(hh,dateadd(mi, @UTCOffset, UTCCollectionDateTime)) else datepart(yy,dateadd(mi, @UTCOffset, UTCCollectionDateTime)) end
	,case when isnull(@Interval,5) =  0 then datepart(mi,dateadd(mi, @UTCOffset, UTCCollectionDateTime)) else datepart(yy,dateadd(mi, @UTCOffset, UTCCollectionDateTime)) end
order by UTCCollectionDateTime asc'

IF(@CompareSQLServerID >= 0)
BEGIN
	select @SQLString = @SQLString + '
	;with BaselineStatisticsCompare(UTCCalculation,[Template], [Mean],[StdDeviation],[Min],[Max],[Count])
	as (
	 select 
		UTCCalculation,
		s.[Template],	
		[Mean],
		[StdDeviation],
		[Min],
		[Max],
		[Count]
	 from 
		BaselineStatistics bs INNER JOIN   
		BaselineTemplates bt ON bt.TemplateID = bs.TemplateID AND bt.SQLServerID = bs.SQLServerID 
		cross apply dbo.fn_GetFormattedTemplate(bt.Template) s'
	Select @SQLString = @SQLString + 

	case @CompareToday when 0 then ' where bs.MetricID = @CompareMetricID and bs.SQLServerID = @CompareSQLServerID and UTCCalculation BETWEEN @CompareStartRange AND @CompareEndRange )  '
					   else ' where bs.MetricID = @CompareMetricID and bs.SQLServerID = @CompareSQLServerID and dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, UTCCalculation)) = dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, getdate())))
					   ' end
					   
Select @SQLString = @SQLString + '


	SELECT 			
		[UTCCollectionDateTime] = dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, S.[UTCCollectionDateTime]))),	
		[ServerName] = MAX(
			case 
				when @ServerID = @CompareSQLServerID
			then 
				ms.InstanceName + '' (Compare)''
			else ms.InstanceName end),			
		[MetricName] = (Select Name from BaselineMetaData where MetricID = @CompareMetricID),		
		[Unit] = (Select Unit from BaselineMetaData where MetricID = @CompareMetricID),
		[Mean] = (Select top 1 Mean from BaselineStatisticsCompare bs where dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, UTCCalculation)) =  dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, MAX(UTCCollectionDateTime))) order by UTCCalculation desc),
		[MetricValue] = AVG({compareColumnName}),		
		[StdDeviation] = (Select top 1 StdDeviation from BaselineStatisticsCompare bs where dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, UTCCalculation)) =  dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, MAX(UTCCollectionDateTime))) order by UTCCalculation desc),
		[Min] = (Select top 1 [Min] from BaselineStatisticsCompare bs where dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, UTCCalculation)) =  dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, MAX(UTCCollectionDateTime))) order by UTCCalculation desc),
		[Max] = (Select top 1 [Max] from BaselineStatisticsCompare bs where dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, UTCCalculation)) =  dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, MAX(UTCCollectionDateTime))) order by UTCCalculation desc),	
		[Count] = (Select top 1 [Count] from BaselineStatisticsCompare bs where dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, UTCCalculation)) =  dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, MAX(UTCCollectionDateTime))) order by UTCCalculation desc),
		[Template] = (Select top 1 [Template] from BaselineStatisticsCompare bs where dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, UTCCalculation)) =  dbo.fn_RoundDateTime(2, DATEADD(MI, @UTCOffset, MAX(UTCCollectionDateTime))) order by UTCCalculation desc),
		MetricID = @CompareMetricID
		
	FROM MonitoredSQLServers ms INNER JOIN
	{compareTableName} on ms.SQLServerID = S.SQLServerID

	WHERE ms.SQLServerID = @CompareSQLServerID AND UTCCollectionDateTime BETWEEN @CompareStartRange AND @CompareEndRange
	group by
		case when isnull(@Interval,5) <= 4 then datepart(yy, dateadd(mi, @UTCOffset, UTCCollectionDateTime)) else 1 end
		,case when isnull(@Interval,5) <= 3 then datepart(mm,dateadd(mi, @UTCOffset, UTCCollectionDateTime)) else datepart(yy,dateadd(mi, @UTCOffset, UTCCollectionDateTime)) end
		,case when isnull(@Interval,5) <= 2 then datepart(dd,dateadd(mi, @UTCOffset, UTCCollectionDateTime)) else datepart(yy,dateadd(mi, @UTCOffset, UTCCollectionDateTime)) end
		,case when isnull(@Interval,5) <= 1 then datepart(hh,dateadd(mi, @UTCOffset, UTCCollectionDateTime)) else datepart(yy,dateadd(mi, @UTCOffset, UTCCollectionDateTime)) end
		,case when isnull(@Interval,5) =  0 then datepart(mi,dateadd(mi, @UTCOffset, UTCCollectionDateTime)) else datepart(yy,dateadd(mi, @UTCOffset, UTCCollectionDateTime)) end
	order by UTCCollectionDateTime asc'
	
	SELECT @SQLString = REPLACE(@SQLString, '{compareTableName}', @compareTableName)
	SELECT @compareColumnName = CASE WHEN @compareColumnName not like @regex
				THEN 'S.' + @compareColumnName
				ELSE @compareColumnName 
				END
	SELECT @SQLString = REPLACE(@SQLString, '{compareColumnName}', @compareColumnName)
END

SELECT @SQLString = REPLACE(@SQLString, '{tableName}', @tableName)
SELECT @columnName = CASE WHEN @columnName not like @regex
				THEN 'S.' + @columnName
				ELSE @columnName 
				END				
SELECT @SQLString = REPLACE(@SQLString, '{columnName}', @columnName )

SET @ParmDefinition = N'@Interval int, @UTCOffset int, @ServerID int, @CompareSQLServerID int, @UTCStart DateTime, @UTCEnd DateTime, @CompareStartRange DateTime, @CompareEndRange DateTime, @MetricID int, @CompareMetricID int';

INSERT INTO @BStatistics (UTCCollectionDateTime, ServerName, MetricName, Unit, Mean, MetricValue, StdDeviation, [Min], [Max], [Count], [Template], [MetricID])
EXECUTE sp_executesql @SQLString, 
					  @ParmDefinition, 
					  @Interval = @Interval, 
					  @UTCOffset = @UTCOffset, 
					  @ServerID = @ServerID, 
					  @CompareSQLServerID = @CompareSQLServerID,
					  @UTCStart = @UTCStart, 
					  @UTCEnd= @UTCEnd, 
					  @CompareStartRange = @CompareStartRange, 
					  @CompareEndRange = @CompareEndRange, 
					  @MetricID = @MetricID,
					  @CompareMetricID = @CompareMetricID

--Need to escalate the units in order to avoid the values to split into 2 lines on the grid.
SELECT 
	[UTCCalculation] = [UTCCollectionDateTime],
	[ServerName],
    [MetricName],
	[Unit] = (SELECT CASE Unit
					When 'KB' THEN 'MB'
					When 'MB' THEN 'GB'
					When 'Milliseconds' THEN CASE When MetricID = 22 OR MetricID = -93 OR MetricID = -100 OR MetricID = -101 THEN 'Milliseconds' ELSE 'Seconds' END -- We need to add Response Time, VM CPU Swap Wait, VM CPU Ready to the exception
					When 'Seconds' THEN CASE When MetricID = 76 OR MetricID = 17 THEN 'Seconds' ELSE 'Minutes' END -- We need to add PageLifeExpectancy and Replication Latency to the exception
					ELSE Unit
					END),
    [Mean]= Mean / (SELECT CASE Unit 
					When 'KB' THEN 1024
					When 'MB' THEN 1024
					When 'Milliseconds' THEN CASE When MetricID = 22 OR MetricID = -93 OR MetricID = -100 OR MetricID = -101 THEN 1 ELSE 1000 END -- We need to add Response Time, VM CPU Swap Wait, VM CPU Ready to the exception
					When 'Seconds' THEN CASE When MetricID = 76 OR MetricID = 17 THEN 1 ELSE 60 END -- We need to add PageLifeExpectancy and Replication Latency to the exception
					ELSE 1
			END),
    [MetricValue] = [MetricValue] / (SELECT CASE Unit 
					When 'KB' THEN 1024
					When 'MB' THEN 1024
					When 'Milliseconds' THEN CASE When MetricID = 22 OR MetricID = -93 OR MetricID = -100 OR MetricID = -101 THEN 1 ELSE 1000 END -- We need to add Response Time, VM CPU Swap Wait, VM CPU Ready to the exception
					When 'Seconds' THEN CASE When MetricID = 76 OR MetricID = 17 THEN 1 ELSE 60 END -- We need to add PageLifeExpectancy and Replication Latency to the exception
					ELSE 1
			END),
    [StdDeviation] = [StdDeviation] / (SELECT CASE Unit 
					When 'KB' THEN 1024
					When 'MB' THEN 1024
					When 'Milliseconds' THEN CASE When MetricID = 22 OR MetricID = -93 OR MetricID = -100 OR MetricID = -101 THEN 1 ELSE 1000 END -- We need to add Response Time, VM CPU Swap Wait, VM CPU Ready to the exception
					When 'Seconds' THEN CASE When MetricID = 76 OR MetricID = 17 THEN 1 ELSE 60 END -- We need to add PageLifeExpectancy and Replication Latency to the exception
					ELSE 1
			END),
    [Min] = [Min] / (SELECT CASE Unit 
					When 'KB' THEN 1024
					When 'MB' THEN 1024
					When 'Milliseconds' THEN CASE When MetricID = 22 OR MetricID = -93 OR MetricID = -100 OR MetricID = -101 THEN 1 ELSE 1000 END -- We need to add Response Time, VM CPU Swap Wait, VM CPU Ready to the exception
					When 'Seconds' THEN CASE When MetricID = 76 OR MetricID = 17 THEN 1 ELSE 60 END -- We need to add PageLifeExpectancy and Replication Latency to the exception
					ELSE 1
			END),
    [Max] = [Max] / (SELECT CASE Unit 
					When 'KB' THEN 1024
					When 'MB' THEN 1024
					When 'Milliseconds' THEN CASE When MetricID = 22 OR MetricID = -93 OR MetricID = -100 OR MetricID = -101 THEN 1 ELSE 1000 END -- We need to add Response Time, VM CPU Swap Wait, VM CPU Ready to the exception
					When 'Seconds' THEN CASE When MetricID = 76 OR MetricID = 17 THEN 1 ELSE 60 END -- We need to add PageLifeExpectancy and Replication Latency to the exception
					ELSE 1
			END),
	[Count],
	Template,
	MetricID
FROM @BStatistics 
ORDER BY [UTCCalculation] ASC, [ServerName] ASC


END
 
GO 

---------- P_GETBASELINETEMPLATESBYID.SQL
IF (OBJECT_ID('p_GetBaselineTemplatesById') is not null)
BEGIN
	DROP PROCEDURE [p_GetBaselineTemplatesById]
END

GO

CREATE PROCEDURE [dbo].[p_GetBaselineTemplatesById] (@InstanceID INT)
AS

BEGIN

SELECT 
	[Template],
	[TemplateID],
	[BaselineName],
	[Active]	
FROM 
	BaselineTemplates	 
WHERE SQLServerID=@InstanceID and Active = '1' and BaselineName != 'Default'
ORDER BY TemplateID DESC;

END
 
 
GO 

---------- P_GETBLOCK.SQL
if (object_id('p_GetBlock') is not null)
begin
drop procedure [p_GetBlock]
end
go

create procedure [p_GetBlock]
	@AlertID bigint
as
begin
	DECLARE @err int
	DECLARE @linkid uniqueidentifier

	-- if no create date is specified then set one
	SELECT @linkid = [LinkedData]
		from Alerts where AlertID = @AlertID

	if (@linkid is not null)
	begin
		select SQLServerID, UTCCollectionDateTime, XDLData 
			from Blocks
			where BlockID = @linkid
	end

	SELECT @err = @@error
	
	RETURN @err
end
 
GO 

---------- P_GETBLOCKEDRECOMMENDATIONDATABASEANALYSISCONFIGURATION.SQL

if (object_id('p_GetBlockedRecommendationDatabaseAnalysisConfiguration') is not null)
begin
drop procedure [p_GetBlockedRecommendationDatabaseAnalysisConfiguration]
end
go


create procedure [p_GetBlockedRecommendationDatabaseAnalysisConfiguration] 
@sqlServerID INT
AS
begin

DECLARE @analysisConfigID INT 


SELECT DatabaseID, DatabaseName FROM SQLServerDatabaseNames

--get record having IsActive true for this server id
SELECT @analysisConfigID = ID FROM [dbo].[AnalysisConfiguration]
WHERE MonitoredServerID = @sqlServerID AND IsActive = 1

if(@analysisConfigID > 0)
BEGIN

-- will string comma saparated for list of database / recommendation
		SELECT (SELECT STUFF((SELECT ', ' + CAST(DatabaseID AS VARCHAR(10)) [text()]
         FROM AnalysisConfigBlockedDatabases 
         WHERE AnalysisConfigurationID = acbd.AnalysisConfigurationID
         FOR XML PATH(''), TYPE)
        .value('.','NVARCHAR(MAX)'),1,2,' ') List_Output
		FROM AnalysisConfigBlockedDatabases acbd
		GROUP BY AnalysisConfigurationID
		HAVING analysisConfig.ID = AnalysisConfigurationID) AS BlockedDatabases
		,(SELECT STUFF((SELECT ',' + CAST(RecommendationID AS VARCHAR(10)) [text()]
         FROM AnalysisConfigBlockedRecommendation 
         WHERE AnalysisConfigurationID = acbr.AnalysisConfigurationID
         FOR XML PATH(''), TYPE)
        .value('.','NVARCHAR(MAX)'),1,1,'') List_Output
		FROM AnalysisConfigBlockedRecommendation acbr
		GROUP BY AnalysisConfigurationID
		HAVING AnalysisConfigurationID = analysisConfig.ID ) AS BlockedRecommendations
		FROM AnalysisConfiguration analysisConfig
			WHERE analysisConfig.ID = @analysisConfigID


END
ELSE
	BEGIN
	Print 'Analysis Id not found - Will Rollback'
	  -- Any Error Occurred during Transaction. Rollback
	    
	  RAISERROR ('Analysis Id not found - Will Rollback',
             16,
             1)
	END 

 Print 'Error while getting blocked recommendations and databases.'
  -- Any Error Occurred during Transaction. Rollback
  		  
  RAISERROR ('Error while getting blocked recommendations and databases.',
             16,
             1)

end
 
GO 
 
GO 

---------- P_GETBLOCKINGDETAILS.SQL
if (object_id('[p_GetBlockingDetails]') is not null)
begin
drop procedure [p_GetBlockingDetails]
end
go
create procedure [dbo].[p_GetBlockingDetails]
	@SQLServerID int,
	@UTCSnapshotCollectionDateTime datetime = null,
	@HistoryInMinutes int = null
as
begin
set transaction isolation level read uncommitted
declare @err int

declare @BeginDateTime datetime
declare @EndDateTime datetime

if (@UTCSnapshotCollectionDateTime is null)
	select @EndDateTime = (select max(UTCCollectionDateTime) from [ServerActivity] where [SQLServerID] = @SQLServerID)
else
	select @EndDateTime = @UTCSnapshotCollectionDateTime

if (@HistoryInMinutes is null)
	select @BeginDateTime = @EndDateTime
else
	select @BeginDateTime = dateadd(n, -@HistoryInMinutes, @EndDateTime)

-- Get session and lock list for requested snapshot
select
	[InstanceName]
	,[UTCCollectionDateTime]
	,[SessionList]
	,[LockList]
from 
	[ServerActivity]
	left join [MonitoredSQLServers]
	on [ServerActivity].[SQLServerID] = [MonitoredSQLServers].[SQLServerID]
where 
	[ServerActivity].[SQLServerID] = @SQLServerID
	and [UTCCollectionDateTime] = @EndDateTime

-- Get history of blocked processes and lead blockers
select
	[ServerStatistics].[UTCCollectionDateTime] as [Date]
	,[BlockedProcesses] as [Blocked Sessions]
	,[LeadBlockers] as [Lead Blockers]
    ,[LockStatistics] as [Lock Statistics]
from
	[ServerStatistics]
	left join [ServerActivity]
	on [ServerActivity].[SQLServerID] = [ServerStatistics].[SQLServerID] and [ServerActivity].[UTCCollectionDateTime] = [ServerStatistics].[UTCCollectionDateTime]
where
	[ServerStatistics].[SQLServerID] = @SQLServerID
	and [ServerStatistics].[UTCCollectionDateTime] between @BeginDateTime and @EndDateTime
order by 
	[ServerStatistics].[UTCCollectionDateTime]

select @err = @@error
return @err
end
 
GO 

---------- P_GETBLOCKSLIST.SQL
if (object_id('p_GetBlocksList') is not null)
begin
drop procedure [p_GetBlocksList]
end
go

create procedure [p_GetBlocksList]
	@SQLServerID int,
	@StartDateTime datetime = null,
	@EndDateTime datetime = null
as
begin
	DECLARE @err int

	if ((@StartDateTime is null) or (@EndDateTime is null))
	begin
		select SQLServerID, UTCCollectionDateTime, XDLData 
			from Blocks
			where SQLServerID = @SQLServerID
			order by UTCCollectionDateTime desc
	end
	else
	begin
		select SQLServerID, UTCCollectionDateTime, XDLData
			from Blocks
			where SQLServerID = @SQLServerID and UTCCollectionDateTime between @StartDateTime and @EndDateTime
			order by UTCCollectionDateTime desc
	end

	SELECT @err = @@error
	
	RETURN @err
end
 
GO 

---------- P_GETCHANGELOGREPOSITORYUSER.SQL
if (object_id('p_GetChangeLogRepositoryUser') is not null)
begin
drop procedure p_GetChangeLogRepositoryUser
end
go
CREATE PROCEDURE [dbo].[p_GetChangeLogRepositoryUser]
AS
BEGIN

DECLARE @RepRepository  TABLE(
    [SQLUser] nvarchar(256) not null
);
INSERT INTO @RepRepository VALUES('< All >')
INSERT @RepRepository
SELECT DISTINCT [SQLUser]
  FROM [AuditableEvents]
  
SELECT * FROM @RepRepository
END
 
GO 

---------- P_GETCHANGELOGSUMMARY.SQL
if (object_id('p_GetChangeLogSummary') is not null)
begin
drop procedure [p_GetChangeLogSummary]
end
go

CREATE PROCEDURE [dbo].[p_GetChangeLogSummary]
		@AuditName nvarchar(128),
		@UTCStart DateTime,
		@UTCEnd DateTime,
		@UTCOffset int,
		@Workstation nvarchar(256),
		@WorkstationUser nvarchar(256),
		@SQLUser nvarchar(256)
AS
BEGIN

DECLARE @SQLString NVARCHAR(MAX) -- String that will contain the main SQL to be executed

SELECT @SQLString = 'SELECT 
	  [AuditableEventID]
	  ,AE.[ActionID]
	  ,[Action] = AA.Name
      ,dateadd(mi, @UTCOffset, [DateTime]) as [DateTime]
      ,[Workstation]
      ,[WorkstationUser]
      ,[SQLUser]
      ,AE.[Name]
      ,[MetaData]
      ,[Header]
  FROM [dbo].[AuditableEvents] AE, [dbo].AuditableActions AA
  WHERE AE.ActionID = AA.ActionID 
  AND  [DateTime] BETWEEN @UTCStart and @UTCEnd'

IF (@AuditName != '< All >')
BEGIN
	SELECT @SQLString = @SQLString + ' AND AA.Name = @AuditName'
END

IF (@Workstation != '< All >')
BEGIN
	SELECT @SQLString = @SQLString + ' AND AE.Workstation = @Workstation'
END

IF (@WorkstationUser != '< All >')
BEGIN
	SELECT @SQLString = @SQLString + ' AND AE.WorkstationUser = @WorkstationUser'
END

IF (@SQLUser != '< All >')
BEGIN
	SELECT @SQLString = @SQLString + ' AND AE.SQLUser = @SQLUser'
END

SELECT @SQLString = @SQLString + ' ORDER BY [DateTime] DESC'

declare @ParamDefinition nvarchar(500)
SET @ParamDefinition = N'@AuditName nvarchar(128),
						@UTCStart DateTime,
						@UTCEnd DateTime,
						@UTCOffset int,						
						@Workstation nvarchar(256),
						@WorkstationUser nvarchar(256),
						@SQLUser nvarchar(256)';
EXECUTE sp_executesql @SQLString, 
					  @ParamDefinition,
					  @AuditName = @AuditName,
					  @UTCStart = @UTCStart,
					  @UTCEnd = @UTCEnd,
					  @UTCOffset = @UTCOffset,					  
					  @Workstation = @Workstation,
					  @WorkstationUser = @WorkstationUser,
					  @SQLUser = @SQLUser

END
 
GO 

---------- P_GETCHANGELOGWORKSTATION.SQL
if (object_id('p_GetChangeLogWorkstation') is not null)
begin
drop procedure p_GetChangeLogWorkstation
end
go
CREATE PROCEDURE [dbo].[p_GetChangeLogWorkstation]
AS
BEGIN

DECLARE @RepWorkstation  TABLE(
    [Workstation] nvarchar(256) not null
);
INSERT INTO @RepWorkstation VALUES('< All >')
INSERT @RepWorkstation
SELECT DISTINCT [Workstation]
  FROM [AuditableEvents]
  
SELECT * FROM @RepWorkstation
END
 
 
GO 

---------- P_GETCHANGELOGWORKSTATIONUSER.SQL
if (object_id('p_GetChangeLogWorkstationUser') is not null)
begin
drop procedure p_GetChangeLogWorkstationUser
end
go
CREATE PROCEDURE [dbo].[p_GetChangeLogWorkstationUser]
AS
BEGIN

DECLARE @RepWorkstation  TABLE(
    [WorkstationUser] nvarchar(256) not null
);
INSERT INTO @RepWorkstation VALUES('< All >')
INSERT @RepWorkstation
SELECT DISTINCT [WorkstationUser]
  FROM [AuditableEvents]
  
SELECT * FROM @RepWorkstation
END
 
 
GO 

---------- P_GETCLIENTSFORSERVER.SQL
--retrieves those clients (hosts) through which at least one 
-- query has been fired on the given instance

-- @SQLServerID is the Instance ID
-- @StartIndex is the index from where clients needs to be retrieved
-- @RecordsCount is the number of clients to be retrieved

-- exec p_GetClientsForServer 9,1,2
if (object_id('p_GetClientsForServer') is not null)
begin
	drop procedure [p_GetClientsForServer]
end
go

create procedure [dbo].[p_GetClientsForServer]
	@SQLServerID int,
	@StartIndex int = 1,
	@RecordsCount int = -1
as
begin
	IF (@RecordsCount = -1)
		SELECT
			DISTINCT(QMS.HostNameID) AS ClientID,	
			HN.HostName	 AS ClientName
		FROM
			[QueryMonitorStatistics] AS QMS 
			INNER JOIN 
			[HostNames] AS HN
			ON QMS.HostNameID = HN.HostNameID
		WHERE
			QMS.SQLServerID = @SQLServerID
		ORDER BY
			HN.HostName
	ELSE
		begin
			WITH ClientNames AS
			(
				SELECT
					DISTINCT(QMS.HostNameID) AS ClientID,	
					HN.HostName	 AS ClientName,
					DENSE_RANK() OVER (ORDER BY HN.HostName) AS RecordRank
				FROM
					[QueryMonitorStatistics] AS QMS 
					INNER JOIN 
					[HostNames] AS HN
					ON QMS.HostNameID = HN.HostNameID
				WHERE
					QMS.SQLServerID = @SQLServerID
			)
	
			SELECT
				ClientID,
				ClientName
			FROM
				ClientNames
			WHERE
				RecordRank BETWEEN @StartIndex AND (@StartIndex + @RecordsCount - 1)
			ORDER BY
				ClientName
		end
end
go
 
GO 

---------- P_GETCLOUDPROVIDERS.SQL
if (object_id('p_GetCloudProviders') is not null)
begin
drop procedure p_GetCloudProviders
end
go

create procedure p_GetCloudProviders
as
begin
	select CloudProviderId,CloudProviderName from CloudProviders
end
 
GO 

---------- P_GETCOLLECTIONSERVICEFORSQLSERVER.SQL
if (object_id('p_GetCollectionServiceForSQLServer') is not null)
begin
drop procedure p_GetCollectionServiceForSQLServer
end
go
CREATE PROCEDURE [dbo].[p_GetCollectionServiceForSQLServer](
	@SQLServerID INT,
	@ReturnServiceID UNIQUEIDENTIFIER OUTPUT,
	@ReturnInstanceName NVARCHAR(256) OUTPUT
)
AS
BEGIN
	declare @e int
	declare @CollectionServiceIDTemp uniqueidentifier
	declare @ManagementServiceIDTemp uniqueidentifier
	declare @InstanceNameTemp nvarchar(256)

	SELECT @CollectionServiceIDTemp = [CollectionServiceID],
		   @InstanceNameTemp = [InstanceName]
	FROM [MonitoredSQLServers]
	WHERE [SQLServerID] = @SQLServerID
	
	SELECT @e = @@error

	if @CollectionServiceIDTemp is null
	begin
		select @ManagementServiceIDTemp = null
		exec p_GetDefaultManagementServiceID @ManagementServiceIDTemp output
		if @ManagementServiceIDTemp is not null
		    exec p_SetDefaultCollectionService @ManagementServiceIDTemp, @CollectionServiceIDTemp output 
	end

	SELECT @ReturnServiceID = @CollectionServiceIDTemp
	SELECT @ReturnInstanceName = @InstanceNameTemp
	RETURN @e
END

 
GO 

---------- P_GETCOLLECTIONSERVICES.SQL
if (object_id('p_GetCollectionServices') is not null)
begin
drop procedure p_GetCollectionServices
end
go
CREATE PROCEDURE [dbo].[p_GetCollectionServices](
	@CollectionServiceId uniqueidentifier,
	@ManagementServiceId uniqueidentifier
)
as
begin
	declare @e int

	IF (@ManagementServiceId is null) 
	begin
		if (@CollectionServiceId is null)
		begin
			select [CollectionServiceID],[InstanceName],[MachineName],[Address],[Port],[Enabled],[LastHeartbeatUTC],[ManagementServiceID] from [CollectionServices]
		end
		else
		begin
			select [CollectionServiceID],[InstanceName],[MachineName],[Address],[Port],[Enabled],[LastHeartbeatUTC],[ManagementServiceID] from [CollectionServices]
				where ([CollectionServiceID] = @CollectionServiceId)
		end
	end
	else
	begin
		iF (@CollectionServiceId is null)
		begin
			select [CollectionServiceID],[InstanceName],[MachineName],[Address],[Port],[Enabled],[LastHeartbeatUTC],[ManagementServiceID] from [CollectionServices]
				where ([ManagementServiceID] = @ManagementServiceId)
		end
		else
		begin
			select [CollectionServiceID],[InstanceName],[MachineName],[Address],[Port],[Enabled],[LastHeartbeatUTC],[ManagementServiceID] from [CollectionServices]
				where ([CollectionServiceID] = @CollectionServiceId) and ([ManagementServiceID] = @ManagementServiceId)
		end
	end

	select @e = @@error
	return @e
end
 
GO 

---------- P_GETCOPYRIGHT.SQL

if (object_id('p_GetCopyright') is not null)
begin
drop procedure [p_GetCopyright]
end
go

create procedure [p_GetCopyright]
as
begin
	select Character_Value as [copyright] from RepositoryInfo where [Name]='Copyright'
end
 
GO 

---------- P_GETCOUNTERCATEGORIES.SQL
if (object_id('p_GetCounterCategories') is not null)
begin
drop procedure p_GetCounterCategories
end
go

CREATE PROCEDURE [dbo].p_GetCounterCategories
AS
begin
	declare @e int

	SELECT DISTINCT [Category] FROM MetricInfo ORDER BY [Category]

	SET @e = @@ERROR

	RETURN @e
END	
 
GO 

---------- P_GETCOUNTERNAMEAVAILABLE.SQL
if (object_id('p_GetCounterNameAvailable') is not null)
begin
drop procedure p_GetCounterNameAvailable
end
go

CREATE PROCEDURE [dbo].p_GetCounterNameAvailable(
	@CounterName nvarchar(255),
	@Available bit output
)
AS
begin
	declare @err int
	declare @Usages int
	
	select @Usages = count([Name]) 
		from [MetricInfo] 
			left join [MetricMetaData] 
			on [MetricMetaData].[Metric] = [MetricInfo].[Metric]
		where 
			lower([MetricInfo].[Name]) = lower(@CounterName) 
			and [MetricMetaData].[Deleted] <> 1
						
	if (@Usages > 0)
		select @Available = 0
	else
		select @Available = 1

	select @err = @@error
	return @err
END	
 
GO 

---------- P_GETCOUNTERS.SQL
if (object_id('p_GetCounters') is not null)
begin
drop procedure p_GetCounters
end
go

CREATE PROCEDURE [dbo].p_GetCounters(
	@Metric int,
	@IncludeMetricInfo bit = 1,
	@IncludeMessages bit = 1,
	@IncludeCustomDefinitions bit = 1,
	@CustomCountersOnly bit = 0,
	@UTCChangedAfterDateTime datetime
)
AS
begin
	declare @e int

	if (@IncludeMetricInfo = 0)
		SELECT [Metric],[UTCLastChangeDateTime],[Deleted],[Class],[Flags],[MinValue],[MaxValue],[DefaultWarningValue],[DefaultCriticalValue],[DoNotifications],[EventCategory],[DefaultMessageID],[AlertEnabledDefault],[ValueComparison],[ValueType],[Rank],[DefaultInfoValue]
		--Getting default aand max value for baseline alert
		,[BaselineMaxValue],[BaselineDefaultWarningValue],[BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]
			FROM [MetricMetaData]
			WHERE (@Metric is null or [Metric] = @Metric) 
				AND (@CustomCountersOnly = 0 and exists(select 1 from [CustomCounterDefinition] CC where CC.[Metric] = [MetricMetaData].[Metric]))
				AND (@UTCChangedAfterDateTime is null or [UTCLastChangeDateTime] > @UTCChangedAfterDateTime)
				AND ([Deleted] = 0)
	else
		SELECT  MMD.[Metric], 
			    'UTCLastChangeDateTime' =
					CASE WHEN MMD.[UTCLastChangeDateTime] > MI.[UTCLastChangeDateTime] then MMD.[UTCLastChangeDateTime] else MI.[UTCLastChangeDateTime] end,
			    [Deleted],[Class],[Flags],[MinValue],[MaxValue],[DefaultWarningValue],[DefaultCriticalValue],[DoNotifications],[EventCategory],[DefaultMessageID],[AlertEnabledDefault],[ValueComparison],[ValueType],MI.[Rank],[Category],[Name],[Description],[Comments],[DefaultInfoValue]
			--Getting default aand max value for baseline alert
		,[BaselineMaxValue],[BaselineDefaultWarningValue],[BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]
		FROM [MetricMetaData] MMD, [MetricInfo] MI
			WHERE MMD.[Metric] = MI.[Metric] 
				AND (@Metric is null or MMD.[Metric] = @Metric)
				AND (@CustomCountersOnly = 0 or exists(select 1 from [CustomCounterDefinition] CC where CC.[Metric] = MMD.[Metric]))
				AND (@UTCChangedAfterDateTime is null or MMD.[UTCLastChangeDateTime] > @UTCChangedAfterDateTime or MI.[UTCLastChangeDateTime] > @UTCChangedAfterDateTime)
				AND ([Deleted] = 0)
	
	SELECT @e = @@error

	if (@e = 0)
	begin
		if (@IncludeMessages <> 0)
		begin 
			SELECT [Metric],[MessageID],[EventID],[HeaderTemplate],[BodyTemplate],[TodoTemplate], 
			[PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]
				FROM [MetricMetaDataMessages]
				WHERE (@Metric is null or [Metric] = @Metric)
				ORDER BY [Metric],[MessageID]
			
			SELECT [Metric],[Value],[MessageID] 
				FROM [MetricMetaDataMessageMap]
				WHERE (@Metric is null or [Metric] = @Metric)
				ORDER BY [Metric]
		end	

	if (@IncludeCustomDefinitions <> 0)
		begin
			SELECT [Metric],[UTCLastChangeDateTime],[Enabled],[MetricType],[CalculationType],[Scale],[Object],[Counter],[Instance],[Batch] ,[ServerType]
				FROM [CustomCounterDefinition]
				WHERE (@Metric is null or [Metric] = @Metric)
					AND (@UTCChangedAfterDateTime is null or [UTCLastChangeDateTime] > @UTCChangedAfterDateTime) 
					AND ([Metric] not in (SELECT [Metric] from [MetricMetaData] where [Deleted] = 1))
				ORDER BY [Metric]
		end
	end

	RETURN @e
END	
 
GO 

---------- P_GETCPUSUMMARY.SQL
if (object_id('[p_GetCPUSummary]') is not null)
begin
drop procedure [p_GetCPUSummary]
end
go
CREATE PROCEDURE [dbo].[p_GetCPUSummary]
		@ServerID int,
		@UTCStart DateTime,
		@UTCEnd DateTime,
		@UTCOffset int,
		@Interval tinyint
AS
BEGIN

-- @Interval - Granularity of calculation:
--	0 - Minutes
--	1 - Hours
--	2 - Days
--	3 - Months
--	4 - Years

select m.InstanceName
		,dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime]))) as [LastCollectioninInterval],
		sum(o.[ProcessorTimePercent] * TimeDeltaInSeconds) / nullif(sum(case when [ProcessorTimePercent] is not null then TimeDeltaInSeconds else 0 end),0) as OSProcessorTimePercent,
		sum(s1.[CPUActivityPercentage] * TimeDeltaInSeconds) / nullif(sum(case when [CPUActivityPercentage] is not null then TimeDeltaInSeconds else 0 end),0) as SQLCPUActivityPercentage,
		sum(o.[ProcessorQueueLength] * TimeDeltaInSeconds) / nullif(sum(case when [ProcessorQueueLength] is not null then TimeDeltaInSeconds else 0 end),0) as OSProcessorQueueLength,
		sum(convert(float,s1.[SqlCompilations])) / nullif((sum(convert(float,case when s1.[SqlCompilations] is not null then TimeDeltaInSeconds else 0 end)) / 60) ,0) as SqlCompilations,
		sum(convert(float,s1.[SqlRecompilations])) / nullif((sum(convert(float,case when s1.[SqlRecompilations] is not null then TimeDeltaInSeconds else 0 end)) / 60) ,0) as SqlRecompilations,
		sum(convert(float,s1.[LockWaits])) / nullif((sum(convert(float,case when s1.[LockWaits] is not null then TimeDeltaInSeconds else 0 end)) / 60) ,0) as LockWaits,
		sum(convert(float,s1.[TableLockEscalations])) / nullif((sum(convert(float,case when s1.[TableLockEscalations] is not null then TimeDeltaInSeconds else 0 end)) / 60) ,0) as TableLockEscalations,
		ProcessorTimePercentMean = (select TOP 1 Mean	--ProcessorTimePercent MetricID = 26 
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = 26 AND dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc),
		CPUActivityPercentageMean = (select TOP 1 Mean	--CPUActivityPercentage MetricID = 0
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = 0 AND dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc),
		ProcessorQueueLengthMean = (select TOP 1 Mean	--ProcessorQueueLength MetricID = 29
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = 29 AND dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc),		
		TableLockEscalationsMean = (select TOP 1 Mean --TableLockEscalations
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -1 AND dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc)	
	from		
		[MonitoredSQLServers] m (nolock) left join
		[ServerStatistics] s1 (nolock)on m.[SQLServerID] = s1.[SQLServerID]left join 
		[OSStatistics] o (nolock)on o.[SQLServerID] = s1.[SQLServerID] and o.[UTCCollectionDateTime] = s1.[UTCCollectionDateTime]
	where
		s1.[SQLServerID] = @ServerID		
		and dbo.fn_RoundDateTime(@Interval, s1.[UTCCollectionDateTime]) between @UTCStart and @UTCEnd
group by
		[InstanceName]
		-- Always group by year at the least
		,datepart(yy, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime]))
		-- Group by all intervals greater than or equal to the selected interval
		,case when @Interval <= 3 then datepart(mm,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
		,case when @Interval <= 2 then datepart(dd,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
		,case when @Interval <= 1 then datepart(hh,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
		,case when @Interval =  0 then datepart(mi,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
END
 
GO 

---------- P_GETCPUSUMMARYBASELINE.SQL

if (object_id('p_GetCPUSummaryBaseline') is not null)
begin
drop procedure p_GetCPUSummaryBaseline
end
go
CREATE PROCEDURE [dbo].[p_GetCPUSummaryBaseline]
		@ServerID int,
		@UTCStart DateTime,
		@UTCEnd DateTime,
		@UTCOffset int,
		@Interval tinyint
AS
BEGIN
		SELECT		
		UTCCalculation = dbo.fn_RoundDateTime(1, max(dateadd(mi, @UTCOffset, UTCCalculation))),
		ProcessorTimePercentMean = (select TOP 1 Mean	--ProcessorTimePercent MetricID = 26 
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = 26 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc),
		CPUActivityPercentageMean = (select TOP 1 Mean	--CPUActivityPercentage MetricID = 0
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = 0 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc),
		ProcessorQueueLengthMean = (select TOP 1 Mean	--ProcessorQueueLength MetricID = 29
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = 29 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc),		
		TableLockEscalationsMean = (select TOP 1 Mean --TableLockEscalations
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -1 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc)	
		FROM		
			[BaselineStatistics] bs (nolock)
		WHERE bs.[SQLServerID] = @ServerID and bs.UTCCalculation between @UTCStart and @UTCEnd
		GROUP BY dbo.fn_RoundDateTime(2, bs.UTCCalculation)

END
 
 
GO 

---------- P_GETCURRENTDISKDRIVES.SQL
if (object_id('p_GetCurrentDiskDrives') is not null)
begin
drop procedure [p_GetCurrentDiskDrives]
end
go
create procedure [dbo].[p_GetCurrentDiskDrives]
				@SQLServerID int
as
begin
	declare @err int

	select DriveName from DiskDrives
		where SQLServerID = @SQLServerID and
			UTCCollectionDateTime = 
				(Select max(UTCCollectionDateTime) 
					from DiskDrives
					where SQLServerID = @SQLServerID
				)

	set @err = @@ERROR
	return @err
end
 
GO 

---------- P_GETCUSTOMCOUNTERSTATISTICS.SQL
if (object_id('p_GetCustomCounterStatistics') is not null)
begin
drop procedure [p_GetCustomCounterStatistics]
end
go
create procedure [dbo].[p_GetCustomCounterStatistics]
	@SQLServerID int,
	@UTCSnapshotCollectionDateTime datetime = null,
	@HistoryInMinutes int = null,
	@CurrentOnly bit = 1
as
begin
set transaction isolation level read uncommitted
declare @err int
declare @BeginDateTime datetime
declare @EndDateTime datetime
declare @InstanceName nvarchar(255)
declare @LinkedCounters table (Metric int)

if (@UTCSnapshotCollectionDateTime is null)
	select @EndDateTime = (select max(UTCCollectionDateTime) from [CustomCounterStatistics] where [SQLServerID] = @SQLServerID)
else
	select @EndDateTime = @UTCSnapshotCollectionDateTime

if (@HistoryInMinutes is null)
	select @BeginDateTime = @EndDateTime
else
	select @BeginDateTime = dateadd(minute, -@HistoryInMinutes, @EndDateTime)

-- get the instance name
select @InstanceName = [InstanceName]
from 
	[MonitoredSQLServers]
where
	[SQLServerID] = @SQLServerID

if (@CurrentOnly = 1)
begin
	insert into @LinkedCounters
	select Metric from CustomCounterMap 
		where SQLServerID = @SQLServerID

	insert into @LinkedCounters
	select Metric from CustomCounterTags ct
		join ServerTags st on st.SQLServerId = @SQLServerID and ct.TagId = st.TagId
		where Metric not in (select Metric from @LinkedCounters)
end

-- get the trend data
select 
	[InstanceName]
	,[UTCCollectionDateTime] as [CollectionDateTime]
	,[MetricID]
	,[TimeDeltaInSeconds]
	,[RawValue]
	,[DeltaValue]
	,[ErrorMessage] 
from 
	[CustomCounterStatistics] [CS]
	join [MonitoredSQLServers] [S] on [S].[SQLServerID] = [CS].[SQLServerID]
where 
	[CS].[SQLServerID] = @SQLServerID
	and [CS].[UTCCollectionDateTime] between @BeginDateTime and @EndDateTime
	and (@CurrentOnly = 0 or [CS].[MetricID] in (select [Metric] from @LinkedCounters))
order by 
	[CS].[UTCCollectionDateTime]

select @err = @@error
return @err
end
 
GO 

---------- P_GETCUSTOMCOUNTERSWITHTAGIDS.SQL
IF (object_id('p_GetCustomCountersWithTagIds') IS NOT NULL)
BEGIN
DROP PROCEDURE p_GetCustomCountersWithTagIds
END
GO

CREATE PROCEDURE [dbo].[p_GetCustomCountersWithTagIds]
(
	@Tags nvarchar(max) = NULL
)
AS
BEGIN
	DECLARE @error INT
	DECLARE @xmlDoc INT

	IF (@Tags IS NOT NULL)
	BEGIN
		DECLARE @TagIds TABLE(TagId INT)

		EXEC sp_xml_preparedocument @xmlDoc OUTPUT, @Tags
		INSERT INTO @TagIds	
			SELECT TagId
				FROM OPENXML(@xmlDoc, '//Tag', 1) WITH (TagId INT)
		EXEC sp_xml_removedocument @xmlDoc

		SELECT [Metric], [TagId] 
		FROM [CustomCounterTags] 
		WHERE [TagId] IN (SELECT TagId FROM @TagIds)
	END
	ELSE
	BEGIN
		SELECT [Metric], [TagId] 
		FROM [CustomCounterTags] 
	END

	SELECT @error = @@error
	RETURN @error
END
 
GO 

---------- P_GETCUSTOMCOUNTERTAGS.SQL
IF (object_id('p_GetCustomCounterTags') IS NOT NULL)
BEGIN
DROP PROCEDURE p_GetCustomCounterTags
END
GO

CREATE PROCEDURE [dbo].[p_GetCustomCounterTags]
(
	@Metric INT
)
AS
BEGIN
	SELECT [TagId], [Name] as [TagName]
	FROM [CustomCounterTags]
	LEFT JOIN [Tags]
	ON TagId = Id
	WHERE [Metric] = @Metric
END
 
GO 

---------- P_GETCUSTOMCOUNTERTAGSANDSERVERS.SQL
if (object_id('p_GetCustomCounterTagsAndServers') is not null)
begin
drop procedure p_GetCustomCounterTagsAndServers
end
go

create procedure [dbo].[p_GetCustomCounterTagsAndServers]
(
	@Metric int
)
AS
begin
	declare @e int

	select [TagId] from [CustomCounterTags] where [Metric] = @Metric
	select [SQLServerID] from [CustomCounterMap] where [Metric] = @Metric

	set @e = @@ERROR
	return @e
end	
 
GO 

---------- P_GETCUSTOMDASHBOARDS.SQL
if (object_id('p_GetCustomDashboards') is not null)
begin
drop procedure [p_GetCustomDashboards]
end
go

create procedure [p_GetCustomDashboards] 

@SID nvarchar(200)
AS
BEGIN
	declare @e int
	
	BEGIN TRANSACTION
	
	BEGIN
		-- check if records for UserSID
		SELECT [CustomDashboardId]
		, [CustomDashboardName]
      ,[IsDefaultOnUI]
	  ,Tags
      ,[RecordCreatedTimestamp]
      ,[RecordUpdateDateTimestamp]
		FROM CustomDashboard 
		WHERE LOWER(UserSID) = LOWER(@SID)
	
	END
	
	SET @e = ERROR_NUMBER();
	
	IF (@e = 0)
		COMMIT TRANSACTION
	ELSE 
		ROLLBACK TRANSACTION	 	

	

END
 
GO 
 
GO 

---------- P_GETCUSTOMREPORTNAME.SQL
if (object_id('[p_GetCustomReportName]') is not null)
begin
drop procedure [p_GetCustomReportName]
end
go

create proc [dbo].[p_GetCustomReportName](
@reportName nvarchar(255) out
)
as
begin
declare @report nvarchar(255)

select @report = reportName from CustomReports where lower(reportName) = lower(@reportName)
if @report is not null 
	select @reportName = @report

end

--declare @a nvarchar(255)
--select @a = 'AAAAA'
--execute [p_GetCustomReportName] @a out
--
--select @a
 
GO 

---------- P_GETCUSTOMREPORTS.SQL
if (object_id('[p_GetCustomReports]') is not null)
begin
	drop procedure [p_GetCustomReports]
end
go

Create proc [dbo].[p_GetCustomReports](@reportName nvarchar(255) = null)
as
begin
	select reportName, reportShortDescription, reportText, ShowTopServers
	from CustomReports
	where lower(reportName) = isnull(lower(@reportName), lower(reportName))
end
 
GO 

---------- P_GETCUSTOMREPORTSDATASET.SQL
/****** Object:  StoredProcedure [dbo].[p_GetCustomReportsDataSet]    Script Date: 12-05-2014 16:38:49 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

IF (OBJECT_ID('p_GetCustomReportsDataSet') IS NOT NULL)
BEGIN
DROP PROCEDURE p_GetCustomReportsDataSet
END
GO

CREATE proc [dbo].[p_GetCustomReportsDataSet](@UTCOffset int,
@Interval int,
@ServerID int,
@UTCStart DateTime,
@UTCEnd DateTime,
@reportName nvarchar(255))
as
begin

IF OBJECT_ID('tempdb..#tempCustomCounters') IS NOT NULL
drop table #tempCustomCounters
IF OBJECT_ID('tempdb..#ReportsCounters') IS NOT NULL
drop table #ReportsCounters


DECLARE @NonVirtualizationSQLString nvarchar(max); --SQLdm 8.5 (Ankit Srivastava): for Virtualization Counters - Changed the variable name from @SQLString
DECLARE @ParmDefinition nvarchar(500);
declare @counterID int
declare @counterName nvarchar(256)
declare @counterAggregation int
declare @counterSource int
declare @metricName1 nvarchar(256)
declare @metricName2 nvarchar(256)
declare @metricName3 nvarchar(256)
declare @metricName4 nvarchar(256)
declare @metricName5 nvarchar(256)
declare @counterSQLWeightedAverage nvarchar(2000)
declare @counterSQLMax nvarchar(2000)
declare @counterSQLPerMinute nvarchar(2000)

declare @maxCounterTemplate nvarchar(500)
declare @weightedAverageCounterTemplate nvarchar(500)
declare @perMinuteCounterTemplate nvarchar(500)
declare @nonCustomCounterSelect nvarchar(4000)
declare @finalSelectMetrics nvarchar(1000)

--SQLdm 8.5 (Ankit Srivastava): for Virtualization Counters - starts here
Declare @VirtualizationSQLString nvarchar(max)
Declare @virtualizationPerMinuteCounterTemplate nvarchar(500)
declare @virtualizationWeightedAverageCounterTemplate nvarchar(500)
declare @VirtualizationCounterSelect nvarchar(4000)
declare @virtualizationFinalSelectMetrics nvarchar(1000)
--SQLdm 8.5 (Ankit Srivastava): for Virtualization Counters - ends here




select @maxCounterTemplate = 'round(max(convert(float,{prefix}.{metric})),2) as {metric}, '
--Moved below
--select @weightedAverageCounterTemplate = 'round(sum({prefix}.{metric} * TimeDeltaInSeconds) / nullif(sum(case when {prefix}.{metric} is not null then TimeDeltaInSeconds else 0 end),0),2) as {metric}, '
select @perMinuteCounterTemplate = 'round(sum(convert(float,{prefix}.{metric})) / nullif((sum(convert(float,case when {prefix}.{metric} is not null then TimeDeltaInSeconds else 0 end)) / 60) ,0),2) as {metric}, '
select @nonCustomCounterSelect = ''
select @finalSelectMetrics = ''

--SQLdm 8.5 (Ankit Srivastava): for Virtualization Counters - starts here
select @virtualizationPerMinuteCounterTemplate='round(avg(convert(float,{prefix}.{metric})),2) as {metric}, '
select @VirtualizationCounterSelect=''
select @virtualizationFinalSelectMetrics=''
--SQLdm 8.5 (Ankit Srivastava): for Virtualization Counters - ends here

set nocount on

--declare @UTCOffset int
--declare @Interval int
--declare @ServerID int
--declare @UTCStart DateTime
--declare @UTCEnd DateTime
--declare @reportName nvarchar(255)
--select @reportName = 'Report1'
--select @UTCOffset = -6
--select @Interval = 0
--select @ServerID = 1
--select @UTCStart = '1/1/1900'
--select @UTCEnd = '1/1/2011'

if not exists(select * from CustomReports where reportName = @reportName)
return
select @counterSQLWeightedAverage = 'select m.InstanceName,'
+ ' dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime]))) as [LastCollectioninInterval],'
+ ' ccs.MetricID, '
+ ' sum(((case ccd.CalculationType when 0 then ccs.RawValue else ccs.DeltaValue end) * ccd.Scale) * ccs.TimeDeltaInSeconds) / nullif(sum(case when ccs.RawValue is not null then ccs.TimeDeltaInSeconds else 0 end),0) as Value ' 
+ ' from  CustomCounterStatistics ccs (nolock)'
+ ' inner join MonitoredSQLServers m (nolock) on ccs.SQLServerID = m.SQLServerID'
+ ' inner join CustomCounterDefinition ccd (nolock) on ccd.Metric = ccs.MetricID'
+ ' where ccs.[SQLServerID] = @ServerID and ccs.[UTCCollectionDateTime] between @UTCStart and @UTCEnd'
+ ' and ccs.MetricID = @CounterID'
+ ' group by [InstanceName] , ccs.MetricID,' 
+ ' datepart(yy, dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime]))'
+ ' ,case when @Interval <= 3 then datepart(mm,dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime])) end'
+ ' ,case when @Interval <= 2 then datepart(dd,dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime])) end'
+ ' ,case when @Interval <= 1 then datepart(hh,dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime])) end'
+ ' ,case when @Interval = 0 then datepart(mi,dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime])) end'

select @counterSQLMax = 'select m.InstanceName,'
+ ' dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime]))) as [LastCollectioninInterval],'
+ ' ccs.MetricID, '
+ ' max((case ccd.CalculationType when 0 then ccs.RawValue else ccs.DeltaValue end) * ccd.Scale) as Value ' 
+ ' from  CustomCounterStatistics ccs '
+ ' inner join MonitoredSQLServers m (nolock) on ccs.SQLServerID = m.SQLServerID'
+ ' inner join CustomCounterDefinition ccd (nolock) on ccd.Metric = ccs.MetricID'
+ ' where ccs.[SQLServerID] = @ServerID and ccs.[UTCCollectionDateTime] between @UTCStart and @UTCEnd'
+ ' and ccs.MetricID = @CounterID'
+ ' group by [InstanceName] , ccs.MetricID,' 
+ ' datepart(yy, dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime]))'
+ ' ,case when @Interval <= 3 then datepart(mm,dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime])) end'
+ ' ,case when @Interval <= 2 then datepart(dd,dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime])) end'
+ ' ,case when @Interval <= 1 then datepart(hh,dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime])) end'
+ ' ,case when @Interval = 0 then datepart(mi,dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime])) end'

select @counterSQLPerMinute = 'select m.InstanceName,'
+ ' dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime]))) as [LastCollectioninInterval],'
+ ' ccs.MetricID, '
+ ' sum(convert(float,((case ccd.CalculationType when 0 then ccs.RawValue else ccs.DeltaValue end) * ccd.Scale))) / nullif((sum(convert(float,case when ((case ccd.CalculationType when 0 then ccs.RawValue else ccs.DeltaValue end) * ccd.Scale) is not null then TimeDeltaInSeconds else 0 end)) / 60) ,0) as Value ' 
+ ' from  CustomCounterStatistics ccs (nolock)'
+ ' inner join MonitoredSQLServers m (nolock) on ccs.SQLServerID = m.SQLServerID'
+ ' inner join CustomCounterDefinition ccd (nolock) on ccd.Metric = ccs.MetricID'
+ ' where ccs.[SQLServerID] = @ServerID and ccs.[UTCCollectionDateTime] between @UTCStart and @UTCEnd'
+ ' and ccs.MetricID = @CounterID'
+ ' group by [InstanceName] , ccs.MetricID,' 
+ ' datepart(yy, dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime]))'
+ ' ,case when @Interval <= 3 then datepart(mm,dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime])) end'
+ ' ,case when @Interval <= 2 then datepart(dd,dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime])) end'
+ ' ,case when @Interval <= 1 then datepart(hh,dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime])) end'
+ ' ,case when @Interval = 0 then datepart(mi,dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, ccs.[UTCCollectionDateTime])) end'

SET @ParmDefinition = N'@Interval int, @UTCOffset int, @ServerID int, @UTCStart DateTime, @UTCEnd DateTime, @CounterID int';

create table #baseTable(InstanceName nvarchar(256), LastCollectioninInterval DateTime)
insert into #baseTable
select m.InstanceName 
,dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime]))) as [LastCollectioninInterval]
from [MonitoredSQLServers] m (nolock)
left join [ServerStatistics] s1 (nolock)
on m.[SQLServerID] = s1.[SQLServerID]
left join [OSStatistics] o (nolock)
on o.[SQLServerID] = s1.[SQLServerID] and o.[UTCCollectionDateTime] = s1.[UTCCollectionDateTime]
where s1.[SQLServerID] = @ServerID and s1.[UTCCollectionDateTime] between @UTCStart and @UTCEnd
group by [InstanceName] 
,datepart(yy, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime]))
,case when @Interval <= 3 then datepart(mm,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
,case when @Interval <= 2 then datepart(dd,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
,case when @Interval <= 1 then datepart(hh,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
,case when @Interval = 0 then datepart(mi,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end

declare customCounterCursor insensitive cursor for

with DistinctMetrics(Metric, Name)as (
 select Metric = min(Metric),Name
 from MetricInfo
 group by Name
)  

select mi.Metric, crc.CounterName, crc.Aggregation, crc.Source
 from CustomReports cr inner join CustomReportsCounters crc on cr.ID = crc.ID
left join DistinctMetrics mi on crc.CounterName = replace(mi.Name,' ','_') 
where reportName = @reportName-- and Source = 2
order by GraphNumber asc

open customCounterCursor 
fetch next from customCounterCursor into @counterID, @counterName, @counterAggregation, @counterSource

declare @metricDeclaration nvarchar(80)
declare @averageDivisor nvarchar(150)

declare @countOfCustomGraphs int
select @countOfCustomGraphs = 0

while @@fetch_status = 0
begin

-- If Metric SQLMemoryUsagePercent then we do not want to look for that column on ServerStatistics table.
if (@counterName = 'SQLMemoryUsagePercent') 
begin
	set @metricDeclaration = '{prefix}.SqlMemoryUsedInKilobytes * 100 / {prefix}.TotalServerMemoryInKilobytes'
	set @averageDivisor = 'nullif(sum(case when {prefix}.SqlMemoryUsedInKilobytes is not null AND {prefix}.TotalServerMemoryInKilobytes is not null then TimeDeltaInSeconds'
end
else
begin
	set @metricDeclaration = '{prefix}.{metric}'
	set @averageDivisor = 'nullif(sum(case when {prefix}.{metric} is not null then TimeDeltaInSeconds'
end

select @weightedAverageCounterTemplate = 'round(sum(' + @metricDeclaration + ' * TimeDeltaInSeconds) / ' + @averageDivisor  + ' else 0 end),0),2) as {metric}, '
select @virtualizationWeightedAverageCounterTemplate= 'round(avg(convert(float,{prefix}.{metric})),2) as {metric}, '  ---SQLdm 8.5 (Ankit Srivastava): for Virtualization Counters - added newly

if @counterSource = 0 --Server
begin
select @finalSelectMetrics = @finalSelectMetrics + 'nonCustom.[' + @counterName + '], '
if @counterAggregation = 0--max
begin
select @nonCustomCounterSelect = @nonCustomCounterSelect + replace(replace(@maxCounterTemplate,'{prefix}','s1'),'{metric}',@counterName)
end
if(@counterAggregation = 1)--weighted average
begin
select @nonCustomCounterSelect = @nonCustomCounterSelect + replace(replace(@weightedAverageCounterTemplate,'{prefix}','s1'),'{metric}',@counterName)
end
if @counterAggregation = 2--per minute
begin
select @nonCustomCounterSelect = @nonCustomCounterSelect + replace(replace(@perMinuteCounterTemplate,'{prefix}','s1'),'{metric}',@counterName)
end
end
if @counterSource = 1 -- os
begin
select @finalSelectMetrics = @finalSelectMetrics + 'nonCustom.[' + @counterName + '], '
if @counterAggregation = 0--max
begin
select @nonCustomCounterSelect = @nonCustomCounterSelect + replace(replace(@maxCounterTemplate,'{prefix}','o'),'{metric}',@counterName)
end
if(@counterAggregation = 1)--weighted average
begin
select @nonCustomCounterSelect = @nonCustomCounterSelect + replace(replace(@weightedAverageCounterTemplate,'{prefix}','o'),'{metric}',@counterName)
end
if @counterAggregation = 2--per minute
begin
select @nonCustomCounterSelect = @nonCustomCounterSelect + replace(replace(@perMinuteCounterTemplate,'{prefix}','o'),'{metric}',@counterName)
end
end

--SQLdm 8.5 (Ankit Srivastava): for Virtualization Counters - starts here
if @counterSource = 3 -- Virtualization
begin
select @virtualizationFinalSelectMetrics = @virtualizationFinalSelectMetrics + 'virt.[' + @counterName + '], '
if @counterAggregation = 0--max
begin
select @VirtualizationCounterSelect = @VirtualizationCounterSelect + replace(replace(@maxCounterTemplate,'{prefix}','vm'),'{metric}',@counterName)
end
if(@counterAggregation = 1)--weighted average
begin
select @VirtualizationCounterSelect = @VirtualizationCounterSelect + replace(replace(@virtualizationWeightedAverageCounterTemplate,'{prefix}','vm'),'{metric}',@counterName)
end
if @counterAggregation = 2--per minute
begin
select @VirtualizationCounterSelect = @VirtualizationCounterSelect + replace(replace(@virtualizationPerMinuteCounterTemplate,'{prefix}','vm'),'{metric}',@counterName)
end
end
--SQLdm 8.5 (Ankit Srivastava): for Virtualization Counters - ends here

if @counterSource = 2 --custom    
begin
select @finalSelectMetrics = @finalSelectMetrics + 'custom.[' + @counterName + '], '
if(@countOfCustomGraphs = 0)
begin
select @metricName1 = @counterName
create table #metrictable1 (InstanceName nvarchar(256), LastCollectioninInterval DateTime, metricid int, metricvalue decimal)

if @counterAggregation = 0--max
begin
insert into #metrictable1
EXECUTE sp_executesql @counterSQLMax, @ParmDefinition, @Interval = @Interval, @UTCOffset=@UTCOffset, @ServerID = @ServerID, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterID = @counterID
end
if(@counterAggregation = 1)--weighted average
begin
insert into #metrictable1
EXECUTE sp_executesql @counterSQLWeightedAverage, @ParmDefinition, @Interval = @Interval, @UTCOffset=@UTCOffset, @ServerID = @ServerID, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterID = @counterID
end
if @counterAggregation = 2--per minute
begin
insert into #metrictable1
EXECUTE sp_executesql @counterSQLPerMinute, @ParmDefinition, @Interval = @Interval, @UTCOffset=@UTCOffset, @ServerID = @ServerID, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterID = @counterID
end
end

if(@countOfCustomGraphs = 1)
begin
select @metricName2 = @counterName
create table #metrictable2 (InstanceName nvarchar(256), LastCollectioninInterval DateTime, metricid int, metricvalue decimal)

if @counterAggregation = 0 -- max
begin
insert into #metrictable2
EXECUTE sp_executesql @counterSQLMax, @ParmDefinition, @Interval = @Interval, @UTCOffset=@UTCOffset, @ServerID = @ServerID, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterID = @counterID
end
if @counterAggregation = 1 -- weighted average
begin
insert into #metrictable2
EXECUTE sp_executesql @counterSQLWeightedAverage, @ParmDefinition, @Interval = @Interval, @UTCOffset=@UTCOffset, @ServerID = @ServerID, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterID = @counterID
end
if @counterAggregation = 2--per minute
begin
insert into #metrictable2
EXECUTE sp_executesql @counterSQLPerMinute, @ParmDefinition, @Interval = @Interval, @UTCOffset=@UTCOffset, @ServerID = @ServerID, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterID = @counterID
end
end

if(@countOfCustomGraphs = 2)
begin
select @metricName3 = @counterName
create table #metrictable3 (InstanceName nvarchar(256), LastCollectioninInterval DateTime, metricid int, metricvalue decimal)

if @counterAggregation = 0 -- max
begin
insert into #metrictable3
EXECUTE sp_executesql @counterSQLMax, @ParmDefinition, @Interval = @Interval, @UTCOffset=@UTCOffset, @ServerID = @ServerID, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterID = @counterID
end
if @counterAggregation = 1 -- weighted average
begin
insert into #metrictable3
EXECUTE sp_executesql @counterSQLWeightedAverage, @ParmDefinition, @Interval = @Interval, @UTCOffset=@UTCOffset, @ServerID = @ServerID, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterID = @counterID
end
if @counterAggregation = 2--per minute
begin
insert into #metrictable3
EXECUTE sp_executesql @counterSQLPerMinute, @ParmDefinition, @Interval = @Interval, @UTCOffset=@UTCOffset, @ServerID = @ServerID, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterID = @counterID
end
end

if(@countOfCustomGraphs = 3)
begin
select @metricName4 = @counterName
create table #metrictable4 (InstanceName nvarchar(256), LastCollectioninInterval DateTime, metricid int, metricvalue decimal)

if @counterAggregation = 0 -- max
begin
insert into #metrictable4
EXECUTE sp_executesql @counterSQLMax, @ParmDefinition, @Interval = @Interval, @UTCOffset=@UTCOffset, @ServerID = @ServerID, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterID = @counterID
end
if @counterAggregation = 1 -- weighted average
begin
insert into #metrictable4
EXECUTE sp_executesql @counterSQLWeightedAverage, @ParmDefinition, @Interval = @Interval, @UTCOffset=@UTCOffset, @ServerID = @ServerID, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterID = @counterID
end
if @counterAggregation = 2--per minute
begin
insert into #metrictable4
EXECUTE sp_executesql @counterSQLPerMinute, @ParmDefinition, @Interval = @Interval, @UTCOffset=@UTCOffset, @ServerID = @ServerID, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterID = @counterID
end
end
if(@countOfCustomGraphs = 4)
begin
select @metricName5 = @counterName
create table #metrictable5 (InstanceName nvarchar(256), LastCollectioninInterval DateTime, metricid int, metricvalue decimal)
if @counterAggregation = 0 -- max
begin
insert into #metrictable5
EXECUTE sp_executesql @counterSQLMax, @ParmDefinition, @Interval = @Interval, @UTCOffset=@UTCOffset, @ServerID = @ServerID, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterID = @counterID
end
if @counterAggregation = 1 -- weighted average
begin
insert into #metrictable5
EXECUTE sp_executesql @counterSQLWeightedAverage, @ParmDefinition, @Interval = @Interval, @UTCOffset=@UTCOffset, @ServerID = @ServerID, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterID = @counterID
end
if @counterAggregation = 2--per minute
begin
insert into #metrictable5
EXECUTE sp_executesql @counterSQLPerMinute, @ParmDefinition, @Interval = @Interval, @UTCOffset=@UTCOffset, @ServerID = @ServerID, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterID = @counterID
end
end

select @countOfCustomGraphs = @countOfCustomGraphs + 1
end --end of source = 2 (custom)

fetch next from customCounterCursor
into @counterID, @counterName,@counterAggregation, @counterSource
end

close customCounterCursor
deallocate customCounterCursor

select @nonCustomCounterSelect = substring(@nonCustomCounterSelect,0,len(@nonCustomCounterSelect))
select @finalSelectMetrics = substring(@finalSelectMetrics,0,len(@finalSelectMetrics))

--SQLdm 8.5 (Ankit Srivastava): for Virtualization Counters - starts here
select @VirtualizationCounterSelect=SUBSTRING(@VirtualizationCounterSelect,0,len(@VirtualizationCounterSelect))
select @virtualizationFinalSelectMetrics=substring(@virtualizationFinalSelectMetrics,0,len(@virtualizationFinalSelectMetrics))
--SQLdm 8.5 (Ankit Srivastava): for Virtualization Counters - ends here

declare @NumberOfCustomGraphs int
select @NumberOfCustomGraphs = @countOfCustomGraphs

create table #tempCustomCounters(InstanceName nvarchar(256), LastCollectioninInterval DateTime)
create table #ReportsCounters(InstanceName nvarchar(256), LastCollectioninInterval DateTime)

if(@NumberOfCustomGraphs = 0)
begin
insert #tempCustomCounters
select b.InstanceName, b.LastCollectioninInterval
from #baseTable b 
end	
if(@NumberOfCustomGraphs = 1)
begin
alter table #tempCustomCounters add m1 decimal
execute('alter table #ReportsCounters add [' + @metricName1 + '] decimal')
exec('insert #tempCustomCounters
select b.InstanceName, b.LastCollectioninInterval, m1.metricvalue as m1
from #baseTable b 
	left join #metrictable1 m1 on b.LastCollectioninInterval = m1.LastCollectioninInterval')
end	
if(@NumberOfCustomGraphs = 2)
begin
alter table #tempCustomCounters add m1 decimal, m2 decimal
execute('alter table #ReportsCounters add [' + @metricName1 + '] decimal')
execute('alter table #ReportsCounters add [' + @metricName2 + '] decimal')
exec('insert #tempCustomCounters
select b.InstanceName, b.LastCollectioninInterval, m1.metricvalue as m1, m2.metricvalue as m2 
from #baseTable b
	left join #metrictable1 m1 on b.LastCollectioninInterval = m1.LastCollectioninInterval
	left join #metrictable2 m2 on b.LastCollectioninInterval = m2.LastCollectioninInterval')
end
if(@NumberOfCustomGraphs = 3)
begin
alter table #tempCustomCounters add m1 decimal, m2 decimal, m3 decimal
execute('alter table #ReportsCounters add [' + @metricName1 + '] decimal')
execute('alter table #ReportsCounters add [' + @metricName2 + '] decimal')
execute('alter table #ReportsCounters add [' + @metricName3 + '] decimal')
exec('insert #tempCustomCounters
select b.InstanceName, b.LastCollectioninInterval, m1.metricvalue as m1, m2.metricvalue as m2, m3.metricvalue as m3 
from #baseTable b 
	left join #metrictable1 m1 on b.LastCollectioninInterval = m1.LastCollectioninInterval
	left join #metrictable2 m2 on b.LastCollectioninInterval = m2.LastCollectioninInterval
	left join #metrictable3 m3 on b.LastCollectioninInterval = m3.LastCollectioninInterval')
end
if(@NumberOfCustomGraphs = 4)
begin
alter table #tempCustomCounters add m1 decimal, m2 decimal, m3 decimal, m4 decimal
execute('alter table #ReportsCounters add [' + @metricName1 + '] decimal')
execute('alter table #ReportsCounters add [' + @metricName2 + '] decimal')
execute('alter table #ReportsCounters add [' + @metricName3 + '] decimal')
execute('alter table #ReportsCounters add [' + @metricName4 + '] decimal')
exec('insert #tempCustomCounters
select b.InstanceName, b.LastCollectioninInterval, m1.metricvalue as m1, m2.metricvalue as m2, m3.metricvalue as m3, m4.metricvalue as m4 
from #baseTable b 
	left join #metrictable1 m1 on b.LastCollectioninInterval = m1.LastCollectioninInterval
	left join #metrictable2 m2 on b.LastCollectioninInterval = m2.LastCollectioninInterval
	left join #metrictable3 m3 on b.LastCollectioninInterval = m3.LastCollectioninInterval
	left join #metrictable4 m4 on b.LastCollectioninInterval = m4.LastCollectioninInterval')
end
if(@NumberOfCustomGraphs = 5)
begin
	alter table #tempCustomCounters add m1 decimal, m2 decimal, m3 decimal, m4 decimal, m5 decimal
execute('alter table #ReportsCounters add [' + @metricName1 + '] decimal')
execute('alter table #ReportsCounters add [' + @metricName2 + '] decimal')
execute('alter table #ReportsCounters add [' + @metricName3 + '] decimal')
execute('alter table #ReportsCounters add [' + @metricName4 + '] decimal')
execute('alter table #ReportsCounters add [' + @metricName5 + '] decimal')
exec('insert #tempCustomCounters	
select b.InstanceName, b.LastCollectioninInterval, m1.metricvalue as m1, m2.metricvalue as m2, m3.metricvalue as m3, m4.metricvalue as m4, m5.metricvalue as m5 
from #baseTable b 
	left join #metrictable1 m1 on b.LastCollectioninInterval = m1.LastCollectioninInterval
	left join #metrictable2 m2 on b.LastCollectioninInterval = m2.LastCollectioninInterval
	left join #metrictable3 m3 on b.LastCollectioninInterval = m3.LastCollectioninInterval
	left join #metrictable4 m4 on b.LastCollectioninInterval = m4.LastCollectioninInterval
	left join #metrictable5 m5 on b.LastCollectioninInterval = m5.LastCollectioninInterval')
end

IF OBJECT_ID('tempdb..#metrictable1') IS NOT NULL
drop table #metrictable1
IF OBJECT_ID('tempdb..#metrictable2') IS NOT NULL
drop table #metrictable2
IF OBJECT_ID('tempdb..#metrictable3') IS NOT NULL
drop table #metrictable3
IF OBJECT_ID('tempdb..#metrictable4') IS NOT NULL
drop table #metrictable4
IF OBJECT_ID('tempdb..#metrictable5') IS NOT NULL
drop table #metrictable5
IF OBJECT_ID('tempdb..#baseTable') IS NOT NULL
drop table #baseTable

execute('insert into #ReportsCounters select * from #tempCustomCounters tcc  ')

select @NonVirtualizationSQLString = '' 
select @VirtualizationSQLString =''


SET @ParmDefinition = N'@Interval int, @UTCOffset int, @ServerID int, @UTCStart DateTime, @UTCEnd DateTime';

if(Len(@finalSelectMetrics) >0)
select @NonVirtualizationSQLString = N'select nonCustom.InstanceName, nonCustom.LastCollectioninInterval, ' + @finalSelectMetrics + ' from ('
else
	select @NonVirtualizationSQLString = N'select nonCustom.InstanceName, nonCustom.LastCollectioninInterval from ('
select @NonVirtualizationSQLString = @NonVirtualizationSQLString + ' select m.InstanceName as InstanceName, '
+ ' dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime]))) as [LastCollectioninInterval], '

--SQLdm 8.5 (Ankit Srivastava): for Virtualization Counters - starts here
if(Len(@virtualizationFinalSelectMetrics) >0)
begin
select @VirtualizationSQLString = N'select virt.InstanceName, virt.LastCollectioninInterval, ' + @virtualizationFinalSelectMetrics + ' from ('
select @virtualizationFinalSelectMetrics= ' , '+@virtualizationFinalSelectMetrics
end
else
	select @VirtualizationSQLString = N'select virt.InstanceName, virt.LastCollectioninInterval from ('

select @VirtualizationSQLString = @VirtualizationSQLString + ' select m.InstanceName as InstanceName, '
+ ' dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, vm.[UTCCollectionDateTime]))) as [LastCollectioninInterval], '
--SQLdm 8.5 (Ankit Srivastava): for Virtualization Counters - ends here

if(len(@VirtualizationCounterSelect) > 0)
begin
	select @VirtualizationSQLString = @VirtualizationSQLString + @VirtualizationCounterSelect  --SQLdm 8.5 (Ankit Srivastava): for Virtualization Counters - added newly
end
else 
begin
	select @VirtualizationSQLString = substring(@VirtualizationSQLString,0,len(@VirtualizationSQLString))  --SQLdm 8.5 (Ankit Srivastava): for Virtualization Counters - added newly

end
if(len(@nonCustomCounterSelect) > 0)
begin
	select @NonVirtualizationSQLString = @NonVirtualizationSQLString + @nonCustomCounterSelect
end
else 
begin
	select @NonVirtualizationSQLString = substring(@NonVirtualizationSQLString,0,len(@NonVirtualizationSQLString))
end
	
select @NonVirtualizationSQLString = @NonVirtualizationSQLString + ' from [MonitoredSQLServers] m (nolock)'
+ ' left join [ServerStatistics] s1 (nolock)'
+ ' on m.[SQLServerID] = s1.[SQLServerID]'
+ ' left join [OSStatistics] o (nolock)'
+ ' on o.[SQLServerID] = s1.[SQLServerID] and o.[UTCCollectionDateTime] = s1.[UTCCollectionDateTime]'
+ ' where m.[SQLServerID] = @ServerID and s1.[UTCCollectionDateTime] between @UTCStart and @UTCEnd'
+ ' group by [InstanceName] '
+ ' ,datepart(yy, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime]))'
+ ' ,case when @Interval <= 3 then datepart(mm,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end'
+ ' ,case when @Interval <= 2 then datepart(dd,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end'
+ ' ,case when @Interval <= 1 then datepart(hh,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end'
+ ' ,case when @Interval = 0 then datepart(mi,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end'

--SQLdm 8.5 (Ankit Srivastava): for Virtualization Counters - starts here
select @VirtualizationSQLString = @VirtualizationSQLString + ' from [MonitoredSQLServers] m (nolock)'
+' left join [VMStatistics] vm (nolock) '
+' on vm.[SQLServerID] = m.[SQLServerID] '
+ ' where vm.[SQLServerID] = @ServerID and vm.[UTCCollectionDateTime] between @UTCStart and @UTCEnd'
+ ' group by [InstanceName] '
+ ' ,datepart(yy, dateadd(mi, @UTCOffset, vm.[UTCCollectionDateTime]))'
+ ' ,case when @Interval <= 3 then datepart(mm,dateadd(mi, @UTCOffset, vm.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, vm.[UTCCollectionDateTime])) end'
+ ' ,case when @Interval <= 2 then datepart(dd,dateadd(mi, @UTCOffset, vm.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, vm.[UTCCollectionDateTime])) end'
+ ' ,case when @Interval <= 1 then datepart(hh,dateadd(mi, @UTCOffset, vm.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, vm.[UTCCollectionDateTime])) end'
+ ' ,case when @Interval = 0 then datepart(mi,dateadd(mi, @UTCOffset, vm.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, vm.[UTCCollectionDateTime])) end'
--SQLdm 8.5 (Ankit Srivastava): for Virtualization Counters - ends here

select @NonVirtualizationSQLString = @NonVirtualizationSQLString + ') as nonCustom'
+ ' left join #ReportsCounters custom on custom.LastCollectioninInterval = nonCustom.LastCollectioninInterval and custom.InstanceName = nonCustom.InstanceName collate database_default ' --SQLdm 8.5 (Ankit Srivastava): for Virtualization Counters - removed order by clause

select @VirtualizationSQLString = @VirtualizationSQLString + ') as virt'
+ ' left join #ReportsCounters custom on custom.LastCollectioninInterval = virt.LastCollectioninInterval and custom.InstanceName = virt.InstanceName collate database_default ' --SQLdm 8.5 (Ankit Srivastava): for Virtualization Counters -removed order by clause


--EXECUTE sp_executesql @SQLString, @ParmDefinition, @Interval = @Interval, @UTCOffset=@UTCOffset, @ServerID = @ServerID, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd --SQLdm 8.5 (Ankit Srivastava): for Virtualization Counters - commented this part

--SQLdm 8.5 (Ankit Srivastava): for Virtualization Counters - starts here
declare @finalString nvarchar(max)
select @finalString='Select nonVirt.* '+@virtualizationFinalSelectMetrics+' from ( ' +@NonVirtualizationSQLString+' ) as nonVirt left Join ( '+@VirtualizationSQLString+' ) as virt '
+' on nonVirt.InstanceName=virt.InstanceName and nonVirt.LastCollectioninInterval=virt.LastCollectioninInterval '
+' order by nonVirt.LastCollectioninInterval asc'
EXECUTE sp_executesql @finalString, @ParmDefinition, @Interval = @Interval, @UTCOffset=@UTCOffset, @ServerID = @ServerID, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd
--SQLdm 8.5 (Ankit Srivastava): for Virtualization Counters - ends here


IF OBJECT_ID('tempdb..#tempCustomCounters') IS NOT NULL
drop table #tempCustomCounters
IF OBJECT_ID('tempdb..#ReportsCounters') IS NOT NULL
drop table #ReportsCounters



end -- end proc
 
 
GO 

---------- P_GETDASHBOARDLAYOUT.SQL
if (object_id('p_GetDashboardLayout') is not null)
begin
drop procedure [p_GetDashboardLayout]
end
go

create procedure [p_GetDashboardLayout] 
	@DashboardLayoutID int
as
begin

	if exists (select 1 from [DashboardLayouts] where DashboardLayoutID = @DashboardLayoutID)
	begin
		select DashboardLayoutID, LoginName, Name, LastUpdated, LastViewed, Configuration, LayoutImage, system_user as CurrentUser 
			from [DashboardLayouts]
			where DashboardLayoutID = @DashboardLayoutID
	end
	else
		raiserror ('The dashboard layout id was not found.', 1, 0)

end
 
GO 

---------- P_GETDASHBOARDLAYOUTID.SQL
if (object_id('p_GetDashboardLayoutID') is not null)
begin
drop procedure [p_GetDashboardLayoutID]
end
go

create procedure [p_GetDashboardLayoutID] 
	@LoginName nvarchar(256),
	@Name nvarchar(128)
as
begin

	select DashboardLayoutID from [DashboardLayouts]
		where LoginName = @LoginName
			and Name = @Name

end	
 
GO 

---------- P_GETDASHBOARDLAYOUTS.SQL
if (object_id('p_GetDashboardLayouts') is not null)
begin
drop procedure [p_GetDashboardLayouts]
end
go

create procedure [p_GetDashboardLayouts] 
	@LoginName nvarchar(256),
	@Filter int
as
begin
	-- get all for the user plus all the defaults
	if (@Filter = 0)
		select DashboardLayoutID, LoginName, Name, LastUpdated, LastViewed, Configuration, LayoutImage, system_user as CurrentUser
			from [DashboardLayouts]
			where LoginName is null
			order by Name
	else if (@Filter = 1)
		select DashboardLayoutID, LoginName, Name, LastUpdated, LastViewed, Configuration, LayoutImage, system_user as CurrentUser
			from [DashboardLayouts]
			where LoginName = @LoginName
				or LoginName is null
			order by LoginName Desc, Name
	else
	-- otherwise get all
		select DashboardLayoutID, LoginName, Name, LastUpdated, LastViewed, Configuration, LayoutImage, system_user as CurrentUser
			from [DashboardLayouts]
			order by LoginName, Name

end	
 
GO 

---------- P_GETDATABASEBYINSTANCE.SQL
-- //Ashu: Should consider creating following indexes
-- create index idx_alerts_data ON Alerts(DatabaseName, Active, AlertID)
-- Indexes on DatabaseStatistics and DatabaseSize tables will be assessed when we have data for those tables.
--p_GetDatabaseByInstance @ServerId = 6
IF (OBJECT_ID('p_GetDatabaseByInstance') IS NOT NULL)
BEGIN
  DROP PROC p_GetDatabaseByInstance
END
GO
CREATE PROCEDURE [dbo].[p_GetDatabaseByInstance]
    @ServerId INT
AS
BEGIN

Create  table #tempDatabase
(
DatabaseName nvarchar(100),
UserTables int
)

DECLARE @SQL NVARCHAR(max)
 
SET @SQL = stuff((
            SELECT '
UNION
SELECT ' + quotename(name, '''') + ' collate database_default as Db_Name, t.Name collate database_default as Table_Name
FROM ' + quotename(name) + '.sys.tables t'
            FROM sys.databases d (NOLOCK) where state = 0
            ORDER BY name
            FOR XML PATH('')
                ,type
            ).value('.', 'nvarchar(max)'), 1, 8, '') 
			 
SET @SQL= 'Insert into #tempDatabase (DatabaseName,UserTables) Select Db_Name,Count(Table_Name) from ( ' +@SQL+ ' ) db group by Db_Name '

EXECUTE sp_executesql @SQL ;

WITH LatestDatabaseStats (DatabaseID, UTCCollectionDateTime)
AS 
(
	SELECT ds.DatabaseID, MAX(ds.UTCCollectionDateTime)
	FROM SQLServerDatabaseNames dbn (NOLOCK) 
	INNER JOIN DatabaseStatistics ds (NOLOCK) ON dbn.DatabaseID = ds.DatabaseID
	WHERE dbn.SQLServerID = @ServerId
	GROUP BY ds.DatabaseID	
), 

LatestDatabaseSize (DatabaseID, UTCCollectionDateTime)
AS
(
	SELECT ds.DatabaseID, MAX(ds.UTCCollectionDateTime)
	FROM SQLServerDatabaseNames dbn  (NOLOCK) INNER JOIN DatabaseSize ds (NOLOCK) ON dbn.DatabaseID = ds.DatabaseID
	WHERE dbn.SQLServerID = @ServerId
	GROUP BY ds.DatabaseID	
),
LatestDatabaseBackUpStats(DatabaseName,LastBackupDateTime)
AS
(
	SELECT database_name DatabaseName, MAX(backup_finish_date) BackUpFinishDate
	FROM msdb..backupset (NOLOCK) WHERE type <> 'F'
	GROUP BY database_name
)

SELECT 
DB.DatabaseID, 
DB.SQLServerID InstanceID, 
DB.DatabaseName, 
DB.SystemDatabase IsSystemDatabase,
DB.CreationDateTime, 
mss.Active IsInstanceEnabled, 
ISNULL(dstats.Transactions, 0) AS LatestTransactions, 
ISNULL(dstats.DatabaseStatus, 4) AS LatestDatabaseStatus,
ISNULL(dsize.DataFileSizeInKilobytes/1024, 0) AS DataFileSizeMb,
ISNULL(dsize.LogFileSizeInKilobytes/1024, 0) AS LogFileSizeMb,
ISNULL((dsize.DataFileSizeInKilobytes + dsize.LogFileSizeInKilobytes)/1024, 0) AS TotalFileSizeMb,
ISNULL(dsize.DataSizeInKilobytes/1024, 0) AS DataSizeMb,
ISNULL(dsize.LogSizeInKilobytes/1024, 0) AS LogSizeMb,
ISNULL((dsize.DataSizeInKilobytes + dsize.LogSizeInKilobytes)/1024, 0) AS TotalSizeMb,
--START SQLdm 10.0 (Sanjali Makkar) - To Add Index Size and Text Size parameters
ISNULL(dsize.IndexSizeInKilobytes/1024, 0) AS IndexSizeMb,
ISNULL(dsize.TextSizeInKilobytes/1024, 0) AS TextSizeMb,
--END SQLdm 10.0 (Sanjali Makkar) - To Add Index Size and Text Size parameters
dsize.UTCCollectionDateTime AS LatestSizeCollectionTime,
dstats.UTCCollectionDateTime AS LatestStatsCollectionTime,
(SELECT COUNT(0) FROM [DatabaseFiles] DF WHERE DF.DatabaseID = DB.DatabaseID AND DF.FileType = 0) DataFileCount,
(SELECT COUNT(0) FROM [DatabaseFiles] DF WHERE DF.DatabaseID = DB.DatabaseID AND DF.FileType = 1) LogFileCount,
--ISNULL(SY.recovery_model_desc,'') RecoveryModel,
DB_BK_UP.LastBackupDateTime,
ISNULL(db.UserTables , 0) UserTables
FROM SQLServerDatabaseNames DB (NOLOCK)
INNER JOIN MonitoredSQLServers mss (NOLOCK) 
	ON mss.SQLServerID = DB.SQLServerID
LEFT OUTER JOIN LatestDatabaseSize ldsize (NOLOCK) ON ldsize.DatabaseID = DB.DatabaseID
LEFT OUTER JOIN DatabaseSize dsize (NOLOCK) 
	ON ldsize.DatabaseID = dsize.DatabaseID 
	AND ldsize.UTCCollectionDateTime = dsize.UTCCollectionDateTime
LEFT OUTER JOIN LatestDatabaseStats ldstats (NOLOCK) 
	ON ldstats.DatabaseID = DB.DatabaseID
LEFT OUTER JOIN DatabaseStatistics dstats (NOLOCK) 
	ON ldstats.DatabaseID = dstats.DatabaseID 
	AND ldstats.UTCCollectionDateTime = dstats.UTCCollectionDateTime
LEFT OUTER JOIN LatestDatabaseBackUpStats DB_BK_UP (NOLOCK) 
	ON LOWER(DB_BK_UP.DatabaseName) COLLATE DATABASE_DEFAULT = LOWER(DB.DatabaseName) COLLATE DATABASE_DEFAULT
LEFT OUTER JOIN #tempDatabase db (NOLOCK) ON DB.DatabaseName COLLATE DATABASE_DEFAULT=db.DatabaseName COLLATE DATABASE_DEFAULT
WHERE DB.SQLServerID = @ServerId 
AND DB.DatabaseName IS NOT NULL
GROUP BY DB.DatabaseID,DB.SQLServerID, DB.DatabaseName, DB.SystemDatabase, DB.CreationDateTime,
mss.Active, 
dstats.Transactions, dstats.DatabaseStatus,
dsize.DataFileSizeInKilobytes, dsize.LogFileSizeInKilobytes, 
dsize.DataSizeInKilobytes, dsize.LogSizeInKilobytes, 
dsize.TextSizeInKilobytes, dsize.IndexSizeInKilobytes,
dsize.UTCCollectionDateTime, dstats.UTCCollectionDateTime,
DB_BK_UP.LastBackupDateTime,
db.UserTables

drop table #tempDatabase

END
 

GO
 
GO 

---------- P_GETDATABASECOUNTERS.SQL
if (object_id('[p_GetDatabaseCounters]') is not null)
begin
drop procedure [p_GetDatabaseCounters]
end
go
create procedure [dbo].[p_GetDatabaseCounters]
	@SQLServerID int,
	@UTCSnapshotCollectionDateTime datetime = null,
	@HistoryInMinutes int = null
as
begin
set transaction isolation level read uncommitted
declare @err int
declare @BeginDateTime datetime
declare @EndDateTime datetime

if (@UTCSnapshotCollectionDateTime is null)
	select @EndDateTime = (select max(UTCCollectionDateTime) from [ServerStatistics] where [SQLServerID] = @SQLServerID)
else
	select @EndDateTime = @UTCSnapshotCollectionDateTime

if (@HistoryInMinutes is null)
	select @BeginDateTime = @EndDateTime
else
	select @BeginDateTime = dateadd(n, -@HistoryInMinutes, @EndDateTime)

-- Get trend data
select
	[DatabaseName],
	[UTCCollectionDateTime],
	[DatabaseStatus],
	[Transactions],
	[LogFlushWaits],
	[LogFlushes],
	[LogKilobytesFlushed],
	[LogCacheReads],
	[LogCacheHitRatio],
	[TimeDeltaInSeconds],
	[NumberReads],
	[NumberWrites],
	[BytesRead],
	[BytesWritten],
	[IoStallMS],
	[DatabaseStatistics].[LastBackupDateTime] -- SQLdm 10.0 (Vandana Gogna) - Database backup alerts
from
	[DatabaseStatistics] (nolock)
	inner join [SQLServerDatabaseNames] 
	on [DatabaseStatistics].DatabaseID = [SQLServerDatabaseNames].DatabaseID 
	inner join [MonitoredSQLServers]
	on [SQLServerDatabaseNames].[SQLServerID] = [MonitoredSQLServers].[SQLServerID]
where
	[SQLServerDatabaseNames].[SQLServerID] = @SQLServerID
	and [DatabaseStatistics].[UTCCollectionDateTime] between @BeginDateTime and @EndDateTime
order by 
	[DatabaseStatistics].[UTCCollectionDateTime]
	
select @err = @@error
return @err
end
 
GO 

---------- P_GETDATABASEOVERVIEW.SQL
IF (OBJECT_ID('p_GetDatabaseOverview') IS NOT NULL)
BEGIN
DROP PROCEDURE p_GetDatabaseOverview
END
GO

CREATE PROCEDURE [dbo].[p_GetDatabaseOverview]
				@ServerId int
AS
BEGIN

declare @Active bit
declare @DBN table(DatabaseID int, DatabaseName nvarchar(256), CreationDateTime datetime, UTCCollectionDateTime datetime, IsSystemDatabase bit,AlertsCount BIGINT)

select @Active = [Active] from MonitoredSQLServers (nolock) where [SQLServerID] = @ServerId
if @Active = 1
begin
insert into @DBN
select distinct(ds.DatabaseID), dn.DatabaseName, dn.CreationDateTime, max(ds.UTCCollectionDateTime),dn.SystemDatabase [IsSystemDatabase], (SELECT COUNT(0) FROM Alerts WHERE DatabaseName = dn.DatabaseName) AlertsCount
from DatabaseSize ds (nolock) inner join SQLServerDatabaseNames dn (nolock) on ds.DatabaseID = dn.DatabaseID
where dn.SQLServerID = @ServerId
--This is being done because it is possible to refresh the report during a scheduled refresh and get a subset of the databases
--by doing this we get all databases that have been updated in the last 10 minutes of the latest refresh 
--and DATEDIFF(MI, ds.UTCCollectionDateTime ,(select MAX(ds.UTCCollectionDateTime) from DatabaseStatistics ds inner join SQLServerDatabaseNames dn2 on ds.DatabaseID = dn2.DatabaseID
--where dn2.SQLServerID = dn.SQLServerID)) < 10
--and ds.UTCCollectionDateTime = (select MAX(UTCCollectionDateTime) from DatabaseStatistics (nolock))
and ds.UTCCollectionDateTime= (
select MAX(ds.UTCCollectionDateTime) from DatabaseSize ds (nolock) inner join SQLServerDatabaseNames dn2 (nolock) on ds.DatabaseID = dn2.DatabaseID
where dn2.SQLServerID = dn.SQLServerID)
group by ds.DatabaseID, dn.DatabaseName, dn.CreationDateTime,dn.SystemDatabase
end

select 
	[DatabaseName],
	[DatabaseStatus],
	dbn.[CreationDateTime],
	dbn.[UTCCollectionDateTime],
	(DataFileSizeInKilobytes + LogFileSizeInKilobytes) / 1024 as TotalSizeMb,
	--SQLdm 8.5 (Gaurav): Added to bring this new field in the response [START]
	dbn.[IsSystemDatabase],
	dbn.[AlertsCount]
	--SQLdm 8.5 (Gaurav): Added to bring this new field in the response [END]
from @DBN dbn
	join [DatabaseSize] ds (nolock)
	on  dbn.[DatabaseID] = ds.[DatabaseID] and
		dbn.[UTCCollectionDateTime] = ds.[UTCCollectionDateTime]
order by
	dbn.[DatabaseName],
	dbn.[UTCCollectionDateTime]
END
 
 
 
GO 

---------- P_GETDATABASES.SQL
if (object_id('p_GetDatabases') is not null)
begin
drop procedure p_GetDatabases
end
go
CREATE PROCEDURE [dbo].p_GetDatabases(
	@InstanceId int
)
AS
BEGIN
	--- Gets the list of databases for the instance id
;WITH cte_DistinctDatabases(DatabaseID, DatabaseName)
AS
(
	SELECT 
		DatabaseID = MIN(DatabaseID)
		,DatabaseName
	FROM SQLServerDatabaseNames
	WHERE SQLServerID = @InstanceId and DatabaseName is not null and len(DatabaseName) > 0
	GROUP BY DatabaseName
)

SELECT
	cte.DatabaseID
	,cte.DatabaseName
	,SystemDatabase
FROM
	SQLServerDatabaseNames dn
	inner join cte_DistinctDatabases cte on dn.DatabaseID = cte.DatabaseID
END
 
GO 

---------- P_GETDATABASESFORSERVER.SQL
--retrieves those databases on which at least one query  
-- has been fired for the given instance

-- @SQLServerID is the Instance ID
-- @StartIndex is the index from where databases needs to be retrieved
-- @RecordsCount is the number of databases to be retrieved

-- exec p_GetDatabasesForServer 9,2,2

if (object_id('p_GetDatabasesForServer') is not null)
begin
	drop procedure [p_GetDatabasesForServer]
end
go

create procedure [dbo].[p_GetDatabasesForServer]
	@SQLServerID int,
	@StartIndex int = 1,
	@RecordsCount int = -1
as
begin
	IF (@RecordsCount = -1)
		SELECT
			DISTINCT(QMS.DatabaseID),
			SSDN.DatabaseName,
			SSDN.SystemDatabase AS IsSystemDatabase
		FROM
			[QueryMonitorStatistics] AS QMS 
			INNER JOIN
			[SQLServerDatabaseNames] AS SSDN
			ON QMS.DatabaseID = SSDN.DatabaseID
		WHERE
			QMS.SQLServerID = @SQLServerID
		ORDER BY
			SSDN.DatabaseName
	ELSE
		begin
			WITH DatabaseNames AS
			(
				SELECT
					DISTINCT(QMS.DatabaseID),
					SSDN.DatabaseName,
					SSDN.SystemDatabase AS IsSystemDatabase,
					DENSE_RANK() OVER (ORDER BY SSDN.DatabaseName) AS RecordRank
				FROM
					[QueryMonitorStatistics] AS QMS 
					INNER JOIN
					[SQLServerDatabaseNames] AS SSDN
					ON QMS.DatabaseID = SSDN.DatabaseID
				WHERE
					QMS.SQLServerID = @SQLServerID
			)

			SELECT
				DatabaseID,
				DatabaseName,
				IsSystemDatabase
			FROM
				DatabaseNames
			WHERE
				RecordRank BETWEEN @StartIndex AND (@StartIndex + @RecordsCount - 1)
			ORDER BY
				DatabaseName
		end
end
go
 
GO 

---------- P_GETDATABASESTATISTICS.SQL
if (object_id('p_GetDatabaseStatistics') is not null)
begin
drop procedure p_GetDatabaseStatistics
end
go
-- @Interval - Granularity of calculation:
--	0 - Minutes
--	1 - Hours
--	2 - Days
--	3 - Months
--	4 - Years
--  5 - All Time
create procedure [dbo].[p_GetDatabaseStatistics]
	@ServerId int,
	@DatabaseNameFilter sysname = null,
	@UTCStart DateTime,
	@UTCEnd DateTime,
	@CompareDatabaseNameFilter sysname = null,
	@CompareStartRange DateTime = null,
	@UTCOffset int = 0,
	@Interval int
as
begin
set ansi_warnings off
set ansi_nulls off


set rowcount 0


declare @CompareEndRange DateTime
set @CompareStartRange = isnull(@CompareStartRange,@UTCStart)
set @CompareEndRange = dateadd(mi, datediff(mi, @UTCStart, @UTCEnd), @CompareStartRange)

if (select isnull(object_id('tempdb..#DBStatistics'), 0)) <> 0 
begin
	drop table #DBStatistics
end

create table #DBStatistics(
	DatabaseName nvarchar(257),
	LastCollectioninInterval datetime,
	IntervalNumber int,
	AverageDataFileSizeMb float,
	AverageLogFileSizeMb float,
	AverageDataSizeMb float,
	GrowthOverPeriod decimal(38, 19),
	KBReadPerSecond float,
	KBWrittenPerSecond float,
	TransactionsPerSecond float,
	W_LogCacheHitRatio float,
	W_LogCacheReads bigint,
	W_LogFileSizeInKilobytes float,
	W_LogFlushWaits bigint,
	W_LogFlushes bigint,
	W_LogKilobytesFlushed bigint,
	W_PercentLogSpace float,
	RowNumber int identity,
	IntervalTemp bigint,
	LastBackupDateTime datetime -- SQLdm 10.0 (Vandana Gogna) - Database backup alerts
) 

insert into #DBStatistics(DatabaseName, LastCollectioninInterval, IntervalTemp, AverageDataFileSizeMb, AverageLogFileSizeMb, AverageDataSizeMb, KBReadPerSecond,
			KBWrittenPerSecond, TransactionsPerSecond, W_LogCacheHitRatio, W_LogCacheReads, W_LogFileSizeInKilobytes, W_LogFlushWaits,
			W_LogFlushes, W_LogKilobytesFlushed, W_PercentLogSpace, LastBackupDateTime)

select 
	[DatabaseName] = 
		case 
			when @DatabaseNameFilter = @CompareDatabaseNameFilter
		then 
			DatabaseName + ' (Base)'
		else DatabaseName end,
	[LastCollectioninInterval] = max(dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])),
	IntervalTemp = case
				 when isnull(@Interval,5) = 5
						then 0
				 when isnull(@Interval,5) = 4
						then datediff(yyyy, @UTCStart, max(dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])))
				 when isnull(@Interval,5) = 3
						then datediff(mm, @UTCStart, max(dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])))
				 when isnull(@Interval,5) = 2
						then datediff(dd, @UTCStart, max(dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])))
				 when isnull(@Interval,5) = 1
						then datediff(hh, @UTCStart, max(dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])))
				 when isnull(@Interval,5) =  0
						then datediff(mi, @UTCStart, max(dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])))
				 end,
	-- Note - isnull(nullif(dz.TimeDeltaInSeconds,0),1)  is used to cause 1 to be returned for the weighted average for size data if the time delta is 0
	-- This is to prevent division by zero and prevent loss of valid data (size data does not have to be converted to a rate)				 
	AverageDataFileSizeMb = (sum(DataFileSizeInKilobytes * isnull(nullif(dz.TimeDeltaInSeconds,0),1)  ) / 
		nullif(sum(case when DataFileSizeInKilobytes is not null then isnull(nullif(dz.TimeDeltaInSeconds,0),1)   else 0 end),0)) / 1024,
	AverageLogFileSizeMb = (sum(LogFileSizeInKilobytes * isnull(nullif(dz.TimeDeltaInSeconds,0),1)  ) / 
		nullif(sum(case when LogFileSizeInKilobytes is not null then isnull(nullif(dz.TimeDeltaInSeconds,0),1)   else 0 end),0)) / 1024,
	AverageDataSizeMb = (sum((DataSizeInKilobytes)* isnull(nullif(dz.TimeDeltaInSeconds,0),1)  ) / 
		nullif(sum(case when (DataSizeInKilobytes) is not null then isnull(nullif(dz.TimeDeltaInSeconds,0),1)   else 0 end),0)) / 1024,
	KBReadPerSecond = sum(convert(float,ds.BytesRead) / 1024) / nullif(sum(case when ds.BytesRead is not null then ds.TimeDeltaInSeconds else 0 end),0),
	KBWrittenPerSecond = sum(convert(float,ds.BytesWritten) / 1024) / nullif(sum(case when ds.BytesWritten is not null then ds.TimeDeltaInSeconds else 0 end) ,0),
	TransactionsPerSecond = sum(convert(float,ds.Transactions)) / nullif(sum(case when ds.Transactions is not null then ds.TimeDeltaInSeconds else 0 end)  ,0),
	W_LogCacheHitRatio =		sum(LogCacheHitRatio * ds.TimeDeltaInSeconds) / nullif(sum(case when LogCacheHitRatio is not null then ds.TimeDeltaInSeconds else 0 end),0),
	W_LogCacheReads =			sum(convert(float, LogCacheReads)) / nullif(sum(case when LogCacheReads is not null then ds.TimeDeltaInSeconds else 0 end),0),
	W_LogFileSizeInKilobytes =	sum(LogFileSizeInKilobytes * ds.TimeDeltaInSeconds) / nullif(sum(case when LogFileSizeInKilobytes is not null then ds.TimeDeltaInSeconds else 0 end),0),
	W_LogFlushWaits =			sum(LogFlushWaits * ds.TimeDeltaInSeconds) / nullif(sum(case when LogFlushWaits is not null then ds.TimeDeltaInSeconds else 0 end),0),
	W_LogFlushes =				sum(convert(float, LogFlushes)) / nullif(sum(case when LogFlushes is not null then ds.TimeDeltaInSeconds else 0 end),0),
	W_LogKilobytesFlushed =		sum(LogKilobytesFlushed * ds.TimeDeltaInSeconds) / nullif(sum(case when LogKilobytesFlushed is not null then ds.TimeDeltaInSeconds else 0 end),0),
	W_PercentLogSpace =			sum(PercentLogSpace * ds.TimeDeltaInSeconds) / nullif(sum(case when PercentLogSpace is not null then ds.TimeDeltaInSeconds else 0 end),0),
	[LastBackupDateTime]  = max(dateadd(mi, @UTCOffset, ds.[LastBackupDateTime]))
from
	[SQLServerDatabaseNames] names (nolock)
	left join [DatabaseStatistics] ds (nolock)
	on names.[DatabaseID] = ds.[DatabaseID]
	left join [DatabaseSize] dz (nolock)
	on names.[DatabaseID] = dz.[DatabaseID]
	and ds.DatabaseSizeTime = dz.UTCCollectionDateTime
where 
	names.[SQLServerID] = @ServerId
	and 
	names.[DatabaseName] = @DatabaseNameFilter
	--START SQLdm 9.1 (Ankit Srivastava ) --Rally Defect DE43423 -- Applying roundFunction to variables instead of column fields and added where caluse to reduce the scope
	and  ds.[UTCCollectionDateTime] BETWEEN dbo.fn_RoundDateTime(@Interval,@UTCStart) and dbo.fn_RoundDateTime(@Interval,@UTCEnd)
	and DatabaseStatisticsID is not null and LogFlushes is not null
	--END SQLdm 9.1 (Ankit Srivastava ) --Rally Defect DE43423 -- Applying roundFunction to variables instead of column fields and added where caluse to reduce the scope
group by
	[DatabaseName], 
--START SQLdm 9.1 (Ankit Srivastava ) --Rally Defect DE43423 -- Implementing bucketing to avoid too many function calls
case @Interval 
when 4 then convert(char(4), dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime]), 120) 
when 3 then convert(char(7), dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime]), 120) 
when 2 then convert(char(10), dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime]), 120) 
when 1 then convert(char(13), dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime]), 120) 
when 0 then convert(char(16), dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime]), 120) 
else '1' end
--END SQLdm 9.1 (Ankit Srivastava ) --Rally Defect DE43423 -- Implementing bucketing to avoid too many function calls
union
select 
	[DatabaseName] = 
		case 
			when @DatabaseNameFilter = @CompareDatabaseNameFilter 
		then 
			DatabaseName + ' (Compare)'
		else DatabaseName end,
	[LastCollectioninInterval] = max(dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])),
	IntervalTemp = case
					 when isnull(@Interval,5) = 5
							then 0
					 when isnull(@Interval,5) = 4
							then datediff(yyyy, @CompareStartRange, max(dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])))
					 when isnull(@Interval,5) = 3
							then datediff(mm, @CompareStartRange, max(dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])))
					 when isnull(@Interval,5) = 2
							then datediff(dd, @CompareStartRange, max(dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])))
					 when isnull(@Interval,5) = 1
							then datediff(hh, @CompareStartRange, max(dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])))
					 when isnull(@Interval,5) = 0
							then datediff(mi, @CompareStartRange, max(dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])))
					 end,
	-- Note - isnull(nullif(dz.TimeDeltaInSeconds,0),1)  is used to cause 1 to be returned for the weighted average for size data if the time delta is 0
	-- This is to prevent division by zero and prevent loss of valid data (size data does not have to be converted to a rate)					 
	AverageDataFileSizeMb = (sum(DataFileSizeInKilobytes * isnull(nullif(dz.TimeDeltaInSeconds,0),1)  ) / 
		nullif(sum(case when DataFileSizeInKilobytes is not null then isnull(nullif(dz.TimeDeltaInSeconds,0),1)   else 0 end),0)) / 1024,
	AverageLogFileSizeMb = (sum(LogFileSizeInKilobytes * isnull(nullif(dz.TimeDeltaInSeconds,0),1)  ) / 
		nullif(sum(case when LogFileSizeInKilobytes is not null then isnull(nullif(dz.TimeDeltaInSeconds,0),1)   else 0 end),0)) / 1024,
	AverageDataSizeMb = (sum((DataSizeInKilobytes)* isnull(nullif(dz.TimeDeltaInSeconds,0),1)  ) / 
		nullif(sum(case when (DataSizeInKilobytes) is not null then isnull(nullif(dz.TimeDeltaInSeconds,0),1)   else 0 end),0)) / 1024,
	KBReadPerSecond = sum(convert(float,ds.BytesRead) / 1024) / nullif(sum(case when ds.BytesRead is not null then ds.TimeDeltaInSeconds else 0 end),0),
	KBWrittenPerSecond = sum(convert(float,ds.BytesWritten) / 1024) / nullif(sum(case when ds.BytesWritten is not null then  ds.TimeDeltaInSeconds else 0 end) ,0),
	TransactionsPerSecond = sum(convert(float,ds.Transactions)) / nullif(sum(case when ds.Transactions is not null then  ds.TimeDeltaInSeconds else 0 end)  ,0),
	W_LogCacheHitRatio =		sum(LogCacheHitRatio *  ds.TimeDeltaInSeconds) / nullif(sum(case when LogCacheHitRatio is not null then  ds.TimeDeltaInSeconds else 0 end),0),
	W_LogCacheReads =			sum(convert(float, LogCacheReads)) / nullif(sum(case when LogCacheReads is not null then  ds.TimeDeltaInSeconds else 0 end),0),
	W_LogFileSizeInKilobytes =	sum(LogFileSizeInKilobytes *  ds.TimeDeltaInSeconds) / nullif(sum(case when LogFileSizeInKilobytes is not null then  ds.TimeDeltaInSeconds else 0 end),0),
	W_LogFlushWaits =			sum(LogFlushWaits *  ds.TimeDeltaInSeconds) / nullif(sum(case when LogFlushWaits is not null then  ds.TimeDeltaInSeconds else 0 end),0),
	W_LogFlushes =				sum(convert(float, LogFlushes)) / nullif(sum(case when LogFlushes is not null then  ds.TimeDeltaInSeconds else 0 end),0),
	W_LogKilobytesFlushed =		sum(LogKilobytesFlushed *  ds.TimeDeltaInSeconds) / nullif(sum(case when LogKilobytesFlushed is not null then  ds.TimeDeltaInSeconds else 0 end),0),
	W_PercentLogSpace =			sum(PercentLogSpace *  ds.TimeDeltaInSeconds) / nullif(sum(case when PercentLogSpace is not null then  ds.TimeDeltaInSeconds else 0 end),0),
	[LastBackupDateTime]  = max(dateadd(mi, @UTCOffset, ds.[LastBackupDateTime]))
from
	[SQLServerDatabaseNames] names (nolock)
	left join [DatabaseStatistics] ds (nolock)
	on names.[DatabaseID] = ds.[DatabaseID]
	left join [DatabaseSize] dz (nolock)
	on names.[DatabaseID] = dz.[DatabaseID]
	and ds.DatabaseSizeTime = dz.UTCCollectionDateTime
where 
	names.[SQLServerID] = @ServerId
	and 
	names.[DatabaseName] = @CompareDatabaseNameFilter
	--START SQLdm 9.1 (Ankit Srivastava ) --Rally Defect DE43423 -- Applying roundFunction to variables instead of column fields and added where caluse to reduce the scope
	and  ds.[UTCCollectionDateTime] BETWEEN dbo.fn_RoundDateTime(@Interval,@CompareStartRange) and dbo.fn_RoundDateTime(@Interval,@CompareEndRange)
	and DatabaseStatisticsID is not null and LogFlushes is not null
	--END SQLdm 9.1 (Ankit Srivastava ) --Rally Defect DE43423 -- Applying roundFunction to variables instead of column fields and added where caluse to reduce the scope
group by
	[DatabaseName], 
--START SQLdm 9.1 (Ankit Srivastava ) --Rally Defect DE43423 -- Implementing bucketing to avoid too many function calls
case @Interval 
when 4 then convert(char(4), dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime]), 120) 
when 3 then convert(char(7), dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime]), 120) 
when 2 then convert(char(10), dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime]), 120) 
when 1 then convert(char(13), dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime]), 120) 
when 0 then convert(char(16), dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime]), 120) 
else '1' end
--END SQLdm 9.1 (Ankit Srivastava ) --Rally Defect DE43423 -- Implementing bucketing to avoid too many function calls
order by
	IntervalTemp asc, 
	[DatabaseName] asc;

With Ranks
As (Select RowNumber, AverageDataSizeMb,
		MainPrev = Cast(Null as float),
		ComparePrev = Cast(Null as float)
    From #DBStatistics
	Where RowNumber = 1
	Union All
	Select R.RowNumber + 1, DBS.AverageDataSizeMb,
		MainPrev = case when [DatabaseName] = @DatabaseNameFilter or [DatabaseName] = @DatabaseNameFilter + ' (Base)' then R.AverageDataSizeMb
			else Null
			end,
		ComparePrev = case when [DatabaseName] = @CompareDatabaseNameFilter or [DatabaseName] = @CompareDatabaseNameFilter + ' (Compare)' then R.AverageDataSizeMb
			else Null
			end
    From #DBStatistics DBS
	Inner Join Ranks R On DBS.RowNumber = R.RowNumber + 1)
select 
	DatabaseName,
	[LastCollectioninInterval] = dbo.fn_RoundDateTime(@Interval, LastCollectioninInterval),
	IntervalNumber = dense_rank() Over (Order By IntervalTemp),
	AverageDataFileSizeMb,
	AverageLogFileSizeMb,
	DBS.AverageDataSizeMb,
	GrowthOverPeriod = Cast((DBS.AverageDataSizeMb / 
		nullif(case when [DatabaseName] = @DatabaseNameFilter then R.MainPrev else R.ComparePrev end,0) ) - 1
		As decimal(38, 19)),
	KBReadPerSecond,
	KBWrittenPerSecond,
	TransactionsPerSecond,
	W_LogCacheHitRatio,
	W_LogCacheReads,
	W_LogFileSizeInKilobytes,
	W_LogFlushWaits,
	W_LogFlushes,
	W_LogKilobytesFlushed,
	W_PercentLogSpace,
	LastBackupDateTime
from #DBStatistics DBS
Inner Join Ranks R On R.RowNumber = DBS.RowNumber
order by
	IntervalNumber asc, 
	[DatabaseName] asc
OPTION (MAXRECURSION 0);

end
Go

grant EXECUTE on [p_GetDatabaseStatistics] to [SQLdmConsoleUser]
 
GO 

---------- P_GETDATAFORMETRICS.SQL
IF (object_id('[p_GetDataForMetrics]') IS NOT NULL)
BEGIN
DROP PROCEDURE [p_GetDataForMetrics]
END
GO

CREATE PROCEDURE [dbo].[p_GetDataForMetrics]
	@SQLServerId int,
	@ItemId int, 
	@WeekCount int
AS
BEGIN
	DECLARE @tableName nvarchar(256)
	DECLARE @columnName nvarchar(256)

	SELECT @tableName=StatisticTable,@columnName=MetricValue FROM BaselineMetaData WHERE ItemID = @ItemId

	DECLARE @sqlQuery nvarchar(512)
	SET @sqlQuery = 'SELECT '+@columnName+' AS Value,UTCCollectionDateTime FROM '+@tableName+' WHERE SQLServerID = '+CONVERT(nvarchar(10),@SQLServerId)+' and UTCCollectionDateTime >= (GETUTCDATE()-'+Convert(nvarchar(10),6*@WeekCount)+') and '+@columnName+' IS NOT NULL'
	print @sqlQuery
	EXECUTE sp_executesql @sqlQuery
END

GO
 
GO 

---------- P_GETDEADLOCK.SQL
if (object_id('p_GetDeadlock') is not null)
begin
drop procedure [p_GetDeadlock]
end
go

create procedure [p_GetDeadlock]
	@AlertID bigint
as
begin
	DECLARE @err int
	DECLARE @linkid uniqueidentifier

	-- if no create date is specified then set one
	SELECT @linkid = [LinkedData]
		from Alerts where AlertID = @AlertID

	if (@linkid is not null)
	begin
		select SQLServerID, UTCCollectionDateTime, XDLData 
			from Deadlocks 
			where DeadlockID = @linkid
	end

	SELECT @err = @@error
	
	RETURN @err
end
 
GO 

---------- P_GETDEADLOCKSLIST.SQL
if (object_id('p_GetDeadlocksList') is not null)
begin
drop procedure [p_GetDeadlocksList]
end
go

create procedure [p_GetDeadlocksList]
	@SQLServerID int,
	@StartDateTime datetime = null,
	@EndDateTime datetime = null
as
begin
	DECLARE @err int

	if ((@StartDateTime is null) or (@EndDateTime is null))
	begin
		select SQLServerID, UTCCollectionDateTime, XDLData 
			from Deadlocks 
			where SQLServerID = @SQLServerID
			order by UTCCollectionDateTime desc
	end
	else
	begin
		select SQLServerID, UTCCollectionDateTime, XDLData 
			from Deadlocks 
			where SQLServerID = @SQLServerID and UTCCollectionDateTime between @StartDateTime and @EndDateTime
			order by UTCCollectionDateTime desc
	end

	SELECT @err = @@error
	
	RETURN @err
end
 
GO 

---------- P_GETDEFAULTMANAGEMENTSERVICE.SQL
if (object_id('[p_GetDefaultManagementService]') is not null)
begin
drop procedure [p_GetDefaultManagementService]
end
go
create procedure [dbo].[p_GetDefaultManagementService]
as
begin
	declare @DefaultManagementServiceID uniqueidentifier
	set @DefaultManagementServiceID = null

	select 
		@DefaultManagementServiceID = cast(Character_Value as uniqueidentifier)
	from 
		[RepositoryInfo] (NOLOCK)
	where 
		Name = 'Default Management Service'

	if @DefaultManagementServiceID is null
		exec p_SetDefaultManagementService @DefaultManagementServiceID output

	select [ManagementServiceID]
	  ,[MachineName]
	  ,[InstanceName]
	  ,[Address]
	  ,[Port]
	  ,[DefaultCollectionServiceID]
	from 
		[ManagementServices] (NOLOCK)
	where [ManagementServiceID] = @DefaultManagementServiceID

	return 0
end
 
GO 

---------- P_GETDEFAULTMANAGEMENTSERVICEID.SQL
if (object_id('[p_GetDefaultManagementServiceID]') is not null)
begin
drop procedure [p_GetDefaultManagementServiceID]
end
go
create procedure [dbo].[p_GetDefaultManagementServiceID]
	@ReturnServiceID uniqueidentifier output
as
begin
	declare @e int
	declare @DefaultManagementServiceID uniqueidentifier
	set @DefaultManagementServiceID = null

	select 
		@DefaultManagementServiceID = cast(Character_Value as uniqueidentifier)
	from 
		[RepositoryInfo] 
	where 
		Name = 'Default Management Service'

	select @e = @@error

	select @ReturnServiceID = @DefaultManagementServiceID
	
	return @e
end
 
GO 

---------- P_GETDEFAULTTEMPLATEID.SQL
if (object_id('p_GetDefaultTemplateID') is not null)
begin
drop procedure p_GetDefaultTemplateID
end
go

CREATE PROCEDURE [dbo].p_GetDefaultTemplateID(
	@DefaultTemplateID int output)
as
BEGIN

	select @DefaultTemplateID = [TemplateID] from AlertTemplateLookup where [Default] = 1
	
END
 
GO 

---------- P_GETDISKDRIVES.SQL
if (object_id('p_GetDiskDrives') is not null)
begin
drop procedure [p_GetDiskDrives]
end
go
create procedure [dbo].[p_GetDiskDrives]
				@ServerID int
as
begin
	select DriveName 
	from DiskDrives (NOLOCK)
	where 
		SQLServerID = @ServerID and
		DriveName != 'No Drives Configured'
	group by DriveName 
end
 
GO 

---------- P_GETDISKSIZEDETAILS.SQL
-- SQLdm 9.1 (Abhishek Joshi)

-- Filegroup and Mount Point Monitoring Improvements
-- get the disk drives information

-- exec p_GetDiskSizeDetails @SQLServerID

if (object_id('p_GetDiskSizeDetails') is not null)
begin
	drop procedure p_GetDiskSizeDetails
end
go

create procedure [dbo].[p_GetDiskSizeDetails]
	@SQLServerID int,
	@UTCSnapshotCollectionDateTime datetime =null,
	@HistoryInMinutes int =null
as
begin
	
	set transaction isolation level read uncommitted
declare @err int

declare @BeginDateTime datetime
declare @EndDateTime datetime

if (@UTCSnapshotCollectionDateTime is null)
	select @EndDateTime = (select max(UTCCollectionDateTime) from [DiskDriveStatistics] where [SQLServerID] = @SQLServerID)
else
	select @EndDateTime = @UTCSnapshotCollectionDateTime

if (@HistoryInMinutes is null)
	select @BeginDateTime = @EndDateTime
else
	select @BeginDateTime = dateadd(n, -@HistoryInMinutes, @EndDateTime)

	Select  @UTCSnapshotCollectionDateTime=max([UTCCollectionDateTime]) from DiskDriveStatistics 
	where
		SQLServerID = @SQLServerID
		and [UTCCollectionDateTime] between @BeginDateTime and @EndDateTime
	
	select 
		DiskDriveStatisticsID,
		SQLServerID,
		UTCCollectionDateTime, 
		DriveName,
		UnusedSizeKB,
		TotalSizeKB
	from
		DiskDriveStatistics
	where
		SQLServerID = @SQLServerID
		and [UTCCollectionDateTime] =@UTCSnapshotCollectionDateTime 

	select 
		DFS.DriveName,
		DFS.InitialSize,
		DFS.UsedSpace,
		DFS.AvailableSpace,
		CASE when DF.FileGroupName = 'n/a' THEN 0
			ELSE 1
		END AS IsDataFile
	from  DatabaseFileStatistics  DFS
	JOIN DatabaseFiles DF ON DF.FileID=DFS.FileID
	JOIN SQLServerDatabaseNames SSDN ON SSDN.DatabaseID=DF.DatabaseID
	WHERE SSDN.SQLServerID = @SQLServerID
	AND DFS.[UTCCollectionDateTime] =@UTCSnapshotCollectionDateTime 


end
go
 
GO 

---------- P_GETDISKSPACEHISTORYOVERALL.SQL
-- SQLdm 9.1 (Ankit Srivastava)

-- Filegroup and Mountpoint Monitoring Improvements
-- retrieves the overall data for the Disk Space History report

 --exec p_GetDiskSpaceHistoryOverall  @SQLServerID = 37,
	--					         	     @DiskNameFilter = 'C',
	--								     @UTCStart = '2015-02-19 00:00:00.000',
 --                                      @UTCEnd = '2015-02-25 00:00:00.000',
 --                                      @UTCOffset = 0

if (object_id('p_GetDiskSpaceHistoryOverall') is not null)
begin
	drop procedure [p_GetDiskSpaceHistoryOverall]
end
go

create procedure [dbo].[p_GetDiskSpaceHistoryOverall]
	@SQLServerID int,
	@DiskNameFilter nvarchar(256),
	@UTCStart dateTime,
	@UTCEnd dateTime,
	@UTCOffset int = 0
as
begin
	create table #FileStats(
				SQLServerID int,
				UTCCollectionDateTime datetime,
				DriveName nvarchar(10),
				SQLDataUsedMB decimal(18,0),
				SQLDataFreeMB decimal(18,0),
				SQLLogFileMB decimal(18,0),
				TotalInitialSizeMB decimal(18,0) );

	insert into #FileStats select
							  FST.SQLServerID, 
							  FST.UTCCollectionDateTime, 
							  FST.DriveName, 
							  sum(FST.SQLDataUsedMB) as SQLDataUsedMB, 
							  sum(FST.SQLDataFreeMB) as SQLDataFreeMB, 
							  sum(FST.SQLLogFileMB) as SQLLogFileMB,
							  sum(FST.TotalInitialSize) as TotalInitialSizeMB
							from (
								select 
									SSDN.SQLServerID, 
									DFS.UTCCollectionDateTime,
									DFS.DriveName,
									SQLDataUsedMB = (case when DF.FileGroupName <> 'n/a' then sum(DFS.UsedSpace) else 0 end),
									SQLDataFreeMB = (case when DF.FileGroupName <> 'n/a' then sum(DFS.AvailableSpace) else 0 end),
									SQLLogFileMB = (case when DF.FileGroupName = 'n/a' then sum(DFS.InitialSize) else 0 end),
									sum(DFS.InitialSize) as TotalInitialSize
								from  
									DatabaseFileStatistics as DFS
									inner join 
									DatabaseFiles as DF 
									on DF.FileID = DFS.FileID
									inner join 
									SQLServerDatabaseNames as SSDN 
									on SSDN.DatabaseID = DF.DatabaseID
								where
									SSDN.SQLServerID = @SQLServerID and DFS.DriveName = @DiskNameFilter 
									and dbo.fn_RoundDateTime(0, [UTCCollectionDateTime]) between @UTCStart and @UTCEnd
								group by
									SSDN.SQLServerID, DFS.UTCCollectionDateTime, DFS.DriveName, DF.FileGroupName ) as FST
								group by
									FST.SQLServerID, FST.UTCCollectionDateTime, FST.DriveName

	select
		[LastCollectioninInterval] = max(dateadd(mi, @UTCOffset, DDS.[UTCCollectionDateTime])),
		DDS.DriveName DiskName,
		ISNULL(max(FS.SQLDataUsedMB ),0)  SQLDataUsedMB,
		ISNULL(max(FS.SQLDataFreeMB ),0)  SQLDataFreeMB,
		ISNULL(max(FS.SQLLogFileMB ),0)  SQLLogFileMB,
		ISNULL(max(((DDS.TotalSizeKB - DDS.UnusedSizeKB)/1024 - TotalInitialSizeMB)),0)  as NonSQLDiskUsageMB,
		ISNULL(max(DDS.UnusedSizeKB/1024),0)  as FreeDiskSpaceMB,
		ISNULL(avg(DDS.DiskReadsPerSecond),0)  DiskReadsPerSecond,
		ISNULL(avg(DDS.DiskWritesPerSecond),0)  DiskWritesPerSecond
	from 
		DiskDriveStatistics as DDS
		left join
		#FileStats as FS
		on (DDS.DriveName COLLATE DATABASE_DEFAULT = FS.DriveName COLLATE DATABASE_DEFAULT and DDS.SQLServerID = FS.SQLServerID and DDS.UTCCollectionDateTime = FS.UTCCollectionDateTime)
	where
		DDS.SQLServerID = @SQLServerID 
		and 
		DDS.DriveName = @DiskNameFilter
		and
		 DDS.UTCCollectionDateTime between @UTCStart and @UTCEnd
	Group by
	DDS.DriveName
	drop table #FileStats

end
go
 
GO 

---------- P_GETDISKSPACEHISTORYREPORTDATA.SQL
-- SQLdm 9.1 (Abhishek Joshi)

-- Filegroup and Mountpoint Monitoring Improvements
-- retrieves the data for the Disk Space History report

 --exec p_GetDiskSpaceHistoryReportData  @SQLServerID = 37,
	--					         	   @DiskNameFilter = 'C',
	--								   @UTCStart = '2015-02-19 00:00:00.000',
 --                                      @UTCEnd = '2015-03-25 00:00:00.000',
 --                                      @UTCOffset = 0,  
 --                                      @Interval = 1

if (object_id('p_GetDiskSpaceHistoryReportData') is not null)
begin
	drop procedure [p_GetDiskSpaceHistoryReportData]
end
go

create procedure [dbo].[p_GetDiskSpaceHistoryReportData]
	@SQLServerID int,
	@DiskNameFilter nvarchar(256),
	@UTCStart dateTime,
	@UTCEnd dateTime,
	@UTCOffset int = 0,
	@Interval int
as
begin
	create table #FileStats(
				SQLServerID int,
				UTCCollectionDateTime datetime,
				DriveName nvarchar(10),
				SQLDataUsedMB decimal(18,0),
				SQLDataFreeMB decimal(18,0),
				SQLLogFileMB decimal(18,0),
				TotalInitialSizeMB decimal(18,0) );

	insert into #FileStats select
							  FST.SQLServerID, 
							  FST.UTCCollectionDateTime, 
							  FST.DriveName, 
							  sum(FST.SQLDataUsedMB) as SQLDataUsedMB, 
							  sum(FST.SQLDataFreeMB) as SQLDataFreeMB, 
							  sum(FST.SQLLogFileMB) as SQLLogFileMB,
							  sum(FST.TotalInitialSize) as TotalInitialSizeMB
							from (
								select 
									SSDN.SQLServerID, 
									DFS.UTCCollectionDateTime,
									DFS.DriveName,
									SQLDataUsedMB = (case when DF.FileGroupName <> 'n/a' then sum(DFS.UsedSpace) else 0 end),
									SQLDataFreeMB = (case when DF.FileGroupName <> 'n/a' then sum(DFS.AvailableSpace) else 0 end),
									SQLLogFileMB = (case when DF.FileGroupName = 'n/a' then sum(DFS.InitialSize) else 0 end),
									sum(DFS.InitialSize) as TotalInitialSize
								from  
									DatabaseFileStatistics as DFS
									inner join 
									DatabaseFiles as DF 
									on DF.FileID = DFS.FileID
									inner join 
									SQLServerDatabaseNames as SSDN 
									on SSDN.DatabaseID = DF.DatabaseID
								where
									SSDN.SQLServerID = @SQLServerID and DFS.DriveName = @DiskNameFilter 
								group by
									SSDN.SQLServerID, DFS.UTCCollectionDateTime, DFS.DriveName, DF.FileGroupName ) as FST
								group by
									FST.SQLServerID, FST.UTCCollectionDateTime, FST.DriveName

	Select 
			[LastCollectioninInterval] = dbo.fn_RoundDateTime(@Interval, LastCollectioninInterval),
			[DiskName],
			IntervalNumber = dense_rank() Over (Order By IntervalTemp),
			AverageTotalSizeMB,
			AverageSQLDataUsedMB,
			AverageSQLDataFreeMB,
			AverageSQLLogFileMB,
			AverageNonSQLDiskUsageMB,
			AverageFreeDiskSpaceMB,
			AverageDiskReadsPerSecond,
			AverageDiskWritesPerSecond
	FROM
	(
	select
		[LastCollectioninInterval] = max(dateadd(mi, @UTCOffset, DDS.[UTCCollectionDateTime])),
		DDS.DriveName as DiskName,
		IntervalTemp = case
				 when isnull(@Interval,5) = 5
						then 0
				 when isnull(@Interval,5) = 4
						then datediff(yyyy, @UTCStart, max(dateadd(mi, @UTCOffset, DDS.[UTCCollectionDateTime])))
				 when isnull(@Interval,5) = 3
						then datediff(mm, @UTCStart, max(dateadd(mi, @UTCOffset, DDS.[UTCCollectionDateTime])))
				 when isnull(@Interval,5) = 2
						then datediff(dd, @UTCStart, max(dateadd(mi, @UTCOffset, DDS.[UTCCollectionDateTime])))
				 when isnull(@Interval,5) = 1
						then datediff(hh, @UTCStart, max(dateadd(mi, @UTCOffset, DDS.[UTCCollectionDateTime])))
				 when isnull(@Interval,5) =  0
						then datediff(mi, @UTCStart, max(dateadd(mi, @UTCOffset, DDS.[UTCCollectionDateTime])))
				 end,
		ISNULL(avg(DDS.TotalSizeKB/1024),0) as AverageTotalSizeMB,
		ISNULL(avg(FS.SQLDataUsedMB),0) as AverageSQLDataUsedMB,
		ISNULL(avg(FS.SQLDataFreeMB),0) as AverageSQLDataFreeMB,
		ISNULL(avg(FS.SQLLogFileMB),0) as AverageSQLLogFileMB,
		ISNULL(avg(((DDS.TotalSizeKB - DDS.UnusedSizeKB)/1024) - TotalInitialSizeMB),0) as AverageNonSQLDiskUsageMB,
		ISNULL(avg(DDS.UnusedSizeKB/1024),0) as AverageFreeDiskSpaceMB,
		ISNULL(avg(DDS.DiskReadsPerSecond),0) as AverageDiskReadsPerSecond,
		ISNULL(avg(DDS.DiskWritesPerSecond),0) as AverageDiskWritesPerSecond
	from 
		DiskDriveStatistics as DDS
		left join
		#FileStats as FS
		on (DDS.DriveName COLLATE DATABASE_DEFAULT = FS.DriveName COLLATE DATABASE_DEFAULT and DDS.SQLServerID = FS.SQLServerID and DDS.UTCCollectionDateTime = FS.UTCCollectionDateTime)
	where
		DDS.SQLServerID = @SQLServerID 
		and 
		DDS.DriveName = @DiskNameFilter
		and
		dbo.fn_RoundDateTime(@Interval, DDS.UTCCollectionDateTime) between @UTCStart and @UTCEnd
	group by
		DDS.DriveName, case when isnull(@Interval,5) <= 4 then datepart(yy, dateadd(mi, @UTCOffset, DDS.[UTCCollectionDateTime])) else 1 end
	,case when isnull(@Interval,5) <= 3 then datepart(mm,dateadd(mi, @UTCOffset, DDS.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, DDS.[UTCCollectionDateTime])) end
	,case when isnull(@Interval,5) <= 2 then datepart(dd,dateadd(mi, @UTCOffset, DDS.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, DDS.[UTCCollectionDateTime])) end
	,case when isnull(@Interval,5) <= 1 then datepart(hh,dateadd(mi, @UTCOffset, DDS.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, DDS.[UTCCollectionDateTime])) end
	,case when isnull(@Interval,5) =  0 then datepart(mi,dateadd(mi, @UTCOffset, DDS.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, DDS.[UTCCollectionDateTime])) end
	,case when isnull(@Interval,5) =  0 then datepart(mi,dateadd(mi, @UTCOffset, DDS.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, DDS.[UTCCollectionDateTime])) end
		) as Result

	drop table #FileStats

end
go
 
GO 

---------- P_GETDISKSPACEUSAGEREPORTDATA.SQL
-- SQLdm 9.1 (Abhishek Joshi)

-- Filegroup and Mountpoint Monitoring Improvements
-- retrieves the data for the Disk Space Usage report

 --exec p_GetDiskSpaceUsageReportData   @SQLServerIDs = '<Srvrs><Srvr ID="37"/><Srvr ID="41"/></Srvrs>',
	--									@SortBy = 'UnusedSizeKB',
	--									@SortOrder = 'DESC'

if (object_id('p_GetDiskSpaceUsageReportData') is not null)
begin
	drop procedure [p_GetDiskSpaceUsageReportData]
end
go

create procedure [dbo].[p_GetDiskSpaceUsageReportData]
	@SQLServerIDs nvarchar(max) = null,
	@SortBy nvarchar(50) = 'InstanceName',
	@SortOrder nvarchar(10) = 'ASC'
as
begin
	declare @Query nvarchar(max),
			@ParameterDefinition nvarchar(4000);

	create table #SQLServersCollectionTime(
				SQLServerID int,
				UTCCollectionDateTime datetime );

	create table #FileStats(
				SQLServerID int,
				UTCCollectionDateTime datetime,
				DriveName nvarchar(256),
				SQLDataUsedMB decimal(18,0),
				SQLDataFreeMB decimal(18,0),
				SQLLogFileMB decimal(18,0),
				TotalInitialSizeMB decimal(18,0) );

	create table #DiskIO (
				SQLServerID int,
				DriveName nvarchar(256),
				AvgDiskReadsPerSec int,                -- last 24 hours reads/writes from most recent collection time
				AvgDiskWritesPerSec int );

	create table #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

	insert into #SecureMonitoredSQLServers
	exec [p_GetReportServers]
				
	select @ParameterDefinition = ' @SortBy nvarchar(50),
									@SortOrder nvarchar(10) ';
	if @SQLServerIDs is not null 
		begin
			declare @xmlDoc int
			exec sp_xml_preparedocument @xmlDoc output, @SQLServerIDs
									
			insert into #SQLServersCollectionTime select dds.SQLServerID, max(UTCCollectionDateTime) from 
										  openxml(@xmlDoc, '//Srvr', 1) with (ID int)
											join DiskDriveStatistics dds (nolock) on dds.SQLServerID = ID
											inner join #SecureMonitoredSQLServers smss on dds.SQLServerID = smss.SQLServerID
										  group by dds.SQLServerID;
			exec sp_xml_removedocument @xmlDoc
		end
	else
		begin
			insert into #SQLServersCollectionTime select dds.SQLServerID, max(UTCCollectionDateTime) from DiskDriveStatistics dds
			inner join #SecureMonitoredSQLServers smss on dds.SQLServerID = smss.SQLServerID
										  group by dds.SQLServerID;
		end

			insert into #FileStats select
							  FST.SQLServerID, 
							  FST.UTCCollectionDateTime, 
							  FST.DriveName, 
							  sum(FST.SQLDataUsedMB) as SQLDataUsedMB, 
							  sum(FST.SQLDataFreeMB) as SQLDataFreeMB, 
							  sum(FST.SQLLogFileMB) as SQLLogFileMB,
							  sum(FST.TotalInitialSize) as TotalInitialSizeMB
							from (
								select 
									SSDN.SQLServerID, 
									DFS.UTCCollectionDateTime,
									DFS.DriveName,
									SQLDataUsedMB = (case when DF.FileGroupName <> 'n/a' then sum(DFS.UsedSpace) else 0 end),
									SQLDataFreeMB = (case when DF.FileGroupName <> 'n/a' then sum(DFS.AvailableSpace) else 0 end),
									SQLLogFileMB = (case when DF.FileGroupName = 'n/a' then sum(DFS.InitialSize) else 0 end),
									sum(DFS.InitialSize) as TotalInitialSize
								from  
									DatabaseFileStatistics as DFS
									inner join 
									DatabaseFiles as DF 
									on DF.FileID = DFS.FileID
									inner join 
									SQLServerDatabaseNames as SSDN 
									on SSDN.DatabaseID = DF.DatabaseID
									inner join
									#SQLServersCollectionTime as SSCT
									on (SSCT.SQLServerID = SSDN.SQLServerID and DFS.UTCCollectionDateTime = SSCT.UTCCollectionDateTime)
								group by
									SSDN.SQLServerID, DFS.UTCCollectionDateTime, DFS.DriveName, DF.FileGroupName) as FST
								group by
									FST.SQLServerID, FST.UTCCollectionDateTime, FST.DriveName
								
	insert into #DiskIO select 
							DDS.SQLServerID,
							DDS.DriveName,
							avg(DDS.DiskReadsPerSecond) as AvgDiskReadsPerSec,
							avg(DDS.DiskWritesPerSecond) as AvgDiskWritesPerSec
						from 
							DiskDriveStatistics as DDS
							left join
							#SQLServersCollectionTime as SSCT
							on (SSCT.SQLServerID = DDS.SQLServerID and SSCT.UTCCollectionDateTime = DDS.UTCCollectionDateTime)
						where
							DDS.UTCCollectionDateTime between dateadd(hour,-24,SSCT.UTCCollectionDateTime) and SSCT.UTCCollectionDateTime
						group by 
							DDS.SQLServerID, DDS.DriveName

	select @Query = '  select
							MSS.SQLServerID,
							MSS.InstanceName,
							DDS.DriveName as DiskName,
							ISNULL(DDS.TotalSizeKB/1024,0) TotalSizeMB,
							ISNULL(FS.SQLDataUsedMB,0) SQLDataUsedMB,
							ISNULL(FS.SQLDataFreeMB,0) SQLDataFreeMB,
							ISNULL(SQLLogFileMB,0) SQLLogFileMB,
							ISNULL((((DDS.TotalSizeKB  - DDS.UnusedSizeKB)/1024) - TotalInitialSizeMB),0) as NonSQLDiskUsageMB,
							ISNULL(DDS.UnusedSizeKB/1024,0) as FreeDiskSpaceMB,
							ISNULL(DIO.AvgDiskReadsPerSec,0) AvgDiskReadsPerSec,
							ISNULL(DIO.AvgDiskWritesPerSec,0) AvgDiskWritesPerSec
					   from
						    DiskDriveStatistics as DDS
						    inner join
							MonitoredSQLServers as MSS
							on DDS.SQLServerID = MSS.SQLServerID
							inner join
							#SQLServersCollectionTime as SSCT
							on (SSCT.SQLServerID = DDS.SQLServerID and SSCT.UTCCollectionDateTime = DDS.UTCCollectionDateTime)
							left join 
							#FileStats as FS
							on (FS.DriveName COLLATE DATABASE_DEFAULT = DDS.DriveName COLLATE DATABASE_DEFAULT and DDS.SQLServerID = FS.SQLServerID and FS.UTCCollectionDateTime = DDS.UTCCollectionDateTime)
							left join
							#DiskIO as DIO
							on (DIO.DriveName COLLATE DATABASE_DEFAULT = DDS.DriveName COLLATE DATABASE_DEFAULT and DDS.SQLServerID = DIO.SQLServerID)
					   where
							1 = 1 ';

	--if @SQLServerID is not null
	--	select @Query = @Query + ' and DDS.SQLServerID = @SQLServerID ';

	select @Query = @Query + ' order by ' + @SortBy + ' ' + @SortOrder;

	execute sp_executesql @Query, 
                          @ParameterDefinition, 
						  --@SQLServerID,
						  @SortBy,
						  @SortOrder

	drop table #SQLServersCollectionTime
	drop table #FileStats
	drop table #DiskIO

end
 
GO 

---------- P_GETDISKSTATISTICSBASELINE.SQL
if (object_id('p_GetDiskStatisticsBaseline') is not null)
begin
drop procedure [p_GetDiskStatisticsBaseline]
end
go

CREATE PROCEDURE [dbo].[p_GetDiskStatisticsBaseline]
		@ServerID int,
		@UTCStart DateTime,
		@UTCEnd DateTime,
		@UTCOffset int,
		@Interval tinyint
AS
BEGIN
		SELECT		
		UTCCalculation = dbo.fn_RoundDateTime(1, max(dateadd(mi, @UTCOffset, UTCCalculation))),
		DiskQueueLengthMean = (select TOP 1 Mean	--DiskQueueLength MetricID = 31
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = 31 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc),
		DiskTimePercentMean = (select TOP 1 Mean	--DiskTimePercent MetricID = 30
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = 30 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc),
		IOActivityPercentageMean = (select TOP 1 Mean	--IOActivityPercentage MetricID = -135
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -135 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc),		
		WorkFilesCreatedMean = (select TOP 1 Mean --WorkFilesCreated -82
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -82 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc) * 60,
		TempDBSizeInKilobytesMean = (select TOP 1 Mean	--'%TempDBSizeInKilobytes%' -- -136
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = -136 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc),
		PageReadsMean = (select TOP 1 Mean	--'%PageReads%' -- -52
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -52 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc),		
		PageWritesMean = (select TOP 1 Mean --'%PageWrites%' -- -1001
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -1001 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc),				
		PageSplitsMean = (select TOP 1 Mean	--'%PageSplits%' -- -55
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = -55 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc) * 60,
		PageLookupsMean = (select TOP 1 Mean	--'%PageLookups%' -- -50
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -50 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc) * 60,		
		ReadAheadPagesMean = (select TOP 1 Mean --'%ReadAheadPages%' -- -63
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -63 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc) * 60	
		FROM		
			[BaselineStatistics] bs (nolock)
		WHERE bs.[SQLServerID] = @ServerID and bs.UTCCalculation between @UTCStart and @UTCEnd
		GROUP BY dbo.fn_RoundDateTime(2, bs.UTCCalculation)

END
 
GO 

---------- P_GETDISKSUMMARY.SQL
if (object_id('p_GetDiskSummary') is not null)
begin
drop procedure p_GetDiskSummary
end
go
CREATE PROCEDURE [dbo].[p_GetDiskSummary]
		@ServerID int,
		@UTCStart DateTime,
		@UTCEnd DateTime,
		@UTCOffset int,
		@Interval tinyint
AS
BEGIN

-- @Interval - Granularity of calculation:
--	0 - Minutes
--	1 - Hours
--	2 - Days
--	3 - Months
--	4 - Years

	select
		m.InstanceName
		,dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, ss.[UTCCollectionDateTime]))) as [LastCollectioninInterval]
		,sum([IOActivityPercentage] * TimeDeltaInSeconds) / nullif(sum(case when [IOActivityPercentage] is not null then TimeDeltaInSeconds else 0 end),0) as [IOActivityPercentage]
		,sum(convert(float,[WorkFilesCreated])) / nullif((sum(convert(float,case when [WorkFilesCreated] is not null then TimeDeltaInSeconds else 0 end)) / 60) ,0)as [WorkFilesCreated]
		,max([TempDBSizeInKilobytes]) as TempDBSizeInKilobytes
		,sum(convert(float,[PageReads])) / nullif((sum(convert(float,case when [PageReads] is not null then TimeDeltaInSeconds else 0 end))) ,0)as [PageReads]
		,sum(convert(float,[PageWrites])) / nullif((sum(convert(float,case when [PageWrites] is not null then TimeDeltaInSeconds else 0 end))) ,0)as [PageWrites]
		,sum(convert(float,[PageSplits])) / nullif((sum(convert(float,case when [PageSplits] is not null then TimeDeltaInSeconds else 0 end)) / 60) ,0)as [PageSplits]
		,sum(convert(float,[PageLookups])) / nullif((sum(convert(float,case when [PageLookups] is not null then TimeDeltaInSeconds else 0 end)) / 60) ,0)as [PageLookups]
		,sum(convert(float,[ReadAheadPages])) / nullif((sum(convert(float,case when [ReadAheadPages] is not null then TimeDeltaInSeconds else 0 end)) / 60) ,0)as [ReadAheadPages]
		,sum([DiskQueueLength] * TimeDeltaInSeconds) / nullif(sum(case when [DiskQueueLength] is not null then TimeDeltaInSeconds else 0 end),0) as [DiskQueueLength]
		,sum([DiskTimePercent] * TimeDeltaInSeconds) / nullif(sum(case when [DiskTimePercent] is not null then TimeDeltaInSeconds else 0 end),0) as [DiskTimePercent]
		,DiskQueueLengthMean = (select TOP 1 Mean	--DiskQueueLength MetricID = 31
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = 31 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, ss.[UTCCollectionDateTime])))
				order by UTCCalculation desc),
		DiskTimePercentMean = (select TOP 1 Mean	--DiskTimePercent MetricID = 30
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = 30 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, ss.[UTCCollectionDateTime])))
				order by UTCCalculation desc),
		IOActivityPercentageMean = (select TOP 1 Mean	--IOActivityPercentage MetricID = -135
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -135 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, ss.[UTCCollectionDateTime])))
				order by UTCCalculation desc),		
		WorkFilesCreatedMean = (select TOP 1 Mean --WorkFilesCreated -82
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -82 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, ss.[UTCCollectionDateTime])))
				order by UTCCalculation desc) * 60,
		TempDBSizeInKilobytesMean = (select TOP 1 Mean	--'%TempDBSizeInKilobytes%' -- -136
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = -136 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, ss.[UTCCollectionDateTime])))
				order by UTCCalculation desc),
		PageReadsMean = (select TOP 1 Mean	--'%PageReads%' -- -52
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -52 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, ss.[UTCCollectionDateTime])))
				order by UTCCalculation desc),		
		PageWritesMean = (select TOP 1 Mean --'%PageWrites%' -- -1001
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -1001 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, ss.[UTCCollectionDateTime])))
				order by UTCCalculation desc),				
		PageSplitsMean = (select TOP 1 Mean	--'%PageSplits%' -- -55
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = -55 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, ss.[UTCCollectionDateTime])))
				order by UTCCalculation desc) * 60,
		PageLookupsMean = (select TOP 1 Mean	--'%PageLookups%' -- -50
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -50 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, ss.[UTCCollectionDateTime])))
				order by UTCCalculation desc) * 60,		
		ReadAheadPagesMean = (select TOP 1 Mean --'%ReadAheadPages%' -- -63
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -63 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, ss.[UTCCollectionDateTime])))
				order by UTCCalculation desc) * 60
	from
		[MonitoredSQLServers] m (nolock)
		left join [ServerStatistics] ss (nolock) on m.[SQLServerID] = ss.[SQLServerID]
		left join [OSStatistics] o (nolock)
		on o.[SQLServerID] = ss.[SQLServerID] and o.[UTCCollectionDateTime] = ss.[UTCCollectionDateTime]
	where
		ss.[SQLServerID] = @ServerID
		and dbo.fn_RoundDateTime(@Interval, ss.[UTCCollectionDateTime]) between @UTCStart and @UTCEnd
	group by
		[InstanceName]
		-- Always group by year at the least
		,datepart(yy, dateadd(mi, @UTCOffset, ss.[UTCCollectionDateTime]))
		-- Group by all intervals greater than or equal to the selected interval
		,case when @Interval <= 3 then datepart(mm,dateadd(mi, @UTCOffset, ss.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, ss.[UTCCollectionDateTime])) end
		,case when @Interval <= 2 then datepart(dd,dateadd(mi, @UTCOffset, ss.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, ss.[UTCCollectionDateTime])) end
		,case when @Interval <= 1 then datepart(hh,dateadd(mi, @UTCOffset, ss.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, ss.[UTCCollectionDateTime])) end
		,case when @Interval =  0 then datepart(mi,dateadd(mi, @UTCOffset, ss.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, ss.[UTCCollectionDateTime])) end
	order by dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, ss.[UTCCollectionDateTime]))) 
END
 
 
GO 

---------- P_GETEARLIESTAVAILABLEDATA.SQL
IF (object_id('p_GetEarliestDataAvailable') IS NOT NULL)
BEGIN
DROP PROCEDURE p_GetEarliestDataAvailable
END
GO

CREATE PROCEDURE [dbo].[p_GetEarliestDataAvailable]
(
	@SqlServerId int,
	@EarliestStatisticsAvailable datetime output
)
AS
BEGIN

	DECLARE @err INT
	
	SELECT @err = @@error
	IF (@err = 0)
	BEGIN
		SELECT TOP 1 @EarliestStatisticsAvailable = [UTCCollectionDateTime] 
		FROM ServerStatistics
		WHERE [SQLServerID] = @SqlServerId
		ORDER BY [UTCCollectionDateTime] ASC
	
		SELECT @err = @@error
	END
	
	RETURN @err

END
 
GO 

---------- P_GETENTERPRISESUMMARY.SQL
if (object_id('p_GetEnterpriseSummary') is not null)
begin
drop procedure [p_GetEnterpriseSummary]
end
go
create procedure [dbo].[p_GetEnterpriseSummary]
	@SQLServerIDs nvarchar(max) = null,
	@UTCOffset int
as
begin
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

declare @SQLServers table(
		SQLServerID int, 
		InstanceName nvarchar(256),
		LastScheduledCollectionTime datetime,
		LastDatabaseCollectionTime datetime,
		LastAlertRefreshTime datetime,
		IsMaintenanceMode bit) 

declare @xmlDoc int
declare @now datetime

set @now = DateAdd(second,10,GetUTCDate())

create table #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

insert into #SecureMonitoredSQLServers
exec [p_GetReportServers]

if @SQLServerIDs is not null 
begin
	exec sp_xml_preparedocument @xmlDoc output, @SQLServerIDs

	insert into @SQLServers
		select ID, smss.InstanceName, LastScheduledCollectionTime, LastDatabaseCollectionTime, LastAlertRefreshTime, 0
		from openxml(@xmlDoc, '//Srvr', 1) with (ID int)
			join MonitoredSQLServers mss (nolock) on mss.SQLServerID = ID
			inner join #SecureMonitoredSQLServers smss on mss.SQLServerID = smss.SQLServerID
		where Active = 1

	exec sp_xml_removedocument @xmlDoc
end
else
begin
	insert into @SQLServers
		select smss.SQLServerID, smss.InstanceName, LastScheduledCollectionTime, LastDatabaseCollectionTime, LastAlertRefreshTime, 0
		from MonitoredSQLServers mss (nolock)
			inner join #SecureMonitoredSQLServers smss on mss.SQLServerID = smss.SQLServerID
		where Active = 1
end



update @SQLServers
set IsMaintenanceMode = 1
from
@SQLServers S inner join Alerts A (NOLOCK) on A.ServerName collate database_default = S.InstanceName collate database_default and S.LastAlertRefreshTime = A.UTCOccurrenceDateTime
where A.Metric = 48 


declare @ServerStatus table (
		SQLServerID int,
		Metric int,	
		ServerStatus int)

insert into @ServerStatus
	select ms.SQLServerID
		--We only care about maintenance mode.  If the server is in maintenance mode, this will be the only active alert.
		--   Leaving out Severity = 2 because Informational Alerts should not affect server state.
		,case when IsMaintenanceMode = 1 then 48 else 0 end
		,case 
			when sum(case when Severity = 8 then 1 else 0 end) > 0 then 8
			when sum(case when Severity = 4 then 1 else 0 end) > 0 then 4
			--when sum(case when Severity = 2 then 1 else 0 end) > 0 then 2
			else 1
		end
	from @SQLServers ms 
		left outer join Alerts a (nolock) on
			ms.InstanceName collate database_default = a.ServerName collate database_default
			And (ms.LastScheduledCollectionTime = a.UTCOccurrenceDateTime
					Or ms.LastDatabaseCollectionTime = a.UTCOccurrenceDateTime)
		left join MetricThresholds t (nolock) on
			ms.[SQLServerID] = t.[SQLServerID] and
			a.[Metric] = t.[Metric] 		
	where 
		(((a.[Active] is null or a.[Active] = 1) and
		(t.[UTCSnoozeEnd] is null or t.[UTCSnoozeEnd] < @now)) or Active = 0)
		and (
		(IsMaintenanceMode = 0 
			and ((a.Metric not in (select MetricID from DBMetrics) and ms.LastScheduledCollectionTime = a.UTCOccurrenceDateTime)
			or (a.Metric  in (select MetricID from DBMetrics) and ms.LastDatabaseCollectionTime = a.UTCOccurrenceDateTime)))
		or (IsMaintenanceMode = 1 and (a.Metric = 48 and ms.LastAlertRefreshTime = a.UTCOccurrenceDateTime)))
	group by 
		ms.SQLServerID , IsMaintenanceMode
		
		

select
	ms.[SQLServerID]
	,[InstanceName]
	,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime]) as CollectionDateTime
	,[AgentServiceStatus]
	,[CPUActivityPercentage]
	,[DiskTimePercent]
	,[OpenTransactions]
	,cast([OSTotalPhysicalMemoryInKilobytes] - [OSAvailableMemoryInKilobytes] as float)/[OSTotalPhysicalMemoryInKilobytes] * 100 as [OSMemoryUsagePercent]  
	,[ResponseTimeInMilliseconds]
	,[ServerVersion] = dbo.fn_GetServerVersionString(s1.[ServerVersion])
	,[SqlServerServiceStatus]
	,s1.[SystemProcesses]
	,[SystemProcessesConsumingCPU]
	,[UserProcesses]
	,[UserProcessesConsumingCPU]
	,isnull(ss.ServerStatus,1) as ServerStatus
	,ss.Metric
	,s1.ProcessorCount
	,s1.ProcessorsUsed
	,WindowsVersion
	,SqlServerEdition
	,RunningSince
	,IsClustered
	,PhysicalMemoryInKilobytes
	,s1.ServerHostName
	,s1.FullTextSearchStatus
	,s1.DTCServiceStatus
	,DataFileSpaceAllocatedInKilobytes
	,DataFileSpaceUsedInKilobytes
	,LogFileSpaceAllocatedInKilobytes
	,LogFileSpaceUsedInKilobytes
	,[dbo].[fn_ServerVersionnVarcharToBigInt](s1.ServerVersion) as ServerVersionNumber
	,[SQLBrowserServiceStatus]     --SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --fetch the status of SQL Browser service
	,[SQLActiveDirectoryHelperServiceStatus]     --SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --fetch the status of SQL Active Directory Helper service
from @SQLServers ms
	left outer join [ServerStatistics] s1 (nolock)
	on ms.[SQLServerID] = s1.[SQLServerID] and s1.[UTCCollectionDateTime] = ms.LastScheduledCollectionTime
	left outer join [OSStatistics] o (nolock)
	on o.[SQLServerID] = ms.[SQLServerID] and o.[UTCCollectionDateTime] = ms.LastScheduledCollectionTime
	left outer join @ServerStatus ss 
	on ms.[SQLServerID] = ss.[SQLServerID]
order by 
	[InstanceName],
	[LastScheduledCollectionTime]

end
 
GO 

---------- P_GETEXCLUDEDWAITTYPES.SQL
if (object_id('p_GetExcludedWaitTypes') is not null)
begin
drop procedure p_GetExcludedWaitTypes
end
go

create procedure p_GetExcludedWaitTypes
as
begin
select wt.WaitType,mk.MapKey as XE_key 
	from
		WaitCategories wc
		left join WaitTypes wt on wc.CategoryID = wt.CategoryID
		left join XEMapKeys mk on  mk.WaitType = wt.WaitType and mk.SQLVersion = 11
		where wc.Category = 'Excluded'

end
 
GO 

---------- P_GETFILEACTIVITY.SQL
if (object_id('p_GetFileActivity') is not null)
begin
drop procedure p_GetFileActivity
end
go 
create procedure p_GetFileActivity
	@SQLServerID int,
	@UTCSnapshotCollectionDateTime datetime = null,
	@HistoryInMinutes int = null
as
begin

declare @BeginDateTime datetime
declare @EndDateTime datetime

if (@UTCSnapshotCollectionDateTime is null)
	select @EndDateTime = (select max(UTCCollectionDateTime) from [DiskDrives] (NOLOCK) where [SQLServerID] = @SQLServerID)
else
	select @EndDateTime = @UTCSnapshotCollectionDateTime

if (@HistoryInMinutes is null)
	select @BeginDateTime = @EndDateTime
else
	select @BeginDateTime = dateadd(n, -@HistoryInMinutes, @EndDateTime)

select
	UTCCollectionDateTime = da.UTCCollectionDateTime,	
	DriveName = dd.DriveName,
	DatabaseName,
	[FileName]= rtrim([FileName]),
	FileType = rtrim(FileType),
	FilePath = rtrim(FilePath),
	DiskReadsPerSecond,	
	DiskWritesPerSecond,
	FileReadsPerSecond = da.Reads / nullif(TimeDeltaInSeconds,0),
	FileWritesPerSecond = da.Writes / nullif(TimeDeltaInSeconds,0),
	DiskTransfersPerSecond,
	FileTransfersPerSecond = (da.Reads + da.Writes) / nullif(TimeDeltaInSeconds,0)
from
	DiskDrives dd (NOLOCK)
	left join SQLServerDatabaseNames dn (NOLOCK)
	on dd.SQLServerID = dn.SQLServerID
	left join DatabaseFiles df (NOLOCK)
	on dn.DatabaseID = df.DatabaseID
	and lower(df.DriveName) = lower(dd.DriveName)
	left join DatabaseFileActivity da (NOLOCK)
	on df.FileID = da.FileID
	and (da.UTCCollectionDateTime = ISNULL(dd.DatabaseSizeTime,dd.UTCCollectionDateTime))
where
	dd.SQLServerID = @SQLServerID
	and dn.SQLServerID = @SQLServerID
	and dd.[UTCCollectionDateTime] >= @BeginDateTime 
	and dd.[UTCCollectionDateTime] <= @EndDateTime
	and da.[UTCCollectionDateTime] >= @BeginDateTime 
	and da.[UTCCollectionDateTime] <= @EndDateTime
	
end
 
GO 

---------- P_GETGRAPHREPRESENTATIONDATABYAPPLICATION.SQL
-- SQLdm 9.0 (Abhishek Joshi)

-- Query Monitoring
-- retrieves the Query Monitor Statistics when grouped by Application
-- according to the set filters for the Graphs representation on WebUI

-- exec p_GetGraphRepresentationDataByApplication  @SQLServerID = 9,
--												   @ViewID = 1,	
--												   @ApplicationFilter = '8,11,12',
--												   @DatabaseFilter = '179',
--											       @UserFilter = '1',
--											       @ClientFilter = '1',
--											       @SQLExclude = null,
--											       @SQLInclude = '%sys%',
--											       @IncludeSQLStatements = '1',
--											       @IncludeSQLProcedure = '1',
--											       @IncludeSQLBatch = '1',
--											       @IncludeIncompletedQueries = '1',
--											       @IncludeTimeOverlappedQueries = '1',
--											       @StartTimestamp = '2014-07-14 16:00:49.343',
--											       @EndTimestamp = '2014-07-16 04:00:53.947',
--											       @SQLSignatureIDFilter = 0,
--                                                 @StatementTypeIDFilter = -1

if (object_id('p_GetGraphRepresentationDataByApplication') is not null)
begin
	drop procedure [p_GetGraphRepresentationDataByApplication]
end
go

create procedure [dbo].[p_GetGraphRepresentationDataByApplication]
	@SQLServerID int,
	@ViewID int,
	@ApplicationFilter nvarchar(500) = null,
	@DatabaseFilter nvarchar(500) = null,
	@UserFilter nvarchar(500) = null,
	@ClientFilter nvarchar(500) = null,
	@SQLExclude nvarchar(200) = null,
	@SQLInclude nvarchar(200) = null,
	@IncludeSQLStatements bit = 1,
	@IncludeSQLProcedure bit = 1,
	@IncludeSQLBatch bit = 1,
	@IncludeIncompletedQueries bit = 0,
	@IncludeTimeOverlappedQueries bit = 0,
	@StartTimestamp datetime = null,     
	@EndTimestamp datetime = null,
	@SQLSignatureIDFilter int = 0,
	@StatementTypeIDFilter int = -1
as
begin
	declare @Query nvarchar(max),
			@ParameterDefinition nvarchar(4000);
	
	select @ParameterDefinition = ' @SQLServerID int,
									@ViewID int,
									@ApplicationFilter nvarchar(500),
									@DatabaseFilter nvarchar(500),
									@UserFilter nvarchar(500),
									@ClientFilter nvarchar(500),
									@SQLExclude nvarchar(200),
									@SQLInclude nvarchar(200),
									@IncludeSQLStatements bit,
									@IncludeSQLProcedure bit,
									@IncludeSQLBatch bit,
									@IncludeIncompletedQueries bit,
									@IncludeTimeOverlappedQueries bit,
									@StartTimestamp datetime,
									@EndTimestamp datetime,
									@SQLSignatureIDFilter int,
									@StatementTypeIDFilter int ';

	if @ViewID = 1              -- Duration (ms)
		select @Query = '  select
								QMS.ApplicationNameID as GroupByID,
								AN.ApplicationName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								QMS.DurationMilliseconds as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								ApplicationNames as AN
								on QMS.ApplicationNameID = AN.ApplicationNameID ';				   
	else if @ViewID = 2         -- Duration (ms)
		select @Query = '  select
								QMS.ApplicationNameID as GroupByID,
								AN.ApplicationName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								QMS.CPUMilliseconds as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								ApplicationNames as AN
							 	on QMS.ApplicationNameID = AN.ApplicationNameID ';
	else if @ViewID = 3         -- Reads
		select @Query = '  select
								QMS.ApplicationNameID as GroupByID,
								AN.ApplicationName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								QMS.Reads as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								ApplicationNames as AN
								on QMS.ApplicationNameID = AN.ApplicationNameID ';
	else if @ViewID = 4           -- Writes
		select @Query = '  select
								QMS.ApplicationNameID as GroupByID,
								AN.ApplicationName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								QMS.Writes as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								ApplicationNames as AN
								on QMS.ApplicationNameID = AN.ApplicationNameID ';
	else if @ViewID = 5         -- I/O
		select @Query = '  select
								QMS.ApplicationNameID as GroupByID,
								AN.ApplicationName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								(QMS.Reads + QMS.Writes) as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								ApplicationNames as AN
								on QMS.ApplicationNameID = AN.ApplicationNameID ';
	else if @ViewID = 6         -- Blocking Duration (ms)
		select @Query = '  select
								QMS.ApplicationNameID as GroupByID,
								AN.ApplicationName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								BDT.BlockingDuration as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								ApplicationNames as AN
								on QMS.ApplicationNameID = AN.ApplicationNameID 
								left join
								(
									select
										BSS.ApplicationNameID,
										BSS.BlockingDurationMilliseconds as BlockingDuration
									from
										BlockingSessionStatistics as BSS
									where
										BSS.SQLServerID = @SQLServerID
								) as BDT
								on QMS.ApplicationNameID = BDT.ApplicationNameID ';
	else if @ViewID = 7         -- Wait Duration (ms)
		select @Query = '  select
								QMS.ApplicationNameID as GroupByID,
								AN.ApplicationName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								WT.WaitDuration as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								ApplicationNames as AN
								on QMS.ApplicationNameID = AN.ApplicationNameID 
								left join
								(
									select
										AWS.ApplicationNameID,
										AWS.WaitDuration
									from
										ActiveWaitStatistics as AWS
									where
										AWS.SQLServerID = @SQLServerID
								) as WT
								on QMS.ApplicationNameID = WT.ApplicationNameID ';
	else if @ViewID = 8         -- Deadlocks
		select @Query = '  select
								QMS.ApplicationNameID as GroupByID,
								AN.ApplicationName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								YAxisValue = case
												when DPT.Deadlocks is null then cast(0 as bigint)
												else cast(1 as bigint) 
											 end,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								ApplicationNames as AN
								on QMS.ApplicationNameID = AN.ApplicationNameID 
								left join
								(
									select
										DP.ApplicationNameID,
										DP.DeadlockID as Deadlocks
									from
										DeadlockProcesses as DP
									where
										DP.SQLServerID = @SQLServerID
								) as DPT
								on QMS.ApplicationNameID = DPT.ApplicationNameID ';

	select @Query = @Query + ' left join
							   (
									select
										SS.SQLStatementID,
										(isnull(SS.SQLStatement,'''') + isnull(SSO.SQLStatementOverflow,'''')) as StatementSQLText
									from	
										SQLStatements as SS
										left join
										SQLStatementsOverflow as SSO
										on SS.SQLStatementID = SSO.SQLStatementID
								) as SST
								on QMS.SQLStatementID = SST.SQLStatementID
							where
								QMS.SQLServerID = @SQLServerID ';

	if @ApplicationFilter is not null
		select @Query = @Query + ' and QMS.ApplicationNameID in (' + @ApplicationFilter + ') ';

	if @DatabaseFilter is not null
		select @Query = @Query + ' and QMS.DatabaseID in (' + @DatabaseFilter + ') ';

	if @UserFilter is not null
		select @Query = @Query + ' and QMS.LoginNameID in (' + @UserFilter + ') ';

	if @ClientFilter is not null
		select @Query = @Query + ' and QMS.HostNameID in (' + @ClientFilter + ') ';

	if @SQLExclude is not null           -- exclude filter given priority, skip include filter if exclude is not null
		select @Query = @Query + ' and (LOWER(SST.StatementSQLText) not like ''' + LOWER(@SQLExclude) + ''' ) ';
	else if @SQLInclude is not null
		select @Query = @Query + ' and (LOWER(SST.StatementSQLText) like ''' + LOWER(@SQLInclude) + ''' ) ';

	if @IncludeSQLStatements = 0                           -- SQL Statement 
		select @Query = @Query + ' and (QMS.StatementType != 1) ';
	
	if @IncludeSQLProcedure = 0                             -- SQL Procedure   
		select @Query = @Query + ' and (QMS.StatementType != 0) ';
		
	if @IncludeSQLBatch = 0                                  -- SQL Batch
		select @Query = @Query + ' and (QMS.StatementType != 2) ';
		
	if @IncludeIncompletedQueries = 0                        -- Include Completed Queries
		select @Query = @Query + ' and (QMS.CompletionTime is not null) ';
		
	if @IncludeTimeOverlappedQueries = 1 and @StartTimestamp is not null and @EndTimestamp is not null      -- Including overlapped queries
		select @Query = @Query + ' and (not ((QMS.StatementUTCStartTime > @EndTimestamp) or (QMS.CompletionTime < @StartTimestamp)))';
	else if @IncludeTimeOverlappedQueries = 0 and @StartTimestamp is not null and @EndTimestamp is not null
		select @Query = @Query + ' and (QMS.StatementUTCStartTime >= @StartTimestamp) and (QMS.StatementUTCStartTime <=  @EndTimestamp)';

	if @SQLSignatureIDFilter <> 0
		select @Query = @Query + ' and QMS.SQLSignatureID = @SQLSignatureIDFilter ';

	if @StatementTypeIDFilter <> -1
		select @Query = @Query + ' and QMS.StatementType = @StatementTypeIDFilter ';

	execute sp_executesql @Query, 
                          @ParameterDefinition, 
						  @SQLServerID, 
						  @ViewID,
						  @ApplicationFilter,
						  @DatabaseFilter,
						  @UserFilter,
						  @ClientFilter,
						  @SQLExclude,
						  @SQLInclude,
						  @IncludeSQLStatements,
						  @IncludeSQLProcedure,
						  @IncludeSQLBatch,
						  @IncludeIncompletedQueries,
						  @IncludeTimeOverlappedQueries,
						  @StartTimestamp,
						  @EndTimestamp,
						  @SQLSignatureIDFilter,
						  @StatementTypeIDFilter

end
go
 
GO 

---------- P_GETGRAPHREPRESENTATIONDATABYCLIENT.SQL
-- SQLdm 9.0 (Abhishek Joshi)

-- Query Monitoring
-- retrieves the Query Monitor Statistics when grouped by Client
-- according to the set filters for the Graphs representation on WebUI

-- exec p_GetGraphRepresentationDataByClient       @SQLServerID = 9,
--												   @ViewID = 1,	
--												   @ApplicationFilter = '8,11,12',
--												   @DatabaseFilter = '179',
--											       @UserFilter = '1',
--											       @ClientFilter = '1',
--											       @SQLExclude = null,
--											       @SQLInclude = '%sys%',
--											       @IncludeSQLStatements = '1',
--											       @IncludeSQLProcedure = '1',
--											       @IncludeSQLBatch = '1',
--											       @IncludeIncompletedQueries = '1',
--											       @IncludeTimeOverlappedQueries = '1',
--											       @StartTimestamp = '2014-07-14 16:00:49.343',
--											       @EndTimestamp = '2014-07-16 04:00:53.947',
--											       @SQLSignatureIDFilter = 0,
--                                                 @StatementTypeIDFilter = -1

if (object_id('p_GetGraphRepresentationDataByClient') is not null)
begin
	drop procedure [p_GetGraphRepresentationDataByClient]
end
go

create procedure [dbo].[p_GetGraphRepresentationDataByClient]
	@SQLServerID int,
	@ViewID int,
	@ApplicationFilter nvarchar(500) = null,
	@DatabaseFilter nvarchar(500) = null,
	@UserFilter nvarchar(500) = null,
	@ClientFilter nvarchar(500) = null,
	@SQLExclude nvarchar(200) = null,
	@SQLInclude nvarchar(200) = null,
	@IncludeSQLStatements bit = 1,
	@IncludeSQLProcedure bit = 1,
	@IncludeSQLBatch bit = 1,
	@IncludeIncompletedQueries bit = 0,
	@IncludeTimeOverlappedQueries bit = 0,
	@StartTimestamp datetime = null,     
	@EndTimestamp datetime = null,
	@SQLSignatureIDFilter int = 0,
	@StatementTypeIDFilter int = -1
as
begin
	declare @Query nvarchar(max),
			@ParameterDefinition nvarchar(4000);
			
	select @ParameterDefinition = ' @SQLServerID int,
									@ViewID int,
									@ApplicationFilter nvarchar(500),
									@DatabaseFilter nvarchar(500),
									@UserFilter nvarchar(500),
									@ClientFilter nvarchar(500),
									@SQLExclude nvarchar(200),
									@SQLInclude nvarchar(200),
									@IncludeSQLStatements bit,
									@IncludeSQLProcedure bit,
									@IncludeSQLBatch bit,
									@IncludeIncompletedQueries bit,
									@IncludeTimeOverlappedQueries bit,
									@StartTimestamp datetime,
									@EndTimestamp datetime,
									@SQLSignatureIDFilter int,
									@StatementTypeIDFilter int ';

	if @ViewID = 1            -- Duration (ms)
		select @Query = '  select
								QMS.HostNameID as GroupByID,
								HN.HostName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								QMS.DurationMilliseconds as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								HostNames as HN
								on QMS.HostNameID = HN.HostNameID ';				   
	else if @ViewID = 2         -- Duration (ms)
		select @Query = '  select
								QMS.HostNameID as GroupByID,
								HN.HostName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								QMS.CPUMilliseconds as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								HostNames as HN
								on QMS.HostNameID = HN.HostNameID ';				   
	else if @ViewID = 3         -- Reads
		select @Query = '  select
								QMS.HostNameID as GroupByID,
								HN.HostName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								QMS.Reads as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								HostNames as HN
								on QMS.HostNameID = HN.HostNameID ';				   
	else if @ViewID = 4         -- Writes
		select @Query = '  select
								QMS.HostNameID as GroupByID,
								HN.HostName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								QMS.Writes as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								HostNames as HN
								on QMS.HostNameID = HN.HostNameID ';				   
	else if @ViewID = 5         -- I/O
		select @Query = '  select
								QMS.HostNameID as GroupByID,
								HN.HostName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								(QMS.Reads + QMS.Writes) as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								HostNames as HN
								on QMS.HostNameID = HN.HostNameID ';				   
	else if @ViewID = 6         -- Blocking Duration (ms)
		select @Query = '  select
								QMS.HostNameID as GroupByID,
								HN.HostName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								BDT.BlockingDuration as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								HostNames as HN
								on QMS.HostNameID = HN.HostNameID 
								left join
								(
									select
										BSS.HostNameID ,
										BSS.BlockingDurationMilliseconds as BlockingDuration
									from
										BlockingSessionStatistics as BSS
									where
										BSS.SQLServerID = @SQLServerID
								) as BDT
								on QMS.HostNameID = BDT.HostNameID ';
	else if @ViewID = 7         -- Wait Duration (ms)
		select @Query = '  select
								QMS.HostNameID as GroupByID,
								HN.HostName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								WT.WaitDuration as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								HostNames as HN
								on QMS.HostNameID = HN.HostNameID 
								left join
								(
									select
										AWS.HostNameID,
										AWS.WaitDuration
									from
										ActiveWaitStatistics as AWS
									where
										AWS.SQLServerID = @SQLServerID
								) as WT
								on QMS.HostNameID = WT.HostNameID ';
	else if @ViewID = 8         -- Deadlocks
		select @Query = '  select
								QMS.HostNameID as GroupByID,
								HN.HostName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								YAxisValue = case
												when DPT.Deadlocks is null then cast(0 as bigint)
												else cast(1 as bigint) 
											 end,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								HostNames as HN
								on QMS.HostNameID = HN.HostNameID 
								left join
								(
									select
										DP.HostNameID,
										DP.DeadlockID as Deadlocks
									from
										DeadlockProcesses as DP
									where
										DP.SQLServerID = @SQLServerID
								) as DPT
								on QMS.HostNameID = DPT.HostNameID ';

	select @Query = @Query + ' left join
							   (
									select
										SS.SQLStatementID,
										(isnull(SS.SQLStatement,'''') + isnull(SSO.SQLStatementOverflow,'''')) as StatementSQLText
									from	
										SQLStatements as SS
										left join
										SQLStatementsOverflow as SSO
										on SS.SQLStatementID = SSO.SQLStatementID
								) as SST
								on QMS.SQLStatementID = SST.SQLStatementID
							where
								QMS.SQLServerID = @SQLServerID ';

	if @ApplicationFilter is not null
		select @Query = @Query + ' and QMS.ApplicationNameID in (' + @ApplicationFilter + ') ';

	if @DatabaseFilter is not null
		select @Query = @Query + ' and QMS.DatabaseID in (' + @DatabaseFilter + ') ';

	if @UserFilter is not null
		select @Query = @Query + ' and QMS.LoginNameID in (' + @UserFilter + ') ';

	if @ClientFilter is not null
		select @Query = @Query + ' and QMS.HostNameID in (' + @ClientFilter + ') ';

	if @SQLExclude is not null           -- exclude filter given priority, skip include filter if exclude is not null
		select @Query = @Query + ' and (LOWER(SST.StatementSQLText) not like ''' + LOWER(@SQLExclude) + ''' ) ';
	else if @SQLInclude is not null
		select @Query = @Query + ' and (LOWER(SST.StatementSQLText) like ''' + LOWER(@SQLInclude) + ''' ) ';

	if @IncludeSQLStatements = 0                           -- SQL Statement 
		select @Query = @Query + ' and (QMS.StatementType != 1) ';
	
	if @IncludeSQLProcedure = 0                             -- SQL Procedure   
		select @Query = @Query + ' and (QMS.StatementType != 0) ';
		
	if @IncludeSQLBatch = 0                                  -- SQL Batch
		select @Query = @Query + ' and (QMS.StatementType != 2) ';
		
	if @IncludeIncompletedQueries = 0                        -- Include Completed Queries
		select @Query = @Query + ' and (QMS.CompletionTime is not null) ';
		
	if @IncludeTimeOverlappedQueries = 1 and @StartTimestamp is not null and @EndTimestamp is not null      -- Including overlapped queries
		select @Query = @Query + ' and (not ((QMS.StatementUTCStartTime > @EndTimestamp) or (QMS.CompletionTime < @StartTimestamp)))';
	else if @IncludeTimeOverlappedQueries = 0 and @StartTimestamp is not null and @EndTimestamp is not null
		select @Query = @Query + ' and (QMS.StatementUTCStartTime >= @StartTimestamp) and (QMS.StatementUTCStartTime <=  @EndTimestamp)';

	if @SQLSignatureIDFilter <> 0
		select @Query = @Query + ' and QMS.SQLSignatureID = @SQLSignatureIDFilter ';

	if @StatementTypeIDFilter <> -1
		select @Query = @Query + ' and QMS.StatementType = @StatementTypeIDFilter ';

	execute sp_executesql @Query, 
                          @ParameterDefinition, 
						  @SQLServerID, 
						  @ViewID,
						  @ApplicationFilter,
						  @DatabaseFilter,
						  @UserFilter,
						  @ClientFilter,
						  @SQLExclude,
						  @SQLInclude,
						  @IncludeSQLStatements,
						  @IncludeSQLProcedure,
						  @IncludeSQLBatch,
						  @IncludeIncompletedQueries,
						  @IncludeTimeOverlappedQueries,
						  @StartTimestamp,
						  @EndTimestamp,
						  @SQLSignatureIDFilter,
						  @StatementTypeIDFilter

end
go
 
GO 

---------- P_GETGRAPHREPRESENTATIONDATABYDATABASE.SQL
-- SQLdm 9.0 (Abhishek Joshi)

-- Query Monitoring
-- retrieves the Query Monitor Statistics when grouped by Database
-- according to the set filters for the Graphs representation on WebUI

-- exec p_GetGraphRepresentationDataByDatabase     @SQLServerID = 9,
--												   @ViewID = 1,	
--												   @ApplicationFilter = '8,11,12',
--												   @DatabaseFilter = '179',
--											       @UserFilter = '1',
--											       @ClientFilter = '1',
--											       @SQLExclude = null,
--											       @SQLInclude = '%sys%',
--											       @IncludeSQLStatements = '1',
--											       @IncludeSQLProcedure = '1',
--											       @IncludeSQLBatch = '1',
--											       @IncludeIncompletedQueries = '1',
--											       @IncludeTimeOverlappedQueries = '1',
--											       @StartTimestamp = '2014-07-14 16:00:49.343',
--											       @EndTimestamp = '2014-07-16 04:00:53.947',
--											       @SQLSignatureIDFilter = 0,
--                                                 @StatementTypeIDFilter = -1

if (object_id('p_GetGraphRepresentationDataByDatabase') is not null)
begin
	drop procedure [p_GetGraphRepresentationDataByDatabase]
end
go

create procedure [dbo].[p_GetGraphRepresentationDataByDatabase]
	@SQLServerID int,
	@ViewID int,
	@ApplicationFilter nvarchar(500) = null,
	@DatabaseFilter nvarchar(500) = null,
	@UserFilter nvarchar(500) = null,
	@ClientFilter nvarchar(500) = null,
	@SQLExclude nvarchar(200) = null,
	@SQLInclude nvarchar(200) = null,
	@IncludeSQLStatements bit = 1,
	@IncludeSQLProcedure bit = 1,
	@IncludeSQLBatch bit = 1,
	@IncludeIncompletedQueries bit = 0,
	@IncludeTimeOverlappedQueries bit = 0,
	@StartTimestamp datetime = null,     
	@EndTimestamp datetime = null,
	@SQLSignatureIDFilter int = 0,
	@StatementTypeIDFilter int = -1
as
begin
	declare @Query nvarchar(max),
			@ParameterDefinition nvarchar(4000);
	
	select @ParameterDefinition = ' @SQLServerID int,
									@ViewID int,
									@ApplicationFilter nvarchar(500),
									@DatabaseFilter nvarchar(500),
									@UserFilter nvarchar(500),
									@ClientFilter nvarchar(500),
									@SQLExclude nvarchar(200),
									@SQLInclude nvarchar(200),
									@IncludeSQLStatements bit,
									@IncludeSQLProcedure bit,
									@IncludeSQLBatch bit,
									@IncludeIncompletedQueries bit,
									@IncludeTimeOverlappedQueries bit,
									@StartTimestamp datetime,
									@EndTimestamp datetime,
									@SQLSignatureIDFilter int,
									@StatementTypeIDFilter int ';

	if @ViewID = 1          -- Duration (ms)
		select @Query = '  select
								QMS.DatabaseID as GroupByID,
								SSDN.DatabaseName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								QMS.DurationMilliseconds as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								SQLServerDatabaseNames as SSDN
								on QMS.DatabaseID = SSDN.DatabaseID ';				   
	else if @ViewID = 2         -- CPU Time (ms)
		select @Query = '  select
								QMS.DatabaseID as GroupByID,
								SSDN.DatabaseName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								QMS.CPUMilliseconds as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								SQLServerDatabaseNames as SSDN
								on QMS.DatabaseID = SSDN.DatabaseID ';				   
	else if @ViewID = 3         -- Reads
		select @Query = '  select
								QMS.DatabaseID as GroupByID,
								SSDN.DatabaseName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								QMS.Reads as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								SQLServerDatabaseNames as SSDN
								on QMS.DatabaseID = SSDN.DatabaseID ';				   
	else if @ViewID = 4         -- Writes
		select @Query = '  select
								QMS.DatabaseID as GroupByID,
								SSDN.DatabaseName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								QMS.Writes as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								SQLServerDatabaseNames as SSDN
								on QMS.DatabaseID = SSDN.DatabaseID ';				   
	else if @ViewID = 5         -- I/O
		select @Query = '  select
								QMS.DatabaseID as GroupByID,
								SSDN.DatabaseName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								(QMS.Reads + QMS.Writes) as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								SQLServerDatabaseNames as SSDN
								on QMS.DatabaseID = SSDN.DatabaseID ';				   
	else if @ViewID = 6         -- Blocking Duration (ms)
		select @Query = '  select
								QMS.DatabaseID as GroupByID,
								SSDN.DatabaseName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								BDT.BlockingDuration as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								SQLServerDatabaseNames as SSDN
								on QMS.DatabaseID = SSDN.DatabaseID 				   
								left join
								(
									select
										BSS.DatabaseID,
										BSS.BlockingDurationMilliseconds as BlockingDuration
									from
										BlockingSessionStatistics as BSS
									where
										BSS.SQLServerID = @SQLServerID
								) as BDT
								on QMS.DatabaseID = BDT.DatabaseID ';
	else if @ViewID = 7         -- Wait Duration (ms)
		select @Query = '  select
								QMS.DatabaseID as GroupByID,
								SSDN.DatabaseName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								WT.WaitDuration as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								SQLServerDatabaseNames as SSDN
								on QMS.DatabaseID = SSDN.DatabaseID 				   
								left join
								(
									select
										AWS.DatabaseID,
										AWS.WaitDuration
									from
										ActiveWaitStatistics as AWS
									where
										AWS.SQLServerID = @SQLServerID
								) as WT
								on QMS.DatabaseID = WT.DatabaseID ';
	else if @ViewID = 8         -- Deadlocks
		select @Query = '  select
								QMS.DatabaseID as GroupByID,
								SSDN.DatabaseName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								YAxisValue = case
												when DPT.Deadlocks is null then cast(0 as bigint)
												else cast(1 as bigint) 
											 end,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								SQLServerDatabaseNames as SSDN
								on QMS.DatabaseID = SSDN.DatabaseID 
								left join
								(
									select
										DP.DatabaseID,
										DP.DeadlockID as Deadlocks
									from
										DeadlockProcesses as DP
									where
										DP.SQLServerID = @SQLServerID
								) as DPT
								on QMS.DatabaseID = DPT.DatabaseID ';

	select @Query = @Query + ' left join
							   (
									select
										SS.SQLStatementID,
										(isnull(SS.SQLStatement,'''') + isnull(SSO.SQLStatementOverflow,'''')) as StatementSQLText
									from	
										SQLStatements as SS
										left join
										SQLStatementsOverflow as SSO
										on SS.SQLStatementID = SSO.SQLStatementID
								) as SST
								on QMS.SQLStatementID = SST.SQLStatementID
							where
								QMS.SQLServerID = @SQLServerID ';

	if @ApplicationFilter is not null
		select @Query = @Query + ' and QMS.ApplicationNameID in (' + @ApplicationFilter + ') ';

	if @DatabaseFilter is not null
		select @Query = @Query + ' and QMS.DatabaseID in (' + @DatabaseFilter + ') ';

	if @UserFilter is not null
		select @Query = @Query + ' and QMS.LoginNameID in (' + @UserFilter + ') ';

	if @ClientFilter is not null
		select @Query = @Query + ' and QMS.HostNameID in (' + @ClientFilter + ') ';

	if @SQLExclude is not null           -- exclude filter given priority, skip include filter if exclude is not null
		select @Query = @Query + ' and (LOWER(SST.StatementSQLText) not like ''' + LOWER(@SQLExclude) + ''' ) ';
	else if @SQLInclude is not null
		select @Query = @Query + ' and (LOWER(SST.StatementSQLText) like ''' + LOWER(@SQLInclude) + ''' ) ';

	if @IncludeSQLStatements = 0                           -- SQL Statement 
		select @Query = @Query + ' and (QMS.StatementType != 1) ';
	
	if @IncludeSQLProcedure = 0                             -- SQL Procedure   
		select @Query = @Query + ' and (QMS.StatementType != 0) ';
		
	if @IncludeSQLBatch = 0                                  -- SQL Batch
		select @Query = @Query + ' and (QMS.StatementType != 2) ';
		
	if @IncludeIncompletedQueries = 0                        -- Include Completed Queries
		select @Query = @Query + ' and (QMS.CompletionTime is not null) ';
		
	if @IncludeTimeOverlappedQueries = 1 and @StartTimestamp is not null and @EndTimestamp is not null      -- Including overlapped queries
		select @Query = @Query + ' and (not ((QMS.StatementUTCStartTime > @EndTimestamp) or (QMS.CompletionTime < @StartTimestamp)))';
	else if @IncludeTimeOverlappedQueries = 0 and @StartTimestamp is not null and @EndTimestamp is not null
		select @Query = @Query + ' and (QMS.StatementUTCStartTime >= @StartTimestamp) and (QMS.StatementUTCStartTime <=  @EndTimestamp)';

	if @SQLSignatureIDFilter <> 0
		select @Query = @Query + ' and QMS.SQLSignatureID = @SQLSignatureIDFilter ';

	if @StatementTypeIDFilter <> -1
		select @Query = @Query + ' and QMS.StatementType = @StatementTypeIDFilter ';

	execute sp_executesql @Query, 
                          @ParameterDefinition, 
						  @SQLServerID, 
						  @ViewID,
						  @ApplicationFilter,
						  @DatabaseFilter,
						  @UserFilter,
						  @ClientFilter,
						  @SQLExclude,
						  @SQLInclude,
						  @IncludeSQLStatements,
						  @IncludeSQLProcedure,
						  @IncludeSQLBatch,
						  @IncludeIncompletedQueries,
						  @IncludeTimeOverlappedQueries,
						  @StartTimestamp,
						  @EndTimestamp,
						  @SQLSignatureIDFilter,
						  @StatementTypeIDFilter

end
go
 
GO 

---------- P_GETGRAPHREPRESENTATIONDATABYQUERYSIGNATURE.SQL
-- SQLdm 9.0 (Abhishek Joshi)

-- Query Monitoring
-- retrieves the Query Monitor Statistics when grouped by Query Signature
-- according to the set filters for the Graphs representation on WebUI

-- exec p_GetGraphRepresentationDataByQuerySignature        @SQLServerID = 9,
--															@ViewID = 1,	
--															@ApplicationFilter = '8,11,12',
--															@DatabaseFilter = '179',
--															@UserFilter = '1',
--															@ClientFilter = '1',
--															@SQLExclude = null,
--															@SQLInclude = '%sys%',
--															@IncludeSQLStatements = '1',
--															@IncludeSQLProcedure = '1',
--															@IncludeSQLBatch = '1',
--															@IncludeIncompletedQueries = '1',
--															@IncludeTimeOverlappedQueries = '1',
--															@StartTimestamp = '2014-07-14 16:00:49.343',
--															@EndTimestamp = '2014-07-16 04:00:53.947',
--															@SQLSignatureIDFilter = 0,
--                                                          @StatementTypeIDFilter = -1

if (object_id('p_GetGraphRepresentationDataByQuerySignature') is not null)
begin
	drop procedure [p_GetGraphRepresentationDataByQuerySignature]
end
go

create procedure [dbo].[p_GetGraphRepresentationDataByQuerySignature]
	@SQLServerID int,
	@ViewID int,
	@ApplicationFilter nvarchar(500) = null,
	@DatabaseFilter nvarchar(500) = null,
	@UserFilter nvarchar(500) = null,
	@ClientFilter nvarchar(500) = null,
	@SQLExclude nvarchar(200) = null,
	@SQLInclude nvarchar(200) = null,
	@IncludeSQLStatements bit = 1,
	@IncludeSQLProcedure bit = 1,
	@IncludeSQLBatch bit = 1,
	@IncludeIncompletedQueries bit = 0,
	@IncludeTimeOverlappedQueries bit = 0,
	@StartTimestamp datetime = null,     
	@EndTimestamp datetime = null,
	@SQLSignatureIDFilter int = 0,
	@StatementTypeIDFilter int = -1
as
begin
	declare @Query nvarchar(max),
			@ParameterDefinition nvarchar(4000);
			
	select @ParameterDefinition = ' @SQLServerID int,
									@ViewID int,
									@ApplicationFilter nvarchar(500),
									@DatabaseFilter nvarchar(500),
									@UserFilter nvarchar(500),
									@ClientFilter nvarchar(500),
									@SQLExclude nvarchar(200),
									@SQLInclude nvarchar(200),
									@IncludeSQLStatements bit,
									@IncludeSQLProcedure bit,
									@IncludeSQLBatch bit,
									@IncludeIncompletedQueries bit,
									@IncludeTimeOverlappedQueries bit,
									@StartTimestamp datetime,
									@EndTimestamp datetime,
									@SQLSignatureIDFilter int,
									@StatementTypeIDFilter int ';

	if @ViewID = 1         -- Duration (ms)
		select @Query = '  select
								(isnull(cast(QMS.SQLSignatureID as nvarchar(50)),''0'') +'':''+ isnull(cast(QMS.StatementType as nvarchar(50)),''-1'')) as GroupByID,
								SSIG.SignatureSQLText as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								QMS.DurationMilliseconds as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS ';
	else if @ViewID = 2        -- CPU Time (ms)
		select @Query = '  select
								(isnull(cast(QMS.SQLSignatureID as nvarchar(50)),''0'') +'':''+ isnull(cast(QMS.StatementType as nvarchar(50)),''-1'')) as GroupByID,
								SSIG.SignatureSQLText as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								QMS.CPUMilliseconds as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS ';				   
	else if @ViewID = 3      -- Reads
		select @Query = '  select
								(isnull(cast(QMS.SQLSignatureID as nvarchar(50)),''0'') +'':''+ isnull(cast(QMS.StatementType as nvarchar(50)),''-1'')) as GroupByID,
								SSIG.SignatureSQLText as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								QMS.Reads as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS ';				   
	else if @ViewID = 4      -- Writes
		select @Query = '  select
								(isnull(cast(QMS.SQLSignatureID as nvarchar(50)),''0'') +'':''+ isnull(cast(QMS.StatementType as nvarchar(50)),''-1'')) as GroupByID,
								SSIG.SignatureSQLText as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								QMS.Writes as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS ';				   
	else if @ViewID = 5       -- I/O
		select @Query = '  select
								(isnull(cast(QMS.SQLSignatureID as nvarchar(50)),''0'') +'':''+ isnull(cast(QMS.StatementType as nvarchar(50)),''-1'')) as GroupByID,
								SSIG.SignatureSQLText as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								(QMS.Reads + QMS.Writes) as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS ';				   
	else if @ViewID = 6        -- Blocking Duration (ms)
		select @Query = '  select
								(isnull(cast(QMS.SQLSignatureID as nvarchar(50)),''0'') +'':''+ isnull(cast(QMS.StatementType as nvarchar(50)),''-1'')) as GroupByID,
								SSIG.SignatureSQLText as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								BDT.BlockingDuration as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								(
									select
										BSS.SQLSignatureID,
										BSS.BlockingDurationMilliseconds as BlockingDuration
									from
										BlockingSessionStatistics as BSS
									where
										BSS.SQLServerID = @SQLServerID
								) as BDT
								on QMS.SQLSignatureID = BDT.SQLSignatureID ';
	else if @ViewID = 7         -- Wait Duration (ms)
		select @Query = '  select
								(isnull(cast(QMS.SQLSignatureID as nvarchar(50)),''0'') +'':''+ isnull(cast(QMS.StatementType as nvarchar(50)),''-1'')) as GroupByID,
								SSIG.SignatureSQLText as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								WT.WaitDuration as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								(
									select
										AWS.SQLSignatureID,
										AWS.WaitDuration
									from
										ActiveWaitStatistics as AWS
									where
										AWS.SQLServerID = @SQLServerID
								) as WT
								on QMS.SQLSignatureID = WT.SQLSignatureID ';
	else if @ViewID = 8         -- Deadlocks
		select @Query = '  select
								(isnull(cast(QMS.SQLSignatureID as nvarchar(50)),''0'') +'':''+ isnull(cast(QMS.StatementType as nvarchar(50)),''-1'')) as GroupByID,
								SSIG.SignatureSQLText as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								YAxisValue = case
												when DPT.Deadlocks is null then cast(0 as bigint)
												else cast(1 as bigint) 
											 end,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								(
									select
										DP.SQLSignatureID,
										DP.DeadlockID as Deadlocks
									from
										DeadlockProcesses as DP
									where
										DP.SQLServerID = @SQLServerID
								) as DPT
								on QMS.SQLSignatureID = DPT.SQLSignatureID ';

	select @Query = @Query + ' left join
							   (
									select
										SS.SQLSignatureID,
										(isnull(SS.SQLSignature,'''') + isnull(SSO.SQLSignatureOverflow,'''')) as SignatureSQLText
									from	
										SQLSignatures as SS
										left join
										SQLSignaturesOverflow as SSO
										on SS.SQLSignatureID = SSO.SQLSignatureID
							   ) as SSIG
							   on QMS.SQLSignatureID = SSIG.SQLSignatureID
							   left join
							   (
									select
										SS.SQLStatementID,
										(isnull(SS.SQLStatement,'''') + isnull(SSO.SQLStatementOverflow,'''')) as StatementSQLText
									from	
										SQLStatements as SS
										left join
										SQLStatementsOverflow as SSO
										on SS.SQLStatementID = SSO.SQLStatementID
								) as SST
								on QMS.SQLStatementID = SST.SQLStatementID
							where
								QMS.SQLServerID = @SQLServerID ';

	if @ApplicationFilter is not null
		select @Query = @Query + ' and QMS.ApplicationNameID in (' + @ApplicationFilter + ') ';

	if @DatabaseFilter is not null
		select @Query = @Query + ' and QMS.DatabaseID in (' + @DatabaseFilter + ') ';

	if @UserFilter is not null
		select @Query = @Query + ' and QMS.LoginNameID in (' + @UserFilter + ') ';

	if @ClientFilter is not null
		select @Query = @Query + ' and QMS.HostNameID in (' + @ClientFilter + ') ';

	if @SQLExclude is not null           -- exclude filter given priority, skip include filter if exclude is not null
		select @Query = @Query + ' and (LOWER(SST.StatementSQLText) not like ''' + LOWER(@SQLExclude) + ''' ) ';
	else if @SQLInclude is not null
		select @Query = @Query + ' and (LOWER(SST.StatementSQLText) like ''' + LOWER(@SQLInclude) + ''' ) ';

	if @IncludeSQLStatements = 0                           -- SQL Statement 
		select @Query = @Query + ' and (QMS.StatementType != 1) ';
	
	if @IncludeSQLProcedure = 0                             -- SQL Procedure   
		select @Query = @Query + ' and (QMS.StatementType != 0) ';
		
	if @IncludeSQLBatch = 0                                  -- SQL Batch
		select @Query = @Query + ' and (QMS.StatementType != 2) ';
		
	if @IncludeIncompletedQueries = 0                        -- Include Completed Queries
		select @Query = @Query + ' and (QMS.CompletionTime is not null) ';
		
	if @IncludeTimeOverlappedQueries = 1 and @StartTimestamp is not null and @EndTimestamp is not null      -- Including overlapped queries
		select @Query = @Query + ' and (not ((QMS.StatementUTCStartTime > @EndTimestamp) or (QMS.CompletionTime < @StartTimestamp)))';
	else if @IncludeTimeOverlappedQueries = 0 and @StartTimestamp is not null and @EndTimestamp is not null
		select @Query = @Query + ' and (QMS.StatementUTCStartTime >= @StartTimestamp) and (QMS.StatementUTCStartTime <=  @EndTimestamp)';
		
	if @SQLSignatureIDFilter <> 0
		select @Query = @Query + ' and QMS.SQLSignatureID = @SQLSignatureIDFilter ';

	if @StatementTypeIDFilter <> -1
		select @Query = @Query + ' and QMS.StatementType = @StatementTypeIDFilter ';

	execute sp_executesql @Query, 
                          @ParameterDefinition, 
						  @SQLServerID, 
						  @ViewID,
						  @ApplicationFilter,
						  @DatabaseFilter,
						  @UserFilter,
						  @ClientFilter,
						  @SQLExclude,
						  @SQLInclude,
						  @IncludeSQLStatements,
						  @IncludeSQLProcedure,
						  @IncludeSQLBatch,
						  @IncludeIncompletedQueries,
						  @IncludeTimeOverlappedQueries,
						  @StartTimestamp,
						  @EndTimestamp,
						  @SQLSignatureIDFilter,
						  @StatementTypeIDFilter

end
go
 
GO 

---------- P_GETGRAPHREPRESENTATIONDATABYQUERYSTATEMENT.SQL
-- SQLdm 9.0 (Abhishek Joshi)

-- Query Monitoring
-- retrieves the Query Monitor Statistics when grouped by Query Statement
-- according to the set filters for the Graphs representation on WebUI

-- exec p_GetGraphRepresentationDataByQueryStatement        @SQLServerID = 9,
--															@ViewID = 1,	
--															@ApplicationFilter = '8,11,12',
--															@DatabaseFilter = '179',
--															@UserFilter = '1',
--															@ClientFilter = '1',
--															@SQLExclude = null,
--															@SQLInclude = '%sys%',
--															@IncludeSQLStatements = '1',
--															@IncludeSQLProcedure = '1',
--															@IncludeSQLBatch = '1',
--															@IncludeIncompletedQueries = '1',
--															@IncludeTimeOverlappedQueries = '1',
--															@StartTimestamp = '2014-07-14 16:00:49.343',
--															@EndTimestamp = '2014-07-16 04:00:53.947',
--															@SQLSignatureIDFilter = 0,
--                                                          @StatementTypeIDFilter = -1

if (object_id('p_GetGraphRepresentationDataByQueryStatement') is not null)
begin
	drop procedure [p_GetGraphRepresentationDataByQueryStatement]
end
go

create procedure [dbo].[p_GetGraphRepresentationDataByQueryStatement]
	@SQLServerID int,
	@ViewID int,
	@ApplicationFilter nvarchar(500) = null,
	@DatabaseFilter nvarchar(500) = null,
	@UserFilter nvarchar(500) = null,
	@ClientFilter nvarchar(500) = null,
	@SQLExclude nvarchar(200) = null,
	@SQLInclude nvarchar(200) = null,
	@IncludeSQLStatements bit = 1,
	@IncludeSQLProcedure bit = 1,
	@IncludeSQLBatch bit = 1,
	@IncludeIncompletedQueries bit = 0,
	@IncludeTimeOverlappedQueries bit = 0,
	@StartTimestamp datetime = null,     
	@EndTimestamp datetime = null,
	@SQLSignatureIDFilter int = 0,
	@StatementTypeIDFilter int = -1
as
begin
	declare @QueryInit nvarchar(100), --SQLdm 9.0 (Ankit Srivastava) - Query Plan Grpahical View - added new query variable for Selecting querystatistics column 
			@Query nvarchar(max),
			@ParameterDefinition nvarchar(4000);

	select @ParameterDefinition = ' @SQLServerID int,
									@ViewID int,
									@ApplicationFilter nvarchar(500),
									@DatabaseFilter nvarchar(500),
									@UserFilter nvarchar(500),
									@ClientFilter nvarchar(500),
									@SQLExclude nvarchar(200),
									@SQLInclude nvarchar(200),
									@IncludeSQLStatements bit,
									@IncludeSQLProcedure bit,
									@IncludeSQLBatch bit,
									@IncludeIncompletedQueries bit,
									@IncludeTimeOverlappedQueries bit,
									@StartTimestamp datetime,
									@EndTimestamp datetime,
									@SQLSignatureIDFilter int,
									@StatementTypeIDFilter int ';

Select @QueryInit= 'Select QMS.QueryStatisticsID as GroupByID,' --SQLdm 9.0 (Ankit Srivastava) - Query Plan Grpahical View - Select querystatistics column which works as unique key

--START SQLdm 9.0 (Ankit Srivastava) - Query Plan Grpahical View - Removed SELECT keyword since it would already be in the preceding string
	if @ViewID = 1         -- Duration (ms)
		select @Query = '  		QMS.StatementUTCStartTime as StartTime,
								QMS.DurationMilliseconds as YAxisValue,
								SST.StatementSQLText as GroupByName
						   from
								QueryMonitorStatistics as QMS ';
	else if @ViewID = 2      -- CPU Time (ms)
		select @Query = '		QMS.StatementUTCStartTime as StartTime,
								QMS.CPUMilliseconds as YAxisValue,
								SST.StatementSQLText as GroupByName
						   from
								QueryMonitorStatistics as QMS ';				   
	else if @ViewID = 3        -- Reads
		select @Query = '		QMS.StatementUTCStartTime as StartTime,
								QMS.Reads as YAxisValue,
								SST.StatementSQLText as GroupByName
						   from
								QueryMonitorStatistics as QMS ';				   
	else if @ViewID = 4        -- Writes
		select @Query = '       QMS.StatementUTCStartTime as StartTime,
								QMS.Writes as YAxisValue,
								SST.StatementSQLText as GroupByName
						   from
								QueryMonitorStatistics as QMS ';				   
	else if @ViewID = 5        -- I/O
		select @Query = '       QMS.StatementUTCStartTime as StartTime,
								(QMS.Reads + QMS.Writes) as YAxisValue,
								SST.StatementSQLText as GroupByName
						   from
								QueryMonitorStatistics as QMS ';				   
	else if @ViewID = 6         -- Blocking Duration (ms)
		select @Query = '       QMS.StatementUTCStartTime as StartTime,
								BDT.BlockingDuration as YAxisValue,
								SST.StatementSQLText as GroupByName
						   from
								QueryMonitorStatistics as QMS
								left join
								(
									select
										BSS.SQLStatementID,
										BSS.BlockingDurationMilliseconds as BlockingDuration
									from
										BlockingSessionStatistics as BSS
									where
										BSS.SQLServerID = @SQLServerID
								) as BDT
								on QMS.SQLStatementID = BDT.SQLStatementID ';
	else if @ViewID = 7         -- Wait Duration (ms)
		select @Query = '       QMS.StatementUTCStartTime as StartTime,
								WT.WaitDuration as YAxisValue,
								SST.StatementSQLText as GroupByName
						   from
								QueryMonitorStatistics as QMS
								left join
								(
									select
										AWS.SQLStatementID,
										AWS.WaitDuration
									from
										ActiveWaitStatistics as AWS
									where
										AWS.SQLServerID = @SQLServerID
								) as WT
								on QMS.SQLStatementID = WT.SQLStatementID ';
	else if @ViewID = 8         -- Deadlocks
		select @Query = '       QMS.StatementUTCStartTime as StartTime,
								YAxisValue = case
												when DPT.Deadlocks is null then cast(0 as bigint)
												else cast(1 as bigint) 
											 end,
								SST.StatementSQLText as GroupByName
						   from
								QueryMonitorStatistics as QMS
								left join
								(
									select
										DP.SQLStatementID,
										DP.DeadlockID as Deadlocks
									from
										DeadlockProcesses as DP
									where
										DP.SQLServerID = @SQLServerID
								) as DPT
								on QMS.SQLStatementID = DPT.SQLStatementID ';
--END SQLdm 9.0 (Ankit Srivastava) - Query Plan Grpahical View - Removed SELECT keyword since it would already be in the preceding string	

	--SQLdm 9.0 (Ankit Srivastava) - Query Plan Grpahical View - Concotenate the query which select querystatistics column 
	select @Query = @QueryInit + @Query + ' left join
							   (
									select
										SS.SQLStatementID,
										(isnull(SS.SQLStatement,'''') + isnull(SSO.SQLStatementOverflow,'''')) as StatementSQLText
									from	
										SQLStatements as SS
										left join
										SQLStatementsOverflow as SSO
										on SS.SQLStatementID = SSO.SQLStatementID
								) as SST
								on QMS.SQLStatementID = SST.SQLStatementID
							where
								QMS.SQLServerID = @SQLServerID ';

	if @ApplicationFilter is not null
		select @Query = @Query + ' and QMS.ApplicationNameID in (' + @ApplicationFilter + ') ';

	if @DatabaseFilter is not null
		select @Query = @Query + ' and QMS.DatabaseID in (' + @DatabaseFilter + ') ';

	if @UserFilter is not null
		select @Query = @Query + ' and QMS.LoginNameID in (' + @UserFilter + ') ';

	if @ClientFilter is not null
		select @Query = @Query + ' and QMS.HostNameID in (' + @ClientFilter + ') ';

	if @SQLExclude is not null           -- exclude filter given priority, skip include filter if exclude is not null
		select @Query = @Query + ' and (LOWER(SST.StatementSQLText) not like ''' + LOWER(@SQLExclude) + ''' ) ';
	else if @SQLInclude is not null
		select @Query = @Query + ' and (LOWER(SST.StatementSQLText) like ''' + LOWER(@SQLInclude) + ''' ) ';

	if @IncludeSQLStatements = 0                           -- SQL Statement 
		select @Query = @Query + ' and (QMS.StatementType != 1) ';
	
	if @IncludeSQLProcedure = 0                             -- SQL Procedure   
		select @Query = @Query + ' and (QMS.StatementType != 0) ';
		
	if @IncludeSQLBatch = 0                                  -- SQL Batch
		select @Query = @Query + ' and (QMS.StatementType != 2) ';
		
	if @IncludeIncompletedQueries = 0                        -- Include Completed Queries
		select @Query = @Query + ' and (QMS.CompletionTime is not null) ';
		
	if @IncludeTimeOverlappedQueries = 1 and @StartTimestamp is not null and @EndTimestamp is not null      -- Including overlapped queries
		select @Query = @Query + ' and (not ((QMS.StatementUTCStartTime > @EndTimestamp) or (QMS.CompletionTime < @StartTimestamp)))';
	else if @IncludeTimeOverlappedQueries = 0 and @StartTimestamp is not null and @EndTimestamp is not null
		select @Query = @Query + ' and (QMS.StatementUTCStartTime >= @StartTimestamp) and (QMS.StatementUTCStartTime <=  @EndTimestamp)';

	if @SQLSignatureIDFilter <> 0
		select @Query = @Query + ' and QMS.SQLSignatureID = @SQLSignatureIDFilter ';

	if @StatementTypeIDFilter <> -1
		select @Query = @Query + ' and QMS.StatementType = @StatementTypeIDFilter ';

	execute sp_executesql @Query, 
                          @ParameterDefinition, 
						  @SQLServerID, 
						  @ViewID,
						  @ApplicationFilter,
						  @DatabaseFilter,
						  @UserFilter,
						  @ClientFilter,
						  @SQLExclude,
						  @SQLInclude,
						  @IncludeSQLStatements,
						  @IncludeSQLProcedure,
						  @IncludeSQLBatch,
						  @IncludeIncompletedQueries,
						  @IncludeTimeOverlappedQueries,
						  @StartTimestamp,
						  @EndTimestamp,
						  @SQLSignatureIDFilter,
						  @StatementTypeIDFilter

end
go
 
GO 

---------- P_GETGRAPHREPRESENTATIONDATABYUSER.SQL
-- SQLdm 9.0 (Abhishek Joshi)

-- Query Monitoring
-- retrieves the Query Monitor Statistics when grouped by User
-- according to the set filters for the Graphs representation on WebUI

-- exec p_GetGraphRepresentationDataByUser         @SQLServerID = 9,
--												   @ViewID = 1,	
--												   @ApplicationFilter = '8,11,12',
--												   @DatabaseFilter = '179',
--											       @UserFilter = '1',
--											       @ClientFilter = '1',
--											       @SQLExclude = null,
--											       @SQLInclude = '%sys%',
--											       @IncludeSQLStatements = '1',
--											       @IncludeSQLProcedure = '1',
--											       @IncludeSQLBatch = '1',
--											       @IncludeIncompletedQueries = '1',
--											       @IncludeTimeOverlappedQueries = '1',
--											       @StartTimestamp = '2014-07-14 16:00:49.343',
--											       @EndTimestamp = '2014-07-16 04:00:53.947',
--											       @SQLSignatureIDFilter = 0,
--                                                 @StatementTypeIDFilter = -1

if (object_id('p_GetGraphRepresentationDataByUser') is not null)
begin
	drop procedure [p_GetGraphRepresentationDataByUser]
end
go

create procedure [dbo].[p_GetGraphRepresentationDataByUser]
	@SQLServerID int,
	@ViewID int,
	@ApplicationFilter nvarchar(500) = null,
	@DatabaseFilter nvarchar(500) = null,
	@UserFilter nvarchar(500) = null,
	@ClientFilter nvarchar(500) = null,
	@SQLExclude nvarchar(200) = null,
	@SQLInclude nvarchar(200) = null,
	@IncludeSQLStatements bit = 1,
	@IncludeSQLProcedure bit = 1,
	@IncludeSQLBatch bit = 1,
	@IncludeIncompletedQueries bit = 0,
	@IncludeTimeOverlappedQueries bit = 0,
	@StartTimestamp datetime = null,     
	@EndTimestamp datetime = null,
	@SQLSignatureIDFilter int = 0,
	@StatementTypeIDFilter int = -1
as
begin
	declare @Query nvarchar(max),
			@ParameterDefinition nvarchar(4000);
			
	select @ParameterDefinition = ' @SQLServerID int,
									@ViewID int,
									@ApplicationFilter nvarchar(500),
									@DatabaseFilter nvarchar(500),
									@UserFilter nvarchar(500),
									@ClientFilter nvarchar(500),
									@SQLExclude nvarchar(200),
									@SQLInclude nvarchar(200),
									@IncludeSQLStatements bit,
									@IncludeSQLProcedure bit,
									@IncludeSQLBatch bit,
									@IncludeIncompletedQueries bit,
									@IncludeTimeOverlappedQueries bit,
									@StartTimestamp datetime,
									@EndTimestamp datetime,
									@SQLSignatureIDFilter int,
									@StatementTypeIDFilter int ';

	if @ViewID = 1            -- Duration (ms)
		select @Query = '  select
								QMS.LoginNameID as GroupByID,
								LN.LoginName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								QMS.DurationMilliseconds as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								LoginNames as LN
								on QMS.LoginNameID = LN.LoginNameID ';				   
	else if @ViewID = 2        -- CPU Time (ms)
		select @Query = '  select
								QMS.LoginNameID as GroupByID,
								LN.LoginName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								QMS.CPUMilliseconds as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								LoginNames as LN
								on QMS.LoginNameID = LN.LoginNameID ';				   
	else if @ViewID = 3        -- Reads
		select @Query = '  select
								QMS.LoginNameID as GroupByID,
								LN.LoginName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								QMS.Reads as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								LoginNames as LN
								on QMS.LoginNameID = LN.LoginNameID ';				   
	else if @ViewID = 4         -- Writes
		select @Query = '  select
								QMS.LoginNameID as GroupByID,
								LN.LoginName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								QMS.Writes as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								LoginNames as LN
								on QMS.LoginNameID = LN.LoginNameID ';				   
	else if @ViewID = 5        -- I/O
		select @Query = '  select
								QMS.LoginNameID as GroupByID,
								LN.LoginName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								(QMS.Reads + QMS.Writes) as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								LoginNames as LN
								on QMS.LoginNameID = LN.LoginNameID ';				   
	else if @ViewID = 6         -- Blocking Duration (ms)
		select @Query = '  select
								QMS.LoginNameID as GroupByID,
								LN.LoginName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								BDT.BlockingDuration as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								LoginNames as LN
								on QMS.LoginNameID = LN.LoginNameID 				   
								left join
								(
									select
										BSS.LoginNameID,
										BSS.BlockingDurationMilliseconds as BlockingDuration
									from
										BlockingSessionStatistics as BSS
									where
										BSS.SQLServerID = @SQLServerID
								) as BDT
								on QMS.LoginNameID = BDT.LoginNameID ';
	else if @ViewID = 7         -- Wait Duration (ms)
		select @Query = '  select
								QMS.LoginNameID as GroupByID,
								LN.LoginName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								WT.WaitDuration as YAxisValue,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								LoginNames as LN
								on QMS.LoginNameID = LN.LoginNameID 			   
								left join
								(
									select
										AWS.LoginNameID,
										AWS.WaitDuration
									from
										ActiveWaitStatistics as AWS
									where
										AWS.SQLServerID = @SQLServerID
								) as WT
								on QMS.LoginNameID = WT.LoginNameID ';
	else if @ViewID = 8         -- Deadlocks
		select @Query = '  select
								QMS.LoginNameID as GroupByID,
								LN.LoginName as GroupByName,
								QMS.StatementUTCStartTime as StartTime,
								YAxisValue = case
												when DPT.Deadlocks is null then cast(0 as bigint)
												else cast(1 as bigint) 
											 end,
								SST.StatementSQLText
						   from
								QueryMonitorStatistics as QMS
								left join
								LoginNames as LN
								on QMS.LoginNameID = LN.LoginNameID  
								left join
								(
									select
										DP.LoginNameID,
										DP.DeadlockID as Deadlocks
									from
										DeadlockProcesses as DP
									where
										DP.SQLServerID = @SQLServerID
								) as DPT
								on QMS.LoginNameID = DPT.LoginNameID ';

	select @Query = @Query + ' left join
							   (
									select
										SS.SQLStatementID,
										(isnull(SS.SQLStatement,'''') + isnull(SSO.SQLStatementOverflow,'''')) as StatementSQLText
									from	
										SQLStatements as SS
										left join
										SQLStatementsOverflow as SSO
										on SS.SQLStatementID = SSO.SQLStatementID
								) as SST
								on QMS.SQLStatementID = SST.SQLStatementID
							where
								QMS.SQLServerID = @SQLServerID ';

	if @ApplicationFilter is not null
		select @Query = @Query + ' and QMS.ApplicationNameID in (' + @ApplicationFilter + ') ';

	if @DatabaseFilter is not null
		select @Query = @Query + ' and QMS.DatabaseID in (' + @DatabaseFilter + ') ';

	if @UserFilter is not null
		select @Query = @Query + ' and QMS.LoginNameID in (' + @UserFilter + ') ';

	if @ClientFilter is not null
		select @Query = @Query + ' and QMS.HostNameID in (' + @ClientFilter + ') ';

	if @SQLExclude is not null           -- exclude filter given priority, skip include filter if exclude is not null
		select @Query = @Query + ' and (LOWER(SST.StatementSQLText) not like ''' + LOWER(@SQLExclude) + ''' ) ';
	else if @SQLInclude is not null
		select @Query = @Query + ' and (LOWER(SST.StatementSQLText) like ''' + LOWER(@SQLInclude) + ''' ) ';

	if @IncludeSQLStatements = 0                           -- SQL Statement 
		select @Query = @Query + ' and (QMS.StatementType != 1) ';
	
	if @IncludeSQLProcedure = 0                             -- SQL Procedure   
		select @Query = @Query + ' and (QMS.StatementType != 0) ';
		
	if @IncludeSQLBatch = 0                                  -- SQL Batch
		select @Query = @Query + ' and (QMS.StatementType != 2) ';
		
	if @IncludeIncompletedQueries = 0                        -- Include Completed Queries
		select @Query = @Query + ' and (QMS.CompletionTime is not null) ';
		
	if @IncludeTimeOverlappedQueries = 1 and @StartTimestamp is not null and @EndTimestamp is not null      -- Including overlapped queries
		select @Query = @Query + ' and (not ((QMS.StatementUTCStartTime > @EndTimestamp) or (QMS.CompletionTime < @StartTimestamp)))';
	else if @IncludeTimeOverlappedQueries = 0 and @StartTimestamp is not null and @EndTimestamp is not null
		select @Query = @Query + ' and (QMS.StatementUTCStartTime >= @StartTimestamp) and (QMS.StatementUTCStartTime <=  @EndTimestamp)';

	if @SQLSignatureIDFilter <> 0
		select @Query = @Query + ' and QMS.SQLSignatureID = @SQLSignatureIDFilter ';

	if @StatementTypeIDFilter <> -1
		select @Query = @Query + ' and QMS.StatementType = @StatementTypeIDFilter ';

	execute sp_executesql @Query, 
                          @ParameterDefinition, 
						  @SQLServerID, 
						  @ViewID,
						  @ApplicationFilter,
						  @DatabaseFilter,
						  @UserFilter,
						  @ClientFilter,
						  @SQLExclude,
						  @SQLInclude,
						  @IncludeSQLStatements,
						  @IncludeSQLProcedure,
						  @IncludeSQLBatch,
						  @IncludeIncompletedQueries,
						  @IncludeTimeOverlappedQueries,
						  @StartTimestamp,
						  @EndTimestamp,
						  @SQLSignatureIDFilter,
						  @StatementTypeIDFilter

end
go
 
GO 

---------- P_GETGROOMING.SQL
if (object_id('p_GetGrooming') is not null)
begin
drop procedure p_GetGrooming
end
go
CREATE PROCEDURE [dbo].[p_GetGrooming](
	@ActivityOut int output,
	@AlertsOut int output,
	@MetricsOut int output,
	@TasksOut int output,
	@StartTime int output,
	@SubDayType int output,
	@AllowScheduleChange bit output,
	@AgentIsRunning bit output,
	@JobIsRunning bit output,
	@RepositoryTime DateTime output,
	@GroomingTimeLimit int output,
	@LastRunDate int output,
	@LastRunTime int output,
	@LastRunOutcome int output,
	@QueriesOut int output,
	@AggregationStartTime int output,
	@AggregationSubDayType int output,
	@AggregationAllowScheduleChange bit output,
	@AggregationJobIsRunning bit output,
	@AggregationLastRunDate int output,
	@AggregationLastRunTime int output,
	@AggregationLastRunOutcome int output,
	@AuditOut int output,
	@PADaysOut int output
)
AS
BEGIN
	-- Initialize the output parms with default values.
	set @ActivityOut = 31
	set @AlertsOut = 31
	set @AuditOut = 90
	set @MetricsOut = 365 
	set @TasksOut = 7
	set @JobIsRunning = 0
	set @RepositoryTime = getdate()
	set @GroomingTimeLimit = 180
	set @QueriesOut = 14
	--10.0 SQLdm srishti purohit
    --Prescriptive analysis old data grooming implementation
	set @PADaysOut = 90

	SELECT @ActivityOut = Internal_Value FROM RepositoryInfo WHERE [Name] = 'GroomActivity'
	SELECT @AlertsOut = Internal_Value FROM RepositoryInfo WHERE [Name] = 'GroomAlerts'
	SELECT @AuditOut = Internal_Value FROM RepositoryInfo WHERE [Name] = 'GroomAudit'
	SELECT @MetricsOut = Internal_Value FROM RepositoryInfo WHERE [Name] = 'GroomMetrics'
	SELECT @TasksOut = Internal_Value FROM RepositoryInfo WHERE [Name] = 'GroomTasks'
	SELECT @GroomingTimeLimit = Internal_Value from RepositoryInfo where [Name] = 'GroomingMaxNumberMinutes'	
	SELECT @QueriesOut = Internal_Value from RepositoryInfo where [Name] = 'GroomQueryAggregation'	
	SELECT @PADaysOut = Internal_Value FROM RepositoryInfo WHERE [Name] = 'GroomPrescriptiveAnalysis'

	if (@GroomingTimeLimit is null or @GroomingTimeLimit < 1)
		set @GroomingTimeLimit = 180

	exec p_GetSqlAgentRunning @AgentIsRunning output 
	
	-- Get the job schedule from the appropriate system table.
	DECLARE @jobName nvarchar(256)
	DECLARE @job_id  UNIQUEIDENTIFIER
	DECLARE @enabled int
	DECLARE @freq_type int
	DECLARE @freq_interval int
	DECLARE @freq_subday_type int
	DECLARE @freq_subday_interval int
	DECLARE @start_time int
	DECLARE @end_time int
	DECLARE @start_date int
	DECLARE @end_date int

	DECLARE @last_run_date int
	DECLARE @last_run_time int
	DECLARE @last_run_outcome int

---
	set @StartTime = 030000 -- hhmmss
	set @SubDayType = 1 -- once daily
	set @AllowScheduleChange = 0
	set @jobName = 'Groom ' + DB_NAME()
	set @job_id = null
	

	CREATE TABLE #temp_job_schedule2000 
	(
		schedule_id int,
		schedule_name nvarchar(256),
		[enabled] int,
		freq_type int,
		freq_interval int,
		freq_subday_type int,
		freq_subday_interval int,
		freq_relative_interval int,
		freq_recurrence_factor int,
		active_start_date int,
		active_end_date int,
		active_start_time int,
		active_end_time int,
		date_created DateTime,
		schedule_description nvarchar(256),
		next_run_date int,
		next_run_time int
	)

	CREATE TABLE #temp_job_schedule2005 
	(
		schedule_id int,
		schedule_name nvarchar(256),
		[enabled] int,
		freq_type int,
		freq_interval int,
		freq_subday_type int,
		freq_subday_interval int,
		freq_relative_interval int,
		freq_recurrence_factor int,
		active_start_date int,
		active_end_date int,
		active_start_time int,
		active_end_time int,
		date_created DateTime,
		schedule_description nvarchar(256),
		next_run_date int,
		next_run_time int,
		schedule_uid uniqueidentifier,
		job_count int	
	)

	create table #temp_get_grooming_xp_results  (
		job_id                UNIQUEIDENTIFIER NOT NULL,
		last_run_date         INT              NOT NULL,
		last_run_time         INT              NOT NULL,
		next_run_date         INT              NOT NULL,
		next_run_time         INT              NOT NULL,
		next_run_schedule_id  INT              NOT NULL,
		requested_to_run      INT              NOT NULL, -- BOOL
		request_source        INT              NOT NULL,
		request_source_id     sysname          COLLATE database_default NULL,
		running               INT              NOT NULL, -- BOOL
		current_step          INT              NOT NULL,
		current_retry_attempt INT              NOT NULL,
		job_state             INT              NOT NULL)

	SELECT @job_id = job_id FROM msdb.dbo.sysjobs WHERE [name] = @jobName
	IF @job_id IS NOT NULL
	BEGIN
		if (object_id('msdb.dbo.sysschedules') is null)
		BEGIN
			INSERT #temp_job_schedule2000 
			   exec msdb.dbo.sp_help_jobschedule @job_name = @jobName			
			SELECT 
				 @enabled = [enabled],
			     @freq_type = freq_type,
				 @freq_interval = freq_interval,
				 @freq_subday_type = freq_subday_type,
				 @freq_subday_interval = freq_subday_interval,
				 @start_time = active_start_time,
				 @end_time = active_end_time,
				 @start_date = active_start_date,
				 @end_date = active_end_date
				 FROM #temp_job_schedule2000
		END
		ELSE
		BEGIN
			Select @enabled = S.[enabled],
				@freq_type = S.freq_type,
				@freq_interval = S.freq_interval,
				@freq_subday_type = S.freq_subday_type,
				@freq_subday_interval = S.freq_subday_interval,
				@start_time = S.active_start_time,
				@end_time = S.active_end_time,
				@start_date = S.active_start_date,
				@end_date = S.active_end_date
			From msdb.dbo.sysjobschedules JS
			Inner Join msdb.dbo.sysjobs J On J.job_id = JS.job_id
			Inner Join msdb.dbo.sysschedules S On S.schedule_id = JS.schedule_id
			Where J.name = @jobName;
		END

		set @SubDayType = @freq_subday_type
		-- schedule change allowed in ui if job frequency is daily and job interval is unused.  also required is that if
		-- job is not once daily it must be hourly and start at midnight and end by 11:59:59.
		if (@freq_type = 4 and @freq_interval = 1) 
		begin
			if (@freq_subday_type = 1)
			begin
				set @StartTime  = @start_time
				set @AllowScheduleChange = 1
			end
			else
			begin
				set @StartTime  = @freq_subday_interval
				if (@freq_subday_type = 8 and @start_time = 0 and @end_time = 235959)
					set @AllowScheduleChange = 1
			end	
			-- if start/end date is set recognize as changed outside of DM.
			if (@start_date <> 20070511 or @end_date <> 99991231)
				set @AllowScheduleChange = 0
			else if (@enabled = 0) -- job schedule is disabled
				set @AllowScheduleChange = 0	
		end
		else
			set @StartTime = @start_time
			
		if @AgentIsRunning = 1
		BEGIN
			-- Since the agent is running, the job might be running.
			-- Call a system stored proc to find out.
			-- Can't use a table variable with "insert into exec" in 2000,
			-- so use a temp table.
			
			insert #temp_get_grooming_xp_results exec master.dbo.xp_sqlagent_enum_jobs @is_sysadmin = 1, @job_owner = ''
			if EXISTS (SELECT 1 from #temp_get_grooming_xp_results where job_id = @job_id AND (running = 1 OR requested_to_run = 1))
				SELECT @JobIsRunning = 1
		END
	END

	IF (EXISTS (SELECT * FROM msdb.dbo.systargetservers))
	BEGIN
		SELECT	@last_run_date = sjs.last_run_date,
				@last_run_time = sjs.last_run_time,
				@last_run_outcome = sjs.last_run_outcome
		FROM  msdb.dbo.sysjobservers sjs
		WHERE (CONVERT(FLOAT, sjs.last_run_date) * 1000000) + sjs.last_run_time =
				(SELECT MAX((CONVERT(FLOAT, last_run_date) * 1000000) + last_run_time)
					FROM msdb.dbo.sysjobservers
					WHERE (job_id = sjs.job_id)) 
				AND (sjs.job_id = @job_id)
	END
	ELSE
	BEGIN
		SELECT	@last_run_date = sjs.last_run_date,
				@last_run_time = sjs.last_run_time,
				@last_run_outcome = sjs.last_run_outcome
		FROM msdb.dbo.sysjobservers sjs
		WHERE (sjs.job_id = @job_id)
	END

	set @LastRunDate	= @last_run_date
	set @LastRunTime	= @last_run_time
	set @LastRunOutcome = @last_run_outcome

---
	set @AggregationStartTime = 020000 -- hhmmss
	set @AggregationSubDayType = 1 -- once daily
	set @AggregationAllowScheduleChange = 0
	set @jobName = 'Aggregate Data ' + DB_NAME()
	set @job_id = null

	truncate table #temp_job_schedule2000
	truncate table #temp_job_schedule2005
	truncate table #temp_get_grooming_xp_results

	
	SELECT @job_id = job_id FROM msdb.dbo.sysjobs WHERE [name] = @jobName
	IF @job_id IS NOT NULL
	BEGIN
		if (object_id('msdb.dbo.sysschedules') is null)
		BEGIN
			
			INSERT #temp_job_schedule2000 
			   exec msdb.dbo.sp_help_jobschedule @job_name = @jobName			
			SELECT 
				 @enabled = [enabled],
			     @freq_type = freq_type,
				 @freq_interval = freq_interval,
				 @freq_subday_type = freq_subday_type,
				 @freq_subday_interval = freq_subday_interval,
				 @start_time = active_start_time,
				 @end_time = active_end_time,
				 @start_date = active_start_date,
				 @end_date = active_end_date
				 FROM #temp_job_schedule2000
		END
		ELSE
		BEGIN
			Select @enabled = S.[enabled],
				@freq_type = S.freq_type,
				@freq_interval = S.freq_interval,
				@freq_subday_type = S.freq_subday_type,
				@freq_subday_interval = S.freq_subday_interval,
				@start_time = S.active_start_time,
				@end_time = S.active_end_time,
				@start_date = S.active_start_date,
				@end_date = S.active_end_date
			From msdb.dbo.sysjobschedules JS
			Inner Join msdb.dbo.sysjobs J On J.job_id = JS.job_id
			Inner Join msdb.dbo.sysschedules S On S.schedule_id = JS.schedule_id
			Where J.name = @jobName;
		END

		set @AggregationSubDayType = @freq_subday_type
		-- schedule change allowed in ui if job frequency is daily and job interval is unused.  also required is that if
		-- job is not once daily it must be hourly and start at midnight and end by 11:59:59.
		if (@freq_type = 4 and @freq_interval = 1) 
		begin
			if (@freq_subday_type = 1)
			begin
				set @AggregationStartTime  = @start_time
				set @AggregationAllowScheduleChange = 1
			end
			else
			begin
				set @AggregationStartTime  = @freq_subday_interval
				if (@freq_subday_type = 8 and @start_time = 0 and @end_time = 235959)
					set @AggregationAllowScheduleChange = 1
			end	
			-- if start/end date is set recognize as changed outside of DM.
			if (@start_date <> 20070511 or @end_date <> 99991231)
				set @AggregationAllowScheduleChange = 0
			else if (@enabled = 0) -- job schedule is disabled
				set @AggregationAllowScheduleChange = 0	
		end
		else
			set @AggregationStartTime = @start_time
			
		if @AgentIsRunning = 1
		BEGIN
			-- Since the agent is running, the job might be running.
			-- Call a system stored proc to find out.
			-- Can't use a table variable with "insert into exec" in 2000,
			-- so use a temp table.

			insert #temp_get_grooming_xp_results exec master.dbo.xp_sqlagent_enum_jobs @is_sysadmin = 1, @job_owner = ''
			if EXISTS (SELECT * from #temp_get_grooming_xp_results where job_id = @job_id AND (running = 1 OR requested_to_run = 1))
				SELECT @AggregationJobIsRunning = 1
		END
	END

	IF (EXISTS (SELECT * FROM msdb.dbo.systargetservers))
	BEGIN
		SELECT	@last_run_date = sjs.last_run_date,
				@last_run_time = sjs.last_run_time,
				@last_run_outcome = sjs.last_run_outcome
		FROM  msdb.dbo.sysjobservers sjs
		WHERE (CONVERT(FLOAT, sjs.last_run_date) * 1000000) + sjs.last_run_time =
				(SELECT MAX((CONVERT(FLOAT, last_run_date) * 1000000) + last_run_time)
					FROM msdb.dbo.sysjobservers
					WHERE (job_id = sjs.job_id)) 
				AND (sjs.job_id = @job_id)
	END
	ELSE
	BEGIN
		SELECT	@last_run_date = sjs.last_run_date,
				@last_run_time = sjs.last_run_time,
				@last_run_outcome = sjs.last_run_outcome
		FROM msdb.dbo.sysjobservers sjs
		WHERE (sjs.job_id = @job_id)
	END

	set @AggregationLastRunDate	= @last_run_date
	set @AggregationLastRunTime	= @last_run_time
	set @AggregationLastRunOutcome = @last_run_outcome
END

 
GO 

---------- P_GETGROOMINGSTATUSINFO.SQL

--SQLdm 9.0 --(Ankit Srivastava) --New procedure to get if grooming have been timed out
--EXEC [p_GetGroomingStatusInfo] 37
IF (object_id('p_GetGroomingStatusInfo') IS NOT NULL)
BEGIN
DROP PROCEDURE p_GetGroomingStatusInfo
END
GO

CREATE PROCEDURE [dbo].[p_GetGroomingStatusInfo]
(
	@SQLServerID INT
)
AS 
BEGIN

	DECLARE @Run_Id uniqueidentifier
	 
	IF (EXISTS(Select * FROM [LatestGroomingStatus] where ([SQLServerID]= @SQLServerID OR [SQLServerID] IS NULL) AND [Status]=0 AND [IsPrimary]=1 AND [LastStatusMessage] like '%Timeout%' )) 
	BEGIN
		SELECT @Run_Id=[GroomingRunID] FROM [LatestGroomingStatus] where [SQLServerID]= @SQLServerID AND [Status]=0 AND [LastStatusMessage] like '%Timeout%'
		
		SELECT Convert(bit,1) -- it timed out
		
		SELECT MSS.[InstanceName]
		FROM [LatestGroomingStatus] LGS
		RIGHT JOIN [MonitoredSQLServers] MSS ON LGS.SQLServerID=MSS.SQLServerID
		where [GroomingRunID]=@Run_Id AND [IsPrimary]=0
	END	
END
 
GO 

---------- P_GETHOURSLIST.SQL
if (object_id('p_GetHoursList') is not null)
begin
drop procedure [p_GetHoursList]
end

GO
CREATE PROCEDURE [p_GetHoursList]	
AS
BEGIN
	if (OBJECT_ID('#tempHoursTable') IS NOT NULL)
	begin
		drop table #tempHoursTable
	end
	
	CREATE TABLE #tempHoursTable (
		hoursKey int NOT NULL PRIMARY KEY,
		hoursValue VARCHAR(5) NOT NULL 
	);

	DECLARE @intFlag INT
	DECLARE @twoDigitsHour VARCHAR(2)

	SET @intFlag = 0
	SET @twoDigitsHour = '00'

	WHILE (@intFlag < 24)
	BEGIN

		IF(@intFlag < 10)
		BEGIN
			SET @twoDigitsHour = '0' + CAST(@intFlag AS varchar(1))
		END
		ELSE
		BEGIN
			SET @twoDigitsHour = CAST(@intFlag AS varchar(2))
		END

		INSERT INTO #tempHoursTable(hoursKey, hoursValue)
		SELECT @twoDigitsHour, @twoDigitsHour + ':00'

		SET @intFlag = @intFlag + 1
	END

	select * from #tempHoursTable	

	drop table #tempHoursTable
END
 
GO 

---------- P_GETINSTANCEAVAILBILITYGROUPDETAILS.SQL

IF (OBJECT_ID('p_GetInstanceAvailbilityGroupDetails') IS NOT NULL)
BEGIN
  DROP PROC [p_GetInstanceAvailbilityGroupDetails]
END
GO
CREATE PROCEDURE [dbo].[p_GetInstanceAvailbilityGroupDetails]
@SQLServerId int,
@HistoryInMinutes int = null
AS
BEGIN

declare @BeginDateTime datetime
declare @EndDateTime datetime

select @EndDateTime = (select max([UTCCollectionDateTime]) from [AlwaysOnStatistics] (NOLOCK) where [SQLServerID] = @SQLServerId)

if (@HistoryInMinutes is null)
	select @BeginDateTime = @EndDateTime;
else
	select @BeginDateTime = dateadd(n, -@HistoryInMinutes, @EndDateTime);

WITH AVGs (GroupId, GroupName) AS 
(SELECT DISTINCT aog.GroupId, aog.GroupName
	FROM AlwaysOnAvailabilityGroups aog WITH(NOLOCK)
	INNER JOIN AlwaysOnReplicas aor  WITH(NOLOCK) ON aor.GroupId = aog.GroupId
	WHERE aor.SQLServerID = @SQLServerId AND aor.Active = 1 AND aor.[Delete] = 0 AND aog.Active = 1 AND aog.[Delete] = 0)

SELECT		DISTINCT 			
			AOG.GroupName
			,aor.ReplicaName
			,aor.ReplicaRole
			,AOS.SynchronizationHealth
			,isnull(AOS.DatabaseState,0) AS [DatabaseState]
			,sum(AOS.[RedoRate] * TimeDeltaInSeconds) / nullif(sum(case when AOS.[RedoRate] is not null then TimeDeltaInSeconds else 0 end),0) as [RedoRate]
			,sum(AOS.[RedoQueueSize] * TimeDeltaInSeconds)/nullif(sum(case when AOS.[RedoQueueSize]is not null then TimeDeltaInSeconds else 0 end),0) AS [RedoQueue]
			,sum(AOS.[LogSendRate] * TimeDeltaInSeconds) / nullif(sum(case when AOS.[LogSendRate] is not null then TimeDeltaInSeconds else 0 end),0) as [LogSendRate]
			,sum(AOS.[LogSedQueueSize] * TimeDeltaInSeconds) / nullif(sum(case when AOS.[LogSedQueueSize] is not null then TimeDeltaInSeconds else 0 end),0) as [LogSendQueue]
			,AOS.UTCCollectionDateTime
		FROM 
			AlwaysOnReplicas aor 			
			INNER JOIN AVGs AS AOG (NOLOCK)
			ON AOG.GroupId = aor.GroupId
			LEFT OUTER JOIN [AlwaysOnStatistics] AS AOS (NOLOCK) 
				on AOS.GroupId = AOG.GroupId AND AOS.ReplicaId = aor.ReplicaId
		WHERE (AOS.UTCCollectionDateTime IS NULL  OR AOS.UTCCollectionDateTime between @BeginDateTime and @EndDateTime)
		GROUP BY
			AOG.GroupName
			,aor.ReplicaId 
			,aor.ReplicaName
			,aor.ReplicaRole
			,AOS.SynchronizationHealth
			,AOS.DatabaseState	
			,AOS.UTCCollectionDateTime
			ORDER BY AOS.UTCCollectionDateTime DESC
END
 
GO 

---------- P_GETINSTANCEQUERYSTATS.SQL

if (object_id('p_GetInstanceQueryStats') is not null)
begin
drop procedure [p_GetInstanceQueryStats]
end
go

CREATE procedure [dbo].[p_GetInstanceQueryStats]
	@SQLServerID int,
	@NumHistoryMinutes int = 30,
	@ListRowcount int = 200,
	@StartDateTime DateTime = NULL,
	@EndDateTime DateTime = NULL
as
begin


if(@EndDateTime is null)
begin
	SET @EndDateTime = (SELECT MAX(CompletionTime) FROM QueryMonitorStatistics WHERE SQLServerID = @SQLServerID);
end
if(@StartDateTime is null)
begin
	SET @StartDateTime = (SELECT DATEADD(minute, -1*@NumHistoryMinutes, @EndDateTime));
end

declare  @QueryStatementAggregationStep1 table
	(
		SQLServerID int,
		EventUTCStartTime datetime,	
		QueryMonitorOccurrences dec(38,0),
		--WaitOcurrences dec(38,0),
		--BlockingOcurrences dec(38,0),
		--DeadlockOcurrences dec(38,0),
		TotalDurationMilliseconds dec(38,0),
		TotalCPUMilliseconds dec(38,0),
		TotalReads dec(38,0),
		TotalWrites dec(38,0),
		StatementType int,
		--TotalBlockingDurationMilliseconds dec(38,0),
		--TotalWaitDuration dec(38,0),
		ApplicationNameID bigint,
		DatabaseID bigint,
		HostNameID bigint,
		LoginNameID bigint,
		SQLTextID  bigint,
		SQLSignatureID bigint,
		MaxCPUMilliseconds dec(38,0),
		MaxReads dec(38,0),
		MaxWrites dec(38,0),
		Spid int
	)
	

Declare @QueryStatementAggregationStep2 table
	(
		SQLServerID int,
		EventUTCStartTime datetime,	
		QueryMonitorOccurrences dec(38,0),
		--WaitOcurrences dec(38,0),
		--BlockingOcurrences dec(38,0),
		--DeadlockOcurrences dec(38,0),
		TotalDurationMilliseconds dec(38,0),
		TotalCPUMilliseconds dec(38,0),
		TotalReads dec(38,0),
		TotalWrites dec(38,0),
		StatementType int,
		--TotalBlockingDurationMilliseconds dec(38,0),
		--TotalWaitDuration dec(38,0),
		ApplicationName nvarchar(256),
		DatabaseName nvarchar(255),
		HostName nvarchar(255),
		LoginName nvarchar(255),
		SQLTextID  bigint,
		SQLSignatureID bigint,
		AggregationFlag tinyint,
		MaxCPUMilliseconds dec(38,0),
		MaxReads dec(38,0),
		MaxWrites dec(38,0),
		Spid int
	)
	
--create clustered index IX_QueryStatementAggregationStep2 on @QueryStatementAggregationStep2(SQLTextID) -- can't create lustered ndex on table variable

	insert into @QueryStatementAggregationStep1
	(
		SQLServerID,
		EventUTCStartTime,	
		QueryMonitorOccurrences,
		TotalDurationMilliseconds,
		TotalCPUMilliseconds,
		TotalReads,
		TotalWrites,
		ApplicationNameID,
		DatabaseID,
		HostNameID,
		LoginNameID,
		StatementType,
		SQLTextID,
		SQLSignatureID,
		MaxCPUMilliseconds,
		MaxReads,
		MaxWrites,
		Spid
	)

	-- Query Monitor
	select
		SQLServerID,
		EventUTCStartTime = dateadd(ms,datepart(ms,StatementUTCStartTime)*-1,StatementUTCStartTime),	
		QueryMonitorOccurrences = count(SQLServerID),
		TotalDurationMilliseconds = sum(cast(DurationMilliseconds as dec(38,0))),
		TotalCPUMilliseconds = sum(cast(CPUMilliseconds as dec(38,0))),
		TotalReads = sum(cast(Reads as dec(38,0))),
		TotalWrites = sum(cast(Writes as dec(38,0))),
		ApplicationNameID,
		DatabaseID,
		HostNameID ,
		LoginNameID,
		StatementType,
		SQLTextID =SQLStatementID,
		SQLSignatureID,
		MaxCPUMilliseconds = max(cast(CPUMilliseconds as dec(38,0))),
		MaxReads = max(cast(Reads as dec(38,0))),
		MaxWrites = max(cast(Writes as dec(38,0))),
		Spid =qm.SessionID 
	from 
		QueryMonitorStatistics qm (NOLOCK)
	where
		SQLServerID = @SQLServerID
		and 
		(		
			((StatementUTCStartTime between @StartDateTime and @EndDateTime) or (CompletionTime between @StartDateTime and @EndDateTime))
			
		)
	group by
		SQLServerID,
		dateadd(ms,datepart(ms,StatementUTCStartTime)*-1,StatementUTCStartTime),
		ApplicationNameID,
		DatabaseID,
		StatementType,
		SQLStatementID,
		SQLSignatureID,
		HostNameID,
		LoginNameID,
		qm.SessionID

	insert into 
	@QueryStatementAggregationStep2
	(
		SQLServerID,
		EventUTCStartTime,	
		QueryMonitorOccurrences,
		--WaitOcurrences,
		--BlockingOcurrences,
		--DeadlockOcurrences,
		TotalDurationMilliseconds,
		TotalCPUMilliseconds,
		TotalReads,
		TotalWrites,
		StatementType,
		--TotalBlockingDurationMilliseconds,
		--TotalWaitDuration,
		ApplicationName,
		DatabaseName,
		HostName,
		LoginName,
		SQLTextID,
		SQLSignatureID,
		AggregationFlag,
		MaxCPUMilliseconds,
		MaxReads,
		MaxWrites,
		Spid
	)
	select
		qs1.SQLServerID,
		qs1.EventUTCStartTime,	
		max(qs1.QueryMonitorOccurrences),
		--max(qs1.WaitOcurrences),
		--max(qs1.BlockingOcurrences),
		--max(qs1.DeadlockOcurrences),
		max(qs1.TotalDurationMilliseconds),
		max(qs1.TotalCPUMilliseconds),
		max(qs1.TotalReads),
		max(qs1.TotalWrites),
		max(qs1.StatementType),
		--max(qs1.TotalBlockingDurationMilliseconds),
		--max(qs1.TotalWaitDuration),
		ApplicationName,
		DatabaseName,
		HostName,
		LoginName,
		qs1.SQLTextID,
		qs1.SQLSignatureID,
		0,		
		max(MaxCPUMilliseconds),
		max(MaxReads),
		max(MaxWrites),
		Spid
	from @QueryStatementAggregationStep1 qs1
		inner join SQLServerDatabaseNames dn (NOLOCK)
		on qs1.DatabaseID = dn.DatabaseID
		inner join ApplicationNames an (NOLOCK)
		on qs1.ApplicationNameID = an.ApplicationNameID
		inner join LoginNames ln (NOLOCK)
		on qs1.LoginNameID = ln.LoginNameID
		inner join HostNames hn (NOLOCK)
		on qs1.HostNameID = hn.HostNameID
		--inner join AllSQLStatements s
		--on qs1.SQLTextID = s.SQLStatementID
	group by
		qs1.SQLServerID,
		qs1.EventUTCStartTime,	
		ApplicationName,
		DatabaseName,
		HostName,
		LoginName,
		qs1.SQLTextID,
		qs1.SQLSignatureID,
		Spid

    insert into 
	@QueryStatementAggregationStep2
	(
		SQLServerID,
		EventUTCStartTime,	
		QueryMonitorOccurrences,
		--WaitOcurrences,
		--BlockingOcurrences,
		--DeadlockOcurrences,
		TotalDurationMilliseconds,
		TotalCPUMilliseconds,
		TotalReads,
		TotalWrites,
		StatementType,
		--TotalBlockingDurationMilliseconds,
		--TotalWaitDuration,
		ApplicationName,
		DatabaseName,
		SQLTextID,
		SQLSignatureID,
		AggregationFlag,
		MaxCPUMilliseconds,
		MaxReads,
		MaxWrites
	)
	select
		q.SQLServerID,
		EventUTCStartTime,
		QueryMonitorOccurrences,
		--WaitOcurrences,
		--BlockingOcurrences,
		--DeadlockOcurrences,
		TotalDurationMilliseconds,
		TotalCPUMilliseconds,
		TotalReads,
		TotalWrites,
		StatementType,
		--TotalBlockingDurationMilliseconds,
		--TotalWaitDuration,
		ApplicationName,
		DatabaseName,
		q.SQLSignatureID,
		q.SQLSignatureID,
		1,		
		MaxCPUMilliseconds,
		MaxReads,
		MaxWrites
	from
		QuerySignatureAggregation q (NOLOCK)
		inner join SQLServerDatabaseNames dn (NOLOCK)
		on q.DatabaseID = dn.DatabaseID
		inner join ApplicationNames an (NOLOCK)
		on q.ApplicationNameID = an.ApplicationNameID
		inner join AllSQLSignatures s (NOLOCK)
		on q.SQLSignatureID = s.SQLSignatureID
	where
		q.SQLServerID = @SQLServerID

	declare @NewLine char(1), @NewLine2 char(1)

	set @NewLine = char(13)
	set @NewLine2 = char(10)
	set rowcount @ListRowcount

	select --top @ListRowcount
		DatabaseName,
		StatementUTCStartTime = EventUTCStartTime,
		--UTCCompletionTime = dateadd(ms,TotalDurationMilliseconds,EventUTCStartTime),
		AvgDurationMilliseconds = TotalDurationMilliseconds / nullif(QueryMonitorOccurrences,0),
		AvgCpu = TotalCPUMilliseconds / nullif(QueryMonitorOccurrences,0),
		TotalCPu=TotalCPUMilliseconds,
		AvgReads = TotalReads / nullif(QueryMonitorOccurrences,0),
		TotalReads,
		AvgWrites = TotalWrites / nullif(QueryMonitorOccurrences,0),
		TotalWrites,
		--WaitMilliseconds = TotalWaitDuration / nullif(WaitOcurrences,0),
		LoginName,-- = LoginName,
		ApplicationName = rtrim(ApplicationName),
		Case StatementType when 0 then 'StoredProcedure' when 1 then 'SingleStatement' when 2 then 'Batch' else 'none' end as StatementType,
		--BlockingTimeMilliseconds = TotalBlockingDurationMilliseconds / nullif(BlockingOcurrences,0),
		--Deadlocks = DeadlockOcurrences,
		sig.SQLSignature,
		sig.SQLSignatureID,
		SQLStatementText = left(replace(replace(s.SQLStatement,@NewLine,' '),@NewLine2,' '),255),
		HostName,-- = hn.HostName,
		AvgCPUPerSecond = cast(cast(TotalCPUMilliseconds as dec(15,0)) / nullif(TotalDurationMilliseconds,0) as dec (15,2)),
		--IOPerSecond = cast(cast(TotalReads + TotalWrites as dec(15,0)) / nullif(TotalDurationMilliseconds,0) as dec (15,2)),
		--Occurrences = coalesce(QueryMonitorOccurrences,WaitOcurrences,BlockingOcurrences,DeadlockOcurrences),
		Occurrence = QueryMonitorOccurrences,
		--AggregationFlag,
		SQLTextID = q.SQLTextID,
		--DoNotAggregate = isnull(sig.DoNotAggregate,0),
		Spid
	from
		@QueryStatementAggregationStep2	q
		inner join AllSQLStatements s (NOLOCK)
		on q.SQLTextID = s.SQLStatementID
		inner join AllSQLSignatures sig (NOLOCK)
		on q.SQLSignatureID  = sig.SQLSignatureID
	order by
		cast(cast(TotalCPUMilliseconds as dec(15,0)) / nullif(TotalDurationMilliseconds,0) as dec (15,2)) desc,  -- CPU Per Second
		cast(cast(TotalReads + TotalWrites as dec(15,0)) / nullif(TotalDurationMilliseconds,0) as dec (15,2)) desc,  -- IO Per Second
		TotalDurationMilliseconds / nullif(QueryMonitorOccurrences,0) desc, -- Duration
		TotalReads / nullif(QueryMonitorOccurrences,0) desc, -- Reads
		TotalWrites / nullif(QueryMonitorOccurrences,0) desc  -- Writes
		--DeadlockOcurrences desc -- Deadlocks

end

 
 
GO 

---------- P_GETINSTANCERESOURCES.SQL

if (object_id('p_GetInstanceResources') is not null)
begin
	drop procedure [p_GetInstanceResources]
end
go

-- [p_GetInstanceResources] 1,null,null,null
CREATE PROCEDURE [dbo].[p_GetInstanceResources](
	@SQLServerID int,
	@UTCSnapshotCollectionDateTime datetime = null,
	@HistoryInMinutes int = null,
	@Count int = null
)
AS
begin

declare	@StartDate datetime 
select @StartDate= null
declare @EndDate datetime 
select @EndDate= null
declare @e int

if (@UTCSnapshotCollectionDateTime is null)
	select @EndDate = (select max(UTCCollectionDateTime) from [ServerStatistics] where [SQLServerID] = @SQLServerID)
else
	select @EndDate = @UTCSnapshotCollectionDateTime

if (@HistoryInMinutes is null)
	select @StartDate = @EndDate
else
	select @StartDate = dateadd(n, -@HistoryInMinutes, @EndDate)

if(@Count is not null AND @Count != 0)
	Set rowcount @Count

Select MS.SQLServerID,MS.InstanceName,SS.UTCCollectionDateTime
	, OS.ProcessorTimePercent as OSCpu
	,SS.CPUActivityPercentage as SSCpu
	,OS.PrivilegedTimePercent,OS.UserTimePercent,OS.ProcessorQueueLength
	,SS.SqlMemoryAllocatedInKilobytes
	,SS.SqlMemoryUsedInKilobytes
	,OS.OSTotalPhysicalMemoryInKilobytes - OS.OSAvailableMemoryInKilobytes AS TotalServerMemoryInKilobytes
	,SS.ProcedureCacheSizeInKilobytes,SS.ConnectionMemoryInKilobytes,SS.LockMemoryInKilobytes,SS.CommittedInKilobytes
	,SS.PageLifeExpectancy,SS.BufferCacheHitRatioPercentage,SS.ProcedureCacheHitRatioPercentage
	,DD.DiskReadsPerSecond,DD.DiskWritesPerSecond,DD.DiskTransfersPerSecond --SQLdm 9.1 (Sanjali Makkar) - Adding the parameter of Disk Transfers Per Second
	,DD.DriveName 
	,ROUND(isnull(SS.CheckpointWrites,0)/(case when SS.TimeDeltaInSeconds = 0 then NULL else SS.TimeDeltaInSeconds end) , 2) CheckpointWrites
	,ROUND(isnull(SS.LazyWriterWrites,0)/(case when SS.TimeDeltaInSeconds = 0 then NULL else SS.TimeDeltaInSeconds end), 2) LazyWriterWrites
	,ROUND(isnull(SS.ReadAheadPages,0)/(case when SS.TimeDeltaInSeconds = 0 then NULL else SS.TimeDeltaInSeconds end), 2) ReadAheadPages
	,ROUND(isnull(SS.PageReads,0)/(case when SS.TimeDeltaInSeconds = 0 then NULL else SS.TimeDeltaInSeconds end), 2) PageReads
	,ROUND(isnull(SS.PageWrites,0)/(case when SS.TimeDeltaInSeconds = 0 then NULL else SS.TimeDeltaInSeconds end), 2) PageWrites	
from [ServerStatistics] SS (NOLOCK)
	 join [MonitoredSQLServers] MS (NOLOCK)
	on SS.[SQLServerID] = MS.[SQLServerID]
	and MS.Active = 1
	and MS.SQLServerID = @SQLServerID
	and SS.UTCCollectionDateTime between ISNULL(@StartDate,SS.UTCCollectionDateTime) and ISNULL(@EndDate,SS.UTCCollectionDateTime)
	left join [OSStatistics] OS (NOLOCK)
	on SS.[SQLServerID] = OS.[SQLServerID]
	and SS.[UTCCollectionDateTime] = OS.[UTCCollectionDateTime]
	and MS.SQLServerID = OS.SQLServerID
	and MS.SQLServerID is not null
	left JOIN DiskDrives DD (NOLOCK)
	on DD.SQLServerID = SS.SQLServerID
	and DD.UTCCollectionDateTime = SS.UTCCollectionDateTime
	Order by SS.UTCCollectionDateTime DESC

SELECT @e = @@error

return @e

end
 

GO

 
GO 

---------- P_GETINSTANCESLIST.SQL
IF (OBJECT_ID('p_GetInstancesList') IS NOT NULL)
BEGIN
  DROP PROC [p_GetInstancesList]
END
GO
-- [p_GetInstancesList] 30
CREATE PROCEDURE [dbo].[p_GetInstancesList]
AS
BEGIN

	SELECT mss.InstanceName, mss.SQLServerID 
	FROM MonitoredSQLServers mss (NOLOCK)
	WHERE mss.Active = 1 AND mss.InstanceName IS NOT NULL

END
 
GO 

---------- P_GETINSTANCESMONITORINGCUSTOMCOUNTER.SQL
if (object_id('p_GetInstancesMonitoringCustomCounter') is not null)
begin
drop procedure p_GetInstancesMonitoringCustomCounter
end
go

create procedure [dbo].p_GetInstancesMonitoringCustomCounter(
	@Metric int
)
AS
begin
	declare @e int

	select [SQLServerID] from [CustomCounterMap] where [Metric] = @Metric

	set @e = @@ERROR

	return @e
end	
 
GO 

---------- P_GETINSTANCESTATUS.SQL
-- SQLdm 9.1 (Sanjali Makkar)

-- Gets the status of the instances in terms of active alerts and other parameters
-- EXEC p_GetInstanceStatus 

if (object_id('p_GetInstanceStatus') is not null)
begin
drop procedure p_GetInstanceStatus
end
go

CREATE PROCEDURE [dbo].[p_GetInstanceStatus]
@SqlIdList XML--,
--@SQLServerID INT = NULL
AS
BEGIN

--This procedure is designed in a way of returning multiple result sets. 

declare @ServerActivityByMaxCollectionTime TABLE (  
InstanceID int,   
UTCCollectionDateTime DateTime)  

--START SQLdm 9.1 (Sanjali Makkar): Gets Health Index coefficients for specific alerts   
INSERT INTO @ServerActivityByMaxCollectionTime  
SELECT mss.SQLServerID, MAX(sa.UTCCollectionDateTime) UTCCollectionDateTime 
FROM MonitoredSQLServers mss (NOLOCK)  
LEFT OUTER JOIN ServerActivity sa (NOLOCK) ON mss.SQLServerID = sa.SQLServerID  
WHERE mss.Active = 1 AND mss.SQLServerID IN (SELECT A.B.value('(ID)[1]', 'int' ) ID
		FROM    @SqlIdList.nodes('/Root/Source') A(B)) AND sa.StateOverview IS NOT NULL
GROUP BY mss.SQLServerID  

-- Get state overview data  
SELECT ISNULL(samax.InstanceID,0) InstanceID, sa.[StateOverview]  
from @ServerActivityByMaxCollectionTime samax 
	JOIN ServerActivity sa (NOLOCK) on samax.InstanceID = sa.SQLServerID and  sa.UTCCollectionDateTime = samax.UTCCollectionDateTime

--Instances Overview Result Set
SELECT COUNT(0) ServerCount, Active FROM MonitoredSQLServers (NOLOCK) WHERE Deleted = 0 
GROUP BY Active

END
 
GO 

---------- P_GETLATESTRESPONSETIMESBYINSTANCE.SQL
if (object_id('p_GetLatestResponseTimesByInstance') is not null)
begin
drop procedure p_GetLatestResponseTimesByInstance
end
go
CREATE PROCEDURE [dbo].[p_GetLatestResponseTimesByInstance]
AS
BEGIN

create table #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

insert into #SecureMonitoredSQLServers
exec [p_GetReportServers]


SELECT T.SQLServerID, T.ServerHostName, T.InstanceName, T.ResponseTimeInMilliseconds, T.UTCCollectionDateTime FROM
(SELECT ss.SQLServerID, ss.ServerHostName, mss.InstanceName,  ss.ResponseTimeInMilliseconds, ss.UTCCollectionDateTime,  
ROW_NUMBER()OVER(PARTITION BY ss.SQLServerID ORDER BY ss.UTCCollectionDateTime DESC) AS GroupRank
FROM ServerStatistics ss (NOLOCK)
INNER JOIN MonitoredSQLServers mss (NOLOCK) ON ss.SQLServerID = mss.SQLServerID
INNER JOIN #SecureMonitoredSQLServers smss (nolock) on mss.SQLServerID = smss.SQLServerID WHERE mss.Active = 1) T
WHERE T.GroupRank = 1
ORDER BY T.ResponseTimeInMilliseconds DESC;

END
 
GO 

---------- P_GETLICENSEKEYS.SQL
if (object_id('p_GetLicenseKeys') is not null)
begin
drop procedure p_GetLicenseKeys
end
go
CREATE PROCEDURE [dbo].[p_GetLicenseKeys](
	@LicenseID UNIQUEIDENTIFIER,
	@ReturnServerCount int output,
	@ReturnInstanceName nvarchar(128) output
)
AS
BEGIN
	DECLARE @e INT
	DECLARE @rmsc INT
	DECLARE @instanceName nvarchar(128)
	declare @listener nvarchar(1024)
	
	-- set return values to current number of registered servers and SQL instance
	SELECT @rmsc = COUNT([SQLServerID]) FROM MonitoredSQLServers (NOLOCK) WHERE Active = 1  
	select @instanceName = CONVERT(nvarchar(128), serverproperty('servername'))
	
	select @listener = rInfo.Character_Value 
	  from RepositoryInfo rInfo
	  where rInfo.Name = 'AGListener';
	
	IF (@LicenseID IS NULL) 
	BEGIN
		SELECT [LicenseID],[LicenseKey],[DateAddedUtc] FROM [LicenseKeys] (NOLOCK)
		ORDER BY [DateAddedUtc]
	END
	ELSE
	BEGIN
		SELECT [LicenseID],[LicenseKey],[DateAddedUtc] FROM [LicenseKeys] (NOLOCK)
				WHERE ([LicenseID] = @LicenseID)
		ORDER BY [DateAddedUtc]
	END

	SELECT @e = @@error
	IF (@e = 0)
	BEGIN
		SELECT @ReturnServerCount = @rmsc
		select @ReturnInstanceName = @listener
		-- irst use the listener
		if @ReturnInstanceName is null
			SELECT @ReturnInstanceName = @instanceName
	END

	RETURN @e
END
 
GO 

---------- P_GETLICENSEKEYSANDLISTENER.SQL
if (object_id('p_GetLicenseKeysAndListener') is not null)
begin
drop procedure p_GetLicenseKeysAndListener
end
go

CREATE PROCEDURE [dbo].[p_GetLicenseKeysAndListener](
    @LicenseID UNIQUEIDENTIFIER,
    @ReturnServerCount int output,
    @ReturnInstanceName nvarchar(128) output
)
AS

BEGIN
       DECLARE @err INT
       DECLARE @monitoredServerCount INT
       DECLARE @instanceName nvarchar(128)
       DECLARE @SQLString nvarchar(max);
       DECLARE @ParmDefinition nvarchar(500);

       declare @repo sysname;
       set @repo = db_name()

       -- set return values to current number of registered servers and SQL instance
       SELECT @monitoredServerCount = COUNT([SQLServerID]) FROM MonitoredSQLServers (NOLOCK) WHERE Active = 1  

       DECLARE @sqlServerVersion nvarchar(128)
       select @sqlServerVersion = @@MICROSOFTVERSION / 0x01000000
       SET @ParmDefinition = N'@repoName sysname, @instanceNameOut nvarchar(255) OUTPUT';

       if @sqlServerVersion >= 11
       begin
              -- Used to avoid compatibility problems with lower versions of SQL Server.
              select @SQLString = 'select @instanceNameOut = l.dns_name + '','' + convert(nvarchar(10),l.port)'
              + ' from sys.dm_hadr_database_replica_states s'
              + ' inner join sys.availability_group_listeners l on l.group_id = s.group_id'
              + ' and db_name(database_id) = @repoName'
              + ' group by l.dns_name + '','' + convert(nvarchar(10),l.port)'
              EXECUTE sp_executesql @SQLString, @ParmDefinition, @repoName = @repo, @instanceNameOut = @instanceName  OUTPUT;
       end
       
       -- Verify if the listener exist or not.
	   declare @oldListener nvarchar(1024)
	   select @oldListener = (select top (1) Character_Value from RepositoryInfo where Name = 'AGListener');

	   if @instanceName is not null and not exists(select 1 from RepositoryInfo where Name = 'AGListener')
		insert into RepositoryInfo (Name, Character_Value) values('AGListener',@instanceName)
	   else
	       if @instanceName is not null and @instanceName <> @oldListener
		   begin
			   --Update the RepositoryInfo table with the new AG listener
			   update RepositoryInfo set Character_Value = @instanceName where Name = 'AGListener'
		   end
	   
       if @instanceName is null
	   begin
               delete from RepositoryInfo where Name = 'AGListener'
               select @instanceName = CONVERT(nvarchar(128), serverproperty('servername'))
	   end


       IF (@LicenseID IS NULL) 
       BEGIN
              SELECT [LicenseID],[LicenseKey],[DateAddedUtc] FROM [LicenseKeys] (NOLOCK)
              ORDER BY [DateAddedUtc]
       END
       ELSE
       BEGIN
              SELECT [LicenseID],[LicenseKey],[DateAddedUtc] FROM [LicenseKeys] (NOLOCK)
				WHERE ([LicenseID] = @LicenseID)
              ORDER BY [DateAddedUtc]
       END

       SELECT @err = @@error
       IF (@err = 0)
       BEGIN
              SELECT @ReturnServerCount = @monitoredServerCount 
              SELECT @ReturnInstanceName = @instanceName
       END

       RETURN @err

END
 
GO 

---------- P_GETLISTOFCOUNTERS.SQL
if (object_id('[p_GetListOfCounters]') is not null)
begin
drop procedure [p_GetListOfCounters]
end
go
create proc [dbo].[p_GetListOfCounters] as 
begin

select CounterName, CounterFriendlyName, CounterType as Source 
from CounterMasterList where AvailableInCustomReport = 1
union
select replace(mi.Name,' ','_') as CounterName,
mi.Name as CounterFriendlyName, 
2 as Source 
from CustomCounterDefinition  ccd
left outer join MetricInfo mi on mi.Metric = ccd.Metric
where ccd.Enabled = 1
order by Source,CounterFriendlyName asc

end
 
GO 

---------- P_GETLOCKSDETAILS.SQL
if (object_id('[p_GetLocksDetails]') is not null)
begin
drop procedure [p_GetLocksDetails]
end
go
create procedure [dbo].[p_GetLocksDetails]
	@SQLServerID int,
	@UTCSnapshotCollectionDateTime datetime = null,
	@HistoryInMinutes int = null
as
begin
set transaction isolation level read uncommitted
declare @err int

declare @BeginDateTime datetime
declare @EndDateTime datetime

if (@UTCSnapshotCollectionDateTime is null)
	select @EndDateTime = (select max(UTCCollectionDateTime) from [ServerActivity] where [SQLServerID] = @SQLServerID)
else
	select @EndDateTime = @UTCSnapshotCollectionDateTime

if (@HistoryInMinutes is null)
	select @BeginDateTime = @EndDateTime
else
	select @BeginDateTime = dateadd(n, -@HistoryInMinutes, @EndDateTime)

-- Get lock list for requested snapshot
select
	[InstanceName]
	,[UTCCollectionDateTime]
	,[LockList] 
from 
	[ServerActivity]
	left join [MonitoredSQLServers]
	on [ServerActivity].[SQLServerID] = [MonitoredSQLServers].[SQLServerID]
where 
	[ServerActivity].[SQLServerID] = @SQLServerID
	and [UTCCollectionDateTime] = @EndDateTime

-- Get lock statistics history
select
	[UTCCollectionDateTime]
	,[LockStatistics]
from
	[ServerActivity]
where
	[ServerActivity].[SQLServerID] = @SQLServerID
	and [ServerActivity].[UTCCollectionDateTime] between @BeginDateTime and @EndDateTime
order by 
	[ServerActivity].[UTCCollectionDateTime]

select @err = @@error
return @err
end
 
GO 

---------- P_GETMANAGEMENTSERVICES.SQL
if (object_id('p_GetManagementServices') is not null)
begin
drop procedure p_GetManagementServices
end
go
CREATE PROCEDURE [dbo].[p_GetManagementServices](
	@ManagementServiceId UNIQUEIDENTIFIER
)
AS
BEGIN
	DECLARE @e INT

	IF (@ManagementServiceId IS NULL) 
	BEGIN
		SELECT [ManagementServiceID],[InstanceName],[MachineName],[Address],[Port],[DefaultCollectionServiceID] FROM [ManagementServices]
	END
	ELSE
	BEGIN
		SELECT [ManagementServiceID],[InstanceName],[MachineName],[Address],[Port],[DefaultCollectionServiceID] FROM [ManagementServices]
			WHERE ([ManagementServiceID] = @ManagementServiceId)
	END

	SELECT @e = @@error
	RETURN @e
END
 
GO 

---------- P_GETMASTERMETRICS.SQL
if (object_id('p_GetMasterMetrics') is not null)
begin
drop procedure p_GetMasterMetrics
end
go
CREATE PROCEDURE [dbo].[p_GetMasterMetrics]
		@ServerID int,
		@UTCStart DateTime,
		@UTCEnd DateTime,
		@UTCOffset int,
		@Interval tinyint,
		@MasterMetric tinyint,
		@CompareToId int = null,
		@CompareStartRange DateTime = null
AS
BEGIN

-- @Interval - Granularity of calculation:
--	0 - Minutes
--	1 - Hours
--	2 - Days
--	3 - Months
--	4 - Years

--@MasterMetric 
-- 0 - Response Time
-- 1 - CPU Percentage
-- 2 - Memory Usage
-- 3 - % Disk Busy
-- 4 - Session Count

create table #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

insert into #SecureMonitoredSQLServers
exec [p_GetReportServers]

declare @CompareEndRange DateTime
set @CompareStartRange = isnull(@CompareStartRange,@UTCStart)
set @CompareEndRange = dateadd(mi, datediff(mi, @UTCStart, @UTCEnd), @CompareStartRange)

declare @ServerStats table(
	InstanceName nvarchar(257),
	LastCollectioninInterval datetime,
	IntervalNumber int,
	MemoryUsed float,
	ResponseTimeInMilliseconds int,
	CPUActivityPercentage float,
	DiskTimePercent float,
	SessionCount int,
	MetricName nvarchar(128),
	MetricValue float,
	RowNumber int identity,
	IntervalTemp bigint
) 

insert into @ServerStats(InstanceName,LastCollectioninInterval, IntervalTemp,CPUActivityPercentage,DiskTimePercent,MemoryUsed,
ResponseTimeInMilliseconds,SessionCount,MetricName,MetricValue)

	select
		InstanceName = case 
			when @ServerID = @CompareToId
		then 
			m.InstanceName + ' (Base)'
		else m.InstanceName end
		,dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime]))) as [LastCollectioninInterval]
		,IntervalTemp = case
					 when isnull(@Interval,5) = 5
							then 0
					 when isnull(@Interval,5) = 4
							then datediff(yyyy, @UTCStart, max(dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
					 when isnull(@Interval,5) = 3
							then datediff(mm, @UTCStart, max(dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
					 when isnull(@Interval,5) = 2
							then datediff(dd, @UTCStart, max(dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
					 when isnull(@Interval,5) = 1
							then datediff(hh, @UTCStart, max(dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
					 when isnull(@Interval,5) =  0
							then datediff(mi, @UTCStart, max(dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
					 end
		,sum([CPUActivityPercentage] * TimeDeltaInSeconds) / nullif(sum(case when [CPUActivityPercentage] is not null then TimeDeltaInSeconds else 0 end),0) as [CPUActivityPercentage]
		,sum([DiskTimePercent] * TimeDeltaInSeconds) / nullif(sum(case when [DiskTimePercent] is not null then TimeDeltaInSeconds else 0 end),0) as [DiskTimePercent]
		,sum(cast(([OSTotalPhysicalMemoryInKilobytes] - [OSAvailableMemoryInKilobytes]) as float) * TimeDeltaInSeconds) / nullif(sum(case when cast(([OSTotalPhysicalMemoryInKilobytes] - [OSAvailableMemoryInKilobytes]) as float) is not null then TimeDeltaInSeconds else 0 end),0) / 1024 / 1024
		,sum([ResponseTimeInMilliseconds] * TimeDeltaInSeconds) / nullif(sum(case when [ResponseTimeInMilliseconds] is not null then TimeDeltaInSeconds else 0 end),0) as [ResponseTimeInMilliseconds]
		,sum(([SystemProcesses] + UserProcesses) * TimeDeltaInSeconds) / nullif(sum(case when ([SystemProcesses] + UserProcesses) is not null then TimeDeltaInSeconds else 0 end),0)
		,case when @MasterMetric = 0 then 'Response Time (ms)' 
		     when @MasterMetric = 1 then '% CPU Activity' 
		     when @MasterMetric = 2 then 'Memory Usage (GB)' 
		     when @MasterMetric = 3 then '% Disk Busy' 
		else
		     'Session Count' 
		end
		,case when @MasterMetric = 0 then sum([ResponseTimeInMilliseconds] * TimeDeltaInSeconds) / nullif(sum(case when [ResponseTimeInMilliseconds] is not null then TimeDeltaInSeconds else 0 end),0)
		     when @MasterMetric = 1 then sum([CPUActivityPercentage] * TimeDeltaInSeconds) / nullif(sum(case when [CPUActivityPercentage] is not null then TimeDeltaInSeconds else 0 end),0)
		     when @MasterMetric = 2 then sum(cast(([OSTotalPhysicalMemoryInKilobytes] - [OSAvailableMemoryInKilobytes]) as float) * TimeDeltaInSeconds) / nullif(sum(case when cast(([OSTotalPhysicalMemoryInKilobytes] - [OSAvailableMemoryInKilobytes]) as float) is not null then TimeDeltaInSeconds else 0 end),0) / 1024 / 1024
		     when @MasterMetric = 3 then sum([DiskTimePercent] * TimeDeltaInSeconds) / nullif(sum(case when [DiskTimePercent] is not null then TimeDeltaInSeconds else 0 end),0) 
		else
		     max([SystemProcesses] + UserProcesses)
		end
	from
		[ServerStatistics] s1 (nolock)
		left join [#SecureMonitoredSQLServers] m (nolock)
		on m.[SQLServerID] = s1.[SQLServerID]
		left join [OSStatistics] o (nolock)
		on o.[SQLServerID] = s1.[SQLServerID] and o.[UTCCollectionDateTime] = s1.[UTCCollectionDateTime]
	where
		s1.[SQLServerID] = @ServerID
		and dbo.fn_RoundDateTime(@Interval, s1.[UTCCollectionDateTime]) between @UTCStart and @UTCEnd
	group by
		[InstanceName]
		-- Always group by year at the least
		,datepart(yy, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime]))
		-- Group by all intervals greater than or equal to the selected interval
		,case when @Interval <= 3 then datepart(mm,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
		,case when @Interval <= 2 then datepart(dd,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
		,case when @Interval <= 1 then datepart(hh,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
		,case when @Interval =  0 then datepart(mi,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
union
	select 
		InstanceName= case 
			when @ServerID = @CompareToId
		then 
			m.InstanceName + ' (Compare)'
		else m.InstanceName end
		,dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime]))) as [LastCollectioninInterval]
		,IntervalTemp = case
					 when isnull(@Interval,5) = 5
							then 0
					 when isnull(@Interval,5) = 4
							then datediff(yyyy, @CompareStartRange, max(dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
					 when isnull(@Interval,5) = 3
							then datediff(mm, @CompareStartRange, max(dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
					 when isnull(@Interval,5) = 2
							then datediff(dd, @CompareStartRange, max(dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
					 when isnull(@Interval,5) = 1
							then datediff(hh, @CompareStartRange, max(dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
					 when isnull(@Interval,5) =  0
							then datediff(mi, @CompareStartRange, max(dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
					 end
		,sum([CPUActivityPercentage] * TimeDeltaInSeconds) / nullif(sum(case when [CPUActivityPercentage] is not null then TimeDeltaInSeconds else 0 end),0) as [CPUActivityPercentage]
		,sum([DiskTimePercent] * TimeDeltaInSeconds) / nullif(sum(case when [DiskTimePercent] is not null then TimeDeltaInSeconds else 0 end),0) as [DiskTimePercent]
		,sum(cast(([OSTotalPhysicalMemoryInKilobytes] - [OSAvailableMemoryInKilobytes]) as float) * TimeDeltaInSeconds) / nullif(sum(case when cast(([OSTotalPhysicalMemoryInKilobytes] - [OSAvailableMemoryInKilobytes]) as float) is not null then TimeDeltaInSeconds else 0 end),0) / 1024 / 1024
		,sum([ResponseTimeInMilliseconds] * TimeDeltaInSeconds) / nullif(sum(case when [ResponseTimeInMilliseconds] is not null then TimeDeltaInSeconds else 0 end),0) as [ResponseTimeInMilliseconds]
		,sum(([SystemProcesses] + UserProcesses) * TimeDeltaInSeconds) / nullif(sum(case when ([SystemProcesses] + UserProcesses) is not null then TimeDeltaInSeconds else 0 end),0)
		,case when @MasterMetric = 0 then 'Response Time (ms)' 
		     when @MasterMetric = 1 then '% CPU Activity' 
		     when @MasterMetric = 2 then 'Memory Usage (GB)' 
		     when @MasterMetric = 3 then '% Disk Busy' 
		else
		     'Session Count' 
		end
		,case when @MasterMetric = 0 then sum([ResponseTimeInMilliseconds] * TimeDeltaInSeconds) / nullif(sum(case when [ResponseTimeInMilliseconds] is not null then TimeDeltaInSeconds else 0 end),0)
		     when @MasterMetric = 1 then sum([CPUActivityPercentage] * TimeDeltaInSeconds) / nullif(sum(case when [CPUActivityPercentage] is not null then TimeDeltaInSeconds else 0 end),0)
		     when @MasterMetric = 2 then sum(cast(([OSTotalPhysicalMemoryInKilobytes] - [OSAvailableMemoryInKilobytes]) as float) * TimeDeltaInSeconds) / nullif(sum(case when cast(([OSTotalPhysicalMemoryInKilobytes] - [OSAvailableMemoryInKilobytes]) as float) is not null then TimeDeltaInSeconds else 0 end),0) / 1024 / 1024
		     when @MasterMetric = 3 then sum([DiskTimePercent] * TimeDeltaInSeconds) / nullif(sum(case when [DiskTimePercent] is not null then TimeDeltaInSeconds else 0 end),0) 
		else
		     max([SystemProcesses] + UserProcesses)
		end
	from
		[ServerStatistics] s1 (nolock)
		left join [#SecureMonitoredSQLServers] m (nolock)
		on m.[SQLServerID] = s1.[SQLServerID]
		left join [OSStatistics] o (nolock)
		on o.[SQLServerID] = s1.[SQLServerID] and o.[UTCCollectionDateTime] = s1.[UTCCollectionDateTime]
	where 
		s1.[SQLServerID] = @CompareToId
		and dbo.fn_RoundDateTime(@Interval, s1.[UTCCollectionDateTime]) between @CompareStartRange and @CompareEndRange
	group by
		[InstanceName]
		-- Always group by year at the least
		,datepart(yy, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime]))
		-- Group by all intervals greater than or equal to the selected interval
		,case when @Interval <= 3 then datepart(mm,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
		,case when @Interval <= 2 then datepart(dd,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
		,case when @Interval <= 1 then datepart(hh,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
		,case when @Interval =  0 then datepart(mi,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
	order by
		IntervalTemp asc, 
		InstanceName asc
 
declare @rownum int, @intervalcounter int, @previnterval bigint
	select 
		@rownum = isnull(min(RowNumber),-1) ,
		@intervalcounter = 0,
		@previnterval = 0
	from @ServerStats
	while @rownum > 0
	begin
		update @ServerStats
			set IntervalNumber = case when IntervalTemp = @previnterval then @intervalcounter else @intervalcounter + 1 end
		where 
			RowNumber = @rownum

		select
			@intervalcounter = case when IntervalTemp = @previnterval then @intervalcounter 
									else @intervalcounter + 1 end,
			@previnterval = IntervalTemp
		from 
			@ServerStats
		where 
			RowNumber = @rownum
		
		select 
			@rownum = isnull(min(RowNumber),-1) 
		from 
			@ServerStats
		where 
			RowNumber > @rownum
	end

	select 
		InstanceName,
		LastCollectioninInterval,
		IntervalNumber,
		MemoryUsed,
		ResponseTimeInMilliseconds,
		CPUActivityPercentage,
		DiskTimePercent,
		SessionCount,
		MetricName,
		MetricValue,
		@Interval as Interval,
		ISNULL(@CompareToId, -1) as Compare
	from 
		@ServerStats
	order by
		IntervalNumber asc, 
		[InstanceName] asc
		
END
 
 
GO 

---------- P_GETMASTERRECOMMENDATIONS.SQL
if (object_id('p_GetMasterRecommendations') is not null)
begin
drop procedure [p_GetMasterRecommendations]
end
go

-- SQLdm 10.0 Srishti Purohit Doctor implementation in DM
create procedure [p_GetMasterRecommendations] 

AS
BEGIN
	
		
		SELECT PR.[RecommendationID]
      ,PR.[AdditionalConsiderations]
      ,PR.[bitly]
	  ,PRC.Name AS Category
      ,PR.[ConfidenceFactor]
      ,PR.[Description]
      ,PR.[Finding]
      ,PR.[ImpactExplanation]
      ,PR.[ImpactFactor]
      ,PR.[InfoLinks]
      ,PR.[PluralFormFinding]
      ,PR.[PluralFormImpactExplanation]
      ,PR.[PluralFormRecommendation]
      ,PR.[ProblemExplanation]
      ,PR.[Recommendation]
      ,PR.[Relevance]
      ,PR.[Tags]
		FROM PrescriptiveRecommendation PR
		
		JOIN PrescriptiveRecommendationCategory PRC ON PRC.CategoryID = PR.[CategoryID]
		WHERE PR.IsActive = 1


		IF(@@ERROR <> 0)
		BEGIN
			DECLARE @ErMessage NVARCHAR(2048)
			declare @severity int; 
            declare @state int;

            select @ErMessage = ERROR_MESSAGE(), @severity=error_severity(),@state=error_state();

            RAISERROR(@ErMessage,@severity,@state)
		END
END
 
GO 
 
GO 

---------- P_GETMATCHTYPES.SQL
/****** Object:  Function [dbo].[fn_CheckDuplicateCustomDashboardName] 
Custom Dashboard functionality to Get Match Type
    Script Date: 26-May-15 11:35:58 AM ******/
if (object_id('p_GetMatchTypes') is not null)
begin
drop procedure [p_GetMatchTypes]
end
go

create procedure [p_GetMatchTypes] 

AS
BEGIN
	declare @e int
	
	BEGIN TRANSACTION
	
	SET @e = @@error
	IF (@e = 0)
	BEGIN
		-- check if records for UserSID
		SELECT [MatchID]
      ,[MatchType]
  FROM [dbo].[CustomDashboardMatchTypes]
	
	END
	
	IF (@e = 0)
		COMMIT
	ELSE
		ROLLBACK		

	return @e

END
 
GO 
 
GO 

---------- P_GETMAXALERTID.SQL
if (object_id('p_GetMaxAlertID') is not null)
begin
drop procedure [p_GetMaxAlertID]
end
go

create procedure [p_GetMaxAlertID] 
	@ServerName nvarchar(256),
	@ReturnAlertID bigint output
as
begin
	
declare @e int
declare @maxid bigint

	if (@ServerName is null) 
	begin
		select @maxid = max(AlertID) from Alerts
	end
	else
	begin
		select @maxid = max(AlertID) from Alerts
			where [ServerName] = @ServerName
	end
	select @e = @@error
	select @ReturnAlertID = @maxid

	return @e
end
 
GO 

---------- P_GETMEMORYSUMMARY.SQL
if (object_id('p_GetMemorySummary') is not null)
begin
drop procedure p_GetMemorySummary
end
go
CREATE PROCEDURE [dbo].[p_GetMemorySummary]
		@ServerID int,
		@UTCStart DateTime,
		@UTCEnd DateTime,
		@UTCOffset int,
		@Interval tinyint
AS
BEGIN

-- @Interval - Granularity of calculation:
--	0 - Minutes
--	1 - Hours
--	2 - Days
--	3 - Months
--	4 - Years
--,sum([IOActivityPercentage] * TimeDeltaInSeconds) / nullif(sum(case when [IOActivityPercentage] is not null then TimeDeltaInSeconds else 0 end),0) as [IOActivityPercentage]
	select
		m.InstanceName
		,dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime]))) as [LastCollectioninInterval]
		,sum([OSTotalPhysicalMemoryInKilobytes] * TimeDeltaInSeconds) / nullif(sum(case when [OSTotalPhysicalMemoryInKilobytes] is not null then TimeDeltaInSeconds else 0 end),0) as [OSTotalPhysicalMemoryInKilobytes]
		,sum([OSAvailableMemoryInKilobytes] * TimeDeltaInSeconds) / nullif(sum(case when [OSAvailableMemoryInKilobytes] is not null then TimeDeltaInSeconds else 0 end),0) as [OSAvailableMemoryInKilobytes]
		,sum([SqlMemoryAllocatedInKilobytes] * TimeDeltaInSeconds) / nullif(sum(case when [SqlMemoryAllocatedInKilobytes] is not null then TimeDeltaInSeconds else 0 end),0) as [SqlMemoryAllocatedInKilobytes]
		,sum([SqlMemoryUsedInKilobytes] * TimeDeltaInSeconds) / nullif(sum(case when [SqlMemoryUsedInKilobytes] is not null then TimeDeltaInSeconds else 0 end),0) as [SqlMemoryUsedInKilobytes]
		,sum([PageLifeExpectancy] * TimeDeltaInSeconds) / nullif(sum(case when [PageLifeExpectancy] is not null then TimeDeltaInSeconds else 0 end),0) as [PageLifeExpectancy]
		,sum([BufferCacheHitRatioPercentage] * TimeDeltaInSeconds) / nullif(sum(case when [BufferCacheHitRatioPercentage] is not null then TimeDeltaInSeconds else 0 end),0) as [BufferCacheHitRatioPercentage]
		,sum([BufferCacheSizeInKilobytes] * TimeDeltaInSeconds) / nullif(sum(case when [BufferCacheSizeInKilobytes] is not null then TimeDeltaInSeconds else 0 end),0) as [BufferCacheSizeInKilobytes]
		,sum([ProcedureCacheSizeInKilobytes] * TimeDeltaInSeconds) / nullif(sum(case when [ProcedureCacheSizeInKilobytes] is not null then TimeDeltaInSeconds else 0 end),0) as [ProcedureCacheSizeInKilobytes]
		,sum([ProcedureCacheHitRatioPercentage] * TimeDeltaInSeconds) / nullif(sum(case when [ProcedureCacheHitRatioPercentage] is not null then TimeDeltaInSeconds else 0 end),0) as [ProcedureCacheHitRatioPercentage]
		,sum(convert(float,[WorkTablesCreated])) / nullif((sum(convert(float,case when [WorkTablesCreated] is not null then TimeDeltaInSeconds else 0 end)) / 60) ,0)as [WorkTablesCreated]
		,PageLifeExpectancyMean = (select TOP 1 Mean	--'%PageLifeExpectancy%' -- 76
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = 76 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc),
		ProcedureCacheHitRatioPercentageMean = (select TOP 1 Mean	--'%ProcedureCacheHitRatioPercentage%' -- 81
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = 81 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc),
		OSTotalPhysicalMemoryInKilobytesMean = (select TOP 1 Mean	--'%OSTotalPhysicalMemoryInKilobytes%' -- -1002
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -1002 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc),		
		OSAvailableMemoryInKilobytesMean = (select TOP 1 Mean --'%OSAvailableMemoryInKilobytes%' -- -1000
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -1000 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc),
		SqlMemoryAllocatedInKilobytesMean = (select TOP 1 Mean	--'%SqlMemoryAllocatedInKilobytes%' -- -70
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = -70 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc),
		SqlMemoryUsedInKilobytesMean = (select TOP 1 Mean	--'%SqlMemoryUsedInKilobytes%' -- -71
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -71 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc),		
		BufferCacheHitRatioPercentageMean = (select TOP 1 Mean --'%BufferCacheHitRatioPercentage%' -- -9
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -9 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc),				
		BufferCacheSizeInKilobytesMean = (select TOP 1 Mean	--'%BufferCacheSizeInKilobytes%' -- -10
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = -10 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc),
		ProcedureCacheSizeInKilobytesMean = (select TOP 1 Mean	--'%ProcedureCacheSizeInKilobytes%' -- -1003
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -1003 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc),		
		WorkTablesCreatedMean = (select TOP 1 Mean --'%WorkTablesCreated%' -- -84
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -84 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc) * 60
	from
		[MonitoredSQLServers] m (nolock)
		left join [ServerStatistics] s1 (nolock)
		on m.[SQLServerID] = s1.[SQLServerID]
		left join [OSStatistics] o (nolock)
		on o.[SQLServerID] = s1.[SQLServerID] and o.[UTCCollectionDateTime] = s1.[UTCCollectionDateTime]
	where
		s1.[SQLServerID] = @ServerID
		and dbo.fn_RoundDateTime(@Interval, s1.[UTCCollectionDateTime]) between @UTCStart and @UTCEnd
	group by
		[InstanceName]
		-- Always group by year at the least
		,datepart(yy, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime]))
		-- Group by all intervals greater than or equal to the selected interval
		,case when @Interval <= 3 then datepart(mm,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
		,case when @Interval <= 2 then datepart(dd,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
		,case when @Interval <= 1 then datepart(hh,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
		,case when @Interval =  0 then datepart(mi,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
END
 
 
GO 

---------- P_GETMEMORYSUMMARYBASELINE.SQL
if (object_id('p_GetMemorySummaryBaseline') is not null)
begin
drop procedure [p_GetMemorySummaryBaseline]
end
go

CREATE PROCEDURE [dbo].[p_GetMemorySummaryBaseline]
		@ServerID int,
		@UTCStart DateTime,
		@UTCEnd DateTime,
		@UTCOffset int,
		@Interval tinyint
AS
BEGIN
		SELECT		
		UTCCalculation = dbo.fn_RoundDateTime(1, max(dateadd(mi, @UTCOffset, UTCCalculation))),
		PageLifeExpectancyMean = (select TOP 1 Mean	--'%PageLifeExpectancy%' -- 76
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = 76 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc),
		ProcedureCacheHitRatioPercentageMean = (select TOP 1 Mean	--'%ProcedureCacheHitRatioPercentage%' -- 81
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = 81 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc),
		OSTotalPhysicalMemoryInKilobytesMean = (select TOP 1 Mean	--'%OSTotalPhysicalMemoryInKilobytes%' -- -1002
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -1002 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc),		
		OSAvailableMemoryInKilobytesMean = (select TOP 1 Mean --'%OSAvailableMemoryInKilobytes%' -- -1000
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -1000 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc),
		SqlMemoryAllocatedInKilobytesMean = (select TOP 1 Mean	--'%SqlMemoryAllocatedInKilobytes%' -- -70
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = -70 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc),
		SqlMemoryUsedInKilobytesMean = (select TOP 1 Mean	--'%SqlMemoryUsedInKilobytes%' -- -71
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -71 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc),		
		BufferCacheHitRatioPercentageMean = (select TOP 1 Mean --'%BufferCacheHitRatioPercentage%' -- -9
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -9 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc),				
		BufferCacheSizeInKilobytesMean = (select TOP 1 Mean	--'%BufferCacheSizeInKilobytes%' -- -10
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = -10 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc),
		ProcedureCacheSizeInKilobytesMean = (select TOP 1 Mean	--'%ProcedureCacheSizeInKilobytes%' -- -1003
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -1003 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc),		
		WorkTablesCreatedMean = (select TOP 1 Mean --'%WorkTablesCreated%' -- -84
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -84 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc) * 60
		FROM		
			[BaselineStatistics] bs (nolock)
		WHERE bs.[SQLServerID] = @ServerID and bs.UTCCalculation between @UTCStart and @UTCEnd
		GROUP BY dbo.fn_RoundDateTime(2, bs.UTCCalculation)

END

 
GO 

---------- P_GETMETRICINFO.SQL
if (object_id('p_GetMetricInfo') is not null)
begin
drop procedure [p_GetMetricInfo]
end
go
CREATE PROCEDURE [dbo].[p_GetMetricInfo](
	@Metric int = NULL
)
AS
begin

declare @e int

SELECT	[Metric],[Rank],[Category],[Name],[Description],[Comments]
FROM [MetricInfo] (NOLOCK)
WHERE (@Metric is null or [Metric] = @Metric)

SELECT @e = @@error

return @e

end
 
GO 

---------- P_GETMETRICLIST.SQL
IF (object_id('p_GetMetricList') IS NOT NULL)
BEGIN
DROP PROCEDURE p_GetMetricList
END
GO

CREATE PROCEDURE [dbo].p_GetMetricList
AS
BEGIN

	--SELECT mi.Name,mmd.Metric FROM MetricMetaData mmd 
	--INNER JOIN MetricInfo mi ON mmd.Metric=mi.Metric 
	--INNER JOIN BaselineMetaData bmd on mmd.Metric = bmd.MetricID
	--WHERE TableName IS NOT NULL AND ColumnName IS NOT NULL
	SELECT CASE
		WHEN p.Name IN (SELECT Name FROM BaselineMetaData WHERE Name IS NOT NULL GROUP BY Name HAVING COUNT(Name)>1)
			THEN p.Name+'('+p.Unit+')'
		ELSE p.Name
		END AS MetricName,p.ItemID,ISNULL(p.Unit,'') AS Unit
	FROM BaselineMetaData p
	WHERE p.Name IS NOT NULL

END
 
GO 

---------- P_GETMETRICSHISTORYFORALERT.SQL
/*
Alters to add new cols needed for this proc
alter table MetricMetaData add TableName nvarchar(256);
alter table MetricMetaData add ColumnName nvarchar(256);

Possible Statistics Tables (tables which have UTCCollectionDateTime column)
   ActiveWaitStatistics, AlwaysOnStatistics, BlockingSessionStatistics, Blocks, CustomCounterStatistics, 
   DatabaseFileActivity, DatabaseSize, DatabaseSizeDateTime, DatabaseStatistics, DatabaseStatistics_upgrade,   
   DeadlockProcesses, Deadlocks, DiskDrives, ESXConfigData, ESXStatistics, MirroringStatistics, OSStatistics, 
   QueryMonitor, QueryMonitorStatistics, SATempData, ServerActivity, ServerStatistics, stageDatabaseStatistics, 
   TableGrowth, TableReorganization, TempdbFileData, VMConfigData, VMStatistics, WaitStatistics
*/

if (object_id('p_GetMetricsHistoryForAlert') is not null)
begin
drop procedure p_GetMetricsHistoryForAlert 
end
go


CREATE PROCEDURE [dbo].[p_GetMetricsHistoryForAlert] (@AlertId INT, @NumHistoryHours INT = 4)
AS
BEGIN
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	DECLARE @SQLServerID int 
	SELECT @SQLServerID= null;

	DECLARE @DatabaseID int 
	SELECT @DatabaseID= null;

	DECLARE @MetricId int 
	SELECT @MetricId= null;

	DECLARE @AlertOccurrenceTime DateTime 
	SELECT @AlertOccurrenceTime= null;

	DECLARE @TableName nvarchar(256) 
	SELECT @TableName= null;

	DECLARE @ColumnName nvarchar(256) 
	SELECT @ColumnName= null;

	-- Read metric from Alerts table.
	-- Read MetricMetaData to determine info where Metric is stored.
	SELECT 
		@SQLServerID = mss.SQLServerID,
		@DatabaseID = ssdn.DatabaseID,
		@MetricId = a.Metric, @AlertOccurrenceTime = a.UTCOccurrenceDateTime, 
		@TableName = mmd.TableName, @ColumnName = mmd.ColumnName  
	FROM Alerts a
	INNER JOIN MetricMetaData mmd ON a.Metric = mmd.Metric
	LEFT OUTER JOIN MonitoredSQLServers mss ON mss.InstanceName = a.ServerName
	LEFT OUTER JOIN SQLServerDatabaseNames ssdn ON ssdn.DatabaseName = a.DatabaseName  AND mss.SQLServerID = ssdn.SQLServerID
	WHERE a.AlertID = @AlertId;
	
	DECLARE @EndDateSQLString nvarchar(MAX);
	DECLARE @SQLString nvarchar(MAX);

	DECLARE @end DateTime 
	SELECT @end= @AlertOccurrenceTime;

	declare @start DateTime 
	select @start= DATEADD(HOUR, -@NumHistoryHours, @end);
	
	IF (@TableName IN ('ServerStatistics','OSStatistics','DiskDrives','VMStatistics','ESXStatistics'))
	BEGIN 			
		SELECT @SQLString = 'SELECT UTCCollectionDateTime, ' + @ColumnName + ' AS Value FROM '+ @TableName +
							' WHERE UTCCollectionDateTime BETWEEN @start and @end
							AND SQLServerID = @SQLServerID
							ORDER BY UTCCollectionDateTime DESC';
		EXEC sp_executesql @SQLString, N'@start datetime, @end datetime, @SQLServerID int', @start, @end, @SQLServerID
	END
	ELSE IF (@TableName ='Deadlocks')
	BEGIN 			
		SELECT @SQLString = 'SELECT UTCCollectionDateTime, ' + @ColumnName + ' AS Value FROM '+ @TableName +
							' WHERE UTCCollectionDateTime BETWEEN @start and @end
							AND SQLServerID = @SQLServerID
							GROUP BY SQLServerID
							ORDER BY UTCCollectionDateTime DESC';
		EXEC sp_executesql @SQLString, N'@start datetime, @end datetime, @SQLServerID int', @start, @end, @SQLServerID
	END
	ELSE IF (@TableName = 'TempdbFileData' )
	BEGIN
		SELECT @SQLString = 'SELECT  UTCCollectionDateTime,SUM('+ @ColumnName +') AS Value  FROM '+@TableName+
							' WHERE UTCCollectionDateTime BETWEEN @start and @end
							group by UTCCollectionDateTime
							ORDER BY UTCCollectionDateTime DESC'
		EXEC sp_executesql @SQLString, N'@start datetime, @end datetime', @start, @end
	END

	ELSE IF (@TableName IN ( 'DatabaseStatistics','DatabaseSize','MirroringStatistics'))
	BEGIN
		SELECT @SQLString = 'SELECT UTCCollectionDateTime, ' + @ColumnName + '  AS Value FROM '+ @TableName +
							' WHERE UTCCollectionDateTime BETWEEN @start and @end
							AND DatabaseID = @DatabaseID
							ORDER BY UTCCollectionDateTime DESC';
		EXEC sp_executesql @SQLString, N'@start datetime, @end datetime, @DatabaseID int', @start, @end, @DatabaseID
END
	ELSE IF (@TableName = 'TableReorganization' )
	BEGIN
		SELECT @SQLString = 'SELECT UTCCollectionDateTime, ' + @ColumnName + '  AS Value FROM '+ @TableName +
							' TR LEFT JOIN SQLServerTableNames SST ON SST.TableID=TR.TableID '+
							' WHERE TR.UTCCollectionDateTime BETWEEN @start and @end
							AND SST.DatabaseID = @DatabaseID
							ORDER BY UTCCollectionDateTime DESC';
		EXEC sp_executesql @SQLString, N'@start datetime, @end datetime, @DatabaseID int', @start, @end, @DatabaseID
	END
	
	ELSE IF (@TableName = 'AlwaysOnStatistics')
	BEGIN
		SELECT @SQLString = 'SELECT UTCCollectionDateTime, ' + @ColumnName + '  AS Value FROM '+ @TableName +
							' WHERE UTCCollectionDateTime BETWEEN @start and @end
							AND DatabaseId = @DatabaseID
							ORDER BY UTCCollectionDateTime DESC';
		EXEC sp_executesql @SQLString, N'@start datetime, @end datetime, @DatabaseID int', @start, @end, @DatabaseID
	END

	ELSE IF (@TableName = 'MirroringParticipants')
	BEGIN
		SELECT @SQLString = 'SELECT dateadd(n,-330,last_updated) AS UTCCollectionDateTime, ' + @ColumnName + '  AS Value FROM '+ @TableName +
							' WHERE dateadd(n,-330,last_updated) BETWEEN @start and @end
							AND DatabaseID = @DatabaseID
							ORDER BY UTCCollectionDateTime DESC';
		EXEC sp_executesql @SQLString, N'@start datetime, @end datetime, @DatabaseID int', @start, @end, @DatabaseID
	END

	ELSE IF (@TableName = 'MonitoredSQLServers')
	BEGIN
		SELECT @SQLString = 'SELECT dateadd(n,-330,LastDatabaseCollectionTime) AS UTCCollectionDateTime, ' + @ColumnName + '  AS Value FROM '+ @TableName +
							' WHERE dateadd(n,-330,LastDatabaseCollectionTime) BETWEEN @start and @end
							AND SQLServerID = @SQLServerID
							ORDER BY UTCCollectionDateTime DESC';
		EXEC sp_executesql @SQLString, N'@start datetime, @end datetime, @SQLServerID int', @start, @end, @SQLServerID
	END

	

	
END
 
 
GO 

---------- P_GETMETRICSHISTORYFORCUSTOMDASHBOARD.SQL
if (object_id('p_GetMetricsHistoryForCustomDashboard') is not null)
begin
drop procedure [p_GetMetricsHistoryForCustomDashboard]
end
go

create procedure [p_GetMetricsHistoryForCustomDashboard] 
@dashboardId bigint,        
@widgetId bigint,
@startTime DateTime,
@endTime DateTime
as
BEGIN

DECLARE @matchId INT
DECLARE @metricId INT

SELECT @matchId = 0, @metricId = -1

DECLARE @errorFound nvarchar(250)
declare @e int 
-- Table and Column 
DECLARE @TableName nvarchar(256) 
SELECT @TableName= null;

DECLARE @ColumnName nvarchar(256) 
SELECT @ColumnName= null;

--To make query for random table for metric values
DECLARE @SQLString nvarchar(MAX);

DECLARE @SQLStringCombined nvarchar(MAX);
BEGIN TRY
   -- Start A Transaction
  

-- Get match type for widget
SELECT @matchId=[MatchId], @metricId = [MetricID] FROM CustomDashboardWidgets  WITH(NOLOCK) WHERE [WidgetID] = @widgetId AND [DashboardID] = @dashboardId

if(@matchId != 0 OR @metricId >= 0)
BEGIN
SELECT	@TableName = mmd.TableName, @ColumnName = mmd.ColumnName  
	FROM MetricMetaData mmd WITH(NOLOCK) WHERE mmd.Metric = @metricId
	
SELECT @SQLString = '

--Create temp table to store list of serverId and instance names
DECLARE @serverDetails TABLE(
	SQLServerId INT NOT NULL,
	InstanceName NVARCHAR(256) NOT NULL
	)
IF(@matchId = 1 OR @matchId = 2)
BEGIN
	INSERT INTO @serverDetails (SQLServerId,
	InstanceName
	)
	SELECT 
		WS.SourceServerID,
		mss.InstanceName  
		FROM WidgetSourceMapping WS WITH(NOLOCK) 
		JOIN MonitoredSQLServers mss WITH(NOLOCK) ON WS.SourceServerID = mss.SQLServerID
		WHERE [WidgetID] = @widgetId
	
END
ELSE IF(@matchId = 3)
BEGIN
	--Insert record from table to get list of serverids and instance name
	INSERT INTO @serverDetails (SQLServerId,
	InstanceName
	)
	SELECT 
		ST.SQLServerId,
		mss.InstanceName
		FROM ServerTags ST WITH(NOLOCK) 
		JOIN MonitoredSQLServers mss WITH(NOLOCK) ON ST.SQLServerId = mss.SQLServerID
		WHERE ST.TagId IN (SELECT TagId FROM WidgetTagMapping WHERE [WidgetID] = @widgetId )
	
	--SELECT SQLServerId FROM ServerTags WHERE TagId IN (SELECT TagId FROM WidgetTagMapping WHERE [WidgetID] = 3 )
END
ELSE IF(@matchId = 4)
BEGIN
	--Insert record from table to get list of serverids and instance name
	INSERT INTO @serverDetails (SQLServerId,
	InstanceName
	)
	SELECT SQLServerID, InstanceName FROM MonitoredSQLServers WITH(NOLOCK) 
END
ELSE
BEGIN
	SET @errorFound = ''Invalid WidgetID and dashboardID.''
END
';


	IF (@TableName IN ('ServerStatistics','OSStatistics','DiskDrives','VMStatistics','ESXStatistics','BlockingSessionStatistics'))
	BEGIN 			
		SELECT @SQLStringCombined = @SQLString + ' SELECT SD.SQLServerId AS ServerId, SD.InstanceName As InstanceName, UTCCollectionDateTime, ' + @ColumnName + 
							' AS Value FROM '+ @TableName +
							' AS TN WITH(NOLOCK) JOIN @serverDetails SD ON  SD.SQLServerId = TN.SQLServerID
							WHERE UTCCollectionDateTime BETWEEN @startTime and @endTime
							ORDER BY UTCCollectionDateTime DESC';
		
	END
	
	
	ELSE IF (@TableName ='Deadlocks')
	BEGIN 			
		SELECT @SQLStringCombined = @SQLString + ' SELECT SD.SQLServerId AS ServerId, SD.InstanceName As InstanceName, UTCCollectionDateTime, ' + @ColumnName + ' AS Value FROM '+ @TableName +
							' AS TN WITH(NOLOCK) JOIN @serverDetails SD ON  SD.SQLServerId = TN.SQLServerID WHERE UTCCollectionDateTime BETWEEN @startTime and @endTime
							GROUP BY SD.SQLServerID, SD.InstanceName , UTCCollectionDateTime,'+@ColumnName+'
							ORDER BY UTCCollectionDateTime DESC';
		
	END
	ELSE IF (@TableName = 'TempdbFileData' )
	BEGIN
	
		SELECT @SQLStringCombined = @SQLString + ' SELECT SD.SQLServerId AS ServerId, SD.InstanceName As InstanceName,  UTCCollectionDateTime,(CONVERT(DECIMAL(16,2),SUM('+ @ColumnName +')/1000.0)) AS Value  FROM '+@TableName+
							' AS TD WITH(NOLOCK) LEFT JOIN DatabaseFiles DF ON TD.FileID = DF.FileID
							JOIN SQLServerDatabaseNames ssdn WITH(NOLOCK)  ON ssdn.DatabaseID = DF.DatabaseID
							JOIN @serverDetails SD  ON  SD.SQLServerId =ssdn.SQLServerID 
							WHERE UTCCollectionDateTime BETWEEN @startTime and @endTime
							group by SD.SQLServerId, SD.InstanceName, UTCCollectionDateTime
							ORDER BY TD.UTCCollectionDateTime DESC'
							--PRINT @SQLStringCombined
		
	END

	ELSE IF (@TableName IN ('DatabaseSize','MirroringStatistics'))
	BEGIN
	
		SELECT @SQLStringCombined = @SQLString + ' SELECT SD.SQLServerId AS ServerId, SD.InstanceName As InstanceName, UTCCollectionDateTime, ' + @ColumnName + '  AS Value FROM '+ @TableName +
							' AS TD JOIN SQLServerDatabaseNames ssdn WITH(NOLOCK) ON ssdn.DatabaseID = TD.DatabaseID
							JOIN @serverDetails SD ON  SD.SQLServerId =ssdn.SQLServerID
							WHERE UTCCollectionDateTime BETWEEN @startTime and @endTime
							ORDER BY UTCCollectionDateTime DESC';
		
	END                    
	ELSE IF (@TableName = 'TableReorganization' )
	BEGIN
		SELECT @SQLStringCombined = @SQLString + ' SELECT SD.SQLServerId AS ServerId, SD.InstanceName As InstanceName, UTCCollectionDateTime, ' + @ColumnName + '  AS Value FROM '+ @TableName +
							' AS TR JOIN SQLServerTableNames SST WITH(NOLOCK) ON SST.TableID=TR.TableID '+
							'JOIN SQLServerDatabaseNames ssdn WITH(NOLOCK) ON ssdn.DatabaseID = SST.DatabaseID
							JOIN @serverDetails SD ON  SD.SQLServerId =ssdn.SQLServerID 
							 WHERE TR.UTCCollectionDateTime BETWEEN @startTime and @endTime
							ORDER BY UTCCollectionDateTime DESC';
							
	END
	ELSE IF (@TableName = 'AlwaysOnStatistics')
	BEGIN
		SELECT @SQLStringCombined = @SQLString + ' SELECT SD.SQLServerId AS ServerId, SD.InstanceName As InstanceName, UTCCollectionDateTime, ' + @ColumnName + '  AS Value FROM '+ @TableName +
							--' AS TD JOIN SQLServerDatabaseNames ssdn WITH(NOLOCK) ON ssdn.DatabaseID = TD.DatabaseId
							' AS TD
							JOIN @serverDetails SD  ON  SD.SQLServerId =TD.SQLServerID
							WHERE UTCCollectionDateTime BETWEEN @startTime and @endTime
							ORDER BY UTCCollectionDateTime DESC';
		
		
	END

	--ELSE IF (@TableName = 'MirroringParticipants')
	--BEGIN
	--	SELECT @SQLString = 'SELECT SD.SQLServerId AS ServerId, SD.InstanceName As InstanceName, dateadd(n,-330,last_updated) AS UTCCollectionDateTime, ' + @ColumnName + '  AS Value FROM '+ @TableName +
	--						' WHERE dateadd(n,-330,last_updated) BETWEEN @startTime and @endTime
	--						AND DatabaseID = @DatabaseID
	--						ORDER BY UTCCollectionDateTime DESC';
	--	EXEC sp_executesql @SQLString, N'@startTime datetime, @endTime datetime, @DatabaseID int', @startTime, @endTime, @DatabaseID
	--END
	ELSE IF (@TableName = 'MonitoredSQLServers')
	BEGIN
		SELECT @SQLStringCombined = @SQLString + ' SELECT SQLServerID AS ServerId, InstanceName As InstanceName, dateadd(n,-330,LastDatabaseCollectionTime) AS UTCCollectionDateTime, ' + @ColumnName + '  AS Value FROM '+ @TableName +
							' WITH(NOLOCK) WHERE dateadd(n,-330,LastDatabaseCollectionTime) BETWEEN @startTime and @endTime
							AND SQLServerID IN (SELECT SQLServerId FROM @serverDetails)
							ORDER BY UTCCollectionDateTime DESC';
		
	END

	-- For Custom Counter Metric Value
	ELSE IF (@TableName = 'CustomCounterStatistics')
	BEGIN
	SELECT @SQLStringCombined = @SQLString +' SELECT SD.SQLServerId AS ServerId, SD.InstanceName As InstanceName, UTCCollectionDateTime, ' + @ColumnName + 
						' AS Value FROM '+ @TableName +
						' AS TN WITH(NOLOCK) JOIN @serverDetails SD ON  SD.SQLServerId = TN.SQLServerID WHERE UTCCollectionDateTime BETWEEN @startTime and @endTime
						GROUP BY SD.SQLServerID, SD.InstanceName , UTCCollectionDateTime,'+@ColumnName+'
						ORDER BY UTCCollectionDateTime DESC';
	END

	--SQLdm 10.0 (Srishti Purohit) -- for Query Monitor Events counts
	ELSE IF (@TableName = 'QueryMonitorStatistics')
	BEGIN
	SELECT @SQLStringCombined = @SQLString +'SELECT SD.SQLServerId AS ServerId ,SD.InstanceName As InstanceName, UTCCollectionDateTime, ' + @ColumnName + 
						' AS Value FROM '+ @TableName +
						' AS TN WITH(NOLOCK) JOIN @serverDetails SD ON  SD.SQLServerId = TN.SQLServerID WHERE UTCCollectionDateTime BETWEEN @startTime and @endTime
						GROUP BY SD.SQLServerId,SD.InstanceName,UTCCollectionDateTime';
						
	END
	--Excute @SQLString for all type of tables
	EXEC sp_executesql @SQLStringCombined, N'@startTime datetime, @endTime datetime,@matchId INT,@widgetId bigint,@errorFound nvarchar(250) ', @startTime, @endTime,@matchId,@widgetId,@errorFound
END
ELSE
BEGIN
	SELECT 0 AS ServerId
END


END TRY
BEGIN CATCH
 SELECT @@ERROR AS ErrorCode;
END CATCH

	
END
 
GO 

---------- P_GETMETRICTHRESHOLDDETAILS.SQL
if (object_id('p_GetMetricThresholdDetails') is not null)
begin
drop procedure [p_GetMetricThresholdDetails]
end
go
create procedure [dbo].[p_GetMetricThresholdDetails]
				@ServerID int,
				@InMetric int = null
as
begin
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	declare @metricID int
	declare @AlertThresholds table (
			MetricID int, 
			WarningThreshold nvarchar(200), 
			CriticalThreshold nvarchar(200),
			InfoThreshold nvarchar(200),
			criticalThresholdEnabled nvarchar(256),
			warningThresholdEnabled nvarchar(256),
			infoThresholdEnabled nvarchar(256) ,
			thresholdInstanceId int)

	declare @MetricStatus table (
			MetricID int,
			MetricStatus bit)			
			
	declare @InfoThresholdXML nvarchar(1024), 
			@WarningThresholdXML nvarchar(1024), 
			@CriticalThresholdXML nvarchar(1024),
			@enabled bit,
			@thresholdInstanceId int,
			@thresholdEnabled bit,
			@xmlDoc int, 
			@warningValueArray nvarchar(4000), 		
			@criticalValueArray nvarchar(4000), 		
			@infoValueArray nvarchar(4000), 		
			@serviceState nvarchar(256),
			@criticalThresholdEnabled nvarchar(256),
			@warningThresholdEnabled nvarchar(256),
			@infoThresholdEnabled nvarchar(256)
	
	SET @infoValueArray = ''
	SET @warningValueArray = ''
	SET @criticalValueArray = ''
	
	create table #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

	insert into #SecureMonitoredSQLServers
	exec [p_GetReportServers]

	insert into @MetricStatus select Metric, Enabled from MetricThresholds where SQLServerID = @ServerID and ThresholdInstanceID < 0
	
	--Get the thresholds for each metric		
	declare read_metricId insensitive cursor 
	for
		select Metric from MetricMetaData where @InMetric is null or Metric = @InMetric

	for read only
		set nocount on 
		open read_metricId 
		fetch read_metricId into @metricID

	while @@fetch_status = 0 
	begin

		declare  read_threshold insensitive cursor
		 for
			select  WarningThreshold,
					CriticalThreshold,
					InfoThreshold,
					MT.Enabled,
					MT.ThresholdInstanceID
			from MetricThresholds MT (nolock)
			where Metric = @metricID and SQLServerID = @ServerID
		
		for read only
			set nocount on
			open read_threshold
			fetch read_threshold into @WarningThresholdXML, @CriticalThresholdXML, @InfoThresholdXML, @enabled, @thresholdInstanceId
			
		while @@FETCH_STATUS = 0
		begin	
		
			exec sp_xml_preparedocument @xmlDoc output, @WarningThresholdXML
			select @warningThresholdEnabled = [Enabled], @warningValueArray = Value from openxml(@xmlDoc, '/Threshold', 3) with (Enabled nvarchar(256), Value nvarchar(1024))
			
			declare read_threshold_entry cursor
			for
				select servicestate from openxml(@xmlDoc, '//anyType', 2) with (servicestate nvarchar(256) 'text()')

			open read_threshold_entry
			fetch read_threshold_entry into @serviceState
			
			if (@@FETCH_STATUS = 0)
			BEGIN
				set @warningValueArray = ''
			END
			
			while @@fetch_status = 0
			begin
				set @warningValueArray = @warningValueArray + @serviceState + ', '
				fetch read_threshold_entry into @serviceState
			end
			Close read_threshold_entry
			deallocate read_threshold_entry
			exec sp_xml_removedocument @xmlDoc
			
			exec sp_xml_preparedocument @xmlDoc output, @CriticalThresholdXML
			select @criticalValueArray = Value, @criticalThresholdEnabled = [Enabled] from openxml(@xmlDoc, '/Threshold', 3) with (Value nvarchar(1024), Enabled nvarchar(256))

			declare read_threshold_entry cursor
			for
				select servicestate from openxml(@xmlDoc, '//anyType', 2) with (servicestate nvarchar(256) 'text()')

			open read_threshold_entry
			fetch read_threshold_entry into @serviceState
			
			if (@@FETCH_STATUS = 0)
			BEGIN
				set @criticalValueArray = ''
			END
			
			while @@fetch_status = 0
			begin
				set @criticalValueArray = @criticalValueArray + @serviceState + ', '
				fetch read_threshold_entry into @serviceState
			end
	
			Close read_threshold_entry
			deallocate read_threshold_entry
			exec sp_xml_removedocument @xmlDoc			

			exec sp_xml_preparedocument @xmlDoc output, @InfoThresholdXML
			select @infoValueArray = Value, @infoThresholdEnabled = [Enabled] from openxml(@xmlDoc, '/Threshold', 3) with (Value nvarchar(1024), Enabled nvarchar(256))
			
			declare read_threshold_entry cursor
			for
				select servicestate from openxml(@xmlDoc, '//anyType', 2) with (servicestate nvarchar(256) 'text()')

			open read_threshold_entry
			fetch read_threshold_entry into @serviceState
			
			if (@@FETCH_STATUS = 0)
			BEGIN
				set @infoValueArray = ''
			END
			
			while @@fetch_status = 0
			begin
				set @infoValueArray = @infoValueArray + @serviceState + ', '
				fetch read_threshold_entry into @serviceState
			end
	
			Close read_threshold_entry
			deallocate read_threshold_entry
			exec sp_xml_removedocument @xmlDoc						
			
			insert into @AlertThresholds ([MetricID], [WarningThreshold], [CriticalThreshold], [InfoThreshold], [criticalThresholdEnabled], [warningThresholdEnabled], [infoThresholdEnabled], [thresholdInstanceId])
								 VALUES (@metricID, @warningValueArray, @criticalValueArray, @infoValueArray, @criticalThresholdEnabled, @warningThresholdEnabled, @infoThresholdEnabled, @thresholdInstanceId)
		
			fetch read_threshold into @WarningThresholdXML, @CriticalThresholdXML, @InfoThresholdXML, @enabled, @thresholdInstanceId
		end
		close read_threshold
		deallocate read_threshold
		fetch read_metricId into @metricID
	end
	Close read_metricId 
	deallocate read_metricId 
	
	select	mi.Metric,
			mi.Name, 
			ms.InstanceName, 
			mi.Description, 
			stat.MetricStatus as [Enabled], 
			mt.ThresholdEnabled,
			Category, 
			ISNULL(mti.ThresholdInstanceName,'') as [ThresholdInstanceName],
			at.InfoThreshold, 
			at.CriticalThreshold, 
			at.WarningThreshold,
			at.criticalThresholdEnabled,
			at.warningThresholdEnabled,
			at.infoThresholdEnabled
	from MetricThresholds mt 
	left join MetricThresholdInstances mti on mt.ThresholdInstanceID = mti.InstanceID
	left join MetricInfo mi on mi.Metric = mt.Metric
	left join #SecureMonitoredSQLServers ms on ms.SQLServerID = @ServerID
	left join @AlertThresholds at on at.MetricID = mt.Metric and at.thresholdInstanceId = mt.ThresholdInstanceID
	left join @MetricStatus stat on mt.Metric = stat.MetricID
	where mt.SQLServerID = @ServerID and at.MetricID is not null
	ORDER BY ms.InstanceName ASC, mi.Name ASC
end
 
GO 

---------- P_GETMETRICTHRESHOLDS.SQL
if (object_id('p_GetMetricThresholds') is not null)
begin
drop procedure [p_GetMetricThresholds]
end
go

create procedure [p_GetMetricThresholds](
	@UserViewID int,
	@SQLServerID int,
	@Metric int = null
)
as
begin
	DECLARE @e int

	IF (@UserViewID IS NULL) 
	BEGIN
		SELECT a.[SQLServerID],a.[Metric],[Enabled],[WarningThreshold],[CriticalThreshold],[Data],[UTCSnoozeStart],[UTCSnoozeEnd],[SnoozeStartUser],[SnoozeEndUser],[InfoThreshold], b.[ThresholdInstanceName], a.[ThresholdEnabled] 
		--10.0 srishti purohit -- for baseline alert modifications
		,a.IsBaselineEnabled, a.[BaselineWarningThreshold],
			a.[BaselineCriticalThreshold],
			a.[BaselineInfoThreshold]
			FROM 
				[MetricThresholds] a 
				left join [MetricThresholdInstances] b 
					on a.ThresholdInstanceID = b.InstanceID
			WHERE (@SQLServerID is NULL or a.[SQLServerID] = @SQLServerID) AND
				(@Metric IS NULL or @Metric = a.[Metric])
	END
	ELSE
	BEGIN
		-- returns default metric threshold entries
		SELECT a.[UserViewID],a.[Metric],[Enabled],[WarningThreshold],[CriticalThreshold],[Data],[InfoThreshold], b.ThresholdInstanceName, a.ThresholdEnabled
		--10.0 srishti purohit -- for baseline alert modifications
		, a.[IsBaselineEnabled], a.[BaselineWarningThreshold],
			a.[BaselineCriticalThreshold],
			a.[BaselineInfoThreshold] 
			FROM [DefaultMetricThresholds] a
				left join [MetricThresholdInstances] b 
					on a.ThresholdInstanceID = b.InstanceID
			WHERE [UserViewID] = @UserViewID AND
				(@Metric IS NULL or @Metric = [Metric])
	END

	SELECT @e = @@error
	RETURN @e
end

 
 
GO 

---------- P_GETMETRICTHRESHOLDSFORWEBCONSOLE.SQL
IF (OBJECT_ID('p_GetMetricThresholdsForWebConsole') IS NOT NULL)
BEGIN
DROP PROCEDURE p_GetMetricThresholdsForWebConsole
END
GO
CREATE PROCEDURE [dbo].p_GetMetricThresholdsForWebConsole		
	  @MetricID BIGINT =  NULL,
		@SQLServerID INT = NULL
AS
BEGIN
	with T(SQLServerID, MetricID, InfoThreshold) AS 
	(SELECT mi.SQLServerID, mi.Metric, 
		CONVERT(XML, mi.InfoThreshold)
	FROM MetricThresholds mi
	WHERE Metric = ISNULL(@MetricID, Metric)
		AND SQLServerID = ISNULL(@SQLServerID, SQLServerID)
	)		
	SELECT t.SQLServerID, t.MetricID, T2.InfoThreshold.query('.') AS InfoThreshold FROM T t
	CROSS APPLY t.InfoThreshold.nodes('/Threshold/Value/anyType/text()') AS T2(InfoThreshold)
	UNION ALL
	SELECT t.SQLServerID, t.MetricID, T2.InfoThreshold.query('.') AS InfoThreshold FROM T t
	CROSS APPLY t.InfoThreshold.nodes('/Threshold/Value/text()') AS T2(InfoThreshold);

	with T(SQLServerID, MetricID, WarningThreshold) AS 
	(SELECT mi.SQLServerID, mi.Metric, 
		CONVERT(XML, mi.WarningThreshold)
	FROM MetricThresholds mi
	WHERE Metric = ISNULL(@MetricID, Metric)
		AND SQLServerID = ISNULL(@SQLServerID, SQLServerID)
	)		
	SELECT t.SQLServerID, t.MetricID, T2.WarningThreshold.query('.') AS WarningThreshold FROM T t
	CROSS APPLY t.WarningThreshold.nodes('/Threshold/Value/anyType/text()') AS T2(WarningThreshold)
	UNION ALL
	SELECT t.SQLServerID, t.MetricID, T2.WarningThreshold.query('.') AS WarningThreshold FROM T t
	CROSS APPLY t.WarningThreshold.nodes('/Threshold/Value/text()') AS T2(WarningThreshold);
	
	with T(SQLServerID, MetricID, CriticalThreshold) AS 
	(SELECT mi.SQLServerID, mi.Metric, 
		CONVERT(XML, mi.CriticalThreshold)
	FROM MetricThresholds mi
	WHERE Metric = ISNULL(@MetricID, Metric)
		AND SQLServerID = ISNULL(@SQLServerID, SQLServerID)
	)
	SELECT t.SQLServerID, t.MetricID, T2.CriticalThreshold.query('.') AS CriticalThreshold FROM T t
	CROSS APPLY t.CriticalThreshold.nodes('/Threshold/Value/anyType/text()') AS T2(CriticalThreshold)
	UNION ALL
	SELECT t.SQLServerID, t.MetricID, T2.CriticalThreshold.query('.') AS CriticalThreshold FROM T t
	CROSS APPLY t.CriticalThreshold.nodes('/Threshold/Value/text()') AS T2(CriticalThreshold);
END
 
GO 

---------- P_GETMIRROREDDATABASES.SQL
if (object_id('p_GetMirroredDatabases') is not null)
begin
drop procedure p_GetMirroredDatabases
end
go

Create PROCEDURE [dbo].[p_GetMirroredDatabases]
 @SQLServerIDs nvarchar(4000) = null,
 @addSelectRequest bit = 0
	-- Add the parameters for the stored procure here
AS
BEGIN
declare @xmlDoc int

if @SQLServerIDs is not null 
Begin
	declare @SQLServers table(
			SQLServerID int) 

	-- Prepare XML document if there is one
	exec sp_xml_preparedocument @xmlDoc output, @SQLServerIDs

	insert into @SQLServers
	select
		ID 
	from openxml(@xmlDoc, '//Srvrs/Srvr', 1)
		with (ID int)
end
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	

create table #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

insert into #SecureMonitoredSQLServers
exec [p_GetReportServers]	

if @addSelectRequest=1
	begin
		declare @Databases table (DatabaseName nvarchar(510), DatabaseID int)
		Insert @Databases
		select distinct dbs.DatabaseName, dbs.DatabaseID 
				from MirroringParticipants mp (nolock)
				inner join SQLServerDatabaseNames dbs (nolock) on mp.DatabaseID = dbs.DatabaseID
				inner join #SecureMonitoredSQLServers mss (nolock) on mss.SQLServerID = dbs.SQLServerID 
		where dbs.SQLServerID in (select SQLServerID from @SQLServers)
				or @SQLServerIDs is NULL and dbs.[SQLServerID] = dbs.[SQLServerID]
		if @@rowcount = 0
			SELECT '< No Mirrored Databases >' as DatabaseName, 0 as DatabaseID
			union
			Select DatabaseName, DatabaseID from @Databases
		else
			SELECT '< All >' as DatabaseName, 0 as DatabaseID
			union
			Select DatabaseName, DatabaseID from @Databases
	end
	else
	begin
    -- Insert statements for procedure here
		select distinct dbs.DatabaseName, dbs.DatabaseID 
				from MirroringParticipants mp (nolock)
				inner join SQLServerDatabaseNames dbs (nolock) on mp.DatabaseID = dbs.DatabaseID
				inner join #SecureMonitoredSQLServers mss (nolock) on mss.SQLServerID = dbs.SQLServerID 
		where dbs.SQLServerID in (select SQLServerID from @SQLServers)
				or @SQLServerIDs is NULL and dbs.[SQLServerID] = dbs.[SQLServerID]
	end
END
 
GO 

---------- P_GETMIRRORINGHISTORY.SQL
if (object_id('p_GetMirroringHistory') is not null)
begin
drop procedure [p_GetMirroringHistory]
end
go

CREATE PROCEDURE [dbo].[p_GetMirroringHistory] 
	-- Add the parameters for the stored procedure here
    @problemsOnly bit = 0,
	@server varchar(255) = null,
	@fromDate DateTime = null,
	@toDate DateTime = null,
	@databaseName nvarchar(255) = null,
	@SQLServerIDs nvarchar(max) = null,
	@UTCOffset int = 0
AS
BEGIN
	declare @xmlDoc int

	if @SQLServerIDs is not null 
	Begin
		declare @SQLServers table(
				SQLServerID int) 

		-- Prepare XML document if there is one
		exec sp_xml_preparedocument @xmlDoc output, @SQLServerIDs

		insert into @SQLServers
		select
			ID 
		from openxml(@xmlDoc, '//Srvr', 1)
			with (ID int)
	end

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
create table #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

insert into #SecureMonitoredSQLServers
exec [p_GetReportServers]	
	
create table #NumericAlertThresholds (MetricID int, SQLServerID int, Op nvarchar(16), InfoThreshold int, WarningThreshold int, CriticalThreshold int) 
create table #EnumAlertThresholds (MetricID int, SQLServerID int, InfoThreshold nvarchar(200), WarningThreshold nvarchar(200), CriticalThreshold nvarchar(200)) 

insert into #NumericAlertThresholds exec p_GetAlertThresholdsForNumerics 68
insert into #NumericAlertThresholds exec p_GetAlertThresholdsForNumerics 69
insert into #NumericAlertThresholds exec p_GetAlertThresholdsForNumerics 70
insert into #NumericAlertThresholds exec p_GetAlertThresholdsForNumerics 71
insert into #NumericAlertThresholds exec p_GetAlertThresholdsForNumerics 73
insert into #EnumAlertThresholds exec p_GetAlertThresholdsForEnums 72
insert into #EnumAlertThresholds exec p_GetAlertThresholdsForEnums 75

select ms.DatabaseID, 
'role' = case ms.role when 2 then 'Mirror' when 1 then 'Principal' else 'Unknown' end, 
dbs.DatabaseName, 
svr.InstanceName,
'mirroring_state' = 
case ms.mirroring_state 
when 0 then 'Suspended' 
when 1 then 'Disconnected'
when 2 then 'Synchronizing'
when 3 then 'Pending Failover'
when 4 then 'Synchronized'
else 'Unknown' end,
'Witness Status' = case ms.witness_status
when 0 then 'No Witness'
when 1 then 'Connected'
when 2 then 'Disconnected' end,
log_generation_rate,
unsent_log,
send_rate,
unrestored_log,
recovery_rate,
transaction_delay,
transactions_per_sec,
average_delay,
dateadd(mi, @UTCOffset, UTCCollectionDateTime) as [CollectionTime],
time_behind,
isnull(m68.InfoThreshold,9999) as m68info,
isnull(m68.WarningThreshold,9999) as m68warn,
isnull(m68.CriticalThreshold,9999) as m68crit,
isnull(m69.InfoThreshold,9999) as m69info,
isnull(m69.WarningThreshold,9999) as m69warn,
isnull(m69.CriticalThreshold,9999) as m69crit,
isnull(m70.InfoThreshold,9999) as m70info,
isnull(m70.WarningThreshold,9999) as m70warn,
isnull(m70.CriticalThreshold,9999) as m70crit,
isnull(m71.InfoThreshold,9999) as m71info,
isnull(m71.WarningThreshold,9999) as m71warn,
isnull(m71.CriticalThreshold,9999) as m71crit,
isnull(m73.InfoThreshold,9999) as m73info,
isnull(m73.WarningThreshold,9999) as m73warn,
isnull(m73.CriticalThreshold,9999) as m73crit,
isnull(m72.InfoThreshold,9999) as m72info,
isnull(m72.WarningThreshold,'') as m72warn,
isnull(m72.CriticalThreshold,'') as m72crit,
isnull(m75.InfoThreshold,9999) as m75info,
isnull(m75.WarningThreshold,'') as m75warn,
isnull(m75.CriticalThreshold,'') as m75crit,
'PreferredStatus' = case mpc.NormalConfiguration 
when 1 then case ms.role 
			when 2 then case mpc.MirrorInstanceID 
						when svr.SQLServerID then 'Normal' 
						else 'Failed Over' 
						end 
			when 1 then case mpc.PrincipalInstanceID 
						when svr.SQLServerID then 'Normal' 
						else 'Failed Over' 
						end
			end
when 0 then case ms.role 
			when 1 then case mpc.MirrorInstanceID 
						when svr.SQLServerID then 'Normal' 
						else 'Failed Over' 
						end 
			when 2 then case mpc.PrincipalInstanceID 
						when svr.SQLServerID then 'Normal' 
						else 'Failed Over' 
						end
			end
end
from MirroringStatistics ms (nolock) 
inner join SQLServerDatabaseNames dbs (nolock) on ms.DatabaseID = dbs.DatabaseID
inner join #SecureMonitoredSQLServers svr (nolock) on svr.SQLServerID = dbs.SQLServerID 
left outer join #NumericAlertThresholds m68 on m68.SQLServerID = svr.SQLServerID and m68.MetricID = 68
left outer join #NumericAlertThresholds m69 on m69.SQLServerID = svr.SQLServerID and m69.MetricID = 69
left outer join #NumericAlertThresholds m70 on m70.SQLServerID = svr.SQLServerID and m70.MetricID = 70
left outer join #NumericAlertThresholds m71 on m71.SQLServerID = svr.SQLServerID and m71.MetricID = 71
left outer join #NumericAlertThresholds m73 on m73.SQLServerID = svr.SQLServerID and m73.MetricID = 73
left outer join #EnumAlertThresholds m72 on m72.SQLServerID = svr.SQLServerID and m72.MetricID = 72
left outer join #EnumAlertThresholds m75 on m75.SQLServerID = svr.SQLServerID and m75.MetricID = 75
left outer join MirroringPreferredConfig mpc (nolock) on mpc.MirroringGuid = ms.mirroring_guid
where dbo.fn_RoundDateTime(1, UTCCollectionDateTime) >= isnull(@fromDate,'1 Jan 1900') 
and dbo.fn_RoundDateTime(1, UTCCollectionDateTime) < isnull(@toDate,'1 Jan 2200') 
and Lower(svr.InstanceName) = coalesce(Lower(@server), Lower(svr.InstanceName))
and (svr.[SQLServerID] in (select SQLServerID from @SQLServers)
		or @SQLServerIDs is NULL and svr.[SQLServerID] = svr.[SQLServerID])
and dbs.DatabaseName = isnull(@databaseName, dbs.DatabaseName)
and (@problemsOnly = 1 and 
(
unsent_log >= m68.InfoThreshold 
or unrestored_log >= m69.InfoThreshold
or DateDiff(n, time_behind, time_recorded) >= m70.InfoThreshold
or average_delay >= m71.InfoThreshold
or 
(ms.mirroring_state = 0 and charindex('Suspended', m72.InfoThreshold + m72.WarningThreshold + m72.CriticalThreshold) > 0
 or ms.mirroring_state = 1 and charindex('Disconnected', m72.InfoThreshold + m72.WarningThreshold + m72.CriticalThreshold) > 0
or ms.mirroring_state = 2 and charindex('Synchronizing', m72.InfoThreshold + m72.WarningThreshold + m72.CriticalThreshold) > 0
or ms.mirroring_state = 3 and charindex('PendingFailover', m72.InfoThreshold + m72.WarningThreshold + m72.CriticalThreshold) > 0
or ms.mirroring_state = 4 and charindex('Synchronized', m72.InfoThreshold + m72.WarningThreshold + m72.CriticalThreshold) > 0)
or
  ((m73.CriticalThreshold = 1 or m73.WarningThreshold = 1 or m73.InfoThreshold = 1) 
    and ((mpc.NormalConfiguration = 1 and not((ms.role = 2  and mpc.MirrorInstanceID = svr.SQLServerID) or (ms.role = 1 and mpc.PrincipalInstanceID = svr.SQLServerID))) 
      or(mpc.NormalConfiguration = 0 and not((ms.role = 1  and mpc.MirrorInstanceID = svr.SQLServerID) or (ms.role = 2 and mpc.PrincipalInstanceID = svr.SQLServerID)))
  ))
or ((m75.CriticalThreshold = 1 or m75.WarningThreshold = 1 or m75.InfoThreshold = 1)	and ms.witness_status = 2)) 
or (@problemsOnly = 0))
order by local_time desc

drop table #NumericAlertThresholds
drop table #EnumAlertThresholds
if @SQLServerIDs is not null
	exec sp_xml_removedocument @xmlDoc
END
 
 
GO 

---------- P_GETMIRRORINGPARTICIPANTSFORSERVER.SQL
if (object_id('p_GetMirroringParticipantsForServer') is not null)
begin
drop procedure [p_GetMirroringParticipantsForServer]
end
go


Create procedure p_GetMirroringParticipantsForServer
@serverID int
as

begin
select 'ServerID' = coalesce(mirror_instanceID, principal_instanceID),
mirroring_guid
from MirroringParticipants (nolock)
where @serverID = case role when 1 then principal_instanceID else mirror_instanceID end
end
 
GO 

---------- P_GETMIRRORINGPREFERREDCONFIG.SQL
if (object_id('p_GetMirroringPreferredConfig') is not null)
begin
drop procedure [p_GetMirroringPreferredConfig]
end
go


CREATE procedure [dbo].[p_GetMirroringPreferredConfig] as

SELECT [MirroringGuid]
      ,[MirrorInstanceID]
      ,[PrincipalInstanceID]
      ,[NormalConfiguration]
	  ,[DatabaseName]
      ,[WitnessAddress]
  FROM [MirroringPreferredConfig] (nolock)



 
GO 

---------- P_GETMIRRORINGSERVERSTATUS.SQL
IF (object_id('p_GetMirroringServerStatus') IS NOT NULL)
BEGIN
DROP PROCEDURE p_GetMirroringServerStatus
END
GO

CREATE PROCEDURE [dbo].[p_GetMirroringServerStatus] 
	-- Add the parameters for the stored procedure here
	@problemsOnly bit,
	@SQLServerIDs nvarchar(max) = null
AS
BEGIN

declare @xmlDoc int

if @SQLServerIDs is not null 
Begin
	declare @SQLServers table(
			SQLServerID int) 

	-- Prepare XML document if there is one
	exec sp_xml_preparedocument @xmlDoc output, @SQLServerIDs

	insert into @SQLServers
	select
		ID 
	from openxml(@xmlDoc, '//Srvr', 1)
		with (ID int)
end

create table #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

insert into #SecureMonitoredSQLServers
exec [p_GetReportServers]	

create table #NumericAlertThresholds (MetricID int, SQLServerID int, Op nvarchar(16), InfoThreshold int, WarningThreshold int, CriticalThreshold int) 
create table #EnumAlertThresholds (MetricID int, SQLServerID int, InfoThreshold nvarchar(200), WarningThreshold nvarchar(200), CriticalThreshold nvarchar(200)) 

insert into #NumericAlertThresholds exec p_GetAlertThresholdsForNumerics 73
insert into #EnumAlertThresholds exec p_GetAlertThresholdsForEnums 72
insert into #EnumAlertThresholds exec p_GetAlertThresholdsForEnums 75

select mss.InstanceName, 
db.DatabaseName, 
'mirroring_state' = case mp.mirroring_state 
when 0 then 'Suspended' 
when 1 then 'Disconnected'
when 2 then 'Synchronizing'
when 3 then 'Pending Failover'
when 4 then 'Synchronized'
else 'Unknown' end, 
'role' = case mp.role 
when 1 then 'Principal' 
when 2 then 'Mirror' end,
mp.witness_address,
'witness_status' = case mp.witness_status 
when 0 then 'No Witness' 
when 1 then 'Connected' 
when 2 then 'Disconnected' end,
'Operational Status' = case mpc.NormalConfiguration 
when 0 then 'Failed Over' 
when 1 then 'Normal' 
else 'Not set' end,
'Safety Level' = case mp.safety_level 
when 0 then 'Unknown'
when 1 then 'Off'
when 2 then 'Full' end,
m73.InfoThreshold as m73info,
m73.WarningThreshold as m73warn,
m73.CriticalThreshold as m73crit,
isnull(m72.InfoThreshold,'') as m72info,
isnull(m72.WarningThreshold,'') as m72warn,
isnull(m72.CriticalThreshold,'') as m72crit,
isnull(m75.InfoThreshold,'') as m75info,
isnull(m75.WarningThreshold,'') as m75warn,
isnull(m75.CriticalThreshold,'') as m75crit,
mss.MaintenanceModeEnabled
from MirroringParticipants mp (nolock)
inner join SQLServerDatabaseNames db (nolock) on mp.DatabaseID = db.DatabaseID
left outer join #SecureMonitoredSQLServers smss (nolock) on db.SQLServerID = smss.SQLServerID
left outer join MonitoredSQLServers mss (nolock) on smss.SQLServerID = mss.SQLServerID
left outer join MirroringPreferredConfig mpc (nolock) on mpc.MirroringGuid = mp.mirroring_guid
left outer join #NumericAlertThresholds m73 on m73.SQLServerID = mss.SQLServerID and m73.MetricID = 73
left outer join #EnumAlertThresholds m72 on m72.SQLServerID = mss.SQLServerID and m72.MetricID = 72
left outer join #EnumAlertThresholds m75 on m75.SQLServerID = mss.SQLServerID and m75.MetricID = 75 
where (mss.[SQLServerID] in (select SQLServerID from @SQLServers)
		or (@SQLServerIDs is NULL and mss.[SQLServerID] = mss.[SQLServerID]))
and (@problemsOnly = 1 and 
(
(mp.mirroring_state = 0 and charindex('Suspended', m72.InfoThreshold + m72.WarningThreshold + m72.CriticalThreshold) > 0
 or mp.mirroring_state = 1 and charindex('Disconnected', m72.InfoThreshold + m72.WarningThreshold + m72.CriticalThreshold) > 0
or mp.mirroring_state = 2 and charindex('Synchronizing', m72.InfoThreshold + m72.WarningThreshold + m72.CriticalThreshold) > 0
or mp.mirroring_state = 3 and charindex('PendingFailover', m72.InfoThreshold + m72.WarningThreshold + m72.CriticalThreshold) > 0
or mp.mirroring_state = 4 and charindex('Synchronized', m72.InfoThreshold + m72.WarningThreshold + m72.CriticalThreshold) > 0)
)
or ((m73.CriticalThreshold = 1 or m73.WarningThreshold = 1 or m73.InfoThreshold = 1) 
    and ((mpc.NormalConfiguration = 1 and not((mp.role = 2  and mpc.MirrorInstanceID = mss.SQLServerID) or (mp.role = 1 and mpc.PrincipalInstanceID = mss.SQLServerID))) 
      or(mpc.NormalConfiguration = 0 and not((mp.role = 1  and mpc.MirrorInstanceID = mss.SQLServerID) or (mp.role = 2 and mpc.PrincipalInstanceID = mss.SQLServerID)))
  ))
or ((m75.CriticalThreshold = 1 or m75.WarningThreshold = 1 or m75.WarningThreshold = 1) and mp.witness_status = 2)
	or (@problemsOnly = 0))
and mss.Active = 1

order by db.DatabaseName, mss.InstanceName

drop table #EnumAlertThresholds
drop table #NumericAlertThresholds
if @SQLServerIDs is not null
	exec sp_xml_removedocument @xmlDoc
END
 
 
GO 

---------- P_GETMIRRORINGSESSIONS.SQL
IF (object_id('p_GetMirroringSessions') IS NOT NULL)
BEGIN
DROP PROCEDURE p_GetMirroringSessions
END
GO

CREATE PROCEDURE [dbo].[p_GetMirroringSessions]
	-- Add the parameters for the stored procedure here
	@problemsOnly bit,
	@SQLServerIDs nvarchar(max) = null
AS
BEGIN
declare @xmlDoc int

if @SQLServerIDs is not null 
Begin
	declare @SQLServers table(
			SQLServerID int) 

	-- Prepare XML document if there is one
	exec sp_xml_preparedocument @xmlDoc output, @SQLServerIDs

	insert into @SQLServers
	select
		ID 
	from openxml(@xmlDoc, '//Srvr', 1)
		with (ID int)
end

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
create table #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int, Active bit, MaintenanceModeEnabled bit)

insert into #SecureMonitoredSQLServers(InstanceName,SQLServerID)
exec [p_GetReportServers]	

update #SecureMonitoredSQLServers 
set Active = mss.Active,
MaintenanceModeEnabled = mss.MaintenanceModeEnabled
from #SecureMonitoredSQLServers smss
inner join MonitoredSQLServers mss
on smss.SQLServerID = mss.SQLServerID

-- Insert statements for procedure here
create table #EnumAlertThresholds (MetricID int, SQLServerID int, InfoThreshold nvarchar(200), WarningThreshold nvarchar(200), CriticalThreshold nvarchar(200)) 
insert into #EnumAlertThresholds exec p_GetAlertThresholdsForEnums 72
create table #NumericAlertThresholds (MetricID int, SQLServerID int, Op nvarchar(16), InfoThreshold int, WarningThreshold int, CriticalThreshold int) 
insert into #NumericAlertThresholds exec p_GetAlertThresholdsForNumerics 73

select 'Principal' = isnull(mp.InstanceName, mirrors.partner_instance),
'Mirror' = isnull(mm.InstanceName, principals.partner_instance), 
'DatabaseName' = isnull(dbs.DatabaseName, mdbs.DatabaseName),
mirrors.principal_address,
principals.Mirror_address,
'witness_address' = 
case isnull(principals.witness_address, mirrors.witness_address) 
when '' then 'No Witness' 
else isnull(principals.witness_address, mirrors.witness_address) end,
'Safety Level' = case isnull(principals.safety_level, mirrors.safety_level)
when 0 then 'Unknown'
when 1 then 'Off'
when 2 then 'Full' end,
'is_suspended' = isnull(principals.is_suspended, mirrors.is_suspended),
'mirroring_state' = 
case isnull(principals.mirroring_state, mirrors.mirroring_state)
when 0 then 'Suspended' 
when 1 then 'Disconnected'
when 2 then 'Synchronizing'
when 3 then 'Pending Failover'
when 4 then 'Synchronized'
else 'Unknown' end,
'Witness Status' = case isnull(principals.witness_status,mirrors.witness_status)
when 0 then 'No Witness'
when 1 then 'Connected'
when 2 then 'Disconnected' end,
isnull(m72p.InfoThreshold,'') as m72info,
isnull(m72p.WarningThreshold,'') as m72warn,
isnull(m72p.CriticalThreshold,'') as m72crit,
isnull(m72m.InfoThreshold,'') as m72minfo,
isnull(m72m.WarningThreshold,'') as m72mwarn,
isnull(m72m.CriticalThreshold,'') as m72mcrit,
isnull(m73.InfoThreshold,'') as m73info,
isnull(m73.WarningThreshold,'') as m73warn,
isnull(m73.CriticalThreshold,'') as m73crit,
'PrincipalMaintMode' = mp.MaintenanceModeEnabled,
'MirrorMaintMode' = mm.MaintenanceModeEnabled,
'WitnessAddress' = coalesce(principals.witness_address, mirrors.witness_address, mpc.WitnessAddress),
'Normal' = case mpc.NormalConfiguration when 1 then (mpc.MirrorInstanceID & mm.SQLServerID) | (mpc.PrincipalInstanceID & mp.SQLServerID) when 0 then (mpc.MirrorInstanceID & mp.SQLServerID) | (mpc.PrincipalInstanceID & mm.SQLServerID) end
from MirroringParticipants principals (nolock)
inner join #SecureMonitoredSQLServers mp (nolock) on principals.principal_instanceID = mp.SQLServerID and principals.role = 1
inner join SQLServerDatabaseNames dbs (nolock) on principals.DatabaseID = dbs.DatabaseID
full outer join MirroringParticipants mirrors (nolock) on principals.mirroring_guid = mirrors.mirroring_guid and mirrors.role = 2
left outer join #SecureMonitoredSQLServers mm (nolock) on mirrors.mirror_instanceID = mm.SQLServerID
left outer join SQLServerDatabaseNames mdbs (nolock) on mirrors.DatabaseID = mdbs.DatabaseID
left outer join #EnumAlertThresholds m72p on m72p.SQLServerID = mp.SQLServerID and m72p.MetricID = 72
left outer join #EnumAlertThresholds m72m on m72m.SQLServerID = mm.SQLServerID and m72m.MetricID = 72
left outer join #NumericAlertThresholds m73 on m73.SQLServerID = mp.SQLServerID and m73.MetricID = 73
left outer join MirroringPreferredConfig mpc on mpc.MirroringGuid = principals.mirroring_guid
where (principals.principal_instanceID is not null or mirrors.mirror_instanceID is not null)
and (

	  (@problemsOnly = 1 and 
	  (
	    (
		  principals.mirroring_state = 0 and charindex('Suspended', m72p.InfoThreshold + m72p.WarningThreshold + m72p.CriticalThreshold) > 0
	      or principals.mirroring_state = 1 and charindex('Disconnected', m72p.InfoThreshold + m72p.WarningThreshold + m72p.CriticalThreshold) > 0
	      or principals.mirroring_state = 2 and charindex('Synchronizing', m72p.InfoThreshold + m72p.WarningThreshold + m72p.CriticalThreshold) > 0
	      or principals.mirroring_state = 3 and charindex('PendingFailover', m72p.InfoThreshold + m72p.WarningThreshold + m72p.CriticalThreshold) > 0
	      or principals.mirroring_state = 4 and charindex('Synchronized', m72p.InfoThreshold + m72p.WarningThreshold + m72p.CriticalThreshold) > 0
		) 
		or
		 ((m73.CriticalThreshold = 1 or m73.WarningThreshold = 1 or m73.InfoThreshold = 1) 
			and (
					(
						mpc.NormalConfiguration = 1 and not((mpc.MirrorInstanceID = mm.SQLServerID) or (mpc.PrincipalInstanceID = mp.SQLServerID))) 
						or(mpc.NormalConfiguration = 0 and not((mpc.MirrorInstanceID = mp.SQLServerID) or (mpc.PrincipalInstanceID = mm.SQLServerID)))
						or(mpc.WitnessAddress <> coalesce(principals.witness_address, mirrors.witness_address, mpc.WitnessAddress)
					)
		  ))
	 )
)
		or @problemsOnly = 0
    )
and ((mp.[SQLServerID] in (select SQLServerID from @SQLServers)
		or @SQLServerIDs is NULL and mp.[SQLServerID] = mp.[SQLServerID])
or (mm.[SQLServerID] in (select SQLServerID from @SQLServers)
		or @SQLServerIDs is NULL and mm.[SQLServerID] = mm.[SQLServerID]))
and (mp.Active = 1 or mm.Active = 1)
drop table #EnumAlertThresholds 
drop table #NumericAlertThresholds
if @SQLServerIDs is not null
	exec sp_xml_removedocument @xmlDoc
END
 
GO 

---------- P_GETMONITOREDALWAYSONSERVERS.SQL
------------------------------------------------------------------------------
-- <copyright file="p_GetMonitoredAlwaysOnServers.sql" company="Idera, Inc.">
--     Copyright (c) Idera, Inc. All rights reserved.
-- </copyright>
------------------------------------------------------------------------------

IF (object_id('p_GetMonitoredAlwaysOnServers') IS NOT NULL)
BEGIN
DROP PROCEDURE p_GetMonitoredAlwaysOnServers
END
GO
CREATE PROCEDURE [dbo].[p_GetMonitoredAlwaysOnServers] 
	 @tagID int = 0
	 ,@availabilityGroupName nvarchar(128)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	IF (object_id('#SecureMonitoredSQLServers') IS NOT NULL)
	BEGIN
	    DROP TABLE #SecureMonitoredSQLServers
	END
	CREATE TABLE #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

	INSERT INTO #SecureMonitoredSQLServers
	EXEC [p_GetReportServers] 
	
	DECLARE @Servers TABLE (InstanceName nvarchar(512), SQLServerID int)
	
	IF @tagID = 0
	BEGIN
		INSERT @Servers
		SELECT DISTINCT AOR.ReplicaName as InstanceName, AOR.SQLServerID as SQLServerID
			FROM AlwaysOnStatistics AS AOS (nolock)
			INNER JOIN AlwaysOnReplicas AS AOR (nolock) ON AOR.GroupId=AOS.GroupId AND AOR.ReplicaId=AOS.ReplicaId
			INNER JOIN AlwaysOnAvailabilityGroups AS AOG (nolock) ON AOG.GroupId = AOS.GroupId
			INNER JOIN #SecureMonitoredSQLServers AS smss ON smss.SQLServerID = AOR.SQLServerID
			WHERE @availabilityGroupName=AOG.GroupName 
                AND AOR.[Delete] = 0
	END
	ELSE
	BEGIN	
		INSERT @Servers
		SELECT DISTINCT AOR.ReplicaName AS InstanceName, AOR.SQLServerID AS SQLServerID
			FROM AlwaysOnStatistics AS AOS (nolock)
			INNER JOIN AlwaysOnReplicas AS AOR (nolock) ON AOR.GroupId=AOS.GroupId AND AOR.ReplicaId=AOS.ReplicaId
			INNER JOIN AlwaysOnAvailabilityGroups AS AOG (nolock) ON AOG.GroupId = AOS.GroupId
			INNER JOIN #SecureMonitoredSQLServers AS smss ON smss.SQLServerID = AOR.SQLServerID
			INNER JOIN ServerTags AS st (nolock) ON AOR.SQLServerID=st.SQLServerId
			WHERE @availabilityGroupName=AOG.GroupName AND @tagID = st.TagId 
                AND AOR.[Delete] = 0
	END
		
		IF @@rowcount = 0
			SELECT '< Select a Server >' as InstanceName, 0 as SQLServerID
		ELSE
			SELECT '< All >' as InstanceName, 0 as SQLServerID
			UNION
			SELECT InstanceName, SQLServerID FROM @Servers
END
 
GO 

---------- P_GETMONITOREDMIRROREDSERVERS.SQL
IF (object_id('p_GetMonitoredMirroredServers') IS NOT NULL)
BEGIN
DROP PROCEDURE p_GetMonitoredMirroredServers
END
GO

CREATE PROCEDURE [dbo].[p_GetMonitoredMirroredServers] 
	-- Add the parameters for the stored procedure here
	 @addSelectRequest bit = 0,
	 @tagID int = null
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	create table #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

	insert into #SecureMonitoredSQLServers
	exec [p_GetReportServers]

	if @addSelectRequest = 1
	begin
		declare @Servers table (InstanceName nvarchar(512), SQLServerID int)

		Insert @Servers
		select distinct smss.InstanceName, smss.SQLServerID 
			from MirroringParticipants mp (nolock)
			inner join SQLServerDatabaseNames dbs (nolock) on mp.DatabaseID = dbs.DatabaseID
			inner join #SecureMonitoredSQLServers smss (nolock) on smss.SQLServerID = dbs.SQLServerID
			left outer join ServerTags st (nolock) on st.SQLServerId = smss.SQLServerID
			where st.TagId = isnull(@tagID, st.TagId) or (@tagID is null and st.TagId is null)
		if @@rowcount = 0
			SELECT '< No Mirrored Servers >' as InstanceName, 0 as SQLServerID
			union
			Select InstanceName, SQLServerID from @Servers
		else
			SELECT '< All >' as InstanceName, 0 as SQLServerID
			union
			Select InstanceName, SQLServerID from @Servers
	end
	else
	begin
    -- Insert statements for procedure here
		select distinct smss.InstanceName, smss.SQLServerID 
			from MirroringParticipants mp (nolock)
			inner join SQLServerDatabaseNames dbs (nolock) on mp.DatabaseID = dbs.DatabaseID
			inner join #SecureMonitoredSQLServers smss (nolock) on smss.SQLServerID = dbs.SQLServerID
			left outer join ServerTags st (nolock) on st.SQLServerId = smss.SQLServerID
			where st.TagId = isnull(@tagID, st.TagId) or (@tagID is null and st.TagId is null)
	end
END
 
GO 

---------- P_GETMONITOREDSERVERSSUMMARY.SQL
IF (object_id('p_GetMonitoredServersSummary') is not null)
BEGIN
	DROP PROCEDURE [p_GetMonitoredServersSummary]
END
GO

--EXEC [p_GetMonitoredServersSummary]

create procedure [dbo].[p_GetMonitoredServersSummary]
	@SQLServerID int = null,
	@UTCSnapshotCollectionDateTime datetime = null,
	@HistoryInMinutes int = null
as
BEGIN
set transaction isolation level read uncommitted
declare @err int
declare @BeginDateTime datetime
declare @EndDateTime datetime

declare @InstancesByMaxCollectionTime TABLE (
InstanceID int, 
UTCCollectionDateTime DateTime)


declare @ServerActivityByMaxCollectionTime TABLE (  
InstanceID int,   
UTCCollectionDateTime DateTime)  
  
INSERT INTO @InstancesByMaxCollectionTime  
SELECT mss.SQLServerID, MAX(ss.UTCCollectionDateTime) FROM MonitoredSQLServers mss (NOLOCK)  
LEFT OUTER JOIN [ServerStatistics] ss (NOLOCK) ON mss.SQLServerID = ss.SQLServerID  
WHERE mss.Active = 1 AND (@SQLServerID IS NULL OR mss.SQLServerID = @SQLServerID)   
GROUP BY mss.SQLServerID  
  
--START SQLdm 9.1 (Sanjali Makkar): Gets Health Index coefficients for specific alerts   
INSERT INTO @ServerActivityByMaxCollectionTime  
SELECT mss.SQLServerID, MAX(sa.UTCCollectionDateTime) UTCCollectionDateTime FROM MonitoredSQLServers mss (NOLOCK)  
LEFT OUTER JOIN ServerActivity sa (NOLOCK) ON mss.SQLServerID = sa.SQLServerID  
WHERE mss.Active = 1 AND (@SQLServerID IS NULL OR mss.SQLServerID = @SQLServerID) AND sa.StateOverview IS NOT NULL
GROUP BY mss.SQLServerID  

-- Get state overview data  
SELECT ibmct.InstanceID, sa.[StateOverview], mss.HealthIndexCoefficientForCriticalAlert,  
mss.HealthIndexCoefficientForWarningAlert, mss.HealthIndexCoefficientForInformationalAlert  
from ServerActivity sa JOIN @ServerActivityByMaxCollectionTime samax ON sa.UTCCollectionDateTime = samax.UTCCollectionDateTime
INNER JOIN @InstancesByMaxCollectionTime ibmct on ibmct.InstanceID = sa.SQLServerID
INNER JOIN MonitoredSQLServers mss  
ON mss.SQLServerID = ibmct.InstanceID  
--END SQLdm 9.1 (Sanjali Makkar): Gets Health Index coefficients for specific alerts   
-- Get trend data
;with cte_waitdata as
(
select
	pvt.InstanceID,
	pvt.UTCCollectionDateTime,
	[I/O],
	[Lock],
	[Memory],
	[Transaction Log],
	[Other],
	[Signal] = sum(WaitTimeInMilliseconds-ResourceWaitTimeInMilliseconds) / nullif(TimeDeltaInSeconds,0)
from
	(
	select
		ibmct.InstanceID,
		ibmct.UTCCollectionDateTime,
		Category = case when Category in ('I/O','Lock','Memory','Transaction Log') then Category else 'Other' end,
		ResourceWaitTimeMSPerSec = sum(ResourceWaitTimeInMilliseconds) / nullif(TimeDeltaInSeconds,0)
	from
		WaitStatisticsDetails wsd (NOLOCK)
		inner join WaitTypes wt (NOLOCK) on wt.WaitTypeID = wsd.WaitTypeID
		inner join WaitStatistics ws (NOLOCK) on ws.WaitStatisticsID = wsd.WaitStatisticsID
		INNER JOIN @InstancesByMaxCollectionTime ibmct on ibmct.InstanceID = ws.SQLServerID
		inner join WaitCategories wc (NOLOCK) on wt.CategoryID = wc.CategoryID
	where
		wc.ExcludeFromCollection = 0 and
		ws.[UTCCollectionDateTime] = ibmct.UTCCollectionDateTime
	group by
		case when Category in ('I/O','Lock','Memory','Transaction Log') then Category else 'Other' end,
		ibmct.InstanceID,
		ibmct.UTCCollectionDateTime,
		TimeDeltaInSeconds
	) as PivotSource
pivot
	(
	sum(ResourceWaitTimeMSPerSec)
	for Category 
	in([I/O],[Lock],[Memory],[Transaction Log],[Other])
	) as pvt
inner join WaitStatistics ws2 (NOLOCK)
on pvt.UTCCollectionDateTime = ws2.UTCCollectionDateTime
	and pvt.InstanceID = ws2.SQLServerID
inner join WaitStatisticsDetails wsd2 (NOLOCK)
on ws2.WaitStatisticsID = wsd2.WaitStatisticsID
group by
	ws2.UTCCollectionDateTime, 
	ws2.TimeDeltaInSeconds,
	pvt.InstanceID,
	pvt.UTCCollectionDateTime,
	[I/O],
	[Lock],
	[Memory],
	[Transaction Log],
	[Other]
), cte_TempdbFileData (InstanceID, UTCCollectionDateTime, UserObjectsInKilobytes, InternalObjectsInKilobytes,VersionStoreInKilobytes,MixedExtentsInKilobytes,UnallocatedSpaceInKilobytes)as
(
select
ibmct.InstanceID,
ibmct.UTCCollectionDateTime,
sum(UserObjectsInKilobytes),
sum(InternalObjectsInKilobytes),
sum(VersionStoreInKilobytes),
sum(MixedExtentsInKilobytes),
sum(UnallocatedSpaceInKilobytes)
from @InstancesByMaxCollectionTime ibmct 
inner join SQLServerDatabaseNames (NOLOCK) on ibmct.InstanceID = SQLServerDatabaseNames.SQLServerID
inner join DatabaseFiles (NOLOCK) on SQLServerDatabaseNames.DatabaseID = DatabaseFiles.DatabaseID
inner join TempdbFileData(NOLOCK) on TempdbFileData.FileID = DatabaseFiles.FileID
where
	TempdbFileData.UTCCollectionDateTime = ibmct.UTCCollectionDateTime
group by
ibmct.InstanceID,
ibmct.UTCCollectionDateTime
)
select
	MonitoredSQLServers.SQLServerID
	,[InstanceName]
	,[ServerStatistics].[UTCCollectionDateTime] as [CollectionDateTime]
	,[ActiveProcesses]
	,[AgentServiceStatus]
	,[BlockedProcesses]
	,[BufferCacheHitRatioPercentage]
	,[BufferCacheSizeInKilobytes]
	,[CheckpointWrites] = isnull([CheckpointWrites],0)
	,[ClientComputers]
	,[CommittedInKilobytes]
	,[ConnectionMemoryInKilobytes]
	,[CPUActivityPercentage]
	,[CPUTimeDelta]
	,[CPUTimeRaw]
	,[DatabaseCount]
	,[DataFileCount]
	,[DataFileSpaceAllocatedInKilobytes]
	,[DataFileSpaceUsedInKilobytes]
	,[DiskTimePercent]
	,[DiskQueueLength]
	,[DistributionLatencyInSeconds]
	,[DTCServiceStatus]
	,[FreeCachePagesInKilobytes]
	,[CachePagesInKilobytes]
	,[FreePagesInKilobytes]
	,[FullScans]
	,[FullTextSearchStatus]
	,[GrantedWorkspaceMemoryInKilobytes]
	,[IdleTimeDelta]
	,[IdleTimePercentage]
	,[IdleTimeRaw]
	,[IOActivityPercentage]
	,[IOTimeDelta]
	,[IOTimeRaw]
	,[IsClustered]
	,[ClusterNodeName]
	,[LazyWriterWrites] = isnull([LazyWriterWrites],0)
	,[LeadBlockers]
	,[LockMemoryInKilobytes]
	,[LockStatistics]
	,[LockWaits]
	,[Logins]
	,[LogFileCount]
	,[LogFileSpaceAllocatedInKilobytes]
	,[LogFileSpaceUsedInKilobytes]
	,[LogFlushes]
	,[MaxConnections]
	,[OldestOpenTransactionsInMinutes]
	,[OpenTransactions]
	,[OptimizerMemoryInKilobytes]
	,[OSAvailableMemoryInKilobytes]
	,[OsStatisticAvailability]
	,[OSTotalPhysicalMemoryInKilobytes]
	,[PacketErrors]
	,[PacketsReceived]
	,[PacketsSent]
	,[PageErrors]
	,[PageLifeExpectancy]
	,[PageLookups]
	,[PageReads] = isnull([PageReads],0)
	,[PagesPerSecond]
	,[PageSplits]
	,[PageWrites] = isnull([PageWrites],0)
	,[PrivilegedTimePercent]
	,[ProcedureCacheHitRatioPercentage]
	,[ProcedureCacheSizeInKilobytes]
	,[ProcedureCacheSizePercent]
	,[ProcessorCount]
	,[ProcessorsUsed]
	,[ProcessorTimePercent]
	,[ProcessorQueueLength]
	,[ReadAheadPages] = isnull([ReadAheadPages],0)
	,[ServerHostName]
	,[ServerStatistics].[RealServerName]
	,[ReplicationLatencyInSeconds]
	,[ReplicationSubscribed]
	,[ReplicationUndistributed]
	,[ReplicationUnsubscribed]
	,[ResponseTimeInMilliseconds]
	,[RunningSince]
	,[ServerStatistics].[ServerVersion]
	,[SqlCompilations]
	,[SqlMemoryAllocatedInKilobytes]
	,[SqlMemoryUsedInKilobytes]
	,[SqlRecompilations]
	,[SqlServerEdition]
	,[SqlServerServiceStatus]
	,[ServerStatistics].[SystemProcesses]
	,[SystemProcessesConsumingCPU]
	,[TableLockEscalations]
	,[TempDBSizeInKilobytes]
	,[TempDBSizePercent]
	,[TimeDeltaInSeconds]
	,[TotalLocks]
	,[Transactions]
	,[Batches]
	,[UserProcesses]
	,[UserProcessesConsumingCPU]
	,[UserTimePercent]
	,[WindowsVersion]
	,[WorkFilesCreated]
	,[WorkTablesCreated]
	,[I/O]
	,[Lock]
	,[Memory]
	,[Transaction Log]
	,[Other]
	,[Signal]
	,[VMConfigData].UUID as [vmUUID]
	,[VMConfigData].VMHeartBeat as [vmHeartBeat]
	,[VMConfigData].VMName as [vmName] 
	,[VMConfigData].BootTime as [vmBootTime]
	,[VMConfigData].CPULimit as [vmCPULimit] 
	,[VMConfigData].CPUReserve as [vmCPUReserve]
	,[VMConfigData].DomainName as [vmDomainName]
	,[VMConfigData].MemLimit as [vmMemLimit]
	,[VMConfigData].MemReserve as [vmMemReserve]
	,[VMConfigData].MemSize as [vmMemSize]
	,[VMConfigData].NumCPUs as [vmNumCPUs]
	,[VMStatistics].CPUReady as [vmCPUReady]
	,[VMStatistics].CPUSwapWait as [vmCPUSwapWait]
	,[VMStatistics].CPUUsage as [vmCPUUsage]
	,[VMStatistics].CPUUsageMHz as [vmCPUUsageMHz]
	,[VMStatistics].DiskRead as [vmDiskRead]
	,[VMStatistics].DiskUsage as [vmDiskUsage]
	,[VMStatistics].DiskWrite as [vmDiskWrite]
	,[VMStatistics].MemActive as [vmMemActive]
	,[VMStatistics].MemBalooned as [vmMemBallooned]
	,[VMStatistics].MemConsumed as [vmMemConsumed]
	,[VMStatistics].MemGranted as [vmMemGranted]
	,[VMStatistics].MemSwapInRate as [vmMemSwapInRate]
	,[VMStatistics].MemSwapOutRate as [vmMemSwapOutRate]
	,[VMStatistics].MemSwapped as [vmMemSwapped]
	,[VMStatistics].MemUsage as [vmMemUsage]
	,[VMStatistics].NetReceived as [vmNetReceived]
	,[VMStatistics].NetTransmitted as [vmNetTransmitted]
	,[VMStatistics].NetUsage as [vmNetUsage]
	,[VMStatistics].PagePerSecVM as [PagePerSecVM]
	,[VMStatistics].AvailableByteVm as [AvailableByteVm]
	,[ESXConfigData].HostName as [esxHostName]
	,[ESXConfigData].Status as [esxStatus]
	,[ESXConfigData].BootTime as [esxBootTime]
	,[ESXConfigData].CPUMHz as [esxCPUMHz]
	,[ESXConfigData].DomainName as [esxDomainName]
	,[ESXConfigData].MemorySize as [esxMemSize]
	,[ESXConfigData].NumCPUCores as [esxNumCPUCores]
	,[ESXConfigData].NumCPUPkgs as [esxNumCPUPkgs]
	,[ESXConfigData].NumCPUThreads as [esxNumCPUThreads]
	,[ESXConfigData].NumNICs as [esxNumNICs]
	,[ESXStatistics].CPUUsage as [esxCPUUsage]
	,[ESXStatistics].CPUUsageMHz as [esxCPUUsageMHz]
	,[ESXStatistics].DiskDeviceLatency as [esxDeviceLatency]
	,[ESXStatistics].DiskKernelLatency as [esxKernelLatency]
	,[ESXStatistics].DiskQueueLatency as [esxQueueLatency]
	,[ESXStatistics].DiskRead as [esxDiskRead]
	,[ESXStatistics].DiskTotalLatency as [esxTotalLatency]
	,[ESXStatistics].DiskUsage as [esxDiskUsage]
	,[ESXStatistics].DiskWrite as [esxDiskWrite]
	,[ESXStatistics].MemActive as [esxMemActive]
	,[ESXStatistics].MemBalooned as [esxMemBallooned]
	,[ESXStatistics].MemConsumed as [esxMemConsumed]
	,[ESXStatistics].MemGranted as [esxMemGranted]
	,[ESXStatistics].MemSwapInRate as [esxMemSwapInRate]
	,[ESXStatistics].MemSwapOutRate as [esxMemSwapOutRate]
	,[ESXStatistics].MemUsage as [esxMemUsage]
	,[ESXStatistics].NetReceived as [esxNetReceived]
	,[ESXStatistics].NetTransmitted as [esxNetTransmitted]
	,[ESXStatistics].NetUsage as [esxNetUsage]
	,[ESXStatistics].MemPagePerSec as [pagePerSecHost]
	,[ESXStatistics].AvailableMemBytes as [availableByteHost]
	,TempdbUserObjectsInMegabytes = [cte_TempdbFileData].UserObjectsInKilobytes / 1024.0
	,TempdbInternalObjectsInMegabytes = [cte_TempdbFileData].InternalObjectsInKilobytes / 1024.0
	,TempdbVersionStoreInMegabytes = [cte_TempdbFileData].VersionStoreInKilobytes / 1024.0
	,TempdbMixedExtentsInMegabytes = [cte_TempdbFileData].MixedExtentsInKilobytes / 1024.0
	,TempdbUnallocatedSpaceInMegabytes = [cte_TempdbFileData].UnallocatedSpaceInKilobytes / 1024.0
	,TempdbPFSWaitTimeMilliseconds
	,TempdbGAMWaitTimeMilliseconds
	,TempdbSGAMWaitTimeMilliseconds
	,VersionStoreGenerationKilobytesPerSec = VersionStoreGenerationKilobytes / nullif(TimeDeltaInSeconds,0)
	,VersionStoreCleanupKilobytesPerSec = VersionStoreCleanupKilobytes  / nullif(TimeDeltaInSeconds,0)
	,[MonitoredSQLServers].MaintenanceModeEnabled
	--[START] SQLdm 9.1 (Gaurav Karwal): Added after new sql services were monitored
	,ISNULL(ServerStatistics.SQLBrowserServiceStatus,9) SQLBrowserServiceStatus
	,ISNULL(ServerStatistics.SQLActiveDirectoryHelperServiceStatus,9) SQLActiveDirectoryHelperServiceStatus
	--[END]  SQLdm 9.1 (Gaurav Karwal): Added after new sql services were monitored
from
	@InstancesByMaxCollectionTime ibmct 
	INNER JOIN [MonitoredSQLServers] (NOLOCK) on ibmct.InstanceID = [MonitoredSQLServers].SQLServerID
	left join [ServerStatistics] (NOLOCK)
		on [ServerStatistics].[SQLServerID] = [MonitoredSQLServers].[SQLServerID]
		and [ServerStatistics].[UTCCollectionDateTime] = ibmct.UTCCollectionDateTime
	left join [OSStatistics] (NOLOCK)
		on [OSStatistics].[SQLServerID] = [MonitoredSQLServers].[SQLServerID]
		and [OSStatistics].[UTCCollectionDateTime] = ibmct.UTCCollectionDateTime
	left join [ServerActivity] (NOLOCK)
		on [ServerActivity].[SQLServerID] = [MonitoredSQLServers].[SQLServerID]
		and [ServerActivity].[UTCCollectionDateTime] = ibmct.UTCCollectionDateTime
	left join cte_waitdata
		on cte_waitdata.InstanceID = MonitoredSQLServers.SQLServerID
		and cte_waitdata.[UTCCollectionDateTime] = ibmct.UTCCollectionDateTime
	left join [VMConfigData] (NOLOCK)
		on [VMConfigData].[SQLServerID] = MonitoredSQLServers.[SQLServerID] 
		and [VMConfigData].[UTCCollectionDateTime] = ibmct.UTCCollectionDateTime
	left join [VMStatistics] (NOLOCK)
		on [VMStatistics].SQLServerID = MonitoredSQLServers.[SQLServerID] 
		and [VMStatistics].UTCCollectionDateTime =  ibmct.UTCCollectionDateTime
	left join [ESXConfigData] (NOLOCK)
		on [ESXConfigData].SQLServerID  = MonitoredSQLServers.[SQLServerID] 
		and [ESXConfigData].UTCCollectionDateTime  =  ibmct.UTCCollectionDateTime
	left join [ESXStatistics] (NOLOCK)
		on [ESXStatistics].SQLServerID = MonitoredSQLServers.[SQLServerID] 
		and [ESXStatistics].UTCCollectionDateTime  =  ibmct.UTCCollectionDateTime
	left join cte_TempdbFileData
		on cte_TempdbFileData.InstanceID = MonitoredSQLServers.[SQLServerID] 
		and cte_TempdbFileData.UTCCollectionDateTime =  ibmct.UTCCollectionDateTime
--WHERE [MonitoredSQLServers].Active = 1
ORDER BY ServerStatistics.SQLServerID;
select @err = @@error
return @err

END
 
GO 

---------- P_GETMONITOREDSQLSERVERBYID.SQL
IF (object_id('[p_GetMonitoredSqlServerById]') IS NOT NULL)
BEGIN
DROP PROCEDURE [p_GetMonitoredSqlServerById]
END
GO

CREATE PROCEDURE [dbo].[p_GetMonitoredSqlServerById](
	@Id int,
	@IncludeCounters bit = 0
)
AS
BEGIN
	DECLARE @error int

	SELECT 
		a.[SQLServerID],
		a.[InstanceName],
		a.[FriendlyServerName],
		a.[Active],
		a.[RegisteredDate],
		a.[CollectionServiceID],
		a.[UseIntegratedSecurity],
		a.[Username],
		a.[Password],
		a.[ScheduledCollectionIntervalInSeconds],
		a.[MaintenanceModeEnabled],
		a.[QueryMonitorEnabled],
		a.[QueryMonitorSqlBatchEventsEnabled],
		a.[QueryMonitorSqlStatementEventsEnabled],
		a.[QueryMonitorStoredProcedureEventsEnabled],
		a.[QueryMonitorDurationFilterInMilliseconds],
		a.[QueryMonitorCpuUsageFilterInMilliseconds],
		a.[QueryMonitorLogicalDiskReadsFilter],
		a.[QueryMonitorPhysicalDiskWritesFilter],
		a.[QueryMonitorTraceFileSizeKB],
		a.[QueryMonitorTraceFileRollovers],
		a.[QueryMonitorTraceRecordsPerRefresh],
		--SQLdm 9.0 (Ankit Srivastava) -- Query Monitor Improvement with Extended event -- fetching newly added columns -start
		a.[QueryMonitorTraceMonitoringEnabled],
		a.[QueryMonitorCollectQueryPlan],
		--SQLdm 9.0 (Ankit Srivastava) -- Query Monitor Improvement with Extended event -- fetching newly added columns -end
		a.[QueryMonitorCollectEstimatedQueryPlan],
		--SQLdm 10.0 (Tarun Sapra) - Modified the stored procedure to get the new column for estimated query plan flag
		a.[GrowthStatisticsStartTime],
		a.[ReorgStatisticsStartTime],
		a.[LastGrowthStatisticsRunTime],
		a.[LastReorgStatisticsRunTime],
		a.[GrowthStatisticsDays],
		a.[ReorgStatisticsDays],
		a.[TableStatisticsExcludedDatabases],
		a.[EncryptData],
		a.[TrustServerCert],
		(SELECT min(ServerStatistics.UTCCollectionDateTime)
		FROM ServerStatistics (NOLOCK)
		WHERE ServerStatistics.SQLServerID = a.SQLServerID) AS EarliestData,
		a.[ReorgMinTableSizeKB],
		a.[CustomCounterTimeoutInSeconds],
		a.[OutOfProcOleAutomation],
		a.[DisableReplicationMonitoring],
		a.[MaintenanceModeType],
		a.[MaintenanceModeStart],
		a.[MaintenanceModeStop],
		a.[MaintenanceModeDurationSeconds],
		a.[MaintenanceModeDays],
		a.[MaintenanceModeRecurringStart],

		a.[MaintenanceModeMonth],

		a.[MaintenanceModeSpecificDay],

		a.[MaintenanceModeWeekOrdinal],

		a.[MaintenanceModeWeekDay],

		a.[MaintenanceModeMonthDuration],

		a.[MaintenanceModeMonthRecurringStart],

		a.[QueryMonitorAdvancedConfiguration],
		a.[DisableExtendedHistoryCollection],
		a.[DisableOleAutomation],
		a.[DiskCollectionSettings],
		a.[QueryMonitorStopTimeUTC],
		a.[InputBufferLimiter],
		a.[InputBufferLimited],
		a.[ActiveClusterNode],
		a.[PreferredClusterNode],
		a.[ActiveWaitCollectorStartTimeRelative],
		a.[ActiveWaitCollectorRunTimeSeconds],
		a.[ActiveWaitCollectorCollectionTimeSeconds],
		a.[ActiveWaitCollectorEnabled],	
		a.[ActiveWaitLoopTimeMilliseconds],
		a.[ActiveWaitAdvancedConfiguration],
		a.[ActiveWaitXEEnable],
		a.[ActiveWaitXEFileSizeMB],
		a.[ActiveWaitXEFilesRollover],
		a.[ActiveWaitXERecordsPerRefresh],
		a.[ActiveWaitXEMaxMemoryMB],
		a.[ActiveWaitXEEventRetentionMode],
		a.[ActiveWaitXEMaxDispatchLatencySecs],
		a.[ActiveWaitXEMaxEventSizeMB],
		a.[ActiveWaitXEMemoryPartitionMode],
		a.[ActiveWaitXETrackCausality],
		a.[ActiveWaitXEStartupState],
		a.[ActiveWaitsXEFileName],
		a.[ClusterCollectionSetting],
		a.[ServerPingInterval],
		a.[VHostID],
		a.[VmUID],
		a.[VmName],
		a.[VmDomainName],
		b.[VHostName],
		b.[VHostAddress],
		b.[ServerType],
		b.[Username] as [VCUserName],
		b.[Password] as [VCPassword],
		a.[AlertRefreshInMinutes],
		c.[Template] as [BaselineTemplate],		
		c.[TemplateID] as [BaselineTemplateID],
		c.[BaselineName] as [BaselineName],	
		c.[Active] as [BaselineActive],		
		ServerVersion,
		ServerEdition,
		JobAlertEnabled,
		LogAlertEnabled,
		DatabaseStatisticsRefreshIntervalInSeconds,
		WmiCollectionEnabled,
		WmiConnectAsService,
		WmiUserName,
		WmiPassword,
		a.[ActivityMonitorEnabled],
		--START SQLdm 9.1 (Ankit Srivastava) -- Activity Monitor with Extended Events Improvement with Extended event -- fetching newly added columns
		a.[ActivityMonitorTraceMonitoringEnabled],
		a.[ActivityMonitorXEFileSizeMB],
		a.[ActivityMonitorXEFilesRollover],
		a.[ActivityMonitorXERecordsPerRefresh],
		a.[ActivityMonitorXEMaxMemoryMB],
		a.[ActivityMonitorXEEventRetentionMode],
		a.[ActivityMonitorXEMaxDispatchLatencySecs],
		a.[ActivityMonitorXEMaxEventSizeMB],
		a.[ActivityMonitorXEMemoryPartitionMode],
		a.[ActivityMonitorXETrackCausality],
		a.[ActivityMonitorXEStartupState],
		a.[ActivityMonitorXEFileName],
		--END SQLdm 9.1 (Ankit Srivastava) -- Activity Monitor with Extended Events Improvement with Extended event -- fetching newly added columns
		a.[ActivityMonitorDeadlockEventsEnabled],
		a.[ActivityMonitorBlockingEventsEnabled],
		a.[ActivityMonitorAutoGrowEventsEnabled],
		a.[ActivityMonitorBlockedProcessThreshold],
		f.[InstanceName] as [SS_InstanceName],
		f.[DatabaseName] as [SS_DatabaseName],
		f.[SecurityMode] as [SS_SecurityMode],
		f.[UserName] as [SS_UserName],
		f.[EncryptedPassword] as [SS_EncryptedPassword],
		d.[RelatedInstanceId] as [SS_RelatedInstanceId],
		d.[LastBackupActionId] as [SS_LastBackupActionId],
		d.[LastDefragActionId] as [SS_LastDefragActionId],
		--START SQLdm 9.1 (Ankit Srivastava): Query Monitor 9.0 Improvement feedback - Fetching new columns for uery monitoring extended event session configuration
		[QueryMonitorXEFileSizeMB],
		[QueryMonitorXEFilesRollover],
		--END SQLdm 9.1 (Ankit Srivastava): Query Monitor 9.0 Improvement feedback - Fetching new columns for uery monitoring extended event session configuration
		
		-- START 10.0 (srishti purohit) : To handle analysis configuration
		analysisConfig.[ProductionServer] AS [AnalysisProductionServer],
		analysisConfig.[OLTP],
		analysisConfig.[StartTime],
		analysisConfig.[Duration],
		analysisConfig.[ScheduledDays],
		analysisConfig.[SchedulingStatus],--SQLDM10.0 (praveen suhalka) : scheduling status
		analysisConfig.[IncludeDatabase],
		(SELECT SSDN.DatabaseName FROM SQLServerDatabaseNames SSDN WHERE SSDN.DatabaseID = analysisConfig.[IncludeDatabase]) AS IncludeDatabaseName,
		analysisConfig.[IsActive],
		analysisConfig.[FilterApplication]
		,(SELECT STUFF((SELECT ', ' + CAST(CategoryID AS VARCHAR(10)) [text()]
         FROM AnalysisConfigCategories 
         WHERE AnalysisConfigurationID = acc.AnalysisConfigurationID AND  analysisConfig.ID = AnalysisConfigurationID
         FOR XML PATH(''), TYPE)
        .value('.','NVARCHAR(MAX)'),1,2,' ') List_Output
		FROM AnalysisConfigCategories acc
		GROUP BY AnalysisConfigurationID
		HAVING analysisConfig.ID = AnalysisConfigurationID) AS BlockedCategories
		,(SELECT STUFF((SELECT ', ' + CAST(CC.CategoryID AS VARCHAR(10)) +', '+ PRC.Name [text()]
		FROM AnalysisConfigCategories CC
		JOIN PrescriptiveRecommendationCategory PRC ON PRC.CategoryID = CC.CategoryID
         WHERE AnalysisConfigurationID = acc.AnalysisConfigurationID AND  analysisConfig.ID = AnalysisConfigurationID
		 AND CC.CategoryID = PRC.CategoryID
		 GROUP BY CC.CategoryID, PRC.Name
         FOR XML PATH(''), TYPE)
        .value('.','NVARCHAR(MAX)'),1,2,' ')List_Output
		FROM AnalysisConfigCategories acc
		GROUP BY AnalysisConfigurationID
		HAVING analysisConfig.ID = AnalysisConfigurationID) AS BlockedCategoriesWithName
      ,(SELECT STUFF((SELECT ', ' + CAST(DatabaseID AS VARCHAR(10)) [text()]
         FROM AnalysisConfigBlockedDatabases 
         WHERE AnalysisConfigurationID = acbd.AnalysisConfigurationID AND  analysisConfig.ID = AnalysisConfigurationID
         FOR XML PATH(''), TYPE)
        .value('.','NVARCHAR(MAX)'),1,2,' ') List_Output
		FROM AnalysisConfigBlockedDatabases acbd
		GROUP BY AnalysisConfigurationID
		HAVING analysisConfig.ID = AnalysisConfigurationID) AS BlockedDatabases
		,(SELECT STUFF((SELECT ', ' + CAST(BD.DatabaseID AS VARCHAR(10)) +', '+ SSDN.DatabaseName [text()]
         FROM AnalysisConfigBlockedDatabases  BD

				JOIN SQLServerDatabaseNames SSDN ON SSDN.DatabaseID = BD.DatabaseID
         WHERE AnalysisConfigurationID = acbd.AnalysisConfigurationID AND  analysisConfig.ID = AnalysisConfigurationID
		 AND BD.DatabaseID = SSDN.DatabaseID
		 GROUP BY BD.DatabaseID, SSDN.DatabaseName
         FOR XML PATH(''), TYPE)
        .value('.','NVARCHAR(MAX)'),1,2,' ') List_Output
		FROM AnalysisConfigBlockedDatabases acbd
		GROUP BY AnalysisConfigurationID
		HAVING analysisConfig.ID = AnalysisConfigurationID) AS BlockedDatabasesWithName
		,(SELECT STUFF((SELECT ',' + CAST(RecommendationID AS VARCHAR(10)) [text()]
         FROM AnalysisConfigBlockedRecommendation 
         WHERE AnalysisConfigurationID = acbr.AnalysisConfigurationID AND  analysisConfig.ID = AnalysisConfigurationID
         FOR XML PATH(''), TYPE)
        .value('.','NVARCHAR(MAX)'),1,1,'') List_Output
		FROM AnalysisConfigBlockedRecommendation acbr
		GROUP BY AnalysisConfigurationID
		HAVING analysisConfig.ID = AnalysisConfigurationID) AS BlockedRecommendations
		-- END 10.0 (srishti purohit) : To handle analysis configuration


	FROM [MonitoredSQLServers] a (NOLOCK)
		LEFT JOIN [VirtualHostServers] b 		(NOLOCK)
			on a.VHostID = b.VHostID 
		LEFT JOIN [BaselineTemplates] c (NOLOCK)
				on a.SQLServerID = c.SQLServerID and c.TemplateID = (select MAX(TemplateID) from BaselineTemplates (NOLOCK) where SQLServerID = a.SQLServerID and BaselineName = 'Default' and Active='1')
		LEFT JOIN [MonitoredServerSQLsafeInstance] d (NOLOCK)
			on a.SQLServerID = d.SQLServerID
		LEFT JOIN [SQLsafeConnections] f (NOLOCK)
			on d.RepositoryId = f.RepositoryId and f.Deleted <> 1
		LEFT JOIN AnalysisConfiguration analysisConfig (NOLOCK)
			on a.SQLServerID = analysisConfig.MonitoredServerID AND analysisConfig.IsActive = 1
		outer apply
		(
		select top 1 Enabled as JobAlertEnabled
		from MetricThresholds mt (NOLOCK)
		where Enabled = 1
		and mt.SQLServerID = a.SQLServerID
		-- Job related alerts:
		-- 34 - SQL Server Agent Long Running Job (Percent)
		-- 35 - SQL Server Agent Job Failure
		-- 65 - SQL Server Agent Long Running Job (Minutes)
		-- 88 - SQL Server Agent Job Completion
		and Metric in (34,35,65,88)
		) j
	outer apply
	(
		select top 1 Enabled as LogAlertEnabled
		from MetricThresholds mt (NOLOCK)
		where Enabled = 1
		and mt.SQLServerID = a.SQLServerID
		-- Job related alerts:
		-- 66 - SQL Server Error Log
		-- 67 - SQL Server Agent Log
		and Metric in (66,67)
		) e
	WHERE a.[SQLServerID] = @Id

	SELECT @error = @@error

	IF @error != 0 GOTO HANDLE_ERROR

	SELECT [Metric] 
	FROM [CustomCounterMap] (NOLOCK)
	WHERE [SQLServerID] = @Id

	SELECT [TagId] 
	FROM [ServerTags] (NOLOCK)
	WHERE [SQLServerId] = @Id

	RETURN(0)

	HANDLE_ERROR:
		RAISERROR('An error occurred while getting the monitored SQL Server instance %d.', 10, 1, @Id)
        RETURN(@error)
END
 

GO

 
GO 

---------- P_GETMONITOREDSQLSERVERCOUNTERS.SQL
if (object_id('p_GetMonitoredSQLServerCounters') is not null)
begin
drop procedure p_GetMonitoredSQLServerCounters
end
go

CREATE PROCEDURE [dbo].p_GetMonitoredSQLServerCounters(
	@SQLServerID int,
	@IncludeTagged bit = 0
)
AS
begin
	declare @e int

	if (@IncludeTagged = 0) 
		SELECT SQLServerID, Metric from CustomCounterMap
			WHERE (@SQLServerID is null or [SQLServerID] = @SQLServerID)
			ORDER BY SQLServerID
	else
		-- include tagged counters also
		SELECT SQLServerID, Metric from CustomCounterMap
			WHERE (@SQLServerID is null or [SQLServerID] = @SQLServerID)
		UNION
		SELECT ST.SQLServerId, CCT.Metric from ServerTags ST
			JOIN CustomCounterTags CCT on ST.TagId = CCT.TagId
			LEFT OUTER JOIN CustomCounterMap CCM on ST.SQLServerId = CCM.SQLServerID and CCT.Metric = CCM.Metric
			WHERE (@SQLServerID is null or ST.[SQLServerId] = @SQLServerID)
				   and CCM.SQLServerID is null
		ORDER BY SQLServerID

	SET @e = @@ERROR

	RETURN @e
end
 
GO 

---------- P_GETMONITOREDSQLSERVERID.SQL
if (object_id('p_GetMonitoredSqlServerId') is not null)
begin
drop procedure p_GetMonitoredSqlServerId
end
go
CREATE PROCEDURE [dbo].p_GetMonitoredSqlServerId(
	@InstanceName nvarchar(255)
)
AS
BEGIN
	DECLARE @error int

	SELECT	[SQLServerID]
	FROM	[MonitoredSQLServers]
	WHERE	lower([InstanceName]) collate database_default = lower(@InstanceName)

	SELECT @error = @@error

	IF @error != 0 GOTO HANDLE_ERROR

	RETURN(0)

	HANDLE_ERROR:
		RAISERROR('An error occurred while getting the monitored SQL Server instance %s.', 10, 1, @InstanceName)
        RETURN(@error)
END
 
GO 

---------- P_GETMONITOREDSQLSERVERNAMES.SQL
if (object_id('p_GetMonitoredSqlServerNames') is not null)
begin
drop procedure p_GetMonitoredSqlServerNames
end
go
CREATE PROCEDURE [dbo].[p_GetMonitoredSqlServerNames]
(
	@CollectionServiceId UNIQUEIDENTIFIER = NULL,
	@ActiveOnly BIT = 1
)
AS
BEGIN
	DECLARE @error int

	SELECT 
		[SQLServerID],
		[InstanceName],
		[Active]
	FROM [MonitoredSQLServers] (NOLOCK)
	WHERE
		((@CollectionServiceId IS NULL) OR ([CollectionServiceID] = @CollectionServiceId)) AND
		((@ActiveOnly = 0) OR ([Active] = 1))
	
	SELECT @error = @@error

	IF @error != 0 GOTO HANDLE_ERROR

	RETURN(0)

	HANDLE_ERROR:
		RAISERROR('An error occurred while getting the monitored SQL Server names.', 10, 1)
        RETURN(@error)			
END
 
GO 

---------- P_GETMONITOREDSQLSERVERS.SQL
IF (object_id('[p_GetMonitoredSqlServers]') IS NOT NULL)
BEGIN
DROP PROCEDURE [p_GetMonitoredSqlServers]
END
GO

CREATE PROCEDURE [dbo].[p_GetMonitoredSqlServers]
(
	@CollectionServiceId UNIQUEIDENTIFIER = NULL,
	@ActiveOnly BIT = 0,
	@GetLicenseKeys BIT = 0, -- Indicates if we should also return the license keys.
	@CustomCounters BIT = 0,  -- Indicates if we should also return the custom counters mapped to the server
	@FilterField VARCHAR(256) = NULL, 
	@FilterValue VARCHAR(256) = NULL
)
AS
BEGIN
	DECLARE @error int

	create table #serverIds 
	(
		SQLServerID int not null
	);

	
	
	if (@FilterField is not null and @FilterValue is not null)
	begin

		if (@FilterField = 'TagId')
		begin
			insert into #serverIds
			select DISTINCT mss.[SQLServerID] from dbo.[MonitoredSQLServers] mss (NOLOCK)
			INNER JOIN [ServerTags] st ON st.SQLServerId = mss.SQLServerID
			where [Deleted] = 0 AND st.TagId = @FilterValue
		end

		else if (@FilterField = 'InstanceName')
		begin
			insert into #serverIds
			select DISTINCT [SQLServerID] from dbo.[MonitoredSQLServers] mss (NOLOCK)
			where [Deleted] = 0 AND mss.InstanceName LIKE @FilterValue
		end
		else if (@FilterField = '')
		begin	
			insert into #serverIds
			select DISTINCT [SQLServerID] from dbo.[MonitoredSQLServers] (NOLOCK)
			where [Deleted] = 0
		end
	end
	else 
	begin
		insert into #serverIds
		select DISTINCT [SQLServerID] from dbo.[MonitoredSQLServers] (NOLOCK)
		where [Deleted] = 0
	end

	SELECT 
		a.[SQLServerID],
		a.[InstanceName],
		a.[FriendlyServerName],
		a.[Active],
		a.[RegisteredDate],
		a.[CollectionServiceID],
		a.[UseIntegratedSecurity],
		a.[Username],
		a.[Password],
		a.[ScheduledCollectionIntervalInSeconds],
		a.[MaintenanceModeEnabled],
		a.[QueryMonitorEnabled],
		a.[QueryMonitorSqlBatchEventsEnabled],
		a.[QueryMonitorSqlStatementEventsEnabled],
		a.[QueryMonitorStoredProcedureEventsEnabled],
		a.[QueryMonitorDurationFilterInMilliseconds],
		a.[QueryMonitorCpuUsageFilterInMilliseconds],
		a.[QueryMonitorLogicalDiskReadsFilter],
		a.[QueryMonitorPhysicalDiskWritesFilter],
		a.[QueryMonitorTraceFileSizeKB],
		a.[QueryMonitorTraceFileRollovers],
		a.[QueryMonitorTraceRecordsPerRefresh],
		a.[GrowthStatisticsStartTime],
		a.[ReorgStatisticsStartTime],
		a.[LastGrowthStatisticsRunTime],
		a.[LastReorgStatisticsRunTime],
		a.[GrowthStatisticsDays],
		a.[ReorgStatisticsDays],
		a.[TableStatisticsExcludedDatabases],
		a.[EncryptData],
		a.[TrustServerCert],
		(SELECT min(ServerStatistics.UTCCollectionDateTime)
		FROM ServerStatistics (NOLOCK)
		WHERE ServerStatistics.SQLServerID = a.SQLServerID) AS EarliestData,
		a.[ReorgMinTableSizeKB],
		a.[CustomCounterTimeoutInSeconds],
		a.[OutOfProcOleAutomation],
		a.[DisableReplicationMonitoring],
		a.[LastAlertRefreshTime],
		a.[MaintenanceModeType],
		a.[MaintenanceModeStart],
		a.[MaintenanceModeStop],
		a.[MaintenanceModeDurationSeconds],
		a.[MaintenanceModeDays],
		a.[MaintenanceModeRecurringStart],

		a.[MaintenanceModeMonth],

		a.[MaintenanceModeSpecificDay],

		a.[MaintenanceModeWeekOrdinal],

		a.[MaintenanceModeWeekDay],

		a.[MaintenanceModeMonthDuration],

		a.[MaintenanceModeMonthRecurringStart],

		a.[QueryMonitorAdvancedConfiguration],
		a.[DisableExtendedHistoryCollection],
		a.[DisableOleAutomation],
		a.[DiskCollectionSettings],
		a.[QueryMonitorStopTimeUTC],
		--SQLdm 9.0 (Ankit Srivastava): Query Monitoring with Extended Event Session  --Get the newly added columns from  the repository
		a.QueryMonitorTraceMonitoringEnabled,
		a.QueryMonitorCollectQueryPlan,
		--SQLdm 10.0 (Tarun Sapra): Get the flag for displaying the estimated query plan only
		a.QueryMonitorCollectEstimatedQueryPlan,
		a.[InputBufferLimiter],
		a.[InputBufferLimited],
		a.[ActiveClusterNode],
		a.[PreferredClusterNode],
		a.[ActiveWaitCollectorStartTimeRelative],
		a.[ActiveWaitCollectorRunTimeSeconds],
		a.[ActiveWaitCollectorCollectionTimeSeconds],
		a.[ActiveWaitCollectorEnabled],
		a.[ActiveWaitLoopTimeMilliseconds],
		a.[ActiveWaitAdvancedConfiguration],
		a.[ActiveWaitXEEnable],
		a.[ActiveWaitXEFileSizeMB],
		a.[ActiveWaitXEFilesRollover],
		a.[ActiveWaitXERecordsPerRefresh],
		a.[ActiveWaitXEMaxMemoryMB],
		a.[ActiveWaitXEEventRetentionMode],
		a.[ActiveWaitXEMaxDispatchLatencySecs],
		a.[ActiveWaitXEMaxEventSizeMB],
		a.[ActiveWaitXEMemoryPartitionMode],
		a.[ActiveWaitXETrackCausality],
		a.[ActiveWaitXEStartupState],
		a.[ActiveWaitsXEFileName],
		a.[ClusterCollectionSetting],
		a.[ServerPingInterval],
		a.[VHostID],
		a.[VmUID],
		a.[VmName],
		a.[VmDomainName],
		b.[VHostName],
		b.[VHostAddress],
		b.[ServerType],
		b.[Username] as [VCUserName],
		b.[Password] as [VCPassword],
		a.[AlertRefreshInMinutes],
		c.[Template] as [BaselineTemplate],		
		c.[TemplateID] as [BaselineTemplateID],
		ServerVersion,
		ServerEdition,
		JobAlertEnabled,
		LogAlertEnabled,
		DatabaseStatisticsRefreshIntervalInSeconds,
		WmiCollectionEnabled,
		WmiConnectAsService,
		WmiUserName,
		WmiPassword,
		a.[ActivityMonitorEnabled],
		--START SQLdm 9.1 (Ankit Srivastava): Activity Monitor with Extended Events  --Get the newly added columns from  the repository
		a.[ActivityMonitorTraceMonitoringEnabled],
		a.[ActivityMonitorXEFileSizeMB],
		a.[ActivityMonitorXEFilesRollover],
		a.[ActivityMonitorXERecordsPerRefresh],
		a.[ActivityMonitorXEMaxMemoryMB],
		a.[ActivityMonitorXEEventRetentionMode],
		a.[ActivityMonitorXEMaxDispatchLatencySecs],
		a.[ActivityMonitorXEMaxEventSizeMB],
		a.[ActivityMonitorXEMemoryPartitionMode],
		a.[ActivityMonitorXETrackCausality],
		a.[ActivityMonitorXEStartupState],
		a.[ActivityMonitorXEFileName],
		--END SQLdm 9.1 (Ankit Srivastava): Activity Monitor with Extended Events  --Get the newly added columns from  the repository
		a.[ActivityMonitorDeadlockEventsEnabled],		
		a.[ActivityMonitorBlockingEventsEnabled],
		a.[ActivityMonitorAutoGrowEventsEnabled],
		a.[ActivityMonitorBlockedProcessThreshold],
		f.[InstanceName] as [SS_InstanceName],
		f.[DatabaseName] as [SS_DatabaseName],
		f.[SecurityMode] as [SS_SecurityMode],
		f.[UserName] as [SS_UserName],
		f.[EncryptedPassword] as [SS_EncryptedPassword],
		d.[RelatedInstanceId] as [SS_RelatedInstanceId],
		d.[LastBackupActionId] as [SS_LastBackupActionId],
		d.[LastDefragActionId] as [SS_LastDefragActionId],
		ISNULL(
				(
					SELECT ISNULL(Logins,0) FROM ServerStatistics stat (NOLOCK)
					WHERE stat.SQLServerID = a.SQLServerID 
					AND stat.UTCCollectionDateTime = (SELECT MAX(stat_temp.UTCCollectionDateTime) FROM ServerStatistics stat_temp WHERE stat_temp.SQLServerID = a.SQLServerID)
				),
				0
		) LastRunActiveUserSessions,

		ISNULL(
				(
					SELECT ISNULL(CPUActivityPercentage,0) FROM ServerStatistics stat (NOLOCK)
					WHERE stat.SQLServerID = a.SQLServerID 
					AND stat.UTCCollectionDateTime = (SELECT MAX(stat_temp.UTCCollectionDateTime) FROM ServerStatistics stat_temp WHERE stat_temp.SQLServerID = a.SQLServerID)
				),0
		) LastRunCPUActivityPercentage,

		ISNULL(
				(
					SELECT ISNULL([SqlMemoryAllocatedInKilobytes],0) FROM ServerStatistics stat (NOLOCK)
					WHERE stat.SQLServerID = a.SQLServerID 
					AND stat.UTCCollectionDateTime = (SELECT MAX(stat_temp.UTCCollectionDateTime) FROM ServerStatistics stat_temp WHERE stat_temp.SQLServerID = a.SQLServerID)
				),
		0) LastRunSqlMemoryAllocatedInKilobytes,
		ISNULL(
				(
					SELECT ISNULL([SqlMemoryUsedInKilobytes],0) FROM ServerStatistics stat (NOLOCK)
					WHERE stat.SQLServerID = a.SQLServerID 
					AND stat.UTCCollectionDateTime = (SELECT MAX(stat_temp.UTCCollectionDateTime) FROM ServerStatistics stat_temp WHERE stat_temp.SQLServerID = a.SQLServerID)
				),
		0) LastRunSqlMemoryUsedInKilobytes,

		ISNULL(
				(
					SELECT ISNULL(IOActivityPercentage,0) FROM ServerStatistics stat (NOLOCK)
					WHERE stat.SQLServerID = a.SQLServerID 
					AND stat.UTCCollectionDateTime = (SELECT MAX(stat_temp.UTCCollectionDateTime) FROM ServerStatistics stat_temp WHERE stat_temp.SQLServerID = a.SQLServerID)
				),
		0) LastRunIOActivityPercentage,
		--START SQLdm 9.1 (Ankit Srivastava): Query Monitor 9.0 Improvement feedback - Fetching new columns for uery monitoring extended event session configuration
		[QueryMonitorXEFileSizeMB],
		[QueryMonitorXEFilesRollover]
		--END SQLdm 9.1 (Ankit Srivastava): Query Monitor 9.0 Improvement feedback - Fetching new columns for uery monitoring extended event session configuration

		
		-- START 10.0 (srishti purohit) : To handle analysis configuration
		,analysisConfig.[ProductionServer] AS [AnalysisProductionServer],
		analysisConfig.[OLTP],
		analysisConfig.[SchedulingStatus],--SQLDM10.0 (praveen suhalka) : scheduling status
		analysisConfig.[StartTime],
		analysisConfig.[Duration],
		analysisConfig.[ScheduledDays],
		analysisConfig.[IncludeDatabase],
		(SELECT SSDN.DatabaseName FROM SQLServerDatabaseNames SSDN WHERE SSDN.DatabaseID = analysisConfig.[IncludeDatabase]) AS IncludeDatabaseName,
		analysisConfig.[IsActive],
		analysisConfig.[FilterApplication]
		,(SELECT STUFF((SELECT ', ' + CAST(CategoryID AS VARCHAR(10)) [text()]
         FROM AnalysisConfigCategories 
         WHERE AnalysisConfigurationID = acc.AnalysisConfigurationID AND  analysisConfig.ID = AnalysisConfigurationID
         FOR XML PATH(''), TYPE)
        .value('.','NVARCHAR(MAX)'),1,2,' ') List_Output
		FROM AnalysisConfigCategories acc
		GROUP BY AnalysisConfigurationID
		HAVING analysisConfig.ID = AnalysisConfigurationID) AS BlockedCategories
		,(SELECT STUFF((SELECT ', ' + CAST(CC.CategoryID AS VARCHAR(10)) +', '+ PRC.Name [text()]
FROM AnalysisConfigCategories CC
				JOIN PrescriptiveRecommendationCategory PRC ON PRC.CategoryID = CC.CategoryID
         WHERE AnalysisConfigurationID = acc.AnalysisConfigurationID AND  analysisConfig.ID = AnalysisConfigurationID
		 AND CC.CategoryID = PRC.CategoryID
		 GROUP BY CC.CategoryID, PRC.Name
         FOR XML PATH(''), TYPE)
        .value('.','NVARCHAR(MAX)'),1,2,' ')List_Output
		FROM AnalysisConfigCategories acc
		GROUP BY AnalysisConfigurationID
		HAVING analysisConfig.ID = AnalysisConfigurationID) AS BlockedCategoriesWithName
      ,(SELECT STUFF((SELECT ', ' + CAST(DatabaseID AS VARCHAR(10)) [text()]
         FROM AnalysisConfigBlockedDatabases 
         WHERE AnalysisConfigurationID = acbd.AnalysisConfigurationID AND  analysisConfig.ID = AnalysisConfigurationID
         FOR XML PATH(''), TYPE)
        .value('.','NVARCHAR(MAX)'),1,2,' ') List_Output
		FROM AnalysisConfigBlockedDatabases acbd
		GROUP BY AnalysisConfigurationID
		HAVING analysisConfig.ID = AnalysisConfigurationID) AS BlockedDatabases
		,(SELECT STUFF((SELECT ', ' + CAST(BD.DatabaseID AS VARCHAR(10)) +', '+ SSDN.DatabaseName [text()]
         FROM AnalysisConfigBlockedDatabases  BD

				JOIN SQLServerDatabaseNames SSDN ON SSDN.DatabaseID = BD.DatabaseID
         WHERE AnalysisConfigurationID = acbd.AnalysisConfigurationID AND  analysisConfig.ID = AnalysisConfigurationID
		 AND BD.DatabaseID = SSDN.DatabaseID
		 GROUP BY BD.DatabaseID, SSDN.DatabaseName
         FOR XML PATH(''), TYPE)
        .value('.','NVARCHAR(MAX)'),1,2,' ') List_Output
		FROM AnalysisConfigBlockedDatabases acbd
		GROUP BY AnalysisConfigurationID
		HAVING analysisConfig.ID = AnalysisConfigurationID) AS BlockedDatabasesWithName
		,(SELECT STUFF((SELECT ',' + CAST(RecommendationID AS VARCHAR(10)) [text()]
         FROM AnalysisConfigBlockedRecommendation 
         WHERE AnalysisConfigurationID = acbr.AnalysisConfigurationID AND  analysisConfig.ID = AnalysisConfigurationID
         FOR XML PATH(''), TYPE)
        .value('.','NVARCHAR(MAX)'),1,1,'') List_Output
		FROM AnalysisConfigBlockedRecommendation acbr
		GROUP BY AnalysisConfigurationID
		HAVING analysisConfig.ID = AnalysisConfigurationID) AS BlockedRecommendations
		-- END 10.0 (srishti purohit) : To handle analysis configuration

	FROM [MonitoredSQLServers] a (NOLOCK)
		LEFT JOIN [VirtualHostServers] b (NOLOCK)
			on a.VHostID = b.VHostID 
		LEFT JOIN [BaselineTemplates] c (NOLOCK)
			on a.SQLServerID = c.SQLServerID and c.TemplateID = (select MAX(TemplateID) from BaselineTemplates where SQLServerID = a.SQLServerID)
		LEFT JOIN [MonitoredServerSQLsafeInstance] d (NOLOCK)
			on a.SQLServerID = d.SQLServerID
		LEFT JOIN [SQLsafeConnections] f (NOLOCK)
			on d.RepositoryId = f.RepositoryId and f.Deleted <> 1
		LEFT JOIN AnalysisConfiguration analysisConfig (NOLOCK)
			on a.SQLServerID = analysisConfig.MonitoredServerID AND analysisConfig.IsActive = 1
		
		INNER JOIN #serverIds sids (NOLOCK)
		    on a.SQLServerID = sids.SQLServerID
		outer apply
			(
			select top 1 Enabled as JobAlertEnabled
			from MetricThresholds mt (NOLOCK)
			where Enabled = 1
			and mt.SQLServerID = a.SQLServerID
			-- Job related alerts:
			-- 34 - SQL Server Agent Long Running Job (Percent)
			-- 35 - SQL Server Agent Job Failure
			-- 65 - SQL Server Agent Long Running Job (Minutes)
			-- 88 - SQL Server Agent Job Completion
			and Metric in (34,35,65,88)
			) j
		outer apply
		(
			select top 1 Enabled as LogAlertEnabled
			from MetricThresholds mt (NOLOCK)
			where Enabled = 1
			and mt.SQLServerID = a.SQLServerID
			-- Job related alerts:
			-- 66 - SQL Server Error Log
			-- 67 - SQL Server Agent Log
			and Metric in (66,67)
			) e			
	WHERE
		((@CollectionServiceId IS NULL) OR (a.[CollectionServiceID] = @CollectionServiceId)) AND
		((@ActiveOnly = 0) OR (a.[Active] = 1))
	
	IF (@GetLicenseKeys != 0) 
    BEGIN
		DECLARE @ReturnServerCount int
		DECLARE @ret int
		DECLARE @inst nvarchar(128) 
		EXEC @ret = [p_GetLicenseKeys] 
			@LicenseID = null, 
			@ReturnServerCount = @ReturnServerCount output, 
			@ReturnInstanceName = @inst output
	END

	IF (@CustomCounters = 1)
	BEGIN
		SELECT [CCM].[SQLServerID],[CCM].[Metric] 
			FROM CustomCounterMap CCM (NOLOCK), MonitoredSQLServers MSS (NOLOCK)
			WHERE ([CCM].[SQLServerID] = [MSS].[SQLServerID]) and
				((@ActiveOnly = 0) OR ([MSS].[Active] = 1))
		union
		SELECT ST.SQLServerId, CCT.Metric from ServerTags ST (NOLOCK)
			JOIN CustomCounterTags CCT (NOLOCK) on ST.TagId = CCT.TagId
			LEFT OUTER JOIN CustomCounterMap CCM (NOLOCK) on ST.SQLServerId = CCM.SQLServerID and CCT.Metric = CCM.Metric
			inner join MonitoredSQLServers MSS (NOLOCK) on ST.SQLServerId = MSS.SQLServerID
			WHERE ((@ActiveOnly = 0) OR ([MSS].[Active] = 1))
		ORDER BY SQLServerID
		
		
		SELECT ST.[SQLServerId], ST.[TagId]
			FROM ServerTags ST (NOLOCK), MonitoredSQLServers MSS (NOLOCK)
			WHERE (ST.[SQLServerId] = [MSS].[SQLServerID]) and
				((@ActiveOnly = 0) OR ([MSS].[Active] = 1))
			ORDER BY [ST].[SQLServerId]
	END



	SELECT @error = @@error

	IF @error != 0 GOTO HANDLE_ERROR

	RETURN(0)

	HANDLE_ERROR:
		RAISERROR('An error occurred while getting the monitored SQL Server instances.', 10, 1)
        RETURN(@error)			
END
 

GO

 
GO 

---------- P_GETMONITOREDSQLSERVERSTATUS.SQL
if (object_id('p_GetMonitoredSqlServerStatus') is not null)
begin
drop procedure [p_GetMonitoredSqlServerStatus]
end
go

create procedure [p_GetMonitoredSqlServerStatus]
	(@SelectedServerID int = NULL)
as
begin
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

declare @SQLServerID int, @ThresholdEnabled bit, @WarningThresholdXML nvarchar(1024), @CriticalThresholdXML nvarchar(1024)
declare @ReorgThresholds table(SQLServerID int, WarningThreshold int, CriticalThreshold int) 
declare @WarningThresholdValue float, @CriticalThresholdValue float
declare @WarningThresholdEnabled bit, @CriticalThresholdEnabled bit
declare @xmlDoc int
declare @Now datetime

declare @Snoozers table(InstanceID int not null, NumberSnoozed int not null, NumberThresholds int not null)
declare @AlertSummary table(ServerName nvarchar(256) COLLATE SQL_Latin1_General_CP1_CS_AS not null, NumberWarning int not null, NumberCritical int not null, NumberInfo int not null)
declare @SQLServers table(
		SQLServerID int,
		InstanceName nvarchar(256),
		LastScheduledCollectionTime datetime,
		LastDatabaseCollectionTime datetime,
		IsMaintenanceMode bit ) 

insert into @SQLServers
select SQLServerID, InstanceName, LastScheduledCollectionTime, LastDatabaseCollectionTime, 0
from MonitoredSQLServers MS (NOLOCK)
where 	
	MS.Active = 1

update @SQLServers
set IsMaintenanceMode = 1
from
@SQLServers S inner join Alerts A (NOLOCK) on A.ServerName collate database_default = S.InstanceName collate database_default 
where A.Metric = 48 and S.LastScheduledCollectionTime = A.UTCOccurrenceDateTime

INSERT INTO @AlertSummary
select  InstanceName, 
		sum(case when Severity = 4 then 1 else 0 end),
		sum(case when Severity = 8 then 1 else 0 end),
		sum(case when Severity = 2 then 1 else 0 end)
	from @SQLServers MS  
		left outer join Alerts A (nolock) on
			MS.InstanceName = A.ServerName and
			MS.LastScheduledCollectionTime = A.UTCOccurrenceDateTime
	where 
       (@SelectedServerID is null or @SelectedServerID = MS.SQLServerID) and
	   (A.Active = 1)  
	   and (
			(
			IsMaintenanceMode = 1 and
			(A.Metric = 48 and A.Metric = 48 and MS.LastScheduledCollectionTime = A.UTCOccurrenceDateTime)
			)
			or
			(
			IsMaintenanceMode = 0 and
				(
				(A.Metric not in (select MetricID from DBMetrics) and MS.LastScheduledCollectionTime = A.UTCOccurrenceDateTime)
				or (A.Metric  in (select MetricID from DBMetrics) and MS.LastDatabaseCollectionTime = A.UTCOccurrenceDateTime)
				)
			)
		)
group by InstanceName




set @Now = GetUTCDate()

INSERT INTO @Snoozers
select MS.SQLServerID,
	sum(case when UTCSnoozeEnd > @Now then 1 else 0 end),
	count(MT.SQLServerID)
		from MonitoredSQLServers MS (nolock)
		left outer join MetricThresholds MT (nolock) on
		    MS.SQLServerID = MT.SQLServerID
where
   (MS.Active = 1) and
   (@SelectedServerID is null or @SelectedServerID = MS.SQLServerID) 
group by MS.SQLServerID


Select 1 as [Tag], NULL as [Parent],
	@Now as [Servers!1!Retrieved],
	NULL as [Server!2!SQLServerID],
	NULL as [Server!2!InstanceName],
	NULL as [Server!2!MaintenanceModeEnabled],
	NULL as [Server!2!ServerVersion],
	NULL as [Server!2!ServerEdition],
	NULL as [Server!2!LastScheduledCollectionTime],
	NULL as [Server!2!LastReorgStatisticsRunTime],
	NULL as [Server!2!LastAlertRefreshTime],
	NULL as [Server!2!LastDatabaseRefreshTime],
	NULL as [Server!2!ActiveWarningAlerts],
	NULL as [Server!2!ActiveCriticalAlerts],
	NULL as [Server!2!ActiveInfoAlerts],
    NULL as [Server!2!CustomCounterCount],
	NULL as [Server!2!ThresholdCount],
	NULL as [Server!2!AlertsSnoozing],
	NULL as [Category!3!Name],
	NULL as [State!4!Rank],
	NULL as [State!4!Metric],
	NULL as [State!4!Severity],
	NULL as [State!4!Subject],
	NULL as [State!4!OccurenceTime],
	NULL as [Database!5!Id],
	NULL as [Database!5!Name],
    NULL as [Database!5!IsSystemDatabase],
	NULL as [Table!6!Id],
	NULL as [Table!6!Schema],
	NULL as [Table!6!Name],
	NULL as [Table!6!Severity],
	NULL as [Table!6!IsSystemTable],
	NULL as [Table!6!Fragmentation]

UNION ALL
Select 2 as [Tag], 1 as [Parent], 
	NULL,
	SQLServerID,  
	InstanceName,
	MaintenanceModeEnabled,
	ServerVersion,
	ServerEdition,
	LastScheduledCollectionTime,
	LastReorgStatisticsRunTime,
	LastAlertRefreshTime,
	LastDatabaseCollectionTime,
	COALESCE(NumberWarning,0),
	COALESCE(NumberCritical,0),
	COALESCE(NumberInfo,0),
	-- count of assigned custom counters (direct assign or from tags)
	(select count(distinct CCD.Metric) from [CustomCounterDefinition] CCD (nolock)
		LEFT OUTER JOIN CustomCounterMap CCM (nolock) on CCM.SQLServerID = [MonitoredSQLServers].[SQLServerID] and CCM.Metric = CCD.Metric
		LEFT OUTER JOIN ServerTags ST (nolock) on ST.[SQLServerId] = [MonitoredSQLServers].[SQLServerID]
		LEFT OUTER JOIN CustomCounterTags CCT (nolock) on CCT.Metric = CCD.Metric and ST.TagId = CCT.TagId
		WHERE CCM.Metric is not null or CCT.Metric is not null),
	[NumberThresholds],
	[NumberSnoozed],
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL
from MonitoredSQLServers (nolock)
	left outer join @AlertSummary on InstanceName = ServerName
	left outer join @Snoozers on MonitoredSQLServers.SQLServerID = InstanceID
	where (Active = 1) and (@SelectedServerID is null or @SelectedServerID = MonitoredSQLServers.SQLServerID)

UNION ALL
Select distinct 3 as [Tag], 2 as [Parent],
	NULL,
	SQLServerID,
	InstanceName,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	Category, 
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL
from MonitoredSQLServers (nolock), MetricInfo (nolock)
	where (Active = 1) and
		  (@SelectedServerID is null or @SelectedServerID = SQLServerID)

UNION ALL
Select 4 as [Tag], 3 as [Parent],
	NULL,
	MS.SQLServerID,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	MI.Category,
	MI.[Rank],
	A.Metric,
	A.Severity,
	A.Heading,
	A.UTCOccurrenceDateTime,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL
From @SQLServers MS 
	inner join Alerts A (nolock) on 
		MS.InstanceName = A.ServerName
		And (MS.LastScheduledCollectionTime = A.UTCOccurrenceDateTime
			Or MS.LastDatabaseCollectionTime = A.UTCOccurrenceDateTime)
	inner join MetricInfo MI (NOLOCK) on
		A.Metric = MI.Metric
	left outer join [MetricThresholds] MT (NOLOCK) on 
		MS.SQLServerID = MT.SQLServerID and
		A.Metric = MT.Metric
where 
	(@SelectedServerID is null or @SelectedServerID = MS.SQLServerID) and
	(MT.UTCSnoozeEnd is null or MT.UTCSnoozeEnd <= @Now)
	and (
			(
			IsMaintenanceMode = 1 and
			(A.Metric = 48 and A.Metric = 48 and MS.LastScheduledCollectionTime = A.UTCOccurrenceDateTime)
			)
			or
			(
			IsMaintenanceMode = 0 and
				(
				(A.Metric not in (select MetricID from DBMetrics (NOLOCK)) and MS.LastScheduledCollectionTime = A.UTCOccurrenceDateTime)
				or (A.Metric  in (select MetricID from DBMetrics (NOLOCK)) and MS.LastDatabaseCollectionTime = A.UTCOccurrenceDateTime)
				)
			)
		)

UNION ALL
Select distinct 5 as [Tag], 3 as [Parent],
	NULL,
	MS.SQLServerID,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	MI.Category,
	NULL, --MI.Rank,
	NULL, --A.Metric,
	NULL, --A.Severity,
	NULL, --A.Heading,
	NULL, --A.UTCOccurrenceDateTime,
	DB.DatabaseID,
	A.DatabaseName,
	DB.SystemDatabase,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL
From @SQLServers MS 
	inner join Alerts A (nolock) on 
		MS.InstanceName = A.ServerName
		And (MS.LastScheduledCollectionTime = A.UTCOccurrenceDateTime
			Or MS.LastDatabaseCollectionTime = A.UTCOccurrenceDateTime)
	inner join MetricInfo MI (nolock) on
		A.Metric = MI.Metric
	left outer join [MetricThresholds] MT (NOLOCK) on 
		MS.SQLServerID = MT.SQLServerID and
		A.Metric = MT.Metric
	left outer join SQLServerDatabaseNames DB (nolock) on
		MS.SQLServerID = DB.SQLServerID and 
		A.DatabaseName = DB.DatabaseName
where (A.DatabaseName is not null) and
      (@SelectedServerID is null or @SelectedServerID = MS.SQLServerID) and
	  (MT.UTCSnoozeEnd is null or MT.UTCSnoozeEnd <= @Now)
	   and (
			(
			IsMaintenanceMode = 1 and
			(A.Metric = 48 and A.Metric = 48 and MS.LastScheduledCollectionTime = A.UTCOccurrenceDateTime)
			)
			or
			(
			IsMaintenanceMode = 0 and
				(
				(A.Metric not in (select MetricID from DBMetrics (NOLOCK)) and MS.LastScheduledCollectionTime = A.UTCOccurrenceDateTime)
				or (A.Metric  in (select MetricID from DBMetrics (NOLOCK)) and MS.LastDatabaseCollectionTime = A.UTCOccurrenceDateTime)
				)
			)
		)


-- UNION ALL
--Select 6 as [Tag], 5 as [Parent],
--	NULL,
--	OE.ServerID,
--	NULL,
--	NULL,
--	NULL,
--	NULL,
--	NULL,
--	NULL,
--	NULL,
--	MI.Category,
--	MI.Rank,
--	OE.Metric,
--	NULL,
--	NULL,
--	OE.OccurenceTime,
--	OE.DatabaseID,
--	DB.DatabaseName,
--	NULL,
--	TR.TableID,
--	TB.SchemaName,
--	TB.TableName,
--	case 
--		when convert(int,100 - TR.ScanDensity) >= RT.CriticalThreshold then 4 
--		when convert(int,100 - TR.ScanDensity) >= RT.WarningThreshold then 2 
--		else 1 
--	end,
--	TB.SystemTable,
--	convert(int,100 - TR.ScanDensity)
--From OutstandingEvents OE (nolock)
--	left join  MetricInfo MI (nolock) on OE.Metric = MI.Metric
--	left join SQLServerDatabaseNames DB (nolock)
--		on DB.SQLServerID = OE.ServerID and
--	       DB.DatabaseID = OE.DatabaseID
--	left join SQLServerTableNames TB (nolock)
--		on TB.DatabaseID = DB.DatabaseID 
--	left join MonitoredSQLServers MS (nolock)
--		on DB.SQLServerID = MS.SQLServerID
--	left outer join @ReorgThresholds RT 
--		on RT.SQLServerID = OE.ServerID	
--	left outer join TableReorganization TR (nolock)
--		on TR.TableID = TB.TableID and
--		   TR.UTCCollectionDateTime = MS.LastReorgStatisticsRunTimeUTC
--where 
--  	  (@SelectedServerID is null or @SelectedServerID = OE.ServerID) and
--	  OE.DatabaseID != -1 and 
--	  OE.Metric = 7 and 
--	  TR.TableID is not null and
--	  TR.ScanDensity < 100 and
--	  (100 - TR.ScanDensity) >= RT.WarningThreshold 

UNION ALL
Select 4 as [Tag], 5 as [Parent],
	NULL,
	MS.SQLServerID,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	MI.Category,
	MI.[Rank],
	A.Metric,
	A.Severity,
	A.Heading,
	A.UTCOccurrenceDateTime,
	DB.DatabaseID,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL 
From @SQLServers MS 
	inner join Alerts A (nolock) on 
		MS.InstanceName = A.ServerName 
		And (MS.LastScheduledCollectionTime = A.UTCOccurrenceDateTime
			Or MS.LastDatabaseCollectionTime = A.UTCOccurrenceDateTime)
	inner join MetricInfo MI (nolock) on
		A.Metric = MI.Metric
	left outer join [MetricThresholds] MT (NOLOCK) on 
		MS.SQLServerID = MT.SQLServerID and
		A.Metric = MT.Metric
	left outer join SQLServerDatabaseNames DB (nolock) on
		MS.SQLServerID = DB.SQLServerID and 
		A.DatabaseName = DB.DatabaseName
where 
	  (@SelectedServerID is null or @SelectedServerID = MS.SQLServerID) and
	  (A.DatabaseName is not null) and
	  (MT.UTCSnoozeEnd is null or MT.UTCSnoozeEnd <= @Now)
	  and (
			(
			IsMaintenanceMode = 1 and
			(A.Metric = 48 and A.Metric = 48 and MS.LastScheduledCollectionTime = A.UTCOccurrenceDateTime)
			)
			or
			(
			IsMaintenanceMode = 0 and
				(
				(A.Metric not in (select MetricID from DBMetrics (NOLOCK) ) and MS.LastScheduledCollectionTime = A.UTCOccurrenceDateTime)
				or (A.Metric  in (select MetricID from DBMetrics (NOLOCK) ) and MS.LastDatabaseCollectionTime = A.UTCOccurrenceDateTime)
				)
			)
		)

order by [Server!2!SQLServerID],
		 [Category!3!Name],
		 [Database!5!Id],
		 [Table!6!Id],
		 [Parent],[Tag],
		 [State!4!Severity] DESC,
		 [State!4!Rank],
		 [State!4!OccurenceTime] DESC
		
FOR XML EXPLICIT

end
 
GO 

---------- P_GETMONITOREDSQLSERVERSUSINGCOUNTER.SQL
IF (object_id('p_GetMonitoredSqlServersUsingCounter') IS NOT NULL)
BEGIN
DROP PROCEDURE p_GetMonitoredSqlServersUsingCounter
END
GO

CREATE PROCEDURE [dbo].[p_GetMonitoredSqlServersUsingCounter]
(
	@Metric int
)
AS
BEGIN
	DECLARE @error INT
	
	-- custom counters from tags
	SELECT ST.SQLServerId
		FROM [CustomCounterTags] CCT
			JOIN [ServerTags] ST on CCT.TagId = ST.TagId
		WHERE CCT.[Metric] = @Metric
	UNION 
	-- directly associated counters
	SELECT SQLServerID 
		FROM CustomCounterMap
		WHERE Metric = @Metric

	SELECT @error = @@error
	RETURN @error
END
 
GO 

---------- P_GETMONITOREDSQLSERVERWORKLOAD.SQL
if (object_id('p_GetMonitoredSQLServerWorkload') is not null)
begin
drop procedure p_GetMonitoredSQLServerWorkload
end
go
CREATE PROCEDURE [dbo].[p_GetMonitoredSQLServerWorkload]
(
	@SQLServerID int
)
AS
BEGIN
	DECLARE @e INT

	exec @e = p_GetMetricThresholds NULL, @SQLServerID
	if (@e = 0)
	begin
		exec @e = p_GetMonitoredSQLServerCounters @SQLServerID
	end

	--SQLdm 8.6 -- (Ankit Srivastava) -- Fro Supressing SQL Express Alert which are not required
	SELECT [Metric],[IsValidForSqlExpress]
			FROM [MetricMetaData]	

	if (@e = 0)
	begin
		exec @e = p_GetBaselineCheckThresholdDeviation @SQLServerID
	end

	--START: SQLdm 10.0 (Tarun Sapra)- Get the cloud provider id for the monitored sql server
	SELECT CloudProviderId AS CloudProviderId FROM MonitoredSQLServers WHERE SQLServerID = @SQLServerID 
	--END: SQLdm 10.0 (Tarun Sapra)- Get the cloud provider id for the monitored sql server

	RETURN @e
END
 
GO 

---------- P_GETMOSTCRITICALSERVERS.SQL
if (object_id('p_GetMostCriticalServers') is not null)
begin
drop procedure [p_GetMostCriticalServers]
end
go

create procedure [dbo].[p_GetMostCriticalServers]
as
begin
	declare @now datetime

	declare @IntermediateTable table(
		SQLServerID int,
		InstanceName nvarchar(255) collate database_default,      
		Metric int, 
		LastAlertRefreshTime datetime, 
		IsSnoozed bit,
		[Rank] int)

	select @now = DateAdd(second,10,GetUTCDate())

	insert into @IntermediateTable
	select      
	    MS.SQLServerID,
		MS.InstanceName,
		M.Metric, 
		MS.LastAlertRefreshTime, 
		case when T.UTCSnoozeEnd > @now then 1 else 0 end,
		M.[Rank]
	from MonitoredSQLServers MS (nolock)
	join MetricThresholds T (nolock) on MS.SQLServerID = T.SQLServerID
	join MetricMetaData M (nolock) on T.Metric = M.Metric
	WHERE 
		MS.Active = 1 and M.Deleted = 0 and
	    (T.Enabled = 1 or T.Enabled is null) and
		(T.[UTCSnoozeEnd] is null or T.[UTCSnoozeEnd] < @now)  


	SELECT 
		I.SQLServerID
		,InstanceName=MAX(I.InstanceName)
		,AlertCount=COUNT(*)
		,AlertScore=SUM(I.[Rank] * A.[Severity]) 
	from 
		@IntermediateTable I
		inner join Alerts A (nolock) on 
			A.[ServerName] = I.InstanceName and
			A.UTCOccurrenceDateTime = I.LastAlertRefreshTime and
			A.Metric = I.Metric     
	where
		A.[Active] = 1
		and I.IsSnoozed = 0
	GROUP BY I.SQLServerID
	ORDER BY 4 DESC, 3 DESC, 1 ASC
end
 
GO 

---------- P_GETNEWTEMPLATEOPTIONS.SQL
if (object_id('p_GetNewTemplateOptions') is not null)
begin
drop procedure p_GetNewTemplateOptions
end
go

CREATE PROCEDURE [dbo].p_GetNewTemplateOptions
as
BEGIN
  

-- These selects are broken up on purpose to ensure the order that the data is returned
SELECT 'Template', [TemplateID], [Name] from [dbo].[AlertTemplateLookup] order by [Default] DESC

SELECT 'Server', [SQLServerID], [InstanceName] FROM [dbo].[MonitoredSQLServers]

END
 
GO 

---------- P_GETNEXTANALYSISACTIVITYSNAPSHOTDATETIME.SQL
if (object_id('p_GetNextAnalysisActivitySnapshotDateTime') is not null)
begin
drop procedure [p_GetNextAnalysisActivitySnapshotDateTime]
end
go
create procedure [dbo].[p_GetNextAnalysisActivitySnapshotDateTime]
	@SQLServerID int,
	@UTCSnapshotCollectionDateTime datetime
	--@RefreshType int = 0
as
begin
set transaction isolation level read uncommitted
declare @err int

select 
	min(UTCAnalysisCompleteTime)
from 
	PrescriptiveAnalysis
where 
	UTCAnalysisCompleteTime > @UTCSnapshotCollectionDateTime
	and [SQLServerID] = @SQLServerID
	--and isnull(RefreshType, 0) = @RefreshType

select @err = @@error
return @err
end
 
GO 

---------- P_GETNEXTPREDICTIVEFORECAST.SQL
if (object_id('p_GetNextPredictiveForecast') is not null)
begin
drop procedure p_GetNextPredictiveForecast 
end
go
create procedure p_GetNextPredictiveForecast
as
begin
		select Character_Value from RepositoryInfo where Name = 'PredictiveAnalyticsForecast'
end
 
GO 

---------- P_GETNEXTPREDICTIVEMODELREBUILD.SQL
if (object_id('p_GetNextPredictiveModelRebuild') is not null)
begin
drop procedure p_GetNextPredictiveModelRebuild 
end
go
create procedure p_GetNextPredictiveModelRebuild
as
begin
		select Character_Value from RepositoryInfo where Name = 'PredictiveAnalyticsRebuild'
end
 
GO 

---------- P_GETNEXTSERVERACTIVITYSNAPSHOTDATETIME.SQL
if (object_id('p_GetNextServerActivitySnapshotDateTime') is not null)
begin
drop procedure [p_GetNextServerActivitySnapshotDateTime]
end
go
create procedure [dbo].[p_GetNextServerActivitySnapshotDateTime]
	@SQLServerID int,
	@UTCSnapshotCollectionDateTime datetime,
	@RefreshType int = 0
as
begin
set transaction isolation level read uncommitted
declare @err int

select 
	min(UTCCollectionDateTime)
from 
	[ServerActivity]
where 
	[UTCCollectionDateTime] > @UTCSnapshotCollectionDateTime 
	and [SQLServerID] = @SQLServerID
	and isnull(RefreshType, 0) = @RefreshType

select @err = @@error
return @err
end
 
GO 

---------- P_GETNOTIFICATIONPROVIDERS.SQL
if (object_id('p_GetNotificationProviders') is not null)
begin
drop procedure [p_GetNotificationProviders]
end
go

create procedure [p_GetNotificationProviders]
	@ProviderId uniqueidentifier
as
begin
	DECLARE @err int
	IF (@ProviderId IS NULL)
	BEGIN	
		SELECT [ProviderId], [SerializedType], [SerializedObject] from [NotificationProviders]
	END
	ELSE
	BEGIN
		SELECT [ProviderId], [SerializedType], [SerializedObject] from [NotificationProviders]
			WHERE [ProviderId] = @ProviderId
	END
	SELECT @err = @@error

	RETURN @err
end
 
GO 

---------- P_GETNOTIFICATIONRULES.SQL
if (object_id('p_GetNotificationRules') is not null)
begin
drop procedure [p_GetNotificationRules]
end
go

create procedure [p_GetNotificationRules]
	@RuleID uniqueidentifier
as
begin
	DECLARE @err int
	IF (@RuleID IS NULL)
	BEGIN	
		SELECT [RuleID], [SerializedObject] from [NotificationRules]
	END
	ELSE
	BEGIN
		SELECT [RuleID], [SerializedObject] from [NotificationRules]
			WHERE [RuleID] = @RuleID
	END
	SELECT @err = @@error

	RETURN @err
end
 
GO 

---------- P_GETOSSTATISTICSAVAILABLE.SQL
if (object_id('[p_GetOSStatisticsAvailable]') is not null)
begin
drop procedure [dbo].[p_GetOSStatisticsAvailable]
end
go
Create Proc p_GetOSStatisticsAvailable
@ServerID int
as
begin
SELECT     OsStatisticAvailability
FROM         ServerStatistics AS ss (nolock)
WHERE     (UTCCollectionDateTime =
                          (SELECT     MAX(UTCCollectionDateTime) AS EXPR1
                            FROM          ServerStatistics (nolock)
                            WHERE      (SQLServerID = @ServerID))) AND (SQLServerID = @ServerID)
END
 
GO 

---------- P_GETPERMISSIONS.SQL
IF (object_id('p_GetPermissions') is not null)
BEGIN
drop procedure p_GetPermissions
END
GO

CREATE PROCEDURE [dbo].[p_GetPermissions]
AS
BEGIN
	declare @e int
	declare @securityEnabled bit

	-- check if security is enabled, and return flags.
	if ((select count([Internal_Value]) from dbo.[RepositoryInfo] where [Name] = 'ApplicationSecurityEnabled' and [Internal_Value] != 0) = 1)
		set @securityEnabled = 1
	else
		set @securityEnabled = 0
		
	select @securityEnabled as SecurityEnabled

	-- Get all permissions defined in SQLdm if security is enabled.
	-- Get all users belonging to sysadmin role, these permissions are system defined
	-- and cannot be edited.   These users have administrator power in SQLdm.
	if @securityEnabled = 1
	begin
		select
			[PermisisonID] = -1, -- no identity column, set to magic number -1
			[System] = 1, -- system permission
			[Enabled] = 1,
			sl.sid as [LoginSID],
			sl.[name] as [Login],
			[LoginType] = 	case sl.isntname
						when 1 then -- isntname
							case sl.[isntgroup]
								when 0 then 1 -- windows user
								else 2 -- windows group
							end
						when 0 then 3 -- sql login
						else 
							0 -- unknown
					end,
			[PermissionType] = 2, -- administrator
			[SQLServerID] = null,
			[InstanceName] = null,
			[Active] = cast(null as binary),
			[Deleted] = cast(null as binary),
			[Comment] = ''		,
			[WebAppPermission] =1  -- SQLdm 8.5 <Ankit Srivastava> added new columns
		from [master]..[syslogins] as sl
		where sl.sysadmin = 1 
		union
		-- Get all permissions defined in Permission table.   Do a join with sysusers to
		-- get login name and type.   If there is no corresponding login in sysusers table
		-- then set login type to UNKNOWN.   Do a join with PermissionServers/MonitoredSQLServers
		-- tables to get a list of instances assigned.
		select 
			p.[PermissionID] as [PermissionID], 
			[System] = 0, -- user defined permission
			p.[Enabled] as [Enabled], 
			p.[LoginSID] as [LoginSID], 
			sl.[name] as [Login],
			[LoginType] = 	case sl.isntname
						when 1 then -- isntname
							case sl.[isntgroup]
								when 0 then 1 -- windows user
								else 2 -- windows group
							end
						when 0 then 3 -- sql login
						else 
							0 -- unknown
					end,
			p.[Permission] as [PermissionType], 
			s.[SQLServerID] as [SQLServerID], 
			mss.[InstanceName] as [InstanceName],
			mss.[Active] as [Active],
			mss.[Deleted] as [Deleted],
			p.[Comment] as [Comment],
			p.[WebAppPermission] as [WebAppPermission]  -- SQLdm 8.5 <Ankit Srivastava> added new columns
		from [dbo].[Permission] as p 
			left join [dbo].[PermissionServers] as s on (p.[PermissionID] = s.[PermissionID])
			left join [dbo].[MonitoredSQLServers] as mss on (s.[SQLServerID] = mss.[SQLServerID])
			join [master]..[syslogins] as sl on (p.[LoginSID] = sl.[sid])
		UNION -- pick up server assignments from permission tags
		select 
			p.[PermissionID] as [PermissionID], 
			[System] = 0, -- user defined permission
			p.[Enabled] as [Enabled], 
			p.[LoginSID] as [LoginSID], 
			sl.[name] as [Login],
			[LoginType] = 	case sl.isntname
						when 1 then -- isntname
							case sl.[isntgroup]
								when 0 then 1 -- windows user
								else 2 -- windows group
							end
						when 0 then 3 -- sql login
						else 
							0 -- unknown
					end,
			p.[Permission] as [PermissionType], 
			st.[SQLServerId] as [SQLServerID], 
			mss.[InstanceName] as [InstanceName],
			mss.[Active] as [Active],
			mss.[Deleted] as [Deleted],
			p.[Comment] as [Comment],
			p.[WebAppPermission] as [WebAppPermission]  -- SQLdm 8.5 <Ankit Srivastava> added new columns
		from [dbo].[Permission] as p 
			left join [dbo].[PermissionTags] as pt on (p.[PermissionID] = pt.[PermissionId])
			left join [dbo].[ServerTags] as st on (pt.[TagId] = st.[TagId])
			left join [dbo].[MonitoredSQLServers] as mss on (st.[SQLServerId] = mss.[SQLServerID])
			join [master]..[syslogins] as sl on (p.[LoginSID] = sl.[sid])
		where 
			st.[SQLServerId] is not null and
			st.[SQLServerId] not in
				(select [SQLServerID] 
					from [dbo].[PermissionServers] s 
					where p.[PermissionID] = s.[PermissionID])
	end
	
	select @e = @@error
	return @e
END
GO
 
GO 

---------- P_GETPERMISSIONTAGSANDSERVERS.SQL
IF (object_id('p_GetPermissionTagsAndServers') is not null)
BEGIN
drop procedure p_GetPermissionTagsAndServers
END
GO

CREATE PROCEDURE [dbo].[p_GetPermissionTagsAndServers]
(
	@PermissionId INT
)
AS
BEGIN
	declare @e int
	declare @securityEnabled bit

	if ((select count([Internal_Value]) from dbo.[RepositoryInfo] where [Name] = 'ApplicationSecurityEnabled' and [Internal_Value] != 0) = 1)
		set @securityEnabled = 1
	else
		set @securityEnabled = 0
		
	select @securityEnabled as SecurityEnabled

	if @securityEnabled = 1
	begin
		select TagId from PermissionTags where PermissionId = @PermissionId
		select SQLServerID from PermissionServers where PermissionID = @PermissionId
	end
	
	select @e = @@error
	return @e
END
 
GO 

---------- P_GETPREDICTIVEANALYTICSENABLED.SQL
if (object_id('p_GetPredictiveAnalyticsEnabled') is not null)
begin
drop procedure p_GetPredictiveAnalyticsEnabled 
end
go
create procedure p_GetPredictiveAnalyticsEnabled
	@PredictiveAnalyticsEnabled int output
as
begin
	if exists(select Name from [RepositoryInfo] where Name = 'PredictiveAnalyticsEnabled')
	begin
		select @PredictiveAnalyticsEnabled = Internal_Value from RepositoryInfo where Name = 'PredictiveAnalyticsEnabled'
	end
	else
	begin
		select @PredictiveAnalyticsEnabled = 0
	end
end
 
GO 

---------- P_GETPREDICTIVEFORECASTS.SQL
IF (OBJECT_ID('p_GetPredictiveForecasts') IS NOT NULL)
BEGIN
      DROP PROCEDURE [p_GetPredictiveForecasts]
END
GO

CREATE PROCEDURE [dbo].[p_GetPredictiveForecasts] 
      @SQLServerID int  
AS
BEGIN 
      
      IF @SQLServerID = -1
      BEGIN
      
            SELECT      b.InstanceName as 'ServerName',  c.Name as 'MetricName', Severity, Timeframe, Forecast, 
						case
							when Forecast = 0 then 0.05
							else Accuracy
						end as Accuracy, 
						Expiration 
            FROM  PredictiveForecasts a
                        INNER JOIN MonitoredSQLServers b ON a.SQLServerID = b.SQLServerID
                        INNER JOIN MetricInfo          c ON a.Metric = c.Metric
                        INNER JOIN MetricThresholds    d ON c.Metric = d.Metric and b.SQLServerID = d.SQLServerID
            WHERE
                        d.Enabled = 1
                        AND b.Active = 1
      
      END
      ELSE
      BEGIN
            
            SELECT      b.InstanceName as 'ServerName', c.Name as 'MetricName', Severity, Timeframe, Forecast, 
						case
							when Forecast = 0 then 0.05
							else Accuracy
						end as Accuracy, 
						Expiration 
            FROM  PredictiveForecasts a
                        INNER JOIN MonitoredSQLServers b ON a.SQLServerID = b.SQLServerID
                        INNER JOIN MetricInfo          c ON a.Metric = c.Metric
                        INNER JOIN MetricThresholds    d ON c.Metric = d.Metric and b.SQLServerID = d.SQLServerID
            WHERE a.SQLServerID = @SQLServerID        
                        AND d.Enabled = 1
                        AND b.Active = 1
            
      END   

      DECLARE @err INT
      SELECT  @err = @@error
      RETURN  @err
      
END
 
GO 

---------- P_GETPREDICTIVEMODELINPUT.SQL

IF (OBJECT_ID('p_GetPredictiveModelInput') IS NOT NULL)
BEGIN
	DROP PROCEDURE [p_GetPredictiveModelInput]
END
GO

CREATE PROCEDURE [dbo].[p_GetPredictiveModelInput] 
	@SID   int,
	@INT   int,
	@START datetime,
	@END   datetime
AS
BEGIN

select max(UTCCollectionDateTime), AVG( TimeDeltaInSeconds), AVG( BufferCacheHitRatioPercentage), AVG( CheckpointWrites), AVG( ClientComputers), AVG( CPUActivityPercentage), AVG( CPUTimeDelta), AVG( CPUTimeRaw), AVG( FullScans), AVG( IdleTimeDelta), AVG( IdleTimePercentage), AVG( IdleTimeRaw), AVG( IOActivityPercentage), AVG( IOTimeDelta), AVG( IOTimeRaw), AVG( LazyWriterWrites), AVG( LockWaits), AVG( Logins), AVG( LogFlushes), AVG( SqlMemoryAllocatedInKilobytes), AVG( SqlMemoryUsedInKilobytes), AVG( OldestOpenTransactionsInMinutes), AVG( PacketErrors), AVG( PacketsReceived), AVG( PacketsSent), AVG( PageErrors), AVG( PageLifeExpectancy), AVG( PageLookups), AVG( PageReads), AVG( PageSplits), 
AVG( PageWrites), AVG( ProcedureCacheHitRatioPercentage), AVG( ProcedureCacheSizeInKilobytes), AVG( ProcedureCacheSizePercent), AVG( ReadAheadPages), AVG( ReplicationLatencyInSeconds), AVG( ResponseTimeInMilliseconds), AVG( SqlCompilations), AVG( SqlRecompilations), AVG( TableLockEscalations), AVG( TempDBSizeInKilobytes), AVG( TempDBSizePercent), AVG(Batches), AVG( UserProcesses), AVG( WorkFilesCreated), AVG( WorkTablesCreated), AVG( SystemProcesses), AVG( UserProcessesConsumingCPU), AVG( SystemProcessesConsumingCPU), AVG( BlockedProcesses), AVG( OpenTransactions), AVG( DatabaseCount), AVG( DataFileCount), AVG( LogFileCount), AVG( DataFileSpaceAllocatedInKilobytes), AVG( DataFileSpaceUsedInKilobytes), 
AVG( LogFileSpaceAllocatedInKilobytes), AVG( LogFileSpaceUsedInKilobytes), AVG( TotalLocks), AVG( BufferCacheSizeInKilobytes), AVG( ActiveProcesses), AVG( LeadBlockers), AVG( CommittedInKilobytes), AVG( ConnectionMemoryInKilobytes), AVG( FreePagesInKilobytes), AVG( GrantedWorkspaceMemoryInKilobytes), AVG( LockMemoryInKilobytes), AVG( OptimizerMemoryInKilobytes), AVG( TotalServerMemoryInKilobytes), AVG( FreeCachePagesInKilobytes), AVG( CachePagesInKilobytes), AVG( MaxConnections), AVG( PhysicalMemoryInKilobytes), AVG( ProcessorCount), AVG( ProcessorsUsed), AVG( DistributionLatencyInSeconds)
from ServerStatistics with (nolock)
where SQLServerID = @SID and UTCCollectionDateTime between DATEADD(MINUTE, -@INT, @START) and @END

END
 
GO 

---------- P_GETPREDICTIVEMODELSCOUNT.SQL
if (object_id('p_GetPredictiveModelsCount') is not null)
begin
drop procedure p_GetPredictiveModelsCount 
end
go
create procedure p_GetPredictiveModelsCount
as
begin
		select COUNT(SQLServerID) from PredictiveModels
end
 
GO 

---------- P_GETPREDICTIVETRAININGDATA.SQL

IF (OBJECT_ID('p_GetPredictiveTrainingData') IS NOT NULL)
BEGIN
	DROP PROCEDURE [p_GetPredictiveTrainingData]
END
GO

CREATE PROCEDURE [dbo].[p_GetPredictiveTrainingData] 
	@SID int,
	@MID int,
	@SEV int,
	@OFF int,
	@PRE int,
	@CUT DateTime	
AS
BEGIN	

declare @severity   int
declare @metricid   int
declare @serverid   int
declare @servername varchar(128)
declare @maxsid     int
declare @offset     int      -- time before first alert to encode as ON
declare @preoffset  int      -- number of minutes prior to offset range to also include -- enocded as OFF
declare @cutoff     DateTime -- cutoff for obtaining data

set @serverid  = @SID            
set @metricid  = @MID
set @severity  = @SEV
set @offset    = @OFF -- offset of tminus in minutes (how many minutes prior)
set @preoffset = @PRE -- minutes prior to offset to include
set @cutoff    = @CUT

set nocount on

select @servername = InstanceName from MonitoredSQLServers with (nolock) where SQLServerID = @serverid

declare @alerttimes table
(
    idx		int identity,
    tstamp	datetime
)

insert into @alerttimes 
select UTCOccurrenceDateTime from Alerts with (nolock)
where ServerName = @servername and Metric = @metricid and Severity = @severity
and (       (StateEvent & 0x12) = 0x12 -- OK -> Warning
        or	(StateEvent & 0x14) = 0x14 -- OK -> Critical
        or	(StateEvent & 0x24) = 0x24 -- Warning -> Critical
        or  (StateEvent & 0x53) = 0x53 -- Info -> Warning
        or  (StateEvent & 0x54) = 0x54 -- Info -> Critical
    )
and UTCOccurrenceDateTime <= @cutoff            	

declare @results table
(
    STATE int NULL,
    UTCCollectionDateTime datetime NULL,
    [Day] int NULL,
    [Weekday] int NULL,
    [Hour] int NULL,
    TimeDeltaInSeconds float NULL,
    BufferCacheHitRatioPercentage float NULL,
    CheckpointWrites bigint NULL,
    ClientComputers int NULL,
    CPUActivityPercentage float NULL,
    CPUTimeDelta bigint NULL,
    CPUTimeRaw bigint NULL,
    FullScans bigint NULL,
    IdleTimeDelta bigint NULL,
    IdleTimePercentage float NULL,
    IdleTimeRaw bigint NULL,
    IOActivityPercentage float NULL,
    IOTimeDelta bigint NULL,
    IOTimeRaw bigint NULL,
    LazyWriterWrites bigint NULL,
    LockWaits bigint NULL,
    Logins bigint NULL,
    LogFlushes bigint NULL,
    SqlMemoryAllocatedInKilobytes bigint NULL,
    SqlMemoryUsedInKilobytes bigint NULL,
    OldestOpenTransactionsInMinutes bigint NULL,
    PacketErrors bigint NULL,
    PacketsReceived bigint NULL,
    PacketsSent bigint NULL,
    PageErrors bigint NULL,
    PageLifeExpectancy bigint NULL,
    PageLookups bigint NULL,
    PageReads bigint NULL,
    PageSplits bigint NULL,
    PageWrites bigint NULL,
    ProcedureCacheHitRatioPercentage float NULL,
    ProcedureCacheSizeInKilobytes bigint NULL,
    ProcedureCacheSizePercent float NULL,
    ReadAheadPages bigint NULL,
    ReplicationLatencyInSeconds float NULL,
    ResponseTimeInMilliseconds int NULL,
    SqlCompilations bigint NULL,
    SqlRecompilations bigint NULL,
    TableLockEscalations bigint NULL,
    TempDBSizeInKilobytes bigint NULL,
    TempDBSizePercent float NULL,
    Batches bigint NULL,
    UserProcesses int NULL,
    WorkFilesCreated bigint NULL,
    WorkTablesCreated bigint NULL,
    SystemProcesses int NULL,
    UserProcessesConsumingCPU int NULL,
    SystemProcessesConsumingCPU int NULL,
    BlockedProcesses int NULL,
    OpenTransactions int NULL,
    DatabaseCount int NULL,
    DataFileCount int NULL,
    LogFileCount int NULL,
    DataFileSpaceAllocatedInKilobytes decimal(18,0) NULL,
    DataFileSpaceUsedInKilobytes decimal(18,0) NULL,
    LogFileSpaceAllocatedInKilobytes decimal(18,0) NULL,
    LogFileSpaceUsedInKilobytes decimal(18,0) NULL,
    TotalLocks decimal(18,0) NULL,
    BufferCacheSizeInKilobytes bigint NULL,
    ActiveProcesses int NULL,
    LeadBlockers int NULL,
    CommittedInKilobytes bigint NULL,
    ConnectionMemoryInKilobytes bigint NULL,
    FreePagesInKilobytes bigint NULL,
    GrantedWorkspaceMemoryInKilobytes bigint NULL,
    LockMemoryInKilobytes bigint NULL,
    OptimizerMemoryInKilobytes bigint NULL,
    TotalServerMemoryInKilobytes bigint NULL,
    FreeCachePagesInKilobytes bigint NULL,
    CachePagesInKilobytes bigint NULL,
    MaxConnections bigint NULL,
    PhysicalMemoryInKilobytes bigint NULL,
    ProcessorCount int NULL,
    ProcessorsUsed int NULL,
    DistributionLatencyInSeconds float NULL
)

declare @i      int
declare @maxi   int
declare @t      datetime
declare @tminus datetime
declare @pminus datetime

set @i = 0
select @maxi = MAX(idx) from @alerttimes

while @i <= @maxi
begin

    set @i = @i + 1
	
    select @t = tstamp from @alerttimes where idx = @i
	
    set @tminus = DATEADD(mi, -@offset, @t)
    set @pminus = DATEADD(mi, -@preoffset, @tminus)
	
    insert into @results
    select
        case 
            when UTCCollectionDateTime = @t then 1
            else 0
        end as [STATE],
        UTCCollectionDateTime, DATEPART(DAY, UTCCollectionDateTime), DATEPART(WEEKDAY, UTCCollectionDateTime), DATEPART(HOUR, UTCCollectionDateTime), TimeDeltaInSeconds, BufferCacheHitRatioPercentage, CheckpointWrites, ClientComputers, CPUActivityPercentage, 
        CPUTimeDelta, CPUTimeRaw, FullScans, IdleTimeDelta, IdleTimePercentage, IdleTimeRaw, IOActivityPercentage, IOTimeDelta, IOTimeRaw, LazyWriterWrites, LockWaits, Logins, LogFlushes, SqlMemoryAllocatedInKilobytes, SqlMemoryUsedInKilobytes, OldestOpenTransactionsInMinutes, 
        PacketErrors, PacketsReceived, PacketsSent, PageErrors, PageLifeExpectancy, PageLookups, PageReads, PageSplits, PageWrites, ProcedureCacheHitRatioPercentage, ProcedureCacheSizeInKilobytes, ProcedureCacheSizePercent, ReadAheadPages, ReplicationLatencyInSeconds, ResponseTimeInMilliseconds, 
        SqlCompilations, SqlRecompilations, TableLockEscalations, TempDBSizeInKilobytes, TempDBSizePercent, Batches, UserProcesses, WorkFilesCreated, WorkTablesCreated, SystemProcesses, UserProcessesConsumingCPU, SystemProcessesConsumingCPU, BlockedProcesses, OpenTransactions, 
        DatabaseCount, DataFileCount, LogFileCount, DataFileSpaceAllocatedInKilobytes, DataFileSpaceUsedInKilobytes, LogFileSpaceAllocatedInKilobytes, LogFileSpaceUsedInKilobytes, TotalLocks, BufferCacheSizeInKilobytes, ActiveProcesses, LeadBlockers, CommittedInKilobytes, ConnectionMemoryInKilobytes, 
        FreePagesInKilobytes, GrantedWorkspaceMemoryInKilobytes, LockMemoryInKilobytes, OptimizerMemoryInKilobytes, TotalServerMemoryInKilobytes, FreeCachePagesInKilobytes, CachePagesInKilobytes, MaxConnections, PhysicalMemoryInKilobytes, ProcessorCount, ProcessorsUsed, DistributionLatencyInSeconds
    from	ServerStatistics with (nolock)
    where	SQLServerID = @serverid
            and UTCCollectionDateTime between @pminus and @t

end

select top 1500 * from @results order by UTCCollectionDateTime desc
END
 
GO 

---------- P_GETPRESCRIPTIVEANALYSIS.SQL
if (object_id('p_GetPrescriptiveAnalysis') is not null)
begin
drop procedure p_GetPrescriptiveAnalysis
end
go
CREATE PROCEDURE [dbo].[p_GetPrescriptiveAnalysis]
	@SQLServerID int 
AS
BEGIN
	SELECT [AnalysisID]
      ,[SQLServerID]
      ,[UTCAnalysisStartTime]
      ,[UTCAnalysisCompleteTime]
      ,[RecommendationCount]
	FROM [dbo].[PrescriptiveAnalysis]
	where
		SQLServerID = @SQLServerID
END

GO
 
GO 

---------- P_GETPRESCRIPTIVEANALYSISSCHEDULE.SQL
if (object_id('p_GetPrescriptiveAnalysisSchedule') is not null)
begin
drop procedure [p_GetPrescriptiveAnalysisSchedule]
end
go

-- SQLdm 10.0 Praveen Suhalka Doctor implementation in DM
create procedure [p_GetPrescriptiveAnalysisSchedule] 
AS
BEGIN
	
--For excepttion handling
DECLARE
  @ErrorMessage   varchar(2000)
 ,@ErrorSeverity  tinyint
 ,@ErrorState     tinyint

	SELECT 
			MonitoredServerID, 
			StartTime, 
			ScheduledDays 
	FROM 
			AnalysisConfiguration 
			
	WHERE 
			IsActive	=	1
			AND 
			ScheduledDays > 0;

	IF(@@ERROR <>0)
	BEGIN
			SET @ErrorMessage  = ERROR_MESSAGE()
			SET @ErrorSeverity = ERROR_SEVERITY()
			SET @ErrorState    = ERROR_STATE()
			RAISERROR('Unable to get PrescriptiveAnalysisSchedule.', @ErrorSeverity, @ErrorState)

	END
END
 
GO 
 
GO 

---------- P_GETPRESCRIPTIVESNAPSHOTVALUESFORSERVER.SQL
-- SQLdm 10.0 (Srishti Purohit)

-- Prescriptive Analysis
-- Get Snapshot Values for server which is need to generate SDR-M16 Recomm
-- Details are stored and used every time analysis is triggered
if (object_id('p_GetPrescriptiveSnapshotValuesForServer') is not null)
begin
drop procedure [p_GetPrescriptiveSnapshotValuesForServer]
end
go

create procedure [p_GetPrescriptiveSnapshotValuesForServer] 

@MonitoredServerID INT
AS
BEGIN
	
--For excepttion handling
DECLARE
  @ErrorMessage   varchar(2000)
 ,@ErrorSeverity  tinyint
 ,@ErrorState     tinyint
	
	BEGIN
		-- check if records for UserSID
		SELECT [ActiveNetworkCards]
		, [TotalNetworkBandwidth]
      ,[AllowedProcessorCount]
	  ,[TotalNumberOfLogicalProcessors]
      ,[TotalMaxClockSpeed]
      ,[TotalPhysicalMemory]
	  ,[MaxServerMemory]
	  ,[WindowsVersion]
	  ,[ProductVersion]
	  ,[SQLVersionString]
		FROM [PrescriptiveAnalysisSnapshotValuesPrevious] 
		WHERE [MonitoredServerID] = @MonitoredServerID
	
	END
		
	
END
 
GO 
 
GO 

---------- P_GETPREVIOUSANALYSISACTIVITYSNAPSHOTDATETIME.SQL
if (object_id('p_GetPreviousAnalysisActivitySnapshotDateTime') is not null)
begin
drop procedure [p_GetPreviousAnalysisActivitySnapshotDateTime]
end
go
create procedure [dbo].[p_GetPreviousAnalysisActivitySnapshotDateTime]
	@SQLServerID int,
	@UTCSnapshotCollectionDateTime datetime
	--@RefreshType int = 0
as
begin
set transaction isolation level read uncommitted
declare @err int

select 
	max([UTCAnalysisCompleteTime])
from 
	PrescriptiveAnalysis
where 
	[UTCAnalysisCompleteTime] < @UTCSnapshotCollectionDateTime
	and [SQLServerID] = @SQLServerID
	--and isnull(RefreshType, 0) = @RefreshType

select @err = @@error
return @err
end
 
GO 

---------- P_GETPREVIOUSSERVERACTIVITYSNAPSHOTDATETIME.SQL
if (object_id('p_GetPreviousServerActivitySnapshotDateTime') is not null)
begin
drop procedure [p_GetPreviousServerActivitySnapshotDateTime]
end
go
create procedure [dbo].[p_GetPreviousServerActivitySnapshotDateTime]
	@SQLServerID int,
	@UTCSnapshotCollectionDateTime datetime,
	@RefreshType int = 0
as
begin
set transaction isolation level read uncommitted
declare @err int

select 
	max(UTCCollectionDateTime)
from 
	[ServerActivity]
where 
	[UTCCollectionDateTime] < @UTCSnapshotCollectionDateTime
	and [SQLServerID] = @SQLServerID
	and isnull(RefreshType, 0) = @RefreshType

select @err = @@error
return @err
end
 
GO 

---------- P_GETPRODUCTSTATUS.SQL
--Gets the status of the product in terms of active alerts and other parameters
-- EXEC p_GetProductStatus
if (object_id('p_GetProductStatus') is not null)
begin
drop procedure p_GetProductStatus
end
go
CREATE PROCEDURE [dbo].[p_GetProductStatus]
@SqlIdList XML
AS
BEGIN
--This procedure is designed in a way of returning multiple result sets. For now, 
--it will return only one result set, i.e. alerts.

--Alerts Results Set
DECLARE @AllAlerts TABLE(AlertID INT,UTCOccurenceDateTime DATETIME,InstanceId INT,ServerName NVARCHAR(MAX),DatabaseName NVARCHAR(MAX), TableName NVARCHAR(MAX), Active BIT,Metric INT,Severity INT, PreviousSeverity INT,StateEvent INT, Value DECIMAL(16,2),Heading NVARCHAR(MAX), [Message] NVARCHAR(MAX))
INSERT INTO @AllAlerts exec p_GetAlertsForWebConsole null, null, null, null, null,null, 'Severity', 'desc', 10000, 1  
SELECT Severity,COUNT(0) AlertCount 
FROM @AllAlerts 
WHERE InstanceId IN(
		SELECT A.B.value('(ID)[1]', 'int' ) ID
		FROM    @SqlIdList.nodes('/Root/Source') A(B)) 
GROUP BY Severity
--SELECT Severity, COUNT(1) AlertCount
--FROM Alerts a (NOLOCK)
--WHERE a.Active = 1 AND UTCOccurrenceDateTime = @LatestDate
--GROUP BY Severity

END
 
GO 

---------- P_GETQUERYMONITORDATABYAPPLICATION.SQL
-- SQLdm 9.0 (Abhishek Joshi)

-- Query Monitoring
-- retrieves the Query Monitor Statistics when grouped by Application
-- according to the set filters

-- exec p_GetQueryMonitorDataByApplication  @SQLServerID = 9,
--											@ApplicationFilter = '8,11,12',
--											@DatabaseFilter = '179',
--											@UserFilter = '1',
--											@ClientFilter = '1',
--											@SQLExclude = null,
--											@SQLInclude = '%sys%',
--											@IncludeSQLStatements = '1',
--											@IncludeSQLProcedure = '1',
--											@IncludeSQLBatch = '1',
--											@IncludeIncompletedQueries = '1',
--											@IncludeTimeOverlappedQueries = '1',
--											@StartTimestamp = '2014-07-14 16:00:49.343',
--											@EndTimestamp = '2014-07-16 04:00:53.947',
--											@SortBy = 'AvgDuration',
--											@SortOrder = 'DESC',
--											@RecordStartIndex = 1,
--											@RecordsCount = 3,
--											@SQLSignatureIDFilter = 0,
--                                          @StatementTypeIDFilter = -1

if (object_id('p_GetQueryMonitorDataByApplication') is not null)
begin
	drop procedure [p_GetQueryMonitorDataByApplication]
end
go

create procedure [dbo].[p_GetQueryMonitorDataByApplication]
	@SQLServerID int,
	@ApplicationFilter nvarchar(500) = null,
	@DatabaseFilter nvarchar(500) = null,
	@UserFilter nvarchar(500) = null,
	@ClientFilter nvarchar(500) = null,
	@SQLExclude nvarchar(200) = null,
	@SQLInclude nvarchar(200) = null,
	@IncludeSQLStatements bit = 1,
	@IncludeSQLProcedure bit = 1,
	@IncludeSQLBatch bit = 1,
	@IncludeIncompletedQueries bit = 0,
	@IncludeTimeOverlappedQueries bit = 0,
	@StartTimestamp datetime = null,     
	@EndTimestamp datetime = null,
	@SortBy nvarchar(50) = 'Application',
	@SortOrder nvarchar(10) = 'ASC',
	@RecordStartIndex int = 0, 
	@RecordsCount int = 0,
	@SQLSignatureIDFilter int = 0,
	@StatementTypeIDFilter int = -1
as
begin
	declare @Query nvarchar(max),
			@ParameterDefinition nvarchar(4000);
			
	select @ParameterDefinition = ' @SQLServerID int,
									@ApplicationFilter nvarchar(500),
									@DatabaseFilter nvarchar(500),
									@UserFilter nvarchar(500),
									@ClientFilter nvarchar(500),
									@SQLExclude nvarchar(200),
									@SQLInclude nvarchar(200),
									@IncludeSQLStatements bit,
									@IncludeSQLProcedure bit,
									@IncludeSQLBatch bit,
									@IncludeIncompletedQueries bit,
									@IncludeTimeOverlappedQueries bit,
									@StartTimestamp datetime,
									@EndTimestamp datetime,
									@SortBy nvarchar(50),
									@SortOrder nvarchar(10),
									@RecordStartIndex int,
									@RecordsCount int,
									@SQLSignatureIDFilter int,
									@StatementTypeIDFilter int ';

	select @Query = '  select
							QMS.ApplicationNameID as ApplicationID,
							AN.ApplicationName as Application,
							count(QMS.ApplicationNameID) as Occurrences,
							sum(QMS.DurationMilliseconds) as TotalDuration,
							avg(QMS.DurationMilliseconds) as AvgDuration,
							sum(QMS.CPUMilliseconds) as TotalCPUTime,
							sum(QMS.Reads) as TotalReads,
							sum(QMS.Writes) as TotalWrites,
							sum(QMS.Reads + QMS.Writes) as TotalIO,
							sum(WT.TotalWaitTime)/count(QMS.ApplicationNameID) as TotalWaitTime,
							max(QMS.CompletionTime) as MostRecentCompletion,
							sum(BDT.TotalBlockingTime)/count(QMS.ApplicationNameID) as TotalBlockingTime,
							sum(DPT.TotalDeadlocks)/count(QMS.ApplicationNameID) as TotalDeadlocks,
							avg(QMS.CPUMilliseconds) as AvgCPUTime,
							avg(QMS.Reads) as AvgReads,
							avg(QMS.Writes) as AvgWrites,
							avg(QMS.Reads + QMS.Writes) as AvgIO,
							avg(WT.TotalWaitTime)/count(QMS.ApplicationNameID) as AvgWaitTime,
							avg(BDT.TotalBlockingTime)/count(QMS.ApplicationNameID) as AvgBlockingTime,
							avg(DPT.TotalDeadlocks)/count(QMS.ApplicationNameID) as AvgDeadlocks
					   from
						    QueryMonitorStatistics as QMS
						    left join
						    (
								select
									AWS.ApplicationNameID,
									sum(AWS.WaitDuration) as TotalWaitTime
								from
									ActiveWaitStatistics as AWS
								where
									AWS.SQLServerID = @SQLServerID
								group by
									AWS.ApplicationNameID
							) as WT
							on QMS.ApplicationNameID = WT.ApplicationNameID
							left join
							(
								select
									BSS.ApplicationNameID,
									sum(BSS.BlockingDurationMilliseconds) as TotalBlockingTime
								from
									BlockingSessionStatistics as BSS
								where
									BSS.SQLServerID = @SQLServerID
								group by
									BSS.ApplicationNameID
							) as BDT
							on QMS.ApplicationNameID = BDT.ApplicationNameID
							left join
							(
								select
									DP.ApplicationNameID,
									count(DP.DeadlockID) as TotalDeadlocks
								from
									DeadlockProcesses as DP
								where
									DP.SQLServerID = @SQLServerID
								group by
									DP.ApplicationNameID
							) as DPT
							on QMS.ApplicationNameID = DPT.ApplicationNameID
							left join
							ApplicationNames as AN
							on QMS.ApplicationNameID = AN.ApplicationNameID
							left join
							(
								select
									SS.SQLStatementID,
									(isnull(SS.SQLStatement,'''') + isnull(SSO.SQLStatementOverflow,'''')) as StatementSQLText
								from	
									SQLStatements as SS
									left join
									SQLStatementsOverflow as SSO
									on SS.SQLStatementID = SSO.SQLStatementID
							) as SST
							on QMS.SQLStatementID = SST.SQLStatementID
					   where
							QMS.SQLServerID = @SQLServerID ';

	if @ApplicationFilter is not null
		select @Query = @Query + ' and QMS.ApplicationNameID in (' + @ApplicationFilter + ') ';

	if @DatabaseFilter is not null
		select @Query = @Query + ' and QMS.DatabaseID in (' + @DatabaseFilter + ') ';

	if @UserFilter is not null
		select @Query = @Query + ' and QMS.LoginNameID in (' + @UserFilter + ') ';

	if @ClientFilter is not null
		select @Query = @Query + ' and QMS.HostNameID in (' + @ClientFilter + ') ';

	if @SQLExclude is not null           -- exclude filter given priority, skip include filter if exclude is not null
		select @Query = @Query + ' and (LOWER(SST.StatementSQLText) not like ''' + LOWER(@SQLExclude) + ''' ) ';
	else if @SQLInclude is not null
		select @Query = @Query + ' and (LOWER(SST.StatementSQLText) like ''' + LOWER(@SQLInclude) + ''' ) ';

	if @IncludeSQLStatements = 0                           -- SQL Statement 
		select @Query = @Query + ' and (QMS.StatementType != 1) ';
	
	if @IncludeSQLProcedure = 0                             -- SQL Procedure   
		select @Query = @Query + ' and (QMS.StatementType != 0) ';
		
	if @IncludeSQLBatch = 0                                  -- SQL Batch
		select @Query = @Query + ' and (QMS.StatementType != 2) ';
		
	if @IncludeIncompletedQueries = 0                        -- Include Completed Queries
		select @Query = @Query + ' and (QMS.CompletionTime is not null) ';
		
	if @IncludeTimeOverlappedQueries = 1 and @StartTimestamp is not null and @EndTimestamp is not null      -- Including overlapped queries
		select @Query = @Query + ' and (not ((QMS.StatementUTCStartTime > @EndTimestamp) or (QMS.CompletionTime < @StartTimestamp)))';
	else if @IncludeTimeOverlappedQueries = 0 and @StartTimestamp is not null and @EndTimestamp is not null
		select @Query = @Query + ' and (QMS.StatementUTCStartTime >= @StartTimestamp) and (QMS.StatementUTCStartTime <=  @EndTimestamp)';

	if @SQLSignatureIDFilter <> 0
		select @Query = @Query + ' and QMS.SQLSignatureID = @SQLSignatureIDFilter';

	if @StatementTypeIDFilter <> -1
		select @Query = @Query + ' and QMS.StatementType = @StatementTypeIDFilter ';

	select @Query = @Query + ' group by QMS.ApplicationNameID, AN.ApplicationName ';  

	select @Query = 'select
						FilteredData.*,
						cast(cast(FilteredData.TotalCPUTime as dec(15,0)) / nullif(FilteredData.TotalDuration,0) as dec (15,2)) as AvgCPUPerSec,
						cast(cast(FilteredData.TotalIO as dec(15,0)) / nullif(FilteredData.TotalDuration,0) as dec (15,2)) as AvgIOPerSec,
						cast((cast(FilteredData.TotalCPUTime as dec(20,5))*100)/nullif((select sum(FilteredData.TotalCPUTime) from ( ' + @Query + ' ) as FilteredData),0) as dec(20,5)) as CPUAsPercentOfList,
						cast((cast(FilteredData.TotalReads as dec(20,5))*100)/nullif((select sum(FilteredData.TotalReads) from ( ' + @Query + ' ) as FilteredData),0) as dec(20,5)) as ReadsAsPercentOfList		
						from
						( ' + @Query + ' ) as FilteredData';

	-- Rank (sort) the records on the basis on the given filter
	select @Query = 'select
						SortedData.*,
						row_number() over (order by SortedData.' + @SortBy + ' ' + @SortOrder + ') as RecordRank 
					from
						( ' + @Query + ' ) as SortedData';

	if @RecordStartIndex <> 0 and @RecordsCount <> 0
		select @Query = 'select
							ApplicationData.* 
						 from 
							( ' + @Query + ' ) as ApplicationData
						 where 
							ApplicationData.RecordRank between @RecordStartIndex and (@RecordStartIndex + @RecordsCount - 1)';

	execute sp_executesql @Query, 
                          @ParameterDefinition, 
						  @SQLServerID, 
						  @ApplicationFilter,
						  @DatabaseFilter,
						  @UserFilter,
						  @ClientFilter,
						  @SQLExclude,
						  @SQLInclude,
						  @IncludeSQLStatements,
						  @IncludeSQLProcedure,
						  @IncludeSQLBatch,
						  @IncludeIncompletedQueries,
						  @IncludeTimeOverlappedQueries,
						  @StartTimestamp,
						  @EndTimestamp,
						  @SortBy,
						  @SortOrder,
						  @RecordStartIndex,
						  @RecordsCount,
						  @SQLSignatureIDFilter,
						  @StatementTypeIDFilter

end
go
 
GO 

---------- P_GETQUERYMONITORDATABYCLIENT.SQL
-- SQLdm 9.0 (Abhishek Joshi)

-- Query Monitoring
-- retrieves the Query Monitor Statistics when grouped by Client
-- according to the set filters

-- exec p_GetQueryMonitorDataByClient       @SQLServerID = 9,
--											@ApplicationFilter = '8,11,12',
--											@DatabaseFilter = '179',
--											@UserFilter = '1',
--											@ClientFilter = '1',
--											@SQLExclude = null,
--											@SQLInclude = '%sys%',
--											@IncludeSQLStatements = '1',
--											@IncludeSQLProcedure = '1',
--											@IncludeSQLBatch = '1',
--											@IncludeIncompletedQueries = '1',
--											@IncludeTimeOverlappedQueries = '1',
--											@StartTimestamp = '2014-07-14 16:00:49.343',
--											@EndTimestamp = '2014-07-16 04:00:53.947',
--											@SortBy = 'AvgDuration',
--											@SortOrder = 'DESC',
--											@RecordStartIndex = 1,
--											@RecordsCount = 3,
--											@SQLSignatureIDFilter = 0,
--                                          @StatementTypeIDFilter = -1


if (object_id('p_GetQueryMonitorDataByClient') is not null)
begin
	drop procedure [p_GetQueryMonitorDataByClient]
end
go

create procedure [dbo].[p_GetQueryMonitorDataByClient]
	@SQLServerID int,
	@ApplicationFilter nvarchar(500) = null,
	@DatabaseFilter nvarchar(500) = null,
	@UserFilter nvarchar(500) = null,
	@ClientFilter nvarchar(500) = null,
	@SQLExclude nvarchar(200) = null,
	@SQLInclude nvarchar(200) = null,
	@IncludeSQLStatements bit = 1,
	@IncludeSQLProcedure bit = 1,
	@IncludeSQLBatch bit = 1,
	@IncludeIncompletedQueries bit = 0,
	@IncludeTimeOverlappedQueries bit = 0,
	@StartTimestamp datetime = null,     
	@EndTimestamp datetime = null,
	@SortBy nvarchar(50) = 'Client',
	@SortOrder nvarchar(10) = 'ASC',
	@RecordStartIndex int = 0, 
	@RecordsCount int = 0,
	@SQLSignatureIDFilter int = 0,
	@StatementTypeIDFilter int = -1
as
begin
	declare @Query nvarchar(max),
			@DefaultRecordsCount nvarchar(10),
			@ParameterDefinition nvarchar(4000);
			
	select @DefaultRecordsCount = '10'  -- default records count for Applications, Databases, etc for some other groupings

	select @ParameterDefinition = ' @SQLServerID int,
									@ApplicationFilter nvarchar(500),
									@DatabaseFilter nvarchar(500),
									@UserFilter nvarchar(500),
									@ClientFilter nvarchar(500),
									@SQLExclude nvarchar(200),
									@SQLInclude nvarchar(200),
									@IncludeSQLStatements bit,
									@IncludeSQLProcedure bit,
									@IncludeSQLBatch bit,
									@IncludeIncompletedQueries bit,
									@IncludeTimeOverlappedQueries bit,
									@StartTimestamp datetime,
									@EndTimestamp datetime,
									@SortBy nvarchar(50),
									@SortOrder nvarchar(10),
									@RecordStartIndex int,
									@RecordsCount int,
									@SQLSignatureIDFilter int,
									@StatementTypeIDFilter int ';

	select @Query = '  select
							QMS.HostNameID as ClientID,
							HN.HostName as Client,
							count(QMS.HostNameID) as Occurrences,
							sum(QMS.DurationMilliseconds) as TotalDuration,
							avg(QMS.DurationMilliseconds) as AvgDuration,
							sum(QMS.CPUMilliseconds) as TotalCPUTime,
							sum(QMS.Reads) as TotalReads,
							sum(QMS.Writes) as TotalWrites,
							sum(QMS.Reads + QMS.Writes) as TotalIO,
							avg(WT.TotalWaitTime)/count(QMS.HostNameID) as AvgWaitTime,
							max(QMS.CompletionTime) as MostRecentCompletion,
							avg(BDT.TotalBlockingTime)/count(QMS.HostNameID) as AvgBlockingTime,
							avg(DPT.TotalDeadlocks)/count(QMS.HostNameID) as AvgDeadlocks,						
							substring(
								( select top (' + @DefaultRecordsCount + ') '','' + DT.ApplicationName as [text()]
								  from 
		                          (
										select 
											QMS.HostNameID, 
											AN.ApplicationName, 
											AN.ApplicationNameID,
											sum(QMS.DurationMilliseconds) as TotalDuration 
										from 
											QueryMonitorStatistics as QMS
											left join
											ApplicationNames as AN
											on QMS.ApplicationNameID = AN.ApplicationNameID
										where SQLServerID = @SQLServerID';					
	if @ApplicationFilter is not null
		select @Query = @Query + ' and AN.ApplicationNameID in (' + @ApplicationFilter + ') ';
	
	select @Query = @Query + ' group by QMS.HostNameID, AN.ApplicationName, AN.ApplicationNameID
								) as DT
								   where DT.HostNameID = QMS.HostNameID
								   order by DT.HostNameID
								   for xml path ('''')
                                ), 2, 1000) as Application,
							substring(
								( select top (' + @DefaultRecordsCount +') '','' + LT.DatabaseName as [text()]
								  from 
								  (
									select 
										QMS.HostNameID, 
										SSDN.DatabaseName,
										SSDN.DatabaseID,
										sum(QMS.DurationMilliseconds) as TotalDuration 
									from 
										QueryMonitorStatistics as QMS
										left join
										SQLServerDatabaseNames as SSDN
										on QMS.DatabaseID = SSDN.DatabaseID
										where QMS.SQLServerID = @SQLServerID'; 

	if @DatabaseFilter is not null
		select @Query = @Query + ' and SSDN.DatabaseID in (' + @DatabaseFilter + ') ';

	select @Query = @Query + '	group by QMS.HostNameID, SSDN.DatabaseName, SSDN.DatabaseID
									) as LT
								where LT.HostNameID = QMS.HostNameID
								order by LT.HostNameID
								for xml path ('''')
								), 2, 1000) as DatabaseName,
							avg(QMS.CPUMilliseconds) as AvgCPUTime,
							avg(QMS.Reads) as AvgReads,
							avg(QMS.Writes) as AvgWrites,
							avg(QMS.Reads + QMS.Writes) as AvgIO,
							sum(WT.TotalWaitTime)/count(QMS.HostNameID) as TotalWaitTime,
							sum(BDT.TotalBlockingTime)/count(QMS.HostNameID) as TotalBlockingTime,
							sum(DPT.TotalDeadlocks)/count(QMS.HostNameID) as TotalDeadlocks
					   from
						    QueryMonitorStatistics as QMS
						    left join
						    (
								select
									AWS.HostNameID,
									sum(AWS.WaitDuration) as TotalWaitTime
								from
									ActiveWaitStatistics as AWS
								where
									AWS.SQLServerID = @SQLServerID
								group by
									AWS.HostNameID
							) as WT
							on QMS.HostNameID = WT.HostNameID
							left join
							(
								select
									BSS.HostNameID,
									sum(BSS.BlockingDurationMilliseconds) as TotalBlockingTime
								from
									BlockingSessionStatistics as BSS
								where
									BSS.SQLServerID = @SQLServerID
								group by
									BSS.HostNameID
							) as BDT
							on QMS.HostNameID = BDT.HostNameID
							left join
							(
								select
									DP.HostNameID,
									count(DP.DeadlockID) as TotalDeadlocks
								from
									DeadlockProcesses as DP
								where
									DP.SQLServerID = @SQLServerID
								group by
									DP.HostNameID
							) as DPT
							on QMS.HostNameID = DPT.HostNameID
							left join
							HostNames as HN
							on QMS.HostNameID = HN.HostNameID
							left join
							(
								select
									SS.SQLStatementID,
									(isnull(SS.SQLStatement,'''') + isnull(SSO.SQLStatementOverflow,'''')) as StatementSQLText
								from	
									SQLStatements as SS
									left join
									SQLStatementsOverflow as SSO
									on SS.SQLStatementID = SSO.SQLStatementID
							) as SST
							on QMS.SQLStatementID = SST.SQLStatementID
					   where
							QMS.SQLServerID = @SQLServerID ';


	if @ApplicationFilter is not null
		select @Query = @Query + ' and QMS.ApplicationNameID in (' + @ApplicationFilter + ') ';

	if @DatabaseFilter is not null
		select @Query = @Query + ' and QMS.DatabaseID in (' + @DatabaseFilter + ') ';

	if @UserFilter is not null
		select @Query = @Query + ' and QMS.LoginNameID in (' + @UserFilter + ') ';

	if @ClientFilter is not null
		select @Query = @Query + ' and QMS.HostNameID in (' + @ClientFilter + ') ';

	if @SQLExclude is not null           -- exclude filter given priority, skip include filter if exclude is not null
		select @Query = @Query + ' and (LOWER(SST.StatementSQLText) not like ''' + LOWER(@SQLExclude) + ''' ) ';
	else if @SQLInclude is not null
		select @Query = @Query + ' and (LOWER(SST.StatementSQLText) like ''' + LOWER(@SQLInclude) + ''' ) ';

	if @IncludeSQLStatements = 0                           -- SQL Statement 
		select @Query = @Query + ' and (QMS.StatementType != 1) ';
	
	if @IncludeSQLProcedure = 0                             -- SQL Procedure   
		select @Query = @Query + ' and (QMS.StatementType != 0) ';
		
	if @IncludeSQLBatch = 0                                  -- SQL Batch
		select @Query = @Query + ' and (QMS.StatementType != 2) ';
		
	if @IncludeIncompletedQueries = 0                        -- Include Completed Queries
		select @Query = @Query + ' and (QMS.CompletionTime is not null) ';
		
	if @IncludeTimeOverlappedQueries = 1 and @StartTimestamp is not null and @EndTimestamp is not null      -- Including overlapped queries
		select @Query = @Query + ' and (not ((QMS.StatementUTCStartTime > @EndTimestamp) or (QMS.CompletionTime < @StartTimestamp)))';
	else if @IncludeTimeOverlappedQueries = 0 and @StartTimestamp is not null and @EndTimestamp is not null
		select @Query = @Query + ' and (QMS.StatementUTCStartTime >= @StartTimestamp) and (QMS.StatementUTCStartTime <=  @EndTimestamp)';

	if @SQLSignatureIDFilter <> 0
		select @Query = @Query + ' and QMS.SQLSignatureID = @SQLSignatureIDFilter ';

	if @StatementTypeIDFilter <> -1
		select @Query = @Query + ' and QMS.StatementType = @StatementTypeIDFilter ';
	
	select @Query = @Query + ' group by QMS.HostNameID, HN.HostName';  
	
	select @Query = 'select
						FilteredData.*,
						cast(cast(FilteredData.TotalCPUTime as dec(15,0)) / nullif(FilteredData.TotalDuration,0) as dec (15,2)) as AvgCPUPerSec,
						cast(cast(FilteredData.TotalIO as dec(15,0)) / nullif(FilteredData.TotalDuration,0) as dec (15,2)) as AvgIOPerSec,
						cast((cast(FilteredData.TotalCPUTime as dec(20,5))*100)/nullif((select sum(FilteredData.TotalCPUTime) from ( ' + @Query + ' ) as FilteredData),0) as dec(20,5)) as CPUAsPercentOfList,
						cast((cast(FilteredData.TotalReads as dec(20,5))*100)/nullif((select sum(FilteredData.TotalReads) from ( ' + @Query + ' ) as FilteredData),0) as dec(20,5)) as ReadsAsPercentOfList		
						from
						( ' + @Query + ' ) as FilteredData';

	-- Rank (sort) the records on the basis on the given filter
	select @Query = 'select
						SortedData.*,
						row_number() over (order by SortedData.' + @SortBy + ' ' + @SortOrder + ') as RecordRank 
					from
						( ' + @Query + ' ) as SortedData';

	if @RecordStartIndex <> 0 and @RecordsCount <> 0
		select @Query = 'select
							ClientData.* 
						 from 
							( ' + @Query + ' ) as ClientData
						 where 
							ClientData.RecordRank between @RecordStartIndex and (@RecordStartIndex + @RecordsCount - 1)';

	execute sp_executesql @Query, 
                          @ParameterDefinition, 
						  @SQLServerID, 
						  @ApplicationFilter,
						  @DatabaseFilter,
						  @UserFilter,
						  @ClientFilter,
						  @SQLExclude,
						  @SQLInclude,
						  @IncludeSQLStatements,
						  @IncludeSQLProcedure,
						  @IncludeSQLBatch,
						  @IncludeIncompletedQueries,
						  @IncludeTimeOverlappedQueries,
						  @StartTimestamp,
						  @EndTimestamp,
						  @SortBy,
						  @SortOrder,
						  @RecordStartIndex,
						  @RecordsCount,
						  @SQLSignatureIDFilter,
						  @StatementTypeIDFilter

end
go
 
GO 

---------- P_GETQUERYMONITORDATABYDATABASE.SQL
-- SQLdm 9.0 (Abhishek Joshi)

-- Query Monitoring
-- retrieves the Query Monitor Statistics when grouped by Database
-- according to the set filters

-- exec p_GetQueryMonitorDataByDatabase     @SQLServerID = 9,
--											@ApplicationFilter = '8,11,12',
--											@DatabaseFilter = '179',
--											@UserFilter = '1',
--											@ClientFilter = '1',
--											@SQLExclude = null,
--											@SQLInclude = '%sys%',
--											@IncludeSQLStatements = '1',
--											@IncludeSQLProcedure = '1',
--											@IncludeSQLBatch = '1',
--											@IncludeIncompletedQueries = '1',
--											@IncludeTimeOverlappedQueries = '1',
--											@StartTimestamp = '2014-07-14 16:00:49.343',
--											@EndTimestamp = '2014-07-16 04:00:53.947',
--											@SortBy = 'AvgDuration',
--											@SortOrder = 'DESC',
--											@RecordStartIndex = 1,
--											@RecordsCount = 3,
--											@SQLSignatureIDFilter = 0,
--                                          @StatementTypeIDFilter = -1


if (object_id('p_GetQueryMonitorDataByDatabase') is not null)
begin
	drop procedure [p_GetQueryMonitorDataByDatabase]
end
go

create procedure [dbo].[p_GetQueryMonitorDataByDatabase]
	@SQLServerID int,
	@ApplicationFilter nvarchar(500) = null,
	@DatabaseFilter nvarchar(500) = null,
	@UserFilter nvarchar(500) = null,
	@ClientFilter nvarchar(500) = null,
	@SQLExclude nvarchar(200) = null,
	@SQLInclude nvarchar(200) = null,
	@IncludeSQLStatements bit = 1,
	@IncludeSQLProcedure bit = 1,
	@IncludeSQLBatch bit = 1,
	@IncludeIncompletedQueries bit = 0,
	@IncludeTimeOverlappedQueries bit = 0,
	@StartTimestamp datetime = null,     
	@EndTimestamp datetime = null,
	@SortBy nvarchar(50) = 'DatabaseName',
	@SortOrder nvarchar(10) = 'ASC',
	@RecordStartIndex int = 0, 
	@RecordsCount int = 0,
	@SQLSignatureIDFilter int = 0,
	@StatementTypeIDFilter int = -1
as
begin
	declare @Query nvarchar(max),
			@DefaultRecordsCount nvarchar(10),
			@ParameterDefinition nvarchar(4000);
			
	select @DefaultRecordsCount = '10' -- default records count for Applications, Databases, etc for some other groupings

	select @ParameterDefinition = ' @SQLServerID int,
									@ApplicationFilter nvarchar(500),
									@DatabaseFilter nvarchar(500),
									@UserFilter nvarchar(500),
									@ClientFilter nvarchar(500),
									@SQLExclude nvarchar(200),
									@SQLInclude nvarchar(200),
									@IncludeSQLStatements bit,
									@IncludeSQLProcedure bit,
									@IncludeSQLBatch bit,
									@IncludeIncompletedQueries bit,
									@IncludeTimeOverlappedQueries bit,
									@StartTimestamp datetime,
									@EndTimestamp datetime,
									@SortBy nvarchar(50),
									@SortOrder nvarchar(10),
									@RecordStartIndex int,
									@RecordsCount int,
									@SQLSignatureIDFilter int,
									@StatementTypeIDFilter int ';

	select @Query = '  select
							QMS.DatabaseID,
							SSDN.DatabaseName as DatabaseName,
							count(QMS.DatabaseID) as Occurrences,
							sum(QMS.DurationMilliseconds) as TotalDuration,
							avg(QMS.DurationMilliseconds) as AvgDuration,
							sum(QMS.CPUMilliseconds) as TotalCPUTime,
							sum(QMS.Reads) as TotalReads,
							sum(QMS.Writes) as TotalWrites,
							sum(QMS.Reads + QMS.Writes) as TotalIO,
							avg(WT.TotalWaitTime)/count(QMS.DatabaseID) as AvgWaitTime,
							max(QMS.CompletionTime) as MostRecentCompletion,
							avg(BDT.TotalBlockingTime)/count(QMS.DatabaseID) as AvgBlockingTime,
							avg(DPT.TotalDeadlocks)/count(QMS.DatabaseID) as AvgDeadlocks,
							substring(
								( select top (' + @DefaultRecordsCount + ') '','' + DT.ApplicationName as [text()]
								  from 
		                          (
										select 
											QMS.DatabaseID, 
											AN.ApplicationName, 
											AN.ApplicationNameID,
											sum(QMS.DurationMilliseconds) as TotalDuration 
										from 
											QueryMonitorStatistics as QMS
											left join
											ApplicationNames as AN
											on QMS.ApplicationNameID = AN.ApplicationNameID
										where SQLServerID = @SQLServerID';					
	if @ApplicationFilter is not null
		select @Query = @Query + ' and AN.ApplicationNameID in (' + @ApplicationFilter + ') ';
	
	select @Query = @Query + ' group by QMS.DatabaseID, AN.ApplicationName, AN.ApplicationNameID
								) as DT
								   where DT.DatabaseID = QMS.DatabaseID
								   order by DT.DatabaseID
								   for xml path ('''')
                                ), 2, 1000) as Application,
							avg(QMS.CPUMilliseconds) as AvgCPUTime,
							avg(QMS.Reads) as AvgReads,
							avg(QMS.Writes) as AvgWrites,
							avg(QMS.Reads + QMS.Writes) as AvgIO,
							sum(WT.TotalWaitTime)/count(QMS.DatabaseID) as TotalWaitTime,
							sum(BDT.TotalBlockingTime)/count(QMS.DatabaseID) as TotalBlockingTime,
							sum(DPT.TotalDeadlocks)/count(QMS.DatabaseID) as TotalDeadlocks
					   from
						    QueryMonitorStatistics as QMS
						    left join
						    (
								select
									AWS.DatabaseID,
									sum(AWS.WaitDuration) as TotalWaitTime
								from
									ActiveWaitStatistics as AWS
								where
									AWS.SQLServerID = @SQLServerID
								group by
									AWS.DatabaseID
							) as WT
							on QMS.DatabaseID = WT.DatabaseID
							left join
							(
								select
									BSS.DatabaseID,
									sum(BSS.BlockingDurationMilliseconds) as TotalBlockingTime
								from
									BlockingSessionStatistics as BSS
								where
									BSS.SQLServerID = @SQLServerID
								group by
									BSS.DatabaseID
							) as BDT
							on QMS.DatabaseID = BDT.DatabaseID
							left join
							(
								select
									DP.DatabaseID,
									count(DP.DeadlockID) as TotalDeadlocks
								from
									DeadlockProcesses as DP
								where
									DP.SQLServerID = @SQLServerID
								group by
									DP.DatabaseID
							) as DPT
							on QMS.DatabaseID = DPT.DatabaseID
							left join
							SQLServerDatabaseNames as SSDN
							on QMS.DatabaseID = SSDN.DatabaseID
							left join
							(
								select
									SS.SQLStatementID,
									(isnull(SS.SQLStatement,'''') + isnull(SSO.SQLStatementOverflow,'''')) as StatementSQLText
								from	
									SQLStatements as SS
									left join
									SQLStatementsOverflow as SSO
									on SS.SQLStatementID = SSO.SQLStatementID
							) as SST
							on QMS.SQLStatementID = SST.SQLStatementID
					   where
							QMS.SQLServerID = @SQLServerID ';

	if @ApplicationFilter is not null
		select @Query = @Query + ' and QMS.ApplicationNameID in (' + @ApplicationFilter + ') ';

	if @DatabaseFilter is not null
		select @Query = @Query + ' and QMS.DatabaseID in (' + @DatabaseFilter + ') ';

	if @UserFilter is not null
		select @Query = @Query + ' and QMS.LoginNameID in (' + @UserFilter + ')';

	if @ClientFilter is not null
		select @Query = @Query + ' and QMS.HostNameID in (' + @ClientFilter + ') ';

	if @SQLExclude is not null           -- exclude filter given priority, skip include filter if exclude is not null
		select @Query = @Query + ' and (LOWER(SST.StatementSQLText) not like ''' + LOWER(@SQLExclude) + ''' ) ';
	else if @SQLInclude is not null
		select @Query = @Query + ' and (LOWER(SST.StatementSQLText) like ''' + LOWER(@SQLInclude) + ''' ) ';

	if @IncludeSQLStatements = 0                           -- SQL Statement 
		select @Query = @Query + ' and (QMS.StatementType != 1) ';
	
	if @IncludeSQLProcedure = 0                             -- SQL Procedure   
		select @Query = @Query + ' and (QMS.StatementType != 0) ';
		
	if @IncludeSQLBatch = 0                                  -- SQL Batch
		select @Query = @Query + ' and (QMS.StatementType != 2) ';
		
	if @IncludeIncompletedQueries = 0                        -- Include Completed Queries
		select @Query = @Query + ' and (QMS.CompletionTime is not null) ';
		
	if @IncludeTimeOverlappedQueries = 1 and @StartTimestamp is not null and @EndTimestamp is not null      -- Including overlapped queries
		select @Query = @Query + ' and (not ((QMS.StatementUTCStartTime > @EndTimestamp) or (QMS.CompletionTime < @StartTimestamp)))';
	else if @IncludeTimeOverlappedQueries = 0 and @StartTimestamp is not null and @EndTimestamp is not null
		select @Query = @Query + ' and (QMS.StatementUTCStartTime >= @StartTimestamp) and (QMS.StatementUTCStartTime <=  @EndTimestamp)';

	if @SQLSignatureIDFilter <> 0
		select @Query = @Query + ' and QMS.SQLSignatureID = @SQLSignatureIDFilter';

	if @StatementTypeIDFilter <> -1
		select @Query = @Query + ' and QMS.StatementType = @StatementTypeIDFilter ';

	select @Query = @Query + ' group by QMS.DatabaseID, SSDN.DatabaseName';  
	
	select @Query = 'select
						FilteredData.*,
						cast(cast(FilteredData.TotalCPUTime as dec(15,0)) / nullif(FilteredData.TotalDuration,0) as dec (15,2)) as AvgCPUPerSec,
						cast(cast(FilteredData.TotalIO as dec(15,0)) / nullif(FilteredData.TotalDuration,0) as dec (15,2)) as AvgIOPerSec,
						cast((cast(FilteredData.TotalCPUTime as dec(20,5))*100)/nullif((select sum(FilteredData.TotalCPUTime) from ( ' + @Query + ' ) as FilteredData),0) as dec(20,5)) as CPUAsPercentOfList,
						cast((cast(FilteredData.TotalReads as dec(20,5))*100)/nullif((select sum(FilteredData.TotalReads) from ( ' + @Query + ' ) as FilteredData),0) as dec(20,5)) as ReadsAsPercentOfList		
						from
						( ' + @Query + ' ) as FilteredData';

	-- Rank (sort) the records on the basis on the given filter
	select @Query = 'select
						SortedData.*,
						row_number() over (order by SortedData.' + @SortBy + ' ' + @SortOrder + ') as RecordRank 
					from
						( ' + @Query + ' ) as SortedData';

	if @RecordStartIndex <> 0 and @RecordsCount <> 0
		select @Query = 'select
							DatabaseData.* 
						 from 
							( ' + @Query + ' ) as DatabaseData
						 where 
							DatabaseData.RecordRank between @RecordStartIndex and (@RecordStartIndex + @RecordsCount - 1)';

	execute sp_executesql @Query, 
                          @ParameterDefinition, 
						  @SQLServerID, 
						  @ApplicationFilter,
						  @DatabaseFilter,
						  @UserFilter,
						  @ClientFilter,
						  @SQLExclude,
						  @SQLInclude,
						  @IncludeSQLStatements,
						  @IncludeSQLProcedure,
						  @IncludeSQLBatch,
						  @IncludeIncompletedQueries,
						  @IncludeTimeOverlappedQueries,
						  @StartTimestamp,
						  @EndTimestamp,
						  @SortBy,
						  @SortOrder,
						  @RecordStartIndex,
						  @RecordsCount,
						  @SQLSignatureIDFilter,
						  @StatementTypeIDFilter

end
go
 
GO 

---------- P_GETQUERYMONITORDATABYQUERYSIGNATURE.SQL
-- SQLdm 9.0 (Abhishek Joshi)

-- Query Monitoring
-- retrieves the Query Monitor Statistics when grouped by Query Signature
-- according to the set filters

-- exec p_GetQueryMonitorDataByQuerySignature      @SQLServerID = 9,
--											       @ApplicationFilter = '8,11,12',
--											       @DatabaseFilter = '179',
--											       @UserFilter = '1',
--											       @ClientFilter = '1',
--											       @SQLExclude = null,
--											       @SQLInclude = '%sys%',
--											       @IncludeSQLStatements = '1',
--											       @IncludeSQLProcedure = '1',
--											       @IncludeSQLBatch = '1',
--											       @IncludeIncompletedQueries = '1',
--											       @IncludeTimeOverlappedQueries = '1',
--											       @StartTimestamp = '2014-07-14 16:00:49.343',
--											       @EndTimestamp = '2014-07-16 04:00:53.947',
--											       @SortBy = 'AvgDuration',
--											       @SortOrder = 'DESC',
--											       @RecordStartIndex = 1,
--											       @RecordsCount = 3,
--												   @SQLSignatureIDFilter = 0,
--                                                 @StatementTypeIDFilter = -1


if (object_id('p_GetQueryMonitorDataByQuerySignature') is not null)
begin
	drop procedure [p_GetQueryMonitorDataByQuerySignature]
end
go

create procedure [dbo].[p_GetQueryMonitorDataByQuerySignature]
	@SQLServerID int,
	@ApplicationFilter nvarchar(500) = null,
	@DatabaseFilter nvarchar(500) = null,
	@UserFilter nvarchar(500) = null,
	@ClientFilter nvarchar(500) = null,
	@SQLExclude nvarchar(200) = null,
	@SQLInclude nvarchar(200) = null,
	@IncludeSQLStatements bit = 1,
	@IncludeSQLProcedure bit = 1,
	@IncludeSQLBatch bit = 1,
	@IncludeIncompletedQueries bit = 0,
	@IncludeTimeOverlappedQueries bit = 0,
	@StartTimestamp datetime = null,     
	@EndTimestamp datetime = null,
	@SortBy nvarchar(50) = 'SignatureSQLText',
	@SortOrder nvarchar(10) = 'ASC',
	@RecordStartIndex int = 0, 
	@RecordsCount int = 0,
	@SQLSignatureIDFilter int = 0,
	@StatementTypeIDFilter int = -1
as
begin
	declare @Query nvarchar(max),
			@DefaultRecordsCount nvarchar(10),
			@ParameterDefinition nvarchar(4000);
			
	select @DefaultRecordsCount = '10'  -- default records count for Applications, Databases, etc for some other groupings

	select @ParameterDefinition = ' @SQLServerID int,
									@ApplicationFilter nvarchar(500),
									@DatabaseFilter nvarchar(500),
									@UserFilter nvarchar(500),
									@ClientFilter nvarchar(500),
									@SQLExclude nvarchar(200),
									@SQLInclude nvarchar(200),
									@IncludeSQLStatements bit,
									@IncludeSQLProcedure bit,
									@IncludeSQLBatch bit,
									@IncludeIncompletedQueries bit,
									@IncludeTimeOverlappedQueries bit,
									@StartTimestamp datetime,
									@EndTimestamp datetime,
									@SortBy nvarchar(50),
									@SortOrder nvarchar(10),
									@RecordStartIndex int,
									@RecordsCount int,
									@SQLSignatureIDFilter int,
									@StatementTypeIDFilter int ';

	select @Query = '  select
							QMS.SQLSignatureID,
							SSIG.SignatureSQLText,
							count(QMS.SQLSignatureID) as Occurrences,
							QMS.StatementType as EventType,
							sum(QMS.DurationMilliseconds) as TotalDuration,
							avg(QMS.DurationMilliseconds) as AvgDuration,
							sum(QMS.CPUMilliseconds) as TotalCPUTime,
							sum(QMS.Reads) as TotalReads,
							sum(QMS.Writes) as TotalWrites,
							sum(QMS.Reads + QMS.Writes) as TotalIO,
							avg(WT.TotalWaitTime)/count(QMS.SQLSignatureID) as AvgWaitTime,
							max(QMS.CompletionTime) as MostRecentCompletion,
							avg(BDT.TotalBlockingTime)/count(QMS.SQLSignatureID) as AvgBlockingTime,
							avg(DPT.TotalDeadlocks)/count(QMS.SQLSignatureID) as AvgDeadlocks,
							SSIG.DoNotAggregate as KeepDetailedHistory,
							(1-SSIG.DoNotAggregate) as Aggregated,						
							substring(
								( select top (' + @DefaultRecordsCount + ') '','' + DT.ApplicationName as [text()]
								  from 
		                          (
										select 
											QMS.SQLSignatureID, 
											AN.ApplicationName, 
											AN.ApplicationNameID,
											sum(QMS.DurationMilliseconds) as TotalDuration 
										from 
											QueryMonitorStatistics as QMS
											left join
											ApplicationNames as AN
											on QMS.ApplicationNameID = AN.ApplicationNameID
										where SQLServerID = @SQLServerID';					
	if @ApplicationFilter is not null
		select @Query = @Query + ' and AN.ApplicationNameID in (' + @ApplicationFilter + ') ';
	
	select @Query = @Query + ' group by QMS.SQLSignatureID, AN.ApplicationName, AN.ApplicationNameID
								) as DT
								   where DT.SQLSignatureID = QMS.SQLSignatureID
								   order by DT.SQLSignatureID
								   for xml path ('''')
                                ), 2, 1000) as Application,
							substring(
								( select top (' + @DefaultRecordsCount + ') '','' + LT.DatabaseName as [text()]
								  from 
								  (
									select 
										QMS.SQLSignatureID, 
										SSDN.DatabaseName,
										SSDN.DatabaseID,
										sum(QMS.DurationMilliseconds) as TotalDuration 
									from 
										QueryMonitorStatistics as QMS
										left join
										SQLServerDatabaseNames as SSDN
										on QMS.DatabaseID = SSDN.DatabaseID
										where QMS.SQLServerID = @SQLServerID'; 

	if @DatabaseFilter is not null
		select @Query = @Query + ' and SSDN.DatabaseID in (' + @DatabaseFilter + ') ';

	select @Query = @Query + '	group by QMS.SQLSignatureID, SSDN.DatabaseName, SSDN.DatabaseID
									) as LT
								where LT.SQLSignatureID = QMS.SQLSignatureID
								order by LT.SQLSignatureID
								for xml path ('''')
								), 2, 1000) as DatabaseName,
							avg(QMS.CPUMilliseconds) as AvgCPUTime,
							avg(QMS.Reads) as AvgReads,
							avg(QMS.Writes) as AvgWrites,
							avg(QMS.Reads + QMS.Writes) as AvgIO,
							sum(WT.TotalWaitTime)/count(QMS.SQLSignatureID) as TotalWaitTime,
							sum(BDT.TotalBlockingTime)/count(QMS.SQLSignatureID) as TotalBlockingTime,
							sum(DPT.TotalDeadlocks)/count(QMS.SQLSignatureID) as TotalDeadlocks
					   from
						    QueryMonitorStatistics as QMS
						    left join
						    (
								select
									AWS.SQLSignatureID,
									sum(AWS.WaitDuration) as TotalWaitTime
								from
									ActiveWaitStatistics as AWS
								where
									AWS.SQLServerID = @SQLServerID
								group by
									AWS.SQLSignatureID
							) as WT
							on QMS.SQLSignatureID = WT.SQLSignatureID
							left join
							(
								select
									BSS.SQLSignatureID,
									sum(BSS.BlockingDurationMilliseconds) as TotalBlockingTime
								from
									BlockingSessionStatistics as BSS
								where
									BSS.SQLServerID = @SQLServerID
								group by
									BSS.SQLSignatureID
							) as BDT
							on QMS.SQLSignatureID = BDT.SQLSignatureID
							left join
							(
								select
									DP.SQLSignatureID,
									count(DP.DeadlockID) as TotalDeadlocks
								from
									DeadlockProcesses as DP
								where
									DP.SQLServerID = @SQLServerID
								group by
									DP.SQLSignatureID
							) as DPT
							on QMS.SQLSignatureID = DPT.SQLSignatureID
							left join
							(
								select
									SS.SQLSignatureID,
									(isnull(SS.SQLSignature,'''') + isnull(SSO.SQLSignatureOverflow,'''')) as SignatureSQLText,
									SS.DoNotAggregate
								from	
									SQLSignatures as SS
									left join
									SQLSignaturesOverflow as SSO
									on SS.SQLSignatureID = SSO.SQLSignatureID
							) as SSIG
							on QMS.SQLSignatureID = SSIG.SQLSignatureID
							left join
							(
								select
									SS.SQLStatementID,
									(isnull(SS.SQLStatement,'''') + isnull(SSO.SQLStatementOverflow,'''')) as StatementSQLText
								from	
									SQLStatements as SS
									left join
									SQLStatementsOverflow as SSO
									on SS.SQLStatementID = SSO.SQLStatementID
							) as SST
							on QMS.SQLStatementID = SST.SQLStatementID
					   where
							QMS.SQLServerID = @SQLServerID ';


	if @ApplicationFilter is not null
		select @Query = @Query + ' and QMS.ApplicationNameID in (' + @ApplicationFilter + ') ';

	if @DatabaseFilter is not null
		select @Query = @Query + ' and QMS.DatabaseID in (' + @DatabaseFilter + ') ';

	if @UserFilter is not null
		select @Query = @Query + ' and QMS.LoginNameID in (' + @UserFilter + ') ';

	if @ClientFilter is not null
		select @Query = @Query + ' and QMS.HostNameID in (' + @ClientFilter + ') ';

	if @SQLExclude is not null           -- exclude filter given priority, skip include filter if exclude is not null
		select @Query = @Query + ' and (LOWER(SST.StatementSQLText) not like ''' + LOWER(@SQLExclude) + ''' ) ';
	else if @SQLInclude is not null
		select @Query = @Query + ' and (LOWER(SST.StatementSQLText) like ''' + LOWER(@SQLInclude) + ''' ) ';

	if @IncludeSQLStatements = 0                           -- SQL Statement 
		select @Query = @Query + ' and (QMS.StatementType != 1) ';
	
	if @IncludeSQLProcedure = 0                             -- SQL Procedure   
		select @Query = @Query + ' and (QMS.StatementType != 0) ';
		
	if @IncludeSQLBatch = 0                                  -- SQL Batch
		select @Query = @Query + ' and (QMS.StatementType != 2) ';
		
	if @IncludeIncompletedQueries = 0                        -- Include Completed Queries
		select @Query = @Query + ' and (QMS.CompletionTime is not null) ';
		
	if @IncludeTimeOverlappedQueries = 1 and @StartTimestamp is not null and @EndTimestamp is not null      -- Including overlapped queries
		select @Query = @Query + ' and (not ((QMS.StatementUTCStartTime > @EndTimestamp) or (QMS.CompletionTime < @StartTimestamp)))';
	else if @IncludeTimeOverlappedQueries = 0 and @StartTimestamp is not null and @EndTimestamp is not null
		select @Query = @Query + ' and (QMS.StatementUTCStartTime >= @StartTimestamp) and (QMS.StatementUTCStartTime <=  @EndTimestamp)';

	if @SQLSignatureIDFilter <> 0
		select @Query = @Query + ' and QMS.SQLSignatureID = @SQLSignatureIDFilter';

	if @StatementTypeIDFilter <> -1
		select @Query = @Query + ' and QMS.StatementType = @StatementTypeIDFilter ';
	
	select @Query = @Query + ' group by QMS.SQLSignatureID, SSIG.SignatureSQLText, SSIG.DoNotAggregate, QMS.StatementType';  
	
	
	select @Query = 'select
						FilteredData.*,
						cast(cast(FilteredData.TotalCPUTime as dec(15,0)) / nullif(FilteredData.TotalDuration,0) as dec (15,2)) as AvgCPUPerSec,
						cast(cast(FilteredData.TotalIO as dec(15,0)) / nullif(FilteredData.TotalDuration,0) as dec (15,2)) as AvgIOPerSec,
						cast((cast(FilteredData.TotalCPUTime as dec(20,5))*100)/nullif((select sum(FilteredData.TotalCPUTime) from ( ' + @Query + ' ) as FilteredData),0) as dec(20,5)) as CPUAsPercentOfList,
						cast((cast(FilteredData.TotalReads as dec(20,5))*100)/nullif((select sum(FilteredData.TotalReads) from ( ' + @Query + ' ) as FilteredData),0) as dec(20,5)) as ReadsAsPercentOfList		
						from
						( ' + @Query + ' ) as FilteredData';

	-- Rank (sort) the records on the basis on the given filter
	select @Query = 'select
						SortedData.*,
						row_number() over (order by SortedData.' + @SortBy + ' ' + @SortOrder + ') as RecordRank 
					from
						( ' + @Query + ' ) as SortedData';
	
	if @RecordStartIndex <> 0 and @RecordsCount <> 0
		select @Query = 'select
							SQLSignatureData.* 
						 from 
							( ' + @Query + ' ) as SQLSignatureData
						 where 
							SQLSignatureData.RecordRank between @RecordStartIndex and (@RecordStartIndex + @RecordsCount - 1)';

	execute sp_executesql @Query, 
                          @ParameterDefinition, 
						  @SQLServerID, 
						  @ApplicationFilter,
						  @DatabaseFilter,
						  @UserFilter,
						  @ClientFilter,
						  @SQLExclude,
						  @SQLInclude,
						  @IncludeSQLStatements,
						  @IncludeSQLProcedure,
						  @IncludeSQLBatch,
						  @IncludeIncompletedQueries,
						  @IncludeTimeOverlappedQueries,
						  @StartTimestamp,
						  @EndTimestamp,
						  @SortBy,
						  @SortOrder,
						  @RecordStartIndex,
						  @RecordsCount,
						  @SQLSignatureIDFilter,
						  @StatementTypeIDFilter

end
go
 
GO 

---------- P_GETQUERYMONITORDATABYQUERYSTATEMENT.SQL
-- SQLdm 9.0 (Abhishek Joshi)

-- Query Monitoring
-- retrieves the Query Monitor Statistics when grouped by Query Statement
-- according to the set filters

-- exec p_GetQueryMonitorDataByQueryStatement      @SQLServerID = 9,
--											       @ApplicationFilter = '8,11,12',
--											       @DatabaseFilter = '179',
--											       @UserFilter = '1',
--											       @ClientFilter = '1',
--											       @SQLExclude = null,
--											       @SQLInclude = '%sys%',
--											       @IncludeSQLStatements = '1',
--											       @IncludeSQLProcedure = '1',
--											       @IncludeSQLBatch = '1',
--											       @IncludeIncompletedQueries = '1',
--											       @IncludeTimeOverlappedQueries = '1',
--											       @StartTimestamp = '2014-07-14 16:00:49.343',
--											       @EndTimestamp = '2014-07-16 04:00:53.947',
--											       @SortBy = 'AvgDuration',
--											       @SortOrder = 'DESC',
--											       @RecordStartIndex = 1,
--											       @RecordsCount = 3,
--												   @SQLSignatureIDFilter = 0,
--                                                 @StatementTypeIDFilter = -1

if (object_id('p_GetQueryMonitorDataByQueryStatement') is not null)
begin
	drop procedure [p_GetQueryMonitorDataByQueryStatement]
end
go

create procedure [dbo].[p_GetQueryMonitorDataByQueryStatement]
	@SQLServerID int,
	@ApplicationFilter nvarchar(500) = null,
	@DatabaseFilter nvarchar(500) = null,
	@UserFilter nvarchar(500) = null,
	@ClientFilter nvarchar(500) = null,
	@SQLExclude nvarchar(200) = null,
	@SQLInclude nvarchar(200) = null,
	@IncludeSQLStatements bit = 1,
	@IncludeSQLProcedure bit = 1,
	@IncludeSQLBatch bit = 1,
	@IncludeIncompletedQueries bit = 0,
	@IncludeTimeOverlappedQueries bit = 0,
	@StartTimestamp datetime = null,     
	@EndTimestamp datetime = null,
	@SortBy nvarchar(50) = 'StatementSQLText',
	@SortOrder nvarchar(10) = 'ASC',
	@RecordStartIndex int = 0, 
	@RecordsCount int = 0,
	@SQLSignatureIDFilter int = 0,
	@StatementTypeIDFilter int = -1
as
begin
	declare @Query nvarchar(max),
			@DefaultRecordsCount nvarchar(10),
			@ParameterDefinition nvarchar(4000);
			
	select @DefaultRecordsCount = '10'  -- default records count for Applications, Databases, etc for some other groupings

	select @ParameterDefinition = ' @SQLServerID int,
									@ApplicationFilter nvarchar(500),
									@DatabaseFilter nvarchar(500),
									@UserFilter nvarchar(500),
									@ClientFilter nvarchar(500),
									@SQLExclude nvarchar(200),
									@SQLInclude nvarchar(200),
									@IncludeSQLStatements bit,
									@IncludeSQLProcedure bit,
									@IncludeSQLBatch bit,
									@IncludeIncompletedQueries bit,
									@IncludeTimeOverlappedQueries bit,
									@StartTimestamp datetime,
									@EndTimestamp datetime,
									@SortBy nvarchar(50),
									@SortOrder nvarchar(10),
									@RecordStartIndex int,
									@RecordsCount int,
									@SQLSignatureIDFilter int,
									@StatementTypeIDFilter int ';

	select @Query = '  select
							QMS.QueryStatisticsID, -- SQLdm 9.0 (Ankit Srivastava) - Query Plan Grpahical View - added new column to works as unique key
							QMS.SQLStatementID,
							SST.StatementSQLText,
							QMS.StatementType as EventType,
							count(QMS.SQLStatementID) as Occurrences,
							sum(QMS.DurationMilliseconds) as TotalDuration,
							avg(QMS.DurationMilliseconds) as AvgDuration,
							sum(QMS.CPUMilliseconds) as TotalCPUTime,
							sum(QMS.Reads) as TotalReads,
							sum(QMS.Writes) as TotalWrites,
							sum(WT.TotalWaitTime)/count(QMS.SQLStatementID) as TotalWaitTime,
							max(QMS.CompletionTime) as MostRecentCompletion,
							sum(BDT.TotalBlockingTime)/count(QMS.SQLStatementID) as TotalBlockingTime,
							sum(DPT.TotalDeadlocks)/count(QMS.SQLStatementID) as TotalDeadlocks,
							QMS.SessionID as Spid,
							QMS.StatementUTCStartTime as StartTime,
							SSIG.DoNotAggregate as KeepDetailedHistory,
							(1-SSIG.DoNotAggregate) as Aggregated,						
							substring(
								( select top (' + @DefaultRecordsCount + ') '','' + DT.ApplicationName as [text()]
								  from 
		                          (
										select 
											QMS.SQLStatementID, 
											AN.ApplicationName, 
											AN.ApplicationNameID,
											sum(QMS.DurationMilliseconds) as TotalDuration 
										from 
											QueryMonitorStatistics as QMS
											left join
											ApplicationNames as AN
											on QMS.ApplicationNameID = AN.ApplicationNameID
										where SQLServerID = @SQLServerID';					
	if @ApplicationFilter is not null
		select @Query = @Query + ' and AN.ApplicationNameID in (' + @ApplicationFilter + ') ';
	
	select @Query = @Query + ' group by QMS.SQLStatementID, AN.ApplicationName, AN.ApplicationNameID
								) as DT
								   where DT.SQLStatementID = QMS.SQLStatementID
								   order by DT.SQLStatementID
								   for xml path ('''')
                                ), 2, 1000) as Application,
							substring(
								( select top (' + @DefaultRecordsCount + ') '','' + LT.DatabaseName as [text()]
								  from 
								  (
									select 
										QMS.SQLStatementID, 
										SSDN.DatabaseName,
										SSDN.DatabaseID,
										sum(QMS.DurationMilliseconds) as TotalDuration 
									from 
										QueryMonitorStatistics as QMS
										left join
										SQLServerDatabaseNames as SSDN
										on QMS.DatabaseID = SSDN.DatabaseID
										where QMS.SQLServerID = @SQLServerID'; 

	if @DatabaseFilter is not null
		select @Query = @Query + ' and SSDN.DatabaseID in (' + @DatabaseFilter + ') ';

	select @Query = @Query + '	group by QMS.SQLStatementID, SSDN.DatabaseName, SSDN.DatabaseID
									) as LT
								where LT.SQLStatementID = QMS.SQLStatementID
								order by LT.SQLStatementID
								for xml path ('''')
								), 2, 1000) as DatabaseName,
							substring(
								( select top (' + @DefaultRecordsCount + ') '','' + CT.HostName as [text()]
								  from 
		                          (
										select 
											QMS.SQLStatementID, 
											HN.HostName, 
											HN.HostNameID,
											sum(QMS.DurationMilliseconds) as TotalDuration 
										from 
											QueryMonitorStatistics as QMS
											left join
											HostNames as HN
											on QMS.HostNameID = HN.HostNameID
										where SQLServerID = @SQLServerID';
															
	if @ClientFilter is not null
		select @Query = @Query + ' and HN.HostNameID in (' + @ClientFilter + ') ';
	
	select @Query = @Query + ' group by QMS.SQLStatementID, HN.HostName, HN.HostNameID
								) as CT
								   where CT.SQLStatementID = QMS.SQLStatementID
								   order by CT.SQLStatementID
								   for xml path ('''')
                                ), 2, 1000) as Client,
							substring(
								( select top (' + @DefaultRecordsCount + ') '','' + UT.LoginName as [text()]
								  from 
		                          (
										select 
											QMS.SQLStatementID, 
											LN.LoginName, 
											LN.LoginNameID,
											sum(QMS.DurationMilliseconds) as TotalDuration 
										from 
											QueryMonitorStatistics as QMS
											left join
											LoginNames as LN
											on QMS.LoginNameID = LN.LoginNameID
										where SQLServerID = @SQLServerID';
															
	if @UserFilter is not null
		select @Query = @Query + ' and LN.LoginNameID in (' + @UserFilter + ') ';
	
	select @Query = @Query + ' group by QMS.SQLStatementID, LN.LoginName, LN.LoginNameID
								) as UT
								   where UT.SQLStatementID = QMS.SQLStatementID
								   order by UT.SQLStatementID
								   for xml path ('''')
                                ), 2, 1000) as UserName,
							avg(QMS.CPUMilliseconds) as AvgCPUTime		
					   from
						    QueryMonitorStatistics as QMS
						    left join
						    (
								select
									AWS.SQLStatementID,
									sum(AWS.WaitDuration) as TotalWaitTime
								from
									ActiveWaitStatistics as AWS
								where
									AWS.SQLServerID = @SQLServerID
								group by
									AWS.SQLStatementID
							) as WT
							on QMS.SQLStatementID = WT.SQLStatementID
							left join
							(
								select
									BSS.SQLStatementID,
									sum(BSS.BlockingDurationMilliseconds) as TotalBlockingTime
								from
									BlockingSessionStatistics as BSS
								where
									BSS.SQLServerID = @SQLServerID
								group by
									BSS.SQLStatementID
							) as BDT
							on QMS.SQLStatementID = BDT.SQLStatementID
							left join
							(
								select
									DP.SQLStatementID,
									count(DP.DeadlockID) as TotalDeadlocks
								from
									DeadlockProcesses as DP
								where
									DP.SQLServerID = @SQLServerID
								group by
									DP.SQLStatementID
							) as DPT
							on QMS.SQLStatementID = DPT.SQLStatementID
							left join
							(
								select
									SS.SQLStatementID,
									(isnull(SS.SQLStatement,'''') + isnull(SSO.SQLStatementOverflow,'''')) as StatementSQLText
								from	
									SQLStatements as SS
									left join
									SQLStatementsOverflow as SSO
									on SS.SQLStatementID = SSO.SQLStatementID
							) as SST
							on QMS.SQLStatementID = SST.SQLStatementID
							left join
							SQLSignatures as SSIG
							on QMS.SQLSignatureID = SSIG.SQLSignatureID 
					   where
							QMS.SQLServerID = @SQLServerID ';


	if @ApplicationFilter is not null
		select @Query = @Query + ' and QMS.ApplicationNameID in (' + @ApplicationFilter + ') ';

	if @DatabaseFilter is not null
		select @Query = @Query + ' and QMS.DatabaseID in (' + @DatabaseFilter + ') ';

	if @UserFilter is not null
		select @Query = @Query + ' and QMS.LoginNameID in (' + @UserFilter + ') ';

	if @ClientFilter is not null
		select @Query = @Query + ' and QMS.HostNameID in (' + @ClientFilter + ') ';

	if @SQLExclude is not null           -- exclude filter given priority, skip include filter if exclude is not null
		select @Query = @Query + ' and (LOWER(SST.StatementSQLText) not like ''' + LOWER(@SQLExclude) + ''' ) ';
	else if @SQLInclude is not null
		select @Query = @Query + ' and (LOWER(SST.StatementSQLText) like ''' + LOWER(@SQLInclude) + ''' ) ';

	if @IncludeSQLStatements = 0                           -- SQL Statement 
		select @Query = @Query + ' and (QMS.StatementType != 1) ';
	
	if @IncludeSQLProcedure = 0                             -- SQL Procedure   
		select @Query = @Query + ' and (QMS.StatementType != 0) ';
		
	if @IncludeSQLBatch = 0                                  -- SQL Batch
		select @Query = @Query + ' and (QMS.StatementType != 2) ';
		
	if @IncludeIncompletedQueries = 0                        -- Include Completed Queries
		select @Query = @Query + ' and (QMS.CompletionTime is not null) ';
		
	if @IncludeTimeOverlappedQueries = 1 and @StartTimestamp is not null and @EndTimestamp is not null      -- Including overlapped queries
		select @Query = @Query + ' and (not ((QMS.StatementUTCStartTime > @EndTimestamp) or (QMS.CompletionTime < @StartTimestamp)))';
	else if @IncludeTimeOverlappedQueries = 0 and @StartTimestamp is not null and @EndTimestamp is not null
		select @Query = @Query + ' and (QMS.StatementUTCStartTime >= @StartTimestamp) and (QMS.StatementUTCStartTime <=  @EndTimestamp)';
	
	if @SQLSignatureIDFilter <> 0
		select @Query = @Query + ' and QMS.SQLSignatureID = @SQLSignatureIDFilter ';

	if @StatementTypeIDFilter <> -1
		select @Query = @Query + ' and QMS.StatementType = @StatementTypeIDFilter ';

	select @Query = @Query + ' group by QMS.SQLStatementID, SST.StatementSQLText, QMS.StatementType, QMS.SessionID,	
	                                    QMS.StatementUTCStartTime, SSIG.DoNotAggregate, QMS.QueryStatisticsID ';   -- SQLdm 9.0 (Ankit Srivastava) - Query Plan Graphical View - added new column to works as unique key
	
	select @Query = 'select
						FilteredData.*,
						cast(cast(FilteredData.TotalCPUTime as dec(15,0)) / nullif(FilteredData.TotalDuration,0) as dec (15,2)) as AvgCPUPerSec,
						cast((cast(FilteredData.TotalCPUTime as dec(20,5))*100)/nullif((select sum(FilteredData.TotalCPUTime) from ( ' + @Query + ' ) as FilteredData),0) as dec(20,5)) as CPUAsPercentOfList,
						cast((cast(FilteredData.TotalReads as dec(20,5))*100)/nullif((select sum(FilteredData.TotalReads) from ( ' + @Query + ' ) as FilteredData),0) as dec(20,5)) as ReadsAsPercentOfList		
						from
						( ' + @Query + ' ) as FilteredData';

	-- Rank (sort) the records on the basis on the given filter
	select @Query = 'select
						SortedData.*,
						row_number() over (order by SortedData.' + @SortBy + ' ' + @SortOrder + ') as RecordRank 
					from
						( ' + @Query + ' ) as SortedData';

	if @RecordStartIndex <> 0 and @RecordsCount <> 0
		select @Query = 'select
							SQLStatementData.* 
						 from 
							( ' + @Query + ' ) as SQLStatementData
						 where 
							SQLStatementData.RecordRank between @RecordStartIndex and (@RecordStartIndex + @RecordsCount - 1)';

	execute sp_executesql @Query, 
                          @ParameterDefinition, 
						  @SQLServerID, 
						  @ApplicationFilter,
						  @DatabaseFilter,
						  @UserFilter,
						  @ClientFilter,
						  @SQLExclude,
						  @SQLInclude,
						  @IncludeSQLStatements,
						  @IncludeSQLProcedure,
						  @IncludeSQLBatch,
						  @IncludeIncompletedQueries,
						  @IncludeTimeOverlappedQueries,
						  @StartTimestamp,
						  @EndTimestamp,
						  @SortBy,
						  @SortOrder,
						  @RecordStartIndex,
						  @RecordsCount,
						  @SQLSignatureIDFilter,
						  @StatementTypeIDFilter

end
go
 
GO 

---------- P_GETQUERYMONITORDATABYUSER.SQL
-- SQLdm 9.0 (Abhishek Joshi)

-- Query Monitoring
-- retrieves the Query Monitor Statistics when grouped by User
-- according to the set filters

-- exec p_GetQueryMonitorDataByUser         @SQLServerID = 9,
--											@ApplicationFilter = '8,11,12',
--											@DatabaseFilter = '179',
--											@UserFilter = '1',
--											@ClientFilter = '1',
--											@SQLExclude = null,
--											@SQLInclude = '%sys%',
--											@IncludeSQLStatements = '1',
--											@IncludeSQLProcedure = '1',
--											@IncludeSQLBatch = '1',
--											@IncludeIncompletedQueries = '1',
--											@IncludeTimeOverlappedQueries = '1',
--											@StartTimestamp = '2014-07-14 16:00:49.343',
--											@EndTimestamp = '2014-07-16 04:00:53.947',
--											@SortBy = 'AvgDuration',
--											@SortOrder = 'DESC',
--											@RecordStartIndex = 1,
--											@RecordsCount = 3,
--										    @SQLSignatureIDFilter = 0,
--                                          @StatementTypeIDFilter = -1


if (object_id('p_GetQueryMonitorDataByUser') is not null)
begin
	drop procedure [p_GetQueryMonitorDataByUser]
end
go

create procedure [dbo].[p_GetQueryMonitorDataByUser]
	@SQLServerID int,
	@ApplicationFilter nvarchar(500) = null,
	@DatabaseFilter nvarchar(500) = null,
	@UserFilter nvarchar(500) = null,
	@ClientFilter nvarchar(500) = null,
	@SQLExclude nvarchar(200) = null,
	@SQLInclude nvarchar(200) = null,
	@IncludeSQLStatements bit = 1,
	@IncludeSQLProcedure bit = 1,
	@IncludeSQLBatch bit = 1,
	@IncludeIncompletedQueries bit = 0,
	@IncludeTimeOverlappedQueries bit = 0,
	@StartTimestamp datetime = null,     
	@EndTimestamp datetime = null,
	@SortBy nvarchar(50) = 'UserName',
	@SortOrder nvarchar(10) = 'ASC',
	@RecordStartIndex int = 0, 
	@RecordsCount int = 0,
	@SQLSignatureIDFilter int = 0,
	@StatementTypeIDFilter int = -1
as
begin
	declare @Query nvarchar(max),
			@DefaultRecordsCount nvarchar(10),
			@ParameterDefinition nvarchar(4000);
			
	select @DefaultRecordsCount = '10'  -- default records count for Applications, Databases, etc for some other groupings

	select @ParameterDefinition = ' @SQLServerID int,
									@ApplicationFilter nvarchar(500),
									@DatabaseFilter nvarchar(500),
									@UserFilter nvarchar(500),
									@ClientFilter nvarchar(500),
									@SQLExclude nvarchar(200),
									@SQLInclude nvarchar(200),
									@IncludeSQLStatements bit,
									@IncludeSQLProcedure bit,
									@IncludeSQLBatch bit,
									@IncludeIncompletedQueries bit,
									@IncludeTimeOverlappedQueries bit,
									@StartTimestamp datetime,
									@EndTimestamp datetime,
									@SortBy nvarchar(50),
									@SortOrder nvarchar(10),
									@RecordStartIndex int,
									@RecordsCount int,
									@SQLSignatureIDFilter int,
									@StatementTypeIDFilter int ';

	select @Query = '  select
							QMS.LoginNameID as UserID,
							LN.LoginName as UserName,
							count(QMS.LoginNameID) as Occurrences,
							sum(QMS.DurationMilliseconds) as TotalDuration,
							avg(QMS.DurationMilliseconds) as AvgDuration,
							sum(QMS.CPUMilliseconds) as TotalCPUTime,
							sum(QMS.Reads) as TotalReads,
							sum(QMS.Writes) as TotalWrites,
							sum(QMS.Reads + QMS.Writes) as TotalIO,
							avg(WT.TotalWaitTime)/count(QMS.LoginNameID) as AvgWaitTime,
							max(QMS.CompletionTime) as MostRecentCompletion,
							avg(BDT.TotalBlockingTime)/count(QMS.LoginNameID) as AvgBlockingTime,
							avg(DPT.TotalDeadlocks)/count(QMS.LoginNameID) as AvgDeadlocks,						
							substring(
								( select top (' + @DefaultRecordsCount + ') '','' + DT.ApplicationName as [text()]
								  from 
		                          (
										select 
											QMS.LoginNameID, 
											AN.ApplicationName, 
											AN.ApplicationNameID,
											sum(QMS.DurationMilliseconds) as TotalDuration 
										from 
											QueryMonitorStatistics as QMS
											left join
											ApplicationNames as AN
											on QMS.ApplicationNameID = AN.ApplicationNameID
										where SQLServerID = @SQLServerID';					
	if @ApplicationFilter is not null
		select @Query = @Query + ' and AN.ApplicationNameID in (' + @ApplicationFilter + ') ';
	
	select @Query = @Query + ' group by QMS.LoginNameID, AN.ApplicationName, AN.ApplicationNameID
								) as DT
								   where DT.LoginNameID = QMS.LoginNameID
								   order by DT.LoginNameID
								   for xml path ('''')
                                ), 2, 1000) as Application,
							substring(
								( select top (' + @DefaultRecordsCount + ') '','' + LT.DatabaseName as [text()]
								  from 
								  (
									select 
										QMS.LoginNameID, 
										SSDN.DatabaseName,
										SSDN.DatabaseID,
										sum(QMS.DurationMilliseconds) as TotalDuration 
									from 
										QueryMonitorStatistics as QMS
										left join
										SQLServerDatabaseNames as SSDN
										on QMS.DatabaseID = SSDN.DatabaseID
										where QMS.SQLServerID = @SQLServerID'; 

	if @DatabaseFilter is not null
		select @Query = @Query + ' and SSDN.DatabaseID in (' + @DatabaseFilter + ') ';

	select @Query = @Query + '	group by QMS.LoginNameID, SSDN.DatabaseName, SSDN.DatabaseID
									) as LT
								where LT.LoginNameID = QMS.LoginNameID
								order by LT.LoginNameID
								for xml path ('''')
								), 2, 1000) as DatabaseName,
							avg(QMS.CPUMilliseconds) as AvgCPUTime,
							avg(QMS.Reads) as AvgReads,
							avg(QMS.Writes) as AvgWrites,
							avg(QMS.Reads + QMS.Writes) as AvgIO,
							sum(WT.TotalWaitTime)/count(QMS.LoginNameID) as TotalWaitTime,
							sum(BDT.TotalBlockingTime)/count(QMS.LoginNameID) as TotalBlockingTime,
							sum(DPT.TotalDeadlocks)/count(QMS.LoginNameID) as TotalDeadlocks
					   from
						    QueryMonitorStatistics as QMS
						    left join
						    (
								select
									AWS.LoginNameID,
									sum(AWS.WaitDuration) as TotalWaitTime
								from
									ActiveWaitStatistics as AWS
								where
									AWS.SQLServerID = @SQLServerID
								group by
									AWS.LoginNameID
							) as WT
							on QMS.LoginNameID = WT.LoginNameID
							left join
							(
								select
									BSS.LoginNameID,
									sum(BSS.BlockingDurationMilliseconds) as TotalBlockingTime
								from
									BlockingSessionStatistics as BSS
								where
									BSS.SQLServerID = @SQLServerID
								group by
									BSS.LoginNameID
							) as BDT
							on QMS.LoginNameID = BDT.LoginNameID
							left join
							(
								select
									DP.LoginNameID,
									count(DP.DeadlockID) as TotalDeadlocks
								from
									DeadlockProcesses as DP
								where
									DP.SQLServerID = @SQLServerID
								group by
									DP.LoginNameID
							) as DPT
							on QMS.LoginNameID = DPT.LoginNameID
							left join
							LoginNames as LN
							on QMS.LoginNameID = LN.LoginNameID
							left join
							(
								select
									SS.SQLStatementID,
									(isnull(SS.SQLStatement,'''') + isnull(SSO.SQLStatementOverflow,'''')) as StatementSQLText
								from	
									SQLStatements as SS
									left join
									SQLStatementsOverflow as SSO
									on SS.SQLStatementID = SSO.SQLStatementID
							) as SST
							on QMS.SQLStatementID = SST.SQLStatementID
					   where
							QMS.SQLServerID = @SQLServerID ';


	if @ApplicationFilter is not null
		select @Query = @Query + ' and QMS.ApplicationNameID in (' + @ApplicationFilter + ') ';

	if @DatabaseFilter is not null
		select @Query = @Query + ' and QMS.DatabaseID in (' + @DatabaseFilter + ') ';

	if @UserFilter is not null
		select @Query = @Query + ' and QMS.LoginNameID in (' + @UserFilter + ') ';

	if @ClientFilter is not null
		select @Query = @Query + ' and QMS.HostNameID in (' + @ClientFilter + ') ';

	if @SQLExclude is not null           -- exclude filter given priority, skip include filter if exclude is not null
		select @Query = @Query + ' and (LOWER(SST.StatementSQLText) not like ''' + LOWER(@SQLExclude) + ''' ) ';
	else if @SQLInclude is not null
		select @Query = @Query + ' and (LOWER(SST.StatementSQLText) like ''' + LOWER(@SQLInclude) + ''' ) ';

	if @IncludeSQLStatements = 0                           -- SQL Statement 
		select @Query = @Query + ' and (QMS.StatementType != 1) ';
	
	if @IncludeSQLProcedure = 0                             -- SQL Procedure   
		select @Query = @Query + ' and (QMS.StatementType != 0) ';
		
	if @IncludeSQLBatch = 0                                  -- SQL Batch
		select @Query = @Query + ' and (QMS.StatementType != 2) ';
		
	if @IncludeIncompletedQueries = 0                        -- Include Completed Queries
		select @Query = @Query + ' and (QMS.CompletionTime is not null) ';
		
	if @IncludeTimeOverlappedQueries = 1 and @StartTimestamp is not null and @EndTimestamp is not null      -- Including overlapped queries
		select @Query = @Query + ' and (not ((QMS.StatementUTCStartTime > @EndTimestamp) or (QMS.CompletionTime < @StartTimestamp)))';
	else if @IncludeTimeOverlappedQueries = 0 and @StartTimestamp is not null and @EndTimestamp is not null
		select @Query = @Query + ' and (QMS.StatementUTCStartTime >= @StartTimestamp) and (QMS.StatementUTCStartTime <=  @EndTimestamp)';
	
	if @SQLSignatureIDFilter <> 0
		select @Query = @Query + ' and QMS.SQLSignatureID = @SQLSignatureIDFilter';

	if @StatementTypeIDFilter <> -1
		select @Query = @Query + ' and QMS.StatementType = @StatementTypeIDFilter ';
	
	select @Query = @Query + ' group by QMS.LoginNameID, LN.LoginName';  
	
	select @Query = 'select
						FilteredData.*,
						cast(cast(FilteredData.TotalCPUTime as dec(15,0)) / nullif(FilteredData.TotalDuration,0) as dec (15,2)) as AvgCPUPerSec,
						cast(cast(FilteredData.TotalIO as dec(15,0)) / nullif(FilteredData.TotalDuration,0) as dec (15,2)) as AvgIOPerSec,
						cast((cast(FilteredData.TotalCPUTime as dec(20,5))*100)/nullif((select sum(FilteredData.TotalCPUTime) from ( ' + @Query + ' ) as FilteredData),0) as dec(20,5)) as CPUAsPercentOfList,
						cast((cast(FilteredData.TotalReads as dec(20,5))*100)/nullif((select sum(FilteredData.TotalReads) from ( ' + @Query + ' ) as FilteredData),0) as dec(20,5)) as ReadsAsPercentOfList		
						from
						( ' + @Query + ' ) as FilteredData';

	-- Rank (sort) the records on the basis on the given filter
	select @Query = 'select
						SortedData.*,
						row_number() over (order by SortedData.' + @SortBy + ' ' + @SortOrder + ') as RecordRank 
					from
						( ' + @Query + ' ) as SortedData';

	if @RecordStartIndex <> 0 and @RecordsCount <> 0
		select @Query = 'select
							UserData.* 
						 from 
							( ' + @Query + ' ) as UserData
						 where 
							UserData.RecordRank between @RecordStartIndex and (@RecordStartIndex + @RecordsCount - 1)';

	execute sp_executesql @Query, 
                          @ParameterDefinition, 
						  @SQLServerID, 
						  @ApplicationFilter,
						  @DatabaseFilter,
						  @UserFilter,
						  @ClientFilter,
						  @SQLExclude,
						  @SQLInclude,
						  @IncludeSQLStatements,
						  @IncludeSQLProcedure,
						  @IncludeSQLBatch,
						  @IncludeIncompletedQueries,
						  @IncludeTimeOverlappedQueries,
						  @StartTimestamp,
						  @EndTimestamp,
						  @SortBy,
						  @SortOrder,
						  @RecordStartIndex,
						  @RecordsCount,
						  @SQLSignatureIDFilter,
						  @StatementTypeIDFilter

end
go
 
GO 

---------- P_GETQUERYMONITORSTATEMENTS.SQL
if (object_id('p_GetQueryMonitorStatements') is not null)
begin
drop procedure p_GetQueryMonitorStatements
end
go 
create procedure [dbo].p_GetQueryMonitorStatements
	@SQLServerID int,
	@StartDate datetime = null,
	@EndDate datetime = null,
	@StartTime datetime = null,
	@EndTime datetime = null,
	 @IncludeSQLStatements bit = 1,
	 @IncludeStoredProcedures bit = 1,
	 @IncludeSQLBatches bit = 1,
	 @ApplicationNameExcludeFilter nvarchar(256) = null,
	 @ApplicationNameIncludeFilter nvarchar(256) = null,
	 @ClientComputerNameExcludeFilter nvarchar(255) = null,
	 @ClientComputerNameIncludeFilter nvarchar(255) = null,
	 @DatabaseNameExcludeFilter nvarchar(255) = null,
	 @DatabaseNameIncludeFilter nvarchar(255) = null,
	 @LoginNameExcludeFilter nvarchar(255) = null,
	 @LoginNameIncludeFilter nvarchar(255) = null,
	 @SqlTextExcludeFilter nvarchar(4000) = null,
	 @SqlTextIncludeFilter nvarchar(4000) = null,
	 @DurationFilter bigint = 0,
	@UTCOffset int = 0,
	 @ViewMode int = 0,
	 @SQLSignatureID int = null,
	 @SQLSignatureHash varchar(200) = null, -- SQLdm 9.1 (Ankit Srivastava) -- Rally Defect DE43572 -- Changed to varchar to avoid CONVERT_IMPLICIT
	 @ListRowcount int = 200,
	@SummaryRowcount int = 5,
	@GetFullQueryText bit = 0  -- SQLdm 9.0 (Ankit Srivastava) --(DE3932) get  complete SQLStatement Text

as
begin

set ansi_warnings off

declare 
	@SignatureMode int,
	@StatementMode int,
	@HistoryMode int

select
	@SignatureMode = 0,
	@StatementMode = 1,
	@HistoryMode = 2

declare @ReturnRowCount int

-- Do not honor these filters in this mode
if @ViewMode = @SignatureMode
select
	@ClientComputerNameExcludeFilter = null,
	@ClientComputerNameIncludeFilter = null,
	@LoginNameExcludeFilter = null,
	@LoginNameIncludeFilter = null

if (@StartTime is null)	set @StartTime = '00:00:00 AM'
if (@EndTime is null) set @EndTime = '11:59:59 PM'

select @StartDate = dateadd(ms,datediff(ms,0,dateadd(day,-datediff(day,0,@StartTime),@StartTime)),@StartDate)
select @EndDate = dateadd(ms,datediff(ms,0,dateadd(day,-datediff(day,0,@EndTime),@EndTime)),@EndDate)

declare
	@CorrectedStartTime datetime, 
	@CorrectedEndTime datetime;
	

select 
	@CorrectedStartTime = dateadd(mi,-@UTCOffset,@StartDate), 
	@CorrectedEndTime=dateadd(mi,-@UTCOffset,@EndDate)


if (object_id('#QueryStatementAggregationStep1') is not null)
begin
	drop table #QueryStatementAggregationStep1
end

create table #QueryStatementAggregationStep1
	(
		SQLServerID int,
		EventUTCStartTime datetime,	
		QueryMonitorOccurrences dec(38,0),
		WaitOcurrences dec(38,0),
		BlockingOcurrences dec(38,0),
		DeadlockOcurrences dec(38,0),
		TotalDurationMilliseconds dec(38,0),
		TotalCPUMilliseconds dec(38,0),
		TotalReads dec(38,0),
		TotalWrites dec(38,0),
		StatementType int,
		TotalBlockingDurationMilliseconds dec(38,0),
		TotalWaitDuration dec(38,0),
		ApplicationNameID bigint,
		DatabaseID bigint,
		HostNameID bigint,
		LoginNameID bigint,
		SQLTextID  bigint,
		SQLSignatureID bigint,
		MaxCPUMilliseconds dec(38,0),
		MaxReads dec(38,0),
		MaxWrites dec(38,0),
		Spid int,
		QueryStatisticsID int              --SQLdm 9.1 (Abhishek Joshi) -adding redirect functionality from a query in desktop client to WebUI Queries tab
	)

	
	
if (object_id('#QueryStatementAggregationStep2') is not null)
begin
	drop table #QueryStatementAggregationStep2
end	

create table #QueryStatementAggregationStep2
	(
		SQLServerID int,
		EventUTCStartTime datetime,	
		QueryMonitorOccurrences dec(38,0),
		WaitOcurrences dec(38,0),
		BlockingOcurrences dec(38,0),
		DeadlockOcurrences dec(38,0),
		TotalDurationMilliseconds dec(38,0),
		TotalCPUMilliseconds dec(38,0),
		TotalReads dec(38,0),
		TotalWrites dec(38,0),
		StatementType int,
		TotalBlockingDurationMilliseconds dec(38,0),
		TotalWaitDuration dec(38,0),
		ApplicationName nvarchar(256),
		DatabaseName nvarchar(255),
		HostName nvarchar(255),
		LoginName nvarchar(255),
		SQLTextID  bigint,
		SQLSignatureID bigint,
		AggregationFlag tinyint,
		MaxCPUMilliseconds dec(38,0),
		MaxReads dec(38,0),
		MaxWrites dec(38,0),
		Spid int,
		QueryStatisticsID int              --SQLdm 9.1 (Abhishek Joshi) -adding redirect functionality from a query in desktop client to WebUI Queries tab
	)
	
create clustered index IX_QueryStatementAggregationStep2 on #QueryStatementAggregationStep2(SQLTextID)

if (@ViewMode = @HistoryMode and @SQLSignatureID is null and @SQLSignatureHash is not null)
begin
	select @SQLSignatureID = SQLSignatureID 
	from AllSQLSignatures
	where SQLSignatureHash = @SQLSignatureHash

	if @SQLSignatureID is null
	begin
		goto skip_ahead
	end
end

	insert into #QueryStatementAggregationStep1
	(
		SQLServerID,
		EventUTCStartTime,	
		QueryMonitorOccurrences,
		TotalDurationMilliseconds,
		TotalCPUMilliseconds,
		TotalReads,
		TotalWrites,
		ApplicationNameID,
		DatabaseID,
		HostNameID,
		LoginNameID,
		StatementType,
		SQLTextID,
		SQLSignatureID,
		MaxCPUMilliseconds,
		MaxReads,
		MaxWrites,
		Spid,
		QueryStatisticsID                     --SQLdm 9.1 (Abhishek Joshi) -adding redirect functionality from a query in desktop client to WebUI Queries tab
	)

	-- Query Monitor
	select
		SQLServerID,
		EventUTCStartTime = dateadd(ms,datepart(ms,StatementUTCStartTime)*-1,StatementUTCStartTime),	
		QueryMonitorOccurrences = count(SQLServerID),
		TotalDurationMilliseconds = sum(cast(DurationMilliseconds as dec(38,0))),
		TotalCPUMilliseconds = sum(cast(CPUMilliseconds as dec(38,0))),
		TotalReads = sum(cast(Reads as dec(38,0))),
		TotalWrites = sum(cast(Writes as dec(38,0))),
		ApplicationNameID,
		DatabaseID,
		HostNameID = case when @ViewMode = @SignatureMode then 1 else HostNameID end,
		LoginNameID = case when @ViewMode = @SignatureMode then 1 else LoginNameID end,
		StatementType,
		SQLTextID = case when @ViewMode = @SignatureMode then SQLSignatureID else SQLStatementID end,
		SQLSignatureID,
		MaxCPUMilliseconds = max(cast(CPUMilliseconds as dec(38,0))),
		MaxReads = max(cast(Reads as dec(38,0))),
		MaxWrites = max(cast(Writes as dec(38,0))),
		Spid = case when @ViewMode = @SignatureMode then 1 else qm.SessionID end, 
		QueryStatisticsID = max(QueryStatisticsID)           --SQLdm 9.1 (Abhishek Joshi) -adding redirect functionality from a query in desktop client to WebUI Queries tab
	from 
		QueryMonitorStatistics qm
	where
		SQLServerID = @SQLServerID
		and DurationMilliseconds >= isnull(@DurationFilter,-1)
		and (@SQLSignatureID is null or SQLSignatureID = @SQLSignatureID)
		and 
		(		
			(StatementUTCStartTime between @CorrectedStartTime and @CorrectedEndTime)
			or (CompletionTime between @CorrectedStartTime and @CorrectedEndTime)
		)
		and qm.StatementType in (
		case when @IncludeSQLStatements = 1 then 1 else null end,
		case when @IncludeStoredProcedures = 1 then 0 else null end,
		case when @IncludeSQLBatches = 1 then 2 else null end)
	group by
		SQLServerID,
		dateadd(ms,datepart(ms,StatementUTCStartTime)*-1,StatementUTCStartTime),
		ApplicationNameID,
		DatabaseID,
		StatementType,
		case when @ViewMode = @SignatureMode then SQLSignatureID else SQLStatementID end,
		SQLSignatureID,
		case when @ViewMode = @SignatureMode then 1 else HostNameID end,
		case when @ViewMode = @SignatureMode then 1 else LoginNameID end,
		case when @ViewMode = @SignatureMode then 1 else qm.SessionID end

	-- Treat all blocks as batches
	if (@IncludeSQLBatches = 1)
	begin
		insert into #QueryStatementAggregationStep1
		(
			SQLServerID,
			EventUTCStartTime,	
			BlockingOcurrences,
			TotalBlockingDurationMilliseconds,
			StatementType,
			ApplicationNameID,
			DatabaseID,
			HostNameID,
			LoginNameID,
			SQLTextID,
			SQLSignatureID,
			Spid
		)	
		select
			SQLServerID,
			EventUTCStartTime =  dateadd(ms,datepart(ms,BlockingUTCStartTime)*-1,BlockingUTCStartTime),
			BlockingOcurrences = count(SQLServerID),
			TotalBlockingDurationMilliseconds = sum(cast(BlockingDurationMilliseconds as dec(38,0))),
			StatementType = 2,
			ApplicationNameID,
			DatabaseID,
			HostNameID = case when @ViewMode = @SignatureMode then 1 else HostNameID end,
			LoginNameID = case when @ViewMode = @SignatureMode then 1 else LoginNameID end,
			SQLTextID = case when @ViewMode = @SignatureMode then SQLSignatureID else SQLStatementID end,
			SQLSignatureID,
			Spid = case when @ViewMode = @SignatureMode then 1 else SessionID end
		from
			BlockingSessionStatistics 
		where
			SQLServerID = @SQLServerID
			and BlockingDurationMilliseconds >= isnull(@DurationFilter,-1)
			and (@SQLSignatureID is null or SQLSignatureID = @SQLSignatureID)
			and 
			(		
				(BlockingUTCStartTime between @CorrectedStartTime and @CorrectedEndTime)
				or (dateadd(ms,BlockingDurationMilliseconds,BlockingUTCStartTime) between @CorrectedStartTime and @CorrectedEndTime)
			)
		group by
			SQLServerID,
			dateadd(ms,datepart(ms,BlockingUTCStartTime)*-1,BlockingUTCStartTime),
			--cast(floor(cast(BlockingUTCStartTime as float)) as datetime),
			ApplicationNameID,
			DatabaseID,
			case when @ViewMode = @SignatureMode then SQLSignatureID else SQLStatementID end,
			SQLSignatureID,
			case when @ViewMode = @SignatureMode then 1 else HostNameID end,
			case when @ViewMode = @SignatureMode then 1 else LoginNameID end,
			case when @ViewMode = @SignatureMode then 1 else SessionID end
	end

	-- Treat all waits as statements
	if (@IncludeSQLStatements = 1)
	begin
		
		insert into #QueryStatementAggregationStep1
		(
			SQLServerID,
			EventUTCStartTime,	
			WaitOcurrences,
			TotalWaitDuration,
			StatementType,
			ApplicationNameID,
			DatabaseID,
			HostNameID,
			LoginNameID,
			SQLTextID,
			SQLSignatureID,
			Spid
		)	
		select
			SQLServerID,
			EventUTCStartTime =  dateadd(ms,datepart(ms,StatementUTCStartTime)*-1,StatementUTCStartTime),
			WaitOcurrences = count(StatementUTCStartTime),
			TotalWaitDuration = sum(cast(WaitDuration as dec(38,0))),
			StatementType = 1,
			ApplicationNameID,
			DatabaseID,
			HostNameID = case when @ViewMode = @SignatureMode then 1 else HostNameID end,
			LoginNameID = case when @ViewMode = @SignatureMode then 1 else LoginNameID end,
			SQLTextID = case when @ViewMode = @SignatureMode then SQLSignatureID else SQLStatementID end,
			SQLSignatureID,
			Spid = case when @ViewMode = @SignatureMode then 1 else SessionID end
		from
			ActiveWaitStatistics 
		where
			SQLServerID = @SQLServerID
			and WaitDuration >= isnull(@DurationFilter,-1)
			and 
			(		
				(StatementUTCStartTime between @CorrectedStartTime and @CorrectedEndTime)
				or (dateadd(ms,WaitDuration,StatementUTCStartTime) between @CorrectedStartTime and @CorrectedEndTime)
			)
			and (@SQLSignatureID is null or SQLSignatureID = @SQLSignatureID)
		group by
			SQLServerID,
			dateadd(ms,datepart(ms,StatementUTCStartTime)*-1,StatementUTCStartTime),
			ApplicationNameID,
			DatabaseID,
			case when @ViewMode = @SignatureMode then SQLSignatureID else SQLStatementID end,
			SQLSignatureID,
			case when @ViewMode = @SignatureMode then 1 else HostNameID end,
			case when @ViewMode = @SignatureMode then 1 else LoginNameID end,
			case when @ViewMode = @SignatureMode then 1 else SessionID end
	end

	-- Treat deadlocks as batches.  This is debatable: we attempt to record the inputbuffer
	if (@IncludeSQLBatches = 1) and (@DurationFilter is null)
	begin
		insert into #QueryStatementAggregationStep1
		(
			SQLServerID,
			EventUTCStartTime,	
			DeadlockOcurrences,
			StatementType,
			ApplicationNameID,
			DatabaseID,
			HostNameID,
			LoginNameID,
			SQLTextID,
			SQLSignatureID,
			Spid
		)	
		select
			SQLServerID,
			UTCOccurrenceDateTime =  dateadd(ms,datepart(ms,UTCOccurrenceDateTime)*-1,UTCOccurrenceDateTime),
			Occurrences = count(SQLServerID),
			StatementType = 2,
			ApplicationNameID,
			DatabaseID,
			HostNameID = case when @ViewMode = @SignatureMode then 1 else HostNameID end,
			LoginNameID = case when @ViewMode = @SignatureMode then 1 else LoginNameID end,
			SQLTextID = case when @ViewMode = @SignatureMode then SQLSignatureID else SQLStatementID end,
			SQLSignatureID,
			Spid = case when @ViewMode = @SignatureMode then 1 else SessionID end
		from
			DeadlockProcesses 
		where
			SQLServerID = @SQLServerID
			and UTCOccurrenceDateTime between @CorrectedStartTime and @CorrectedEndTime
			and (@SQLSignatureID is null or SQLSignatureID = @SQLSignatureID)
		group by
			SQLServerID,
			dateadd(ms,datepart(ms,UTCOccurrenceDateTime)*-1,UTCOccurrenceDateTime),
			ApplicationNameID,
			DatabaseID,
			case when @ViewMode = @SignatureMode then SQLSignatureID else SQLStatementID end,
			SQLSignatureID,
			case when @ViewMode = @SignatureMode then 1 else HostNameID end,
			case when @ViewMode = @SignatureMode then 1 else LoginNameID end,
			case when @ViewMode = @SignatureMode then 1 else SessionID end
	end

	

if (@ViewMode = @SignatureMode)
begin

	insert into 
	#QueryStatementAggregationStep2
	(
		SQLServerID,
		EventUTCStartTime,	
		QueryMonitorOccurrences,
		WaitOcurrences,
		BlockingOcurrences,
		DeadlockOcurrences,
		TotalDurationMilliseconds,
		TotalCPUMilliseconds,
		TotalReads,
		TotalWrites,
		StatementType,
		TotalBlockingDurationMilliseconds,
		TotalWaitDuration,
		ApplicationName,
		DatabaseName,
		HostName,
		LoginName,
		SQLTextID,
		SQLSignatureID,
		AggregationFlag,
		MaxCPUMilliseconds,
		MaxReads,
		MaxWrites,
		Spid
	)
	select
		qs1.SQLServerID,
		qs1.EventUTCStartTime,	
		max(qs1.QueryMonitorOccurrences),
		max(qs1.WaitOcurrences),
		max(qs1.BlockingOcurrences),
		max(qs1.DeadlockOcurrences),
		max(qs1.TotalDurationMilliseconds),
		max(qs1.TotalCPUMilliseconds),
		max(qs1.TotalReads),
		max(qs1.TotalWrites),
		max(qs1.StatementType),
		max(qs1.TotalBlockingDurationMilliseconds),
		max(qs1.TotalWaitDuration),
		ApplicationName,
		DatabaseName,
		null,
		null,
		qs1.SQLTextID,
		qs1.SQLSignatureID,
		0,		
		max(MaxCPUMilliseconds),
		max(MaxReads),
		max(MaxWrites),
		Spid
	from #QueryStatementAggregationStep1 qs1
		inner join SQLServerDatabaseNames dn
		on qs1.DatabaseID = dn.DatabaseID
		inner join ApplicationNames an
		on qs1.ApplicationNameID = an.ApplicationNameID
		--inner join AllSQLSignatures s
		--on qs1.SQLTextID = s.SQLSignatureID
	where
		(@ApplicationNameExcludeFilter is null or isnull(an.ApplicationName,'') not like @ApplicationNameExcludeFilter collate SQL_Latin1_General_CP1_CI_AS)
		and (@ApplicationNameIncludeFilter is null or isnull(an.ApplicationName,'') like @ApplicationNameIncludeFilter collate SQL_Latin1_General_CP1_CI_AS)
		and (@DatabaseNameExcludeFilter is null or isnull(dn.DatabaseName,'') not like @DatabaseNameExcludeFilter collate SQL_Latin1_General_CP1_CI_AS)
		and (@DatabaseNameIncludeFilter is null or isnull(dn.DatabaseName,'') like @DatabaseNameIncludeFilter collate SQL_Latin1_General_CP1_CI_AS)
		--and (@SqlTextExcludeFilter is null or isnull(s.SQLSignature,'') not like @SqlTextExcludeFilter collate SQL_Latin1_General_CP1_CI_AS)
		--and (@SqlTextIncludeFilter is null or isnull(s.SQLSignature,'') like @SqlTextIncludeFilter collate SQL_Latin1_General_CP1_CI_AS)
	group by
		qs1.SQLServerID,
		qs1.EventUTCStartTime,	
		ApplicationName,
		DatabaseName,
		qs1.SQLTextID,
		qs1.SQLSignatureID,
		Spid

end
else
begin
	insert into 
	#QueryStatementAggregationStep2
	(
		SQLServerID,
		EventUTCStartTime,	
		QueryMonitorOccurrences,
		WaitOcurrences,
		BlockingOcurrences,
		DeadlockOcurrences,
		TotalDurationMilliseconds,
		TotalCPUMilliseconds,
		TotalReads,
		TotalWrites,
		StatementType,
		TotalBlockingDurationMilliseconds,
		TotalWaitDuration,
		ApplicationName,
		DatabaseName,
		HostName,
		LoginName,
		SQLTextID,
		SQLSignatureID,
		AggregationFlag,
		MaxCPUMilliseconds,
		MaxReads,
		MaxWrites,
		Spid,
		QueryStatisticsID                       --SQLdm 9.1 (Abhishek Joshi) -adding redirect functionality from a query in desktop client to WebUI Queries tab
	)
	select
		qs1.SQLServerID,
		qs1.EventUTCStartTime,	
		max(qs1.QueryMonitorOccurrences),
		max(qs1.WaitOcurrences),
		max(qs1.BlockingOcurrences),
		max(qs1.DeadlockOcurrences),
		max(qs1.TotalDurationMilliseconds),
		max(qs1.TotalCPUMilliseconds),
		max(qs1.TotalReads),
		max(qs1.TotalWrites),
		max(qs1.StatementType),
		max(qs1.TotalBlockingDurationMilliseconds),
		max(qs1.TotalWaitDuration),
		ApplicationName,
		DatabaseName,
		HostName,
		LoginName,
		qs1.SQLTextID,
		qs1.SQLSignatureID,
		0,		
		max(MaxCPUMilliseconds),
		max(MaxReads),
		max(MaxWrites),
		Spid,
		QueryStatisticsID = max(qs1.QueryStatisticsID)                         --SQLdm 9.1 (Abhishek Joshi) -adding redirect functionality from a query in desktop client to WebUI Queries tab
	from #QueryStatementAggregationStep1 qs1
		inner join SQLServerDatabaseNames dn
		on qs1.DatabaseID = dn.DatabaseID
		inner join ApplicationNames an
		on qs1.ApplicationNameID = an.ApplicationNameID
		inner join LoginNames ln
		on qs1.LoginNameID = ln.LoginNameID
		inner join HostNames hn
		on qs1.HostNameID = hn.HostNameID
		--inner join AllSQLStatements s
		--on qs1.SQLTextID = s.SQLStatementID
	where
		(@ApplicationNameExcludeFilter is null or isnull(an.ApplicationName,'') not like @ApplicationNameExcludeFilter collate SQL_Latin1_General_CP1_CI_AS)
		and (@ApplicationNameIncludeFilter is null or isnull(an.ApplicationName,'') like @ApplicationNameIncludeFilter collate SQL_Latin1_General_CP1_CI_AS)
		and (@DatabaseNameExcludeFilter is null or isnull(dn.DatabaseName,'') not like @DatabaseNameExcludeFilter collate SQL_Latin1_General_CP1_CI_AS)
		and (@DatabaseNameIncludeFilter is null or isnull(dn.DatabaseName,'') like @DatabaseNameIncludeFilter collate SQL_Latin1_General_CP1_CI_AS)
		and (@LoginNameExcludeFilter is null or isnull(ln.LoginName,'') not like @LoginNameExcludeFilter collate SQL_Latin1_General_CP1_CI_AS)
		and (@LoginNameIncludeFilter is null or isnull(ln.LoginName,'') like @LoginNameIncludeFilter collate SQL_Latin1_General_CP1_CI_AS)
		--and (@SqlTextExcludeFilter is null or isnull(s.SQLStatement,'') not like @SqlTextExcludeFilter collate SQL_Latin1_General_CP1_CI_AS)
		--and (@SqlTextIncludeFilter is null or isnull(s.SQLStatement,'') like @SqlTextIncludeFilter collate SQL_Latin1_General_CP1_CI_AS)
		and (@ClientComputerNameExcludeFilter is null or isnull(hn.HostName,'') not like @ClientComputerNameExcludeFilter collate SQL_Latin1_General_CP1_CI_AS)
		and (@ClientComputerNameIncludeFilter is null or isnull(hn.HostName,'') like @ClientComputerNameIncludeFilter collate SQL_Latin1_General_CP1_CI_AS)
	group by
		qs1.SQLServerID,
		qs1.EventUTCStartTime,	
		ApplicationName,
		DatabaseName,
		HostName,
		LoginName,
		qs1.SQLTextID,
		qs1.SQLSignatureID,
		Spid

end

insert into 
	#QueryStatementAggregationStep2
	(
		SQLServerID,
		EventUTCStartTime,	
		QueryMonitorOccurrences,
		WaitOcurrences,
		BlockingOcurrences,
		DeadlockOcurrences,
		TotalDurationMilliseconds,
		TotalCPUMilliseconds,
		TotalReads,
		TotalWrites,
		StatementType,
		TotalBlockingDurationMilliseconds,
		TotalWaitDuration,
		ApplicationName,
		DatabaseName,
		SQLTextID,
		SQLSignatureID,
		AggregationFlag,
		MaxCPUMilliseconds,
		MaxReads,
		MaxWrites
	)
	select
		q.SQLServerID,
		EventUTCStartTime,
		QueryMonitorOccurrences,
		WaitOcurrences,
		BlockingOcurrences,
		DeadlockOcurrences,
		TotalDurationMilliseconds,
		TotalCPUMilliseconds,
		TotalReads,
		TotalWrites,
		StatementType,
		TotalBlockingDurationMilliseconds,
		TotalWaitDuration,
		ApplicationName,
		DatabaseName,
		q.SQLSignatureID,
		q.SQLSignatureID,
		1,		
		MaxCPUMilliseconds,
		MaxReads,
		MaxWrites
	from
		QuerySignatureAggregation q
		inner join SQLServerDatabaseNames dn
		on q.DatabaseID = dn.DatabaseID
		inner join ApplicationNames an
		on q.ApplicationNameID = an.ApplicationNameID
		inner join AllSQLSignatures s
		on q.SQLSignatureID = s.SQLSignatureID
	where
		q.SQLServerID = @SQLServerID
		and (@SQLSignatureID is null or q.SQLSignatureID = @SQLSignatureID)
		and (@StartDate is null or cast(floor(cast (dateadd(mi, @UTCOffset, EventUTCStartTime) as float)) as datetime) >= @StartDate)
		and (@EndDate is null or cast(floor(cast (dateadd(mi, @UTCOffset, EventUTCStartTime) as float)) as datetime) <= @EndDate)
		and (@ApplicationNameExcludeFilter is null or isnull(an.ApplicationName,'') not like @ApplicationNameExcludeFilter collate SQL_Latin1_General_CP1_CI_AS)
		and (@ApplicationNameIncludeFilter is null or isnull(an.ApplicationName,'') like @ApplicationNameIncludeFilter collate SQL_Latin1_General_CP1_CI_AS)
		and (@DatabaseNameExcludeFilter is null or isnull(dn.DatabaseName,'') not like @DatabaseNameExcludeFilter collate SQL_Latin1_General_CP1_CI_AS)
		and (@DatabaseNameIncludeFilter is null or isnull(dn.DatabaseName,'') like @DatabaseNameIncludeFilter collate SQL_Latin1_General_CP1_CI_AS)
		and (@SqlTextExcludeFilter is null or isnull(s.SQLSignature,'') not like @SqlTextExcludeFilter collate SQL_Latin1_General_CP1_CI_AS)
		and (@SqlTextIncludeFilter is null or isnull(s.SQLSignature,'') like @SqlTextIncludeFilter collate SQL_Latin1_General_CP1_CI_AS)


if (@ViewMode = @HistoryMode and @SQLSignatureID is null)
begin
	select top 1 @SQLSignatureID = SQLSignatureID
	from #QueryStatementAggregationStep2
	order by
		cast(cast(TotalCPUMilliseconds as dec(15,0)) / nullif(TotalDurationMilliseconds,0) as dec (15,2)) desc,  -- CPU Per Second
		cast(cast(TotalReads + TotalWrites as dec(15,0)) / nullif(TotalDurationMilliseconds,0) as dec (15,2)) desc,  -- IO Per Second
		TotalDurationMilliseconds / nullif(QueryMonitorOccurrences,0) desc, -- Duration
		TotalReads / nullif(QueryMonitorOccurrences,0) desc, -- Reads
		TotalWrites / nullif(QueryMonitorOccurrences,0) desc,  -- Writes
		DeadlockOcurrences desc -- Deadlocks
	
	delete from #QueryStatementAggregationStep2 where @SQLSignatureID <> SQLSignatureID

end

skip_ahead:


declare @NewLine char(1), @NewLine2 char(1)

set @NewLine = char(13)
set @NewLine2 = char(10)

if (@ViewMode = @SignatureMode)
begin

	set rowcount @ListRowcount



	select --top @ListRowcount
		DatabaseName,
		UTCStartTime = min(EventUTCStartTime),
		UTCCompletionTime = max(dateadd(ms,TotalDurationMilliseconds,EventUTCStartTime)),
		DurationMilliseconds = sum(TotalDurationMilliseconds) / isnull(nullif(sum(QueryMonitorOccurrences),0),1),
		AvgCPUMilliseconds = sum(TotalCPUMilliseconds) / isnull(nullif(sum(QueryMonitorOccurrences),0),1),
		TotalCPUMilliseconds = max(TotalCPUMilliseconds),
		AvgReads = sum(TotalReads) / isnull(nullif(sum(QueryMonitorOccurrences),0),1),
		AvgWrites = sum(TotalWrites) / isnull(nullif(sum(QueryMonitorOccurrences),0),1),
		TotalReads = max(TotalReads),
		TotalWrites = max(TotalWrites),
		WaitMilliseconds = sum(TotalWaitDuration) / isnull(nullif(sum(WaitOcurrences),0),1),
		LoginName = null,
		ApplicationName = rtrim(ApplicationName),
		StatementType,
		BlockingTimeMilliseconds = sum(TotalBlockingDurationMilliseconds) / isnull(nullif(sum(BlockingOcurrences),0),1),
		Deadlocks = sum(DeadlockOcurrences),
		SQLSignatureID = q.SQLSignatureID,
		--START: SQLdm 9.0 (Ankit Srivastava) --(DE3932) get  complete SQLStatement Text
		SQLStatementText = case
								when @GetFullQueryText = 0 then left(replace(replace(s.SQLSignature,@NewLine,' '),@NewLine2,' '),255)
								else s.SQLSignature
						   end,
		--END : SQLdm 9.0 (Ankit Srivastava) --(DE3932) get  complete SQLStatement Text
		HostName = null,
		CPUPerSecond = cast(sum(TotalCPUMilliseconds) / nullif(sum(TotalDurationMilliseconds),0) as dec (15,2)),
		IOPerSecond = cast(sum(TotalReads + TotalWrites) / nullif(sum(TotalDurationMilliseconds),0) as dec (15,2)),
		Occurrences = coalesce(sum(QueryMonitorOccurrences),sum(WaitOcurrences),sum(BlockingOcurrences),sum(DeadlockOcurrences)),
		AggregationFlag = max(AggregationFlag),
		SQLTextID = q.SQLTextID,
		DoNotAggregate = isnull(s.DoNotAggregate,0),
		Spid = null
	from
		#QueryStatementAggregationStep2	q
		inner join AllSQLSignatures s
		on q.SQLTextID = s.SQLSignatureID
	where
		(@SqlTextExcludeFilter is null or isnull(s.SQLSignature,'') not like @SqlTextExcludeFilter collate SQL_Latin1_General_CP1_CI_AS)
		and (@SqlTextIncludeFilter is null or isnull(s.SQLSignature,'') like @SqlTextIncludeFilter collate SQL_Latin1_General_CP1_CI_AS)		
	group by
		DatabaseName,
		ApplicationName,
		StatementType,
		q.SQLSignatureID,
		--START: SQLdm 9.0 (Ankit Srivastava) --(DE3932) get  complete SQLStatement Text
		case
			when @GetFullQueryText = 0 then left(replace(replace(s.SQLSignature,@NewLine,' '),@NewLine2,' '),255)
			else s.SQLSignature
		end,
		--END : SQLdm 9.0 (Ankit Srivastava) --(DE3932) get  complete SQLStatement Text
		q.SQLTextID,
		isnull(s.DoNotAggregate,0)
	order by
		cast(sum(TotalCPUMilliseconds) / nullif(sum(TotalDurationMilliseconds),0) as dec (15,2)) desc,  -- CPU Per Second
		cast(sum(TotalReads + TotalWrites) / nullif(sum(TotalDurationMilliseconds),0) as dec (15,2)) desc,  -- IO Per Second
		sum(TotalDurationMilliseconds) / isnull(nullif(sum(QueryMonitorOccurrences),0),1) desc,  -- Duration
		sum(TotalReads) / isnull(nullif(sum(QueryMonitorOccurrences),0),1) desc,  -- Reads
		sum(TotalWrites) / isnull(nullif(sum(QueryMonitorOccurrences),0),1) desc,  -- Writes
		sum(DeadlockOcurrences) desc -- Deadlocks
		
	
end 
else
begin

	set rowcount @ListRowcount

	select --top @ListRowcount
		DatabaseName,
		UTCStartTime = EventUTCStartTime,
		UTCCompletionTime = dateadd(ms,TotalDurationMilliseconds,EventUTCStartTime),
		DurationMilliseconds = TotalDurationMilliseconds / nullif(QueryMonitorOccurrences,0),
		AvgCPUMilliseconds = TotalCPUMilliseconds / nullif(QueryMonitorOccurrences,0),
		TotalCPUMilliseconds,
		AvgReads = TotalReads / nullif(QueryMonitorOccurrences,0),
		AvgWrites = TotalWrites / nullif(QueryMonitorOccurrences,0),
		TotalReads,
		TotalWrites,
		WaitMilliseconds = TotalWaitDuration / nullif(WaitOcurrences,0),
		LoginName,-- = LoginName,
		ApplicationName = rtrim(ApplicationName),
		StatementType,
		BlockingTimeMilliseconds = TotalBlockingDurationMilliseconds / nullif(BlockingOcurrences,0),
		Deadlocks = DeadlockOcurrences,
		SQLSignatureID = q.SQLSignatureID,
		--START: SQLdm 9.0 (Ankit Srivastava) --(DE3932) get  complete SQLStatement Text
		SQLStatementText = case
								when @GetFullQueryText = 0 then left(replace(replace(s.SQLStatement,@NewLine,' '),@NewLine2,' '),255)
								else s.SQLStatement
						   end,
		--END : SQLdm 9.0 (Ankit Srivastava) --(DE3932) get  complete SQLStatement Text
		HostName,-- = hn.HostName,
		CPUPerSecond = cast(cast(TotalCPUMilliseconds as dec(15,0)) / nullif(TotalDurationMilliseconds,0) as dec (15,2)),
		IOPerSecond = cast(cast(TotalReads + TotalWrites as dec(15,0)) / nullif(TotalDurationMilliseconds,0) as dec (15,2)),
		Occurrences = coalesce(QueryMonitorOccurrences,WaitOcurrences,BlockingOcurrences,DeadlockOcurrences),
		AggregationFlag,
		SQLTextID = q.SQLTextID,
		DoNotAggregate = isnull(sig.DoNotAggregate,0),
		Spid,
		QueryStatisticsID                --SQLdm 9.1 (Abhishek Joshi) -adding redirect functionality from a query in desktop client to WebUI Queries tab
	from
		#QueryStatementAggregationStep2	q
		inner join AllSQLStatements s
		on q.SQLTextID = s.SQLStatementID
		inner join AllSQLSignatures sig
		on q.SQLSignatureID  = sig.SQLSignatureID
	where
		isnull(@SQLSignatureID,q.SQLSignatureID) = q.SQLSignatureID
		and (@SqlTextExcludeFilter is null or isnull(s.SQLStatement,'') not like @SqlTextExcludeFilter collate SQL_Latin1_General_CP1_CI_AS)
		and (@SqlTextIncludeFilter is null or isnull(s.SQLStatement,'') like @SqlTextIncludeFilter collate SQL_Latin1_General_CP1_CI_AS)
	order by
		cast(cast(TotalCPUMilliseconds as dec(15,0)) / nullif(TotalDurationMilliseconds,0) as dec (15,2)) desc,  -- CPU Per Second
		cast(cast(TotalReads + TotalWrites as dec(15,0)) / nullif(TotalDurationMilliseconds,0) as dec (15,2)) desc,  -- IO Per Second
		TotalDurationMilliseconds / nullif(QueryMonitorOccurrences,0) desc, -- Duration
		TotalReads / nullif(QueryMonitorOccurrences,0) desc, -- Reads
		TotalWrites / nullif(QueryMonitorOccurrences,0) desc,  -- Writes
		DeadlockOcurrences desc -- Deadlocks

end

set @ReturnRowCount = @@rowcount


declare @LoopTable table
(
	Ordinal int,
	ColumnName nvarchar(255)	
)

declare @AggregationTable table
(
	ColumnName nvarchar(255),
	ColumnValue nvarchar(255),
	AvgCPUMilliseconds dec(15,2),
	AvgReads dec(15,2),
	AvgWrites  dec(15,2),
	AvgWaitMilliseconds dec(15,2),
	TotalDeadlocks dec(15,0),
	AvgBlockMilliseconds dec(15,2),
	AvgDurationMilliseconds dec(15,2),
	CPUPerSecond dec(15,2),
	IOPerSecond dec(15,2),
	MaxCPUMilliseconds dec(38,0),
	MaxReads dec(38,0),
	MaxWrites dec(38,0),
	Occurrences bigint,
	OccurrencesPerDay dec(15,2)
)

declare @ChartOutput table
(
	ColumnName nvarchar(255),
	ColumnValue nvarchar(255),
	AvgCPUMilliseconds dec(15,2),
	AvgReads dec(15,2),
	AvgWrites  dec(15,2),
	AvgWaitMilliseconds dec(15,2),
	TotalDeadlocks dec(15,0),
	AvgBlockMilliseconds dec(15,2),
	AvgDurationMilliseconds dec(15,2),
	CPUPerSecond dec(15,2),
	IOPerSecond dec(15,2),
	MaxCPUMilliseconds dec(38,0),
	MaxReads dec(38,0),
	MaxWrites dec(38,0),
	Occurrences bigint,
	OccurrencesPerDay dec(15,2)
)


if (@ViewMode = @HistoryMode)
	insert into @LoopTable
		select 0,'Total'

if (@ViewMode <> @HistoryMode)
	insert into @LoopTable
		select 1,'ApplicationName'
		union all select 2, 'DatabaseName'

if (@ViewMode = @StatementMode)
	insert into @LoopTable
		select 3,'HostName'
		union all select 4, 'LoginName'

declare @Loop int, @Exit int, @ColumnName nvarchar(255)


select @Loop = min(Ordinal), @Exit = max(Ordinal) from @LoopTable



while @Loop <= @Exit
begin
	set rowcount 0

	select @ColumnName = ColumnName 
	from @LoopTable
	where Ordinal = @Loop

	insert into 
		@AggregationTable
	select
		ColumnName = @ColumnName,
		ColumnValue = case 
			when @Loop = 0 then 'Total' 
			when @Loop = 1 then ApplicationName 
			when @Loop = 2 then DatabaseName 
			when @Loop = 3 then HostName 
			when @Loop = 4 then LoginName 
			else ' ' end,
		AvgCPUMilliseconds = sum(TotalCPUMilliseconds) / isnull(nullif(sum(QueryMonitorOccurrences),0),1),
		AvgReads = sum(TotalReads) / isnull(nullif(sum(QueryMonitorOccurrences),0),1),
		AvgWrites = sum(TotalWrites) / isnull(nullif(sum(QueryMonitorOccurrences),0),1),
		AvgWaitMilliseconds = sum(TotalWaitDuration) / isnull(nullif(sum(WaitOcurrences),0),1),
		TotalDeadlocks = sum(DeadlockOcurrences),
		AvgBlockMilliseconds = sum(TotalBlockingDurationMilliseconds) / isnull(nullif(sum(BlockingOcurrences),0),1),
		AvgDurationMilliseconds = sum(TotalDurationMilliseconds) / isnull(nullif(sum(QueryMonitorOccurrences),0),1),
		CPUPerSecond = cast(sum(TotalCPUMilliseconds) / nullif(sum(TotalDurationMilliseconds),0) as dec (15,2)),
		IOPerSecond = cast(sum(TotalReads + TotalWrites) / nullif(sum(TotalDurationMilliseconds),0) as dec (15,2)),
		MaxCPUMilliseconds = max(MaxCPUMilliseconds),
		MaxReads = max(MaxReads),
		MaxWrites = max(MaxWrites),
		Occurrences = coalesce(sum(QueryMonitorOccurrences),sum(WaitOcurrences),sum(BlockingOcurrences),sum(DeadlockOcurrences)),
		OccurrencesPerDay = 
			coalesce(sum(QueryMonitorOccurrences),sum(WaitOcurrences),sum(BlockingOcurrences),sum(DeadlockOcurrences)) /
			isnull(nullif(case when @StartDate is not null and @EndDate is not null then datediff(d,@StartDate,@EndDate) else datediff(d,min(EventUTCStartTime),max(EventUTCStartTime)) end,0),1)
	from
		#QueryStatementAggregationStep2	q
	group by
		case 
			when @Loop = 0 then 'Total' 
			when @Loop = 1 then ApplicationName 
			when @Loop = 2 then DatabaseName 
			when @Loop = 3 then HostName 
			when @Loop = 4 then LoginName 
			else ' ' end


	if @@rowcount < @SummaryRowcount
	begin
		insert into @ChartOutput
			select
				*
			from
				@AggregationTable
	end
	else
	begin

	set rowcount @SummaryRowcount

	insert into @ChartOutput
	select -- top @SummaryRowcount
		*
	from
		@AggregationTable
	order by
		AvgCPUMilliseconds desc

	insert into @ChartOutput
	select -- top @SummaryRowcount
		*
	from
		@AggregationTable
	order by
		AvgReads desc

	insert into @ChartOutput
	select -- top @SummaryRowcount
		*
	from
		@AggregationTable
	order by
		AvgWrites desc

	insert into @ChartOutput
	select -- top @SummaryRowcount
		*
	from
		@AggregationTable
	order by
		CPUPerSecond desc

	insert into @ChartOutput
	select -- top @SummaryRowcount
		*
	from
		@AggregationTable
	order by
		IOPerSecond desc

	end

	set rowcount 0

	delete from @AggregationTable	

	select @Loop = @Loop + 1

end

	set rowcount 0
	
	if @ViewMode = @HistoryMode
	begin

		select distinct *
		from @ChartOutput ,
		(select SQLSignature = left(replace(replace(SQLSignature,@NewLine,' '),@NewLine2,' '),255), SQLSignatureID = cast(SQLSignatureID as bigint), DoNotAggregate= isnull(DoNotAggregate,0)
		from AllSQLSignatures where SQLSignatureID = @SQLSignatureID)  s
	end
	else
	begin
		select distinct *, SQLSignature = null, SQLSignatureID = null, DoNotAggregate = null
		from @ChartOutput 
	end
	

declare 
	@QueryMonitorRunning bit

declare @DataExplanation table
(
	EnumValue int,
	Description nvarchar(100)
)	

if (@ReturnRowCount = 0)
	insert into @DataExplanation values ('0','No data was returned for the given filter set.')

select
@QueryMonitorRunning = QueryMonitorEnabled
from MonitoredSQLServers
where SQLServerID = @SQLServerID

if (@QueryMonitorRunning = 0)
	insert into @DataExplanation values ('1','The Query Monitor trace is not running.')

if (object_id('QueryMonitor') is not null)
begin
	if exists(select Name from RepositoryInfo where Name = 'QMUpgrading')
		insert into @DataExplanation values ('2','SQLdm is currently upgrading previously collected Query Monitor data.')
end
	
	select * from @DataExplanation

end

 
GO 

---------- P_GETQUERYMONITORUPGRADEDATA.SQL
if (object_id('p_GetQueryMonitorUpgradeData') is not null)
begin
drop procedure p_GetQueryMonitorUpgradeData
end
go

declare @command nvarchar(3000), @RowsRemaining bigint

select 
	@RowsRemaining = sum(rows)
from
	sys.partitions
where
	object_id = object_id('QueryMonitor')
	and index_id < 2 
	
if (isnull(@RowsRemaining,0) <= 0)
begin
set @command = '
create procedure p_GetQueryMonitorUpgradeData
as
begin
	return
end'

end
else
begin

set @command = '
create procedure p_GetQueryMonitorUpgradeData
as
begin

	declare 
		@UpgradeRowCount int,
		@UpgradeTimeLimit int,
		@UpgradeTimeOfDay datetime,
		@UpgradeRowCountDefault int,
		@UpgradeTimeLimitDefault int,
		@UpgradeTimeOfDayDefault datetime,
		@CurrentTime datetime,
		@StartTime datetime,
		@rc int

	set @UpgradeRowCountDefault = 1000
	set @UpgradeTimeLimitDefault = 180
	set @UpgradeTimeOfDayDefault = ''2010-01-01 00:00:00''
	set @CurrentTime = getdate()

	select @UpgradeRowCount = isnull(Internal_Value,@UpgradeRowCountDefault) from RepositoryInfo where [Name] = ''QMUpgradeRowCount''	
	select @UpgradeTimeLimit = isnull(Internal_Value,@UpgradeTimeLimitDefault) from RepositoryInfo where [Name] = ''QMUpgradeTimeLimit''	
	select @UpgradeTimeOfDay = isnull(cast(Character_Value as datetime),@UpgradeTimeOfDayDefault) from RepositoryInfo where [Name] = ''QMUpgradeTimeOfDay''	
	select @StartTime = cast(Character_Value as datetime) from RepositoryInfo where [Name] = ''QMUpgradeStartTime''
	
	set @UpgradeRowCount = isnull(@UpgradeRowCount,@UpgradeRowCountDefault)
	set @UpgradeTimeLimit = isnull(@UpgradeTimeLimit,@UpgradeTimeLimitDefault)
	set @UpgradeTimeOfDay = isnull(@UpgradeTimeOfDay,@UpgradeTimeOfDayDefault)
	set @UpgradeTimeOfDay = cast(@UpgradeTimeOfDay as float) - floor(cast(@UpgradeTimeOfDay as float))


	if (@StartTime is null)
	begin
		set @StartTime = @CurrentTime	
		insert into RepositoryInfo(Name,Character_Value)
			select 
				''QMUpgradeStartTime'',
				convert(nvarchar(100),@StartTime,121)
	end

	if (@StartTime > @CurrentTime)
	begin
		select ''Waiting''
		return
	end

	if (dateadd(mi,@UpgradeTimeLimit,@StartTime) < @CurrentTime)
	begin
		declare @NextStartTime datetime
		set @NextStartTime = dateadd(dd,1,cast((floor(cast(@CurrentTime as float)) + cast(@UpgradeTimeOfDay as float)) as datetime))
				
		update RepositoryInfo set Character_Value = convert(nvarchar(100),@NextStartTime ,121)
			where Name = ''QMUpgradeStartTime''
		
		select ''Waiting''
		return
	end

	set rowcount @UpgradeRowCount

	select 
		SQLServerID,
		UTCCollectionDateTime,
		DatabaseID,
		isnull(CompletionTime,UTCCollectionDateTime) as CompletionTime,
		DurationMilliseconds,
		CPUMilliseconds,
		Reads,
		Writes,
		SqlUserName,
		ClientComputerName,
		ApplicationName,
		StatementType,
		StatementText,
		Spid
	from 
		QueryMonitor
	where
		len(StatementText) > 0
		and isnull(DeleteFlag,0) = 0


	set @rc = @@rowcount

	delete from RepositoryInfo where Name = ''QMUpgrading''

	if @rc > 0
	begin
		insert into RepositoryInfo(Name,Character_Value)
			select 
				''QMUpgrading'',
				 convert(nvarchar(100),getdate() ,121)
	end
	

	
end
--'
end
execute(@command)
 
GO 

---------- P_GETQUERYOVERVIEW.SQL
if (object_id('p_GetQueryOverview') is not null)
begin
drop procedure p_GetQueryOverview
end
go
-- @Interval - Granularity of calculation:
--	0 - Minutes
--	1 - Hours
--	2 - Days
--	3 - Months
--	4 - Years
create procedure [dbo].p_GetQueryOverview 
	@SQLServerID int,
	@StartDateTime datetime = null,
	@EndDateTime datetime = null,
	@UtcOffset int = 0,
	@Interval int,
	@StatementType int = null
as 
begin


if (@StatementType is not null)
	select
		LastCollectionInInterval = dbo.fn_RoundDateTime(@Interval, max(EventTime)),
		EventCount =  sum(EventCount),
		TotalDuration = sum(TotalDuration),
		TotalCPU = sum(TotalCPU),
		TotalReads = sum(TotalReads),
		TotalWrites = sum(TotalWrites)
	from
	(
	select
		EventTime = max(dateadd(mi, @UtcOffset, CompletionTime)),
		EventCount = count(*),
		TotalDuration = sum(DurationMilliseconds),
		TotalCPU = sum(CPUMilliseconds),
		TotalReads = sum(Reads),
		TotalWrites = sum(Writes)
	from
		QueryMonitorStatistics (nolock)
	where
		isnull(@StartDateTime,'1 Jan 1900') <= dbo.fn_RoundDateTime(@Interval, StatementUTCStartTime) and
		isnull(@EndDateTime,'1 Jan 2200') >= dbo.fn_RoundDateTime(@Interval, CompletionTime)	and
		isnull(@StatementType,StatementType) = StatementType and
		SQLServerID = @SQLServerID
	group by
		datepart(yy, dateadd(mi, @UtcOffset,[CompletionTime]))
		,case when @Interval <= 3 then datepart(mm,dateadd(mi, @UtcOffset,[CompletionTime])) else datepart(yy,dateadd(mi, @UtcOffset,[CompletionTime])) end
		,case when @Interval <= 2 then datepart(dd,dateadd(mi, @UtcOffset,[CompletionTime])) else datepart(yy,dateadd(mi, @UtcOffset,[CompletionTime])) end
		,case when @Interval <= 1 then datepart(hh,dateadd(mi, @UtcOffset,[CompletionTime])) else datepart(yy,dateadd(mi, @UtcOffset,[CompletionTime])) end
		,case when @Interval =  0 then datepart(mi,dateadd(mi, @UtcOffset,[CompletionTime])) else datepart(yy,dateadd(mi, @UtcOffset,[CompletionTime])) end
	union all
	select
		EventTime = max(EventUTCStartTime),
		EventCount = sum(QueryMonitorOccurrences),
		TotalDuration = sum(TotalDurationMilliseconds),
		TotalCPU =  sum(TotalCPUMilliseconds),
		TotalReads = sum(TotalReads),
		TotalWrites = sum(TotalWrites)
	from
		QuerySignatureAggregation (nolock)
	where
		isnull(@StartDateTime,'1 Jan 1900') <= dbo.fn_RoundDateTime(@Interval, EventUTCStartTime) and
		isnull(@EndDateTime,'1 Jan 2200') >= dbo.fn_RoundDateTime(@Interval, EventUTCStartTime) and
		isnull(@StatementType,StatementType) = StatementType and
		SQLServerID = @SQLServerID
	group by
		datepart(yy, EventUTCStartTime)
		,case when @Interval <= 3 then datepart(mm,EventUTCStartTime) else datepart(yy,EventUTCStartTime) end
		,case when @Interval <= 2 then datepart(dd,EventUTCStartTime) else datepart(yy,EventUTCStartTime) end
	) as qm
	group by
		datepart(yy, dateadd(mi, @UtcOffset, [EventTime]))
		,case when @Interval <= 3 then datepart(mm,dateadd(mi, @UtcOffset, [EventTime])) else datepart(yy,dateadd(mi, @UtcOffset, [EventTime])) end
		,case when @Interval <= 2 then datepart(dd,dateadd(mi, @UtcOffset, [EventTime])) else datepart(yy,dateadd(mi, @UtcOffset, [EventTime])) end
		,case when @Interval <= 1 then datepart(hh,dateadd(mi, @UtcOffset, [EventTime])) else datepart(yy,dateadd(mi, @UtcOffset, [EventTime])) end
		,case when @Interval =  0 then datepart(mi,dateadd(mi, @UtcOffset, [EventTime])) else datepart(yy,dateadd(mi, @UtcOffset, [EventTime])) end

else
	select
		LastCollectionInInterval = dbo.fn_RoundDateTime(@Interval, max(EventTime)),
		TotalDuration = sum(TotalDuration),
		TotalCPU = sum(TotalCPU),
		TotalReads = sum(TotalReads),
		TotalWrites = sum(TotalWrites),
		TotalProcedures = sum(TotalProcedures),
		TotalStatements = sum(TotalStatements),
		TotalBatches = sum(TotalBatches)
	from
	(
	select
		EventTime = max(dateadd(mi, @UtcOffset, CompletionTime)),
		TotalDuration = sum(DurationMilliseconds),
		TotalCPU = sum(CPUMilliseconds),
		TotalReads = sum(Reads),
		TotalWrites = sum(Writes),
		TotalProcedures = sum(case when StatementType = 0 then 1 else 0 end),
		TotalStatements = sum(case when StatementType = 1 then 1 else 0 end),
		TotalBatches = sum(case when StatementType = 2 then 1 else 0 end)
	from
		QueryMonitorStatistics (nolock)
	where
		isnull(@StartDateTime,'1 Jan 1900') <= dbo.fn_RoundDateTime(@Interval, StatementUTCStartTime) and
		isnull(@EndDateTime,'1 Jan 2200') >= dbo.fn_RoundDateTime(@Interval, CompletionTime)	and
		isnull(@StatementType,StatementType) = StatementType and
		SQLServerID = @SQLServerID
	group by
		datepart(yy, dateadd(mi, @UtcOffset,[CompletionTime]))
		,case when @Interval <= 3 then datepart(mm,dateadd(mi, @UtcOffset,[CompletionTime])) else datepart(yy,dateadd(mi, @UtcOffset,[CompletionTime])) end
		,case when @Interval <= 2 then datepart(dd,dateadd(mi, @UtcOffset,[CompletionTime])) else datepart(yy,dateadd(mi, @UtcOffset,[CompletionTime])) end
		,case when @Interval <= 1 then datepart(hh,dateadd(mi, @UtcOffset,[CompletionTime])) else datepart(yy,dateadd(mi, @UtcOffset,[CompletionTime])) end
		,case when @Interval =  0 then datepart(mi,dateadd(mi, @UtcOffset,[CompletionTime])) else datepart(yy,dateadd(mi, @UtcOffset,[CompletionTime])) end
	union all
	
	select
		EventTime = max(EventUTCStartTime),
		TotalDuration = sum(TotalDurationMilliseconds),
		TotalCPU = sum(TotalCPUMilliseconds),
		TotalReads = sum(TotalReads),
		TotalWrites = sum(TotalWrites),
		TotalProcedures = sum(case when StatementType = 0 then QueryMonitorOccurrences else 0 end),
		TotalStatements = sum(case when StatementType = 1 then QueryMonitorOccurrences else 0 end),
		TotalBatches = sum(case when StatementType = 2 then QueryMonitorOccurrences else 0 end)
	from
		QuerySignatureAggregation (nolock)
	where
		isnull(dbo.fn_RoundDateTime(2,dateadd(mi, @UtcOffset,@StartDateTime)),'1 Jan 1900') <= dbo.fn_RoundDateTime(@Interval, EventUTCStartTime) and 
		isnull(dbo.fn_RoundDateTime(2,dateadd(mi, @UtcOffset,@EndDateTime)),'1 Jan 2200') >= dbo.fn_RoundDateTime(@Interval, EventUTCStartTime)	and 
		isnull(@StatementType,StatementType) = StatementType and
		SQLServerID = @SQLServerID
	group by
		datepart(yy, EventUTCStartTime)
		,case when @Interval <= 3 then datepart(mm,EventUTCStartTime) else datepart(yy,EventUTCStartTime) end
		,case when @Interval <= 2 then datepart(dd,EventUTCStartTime) else datepart(yy,EventUTCStartTime) end
	) as qm
	group by
		datepart(yy, [EventTime])
		,case when @Interval <= 3 then datepart(mm,[EventTime]) else datepart(yy,[EventTime]) end
		,case when @Interval <= 2 then datepart(dd,[EventTime]) else datepart(yy,[EventTime]) end
		,case when @Interval <= 1 then datepart(hh,[EventTime]) else datepart(yy,[EventTime]) end
		,case when @Interval =  0 then datepart(mi,[EventTime]) else datepart(yy,[EventTime]) end
end

Go

grant EXECUTE on p_GetQueryOverview to [SQLdmConsoleUser]

go

if (object_id('p_GetQueryOverviewStoredProcedures') is not null)
begin
drop procedure p_GetQueryOverviewStoredProcedures
end
go
-- @Interval - Granularity of calculation:
--	0 - Minutes
--	1 - Hours
--	2 - Days
--	3 - Months
--	4 - Years
create procedure [dbo].p_GetQueryOverviewStoredProcedures
	@SQLServerID int,
	@StartDateTime datetime = null,
	@EndDateTime datetime = null,
	@UtcOffset int = 0,
	@Interval int
as 
begin
	
	exec p_GetQueryOverview
		@SQLServerID,
		@StartDateTime,
		@EndDateTime,
		@UtcOffset,
		@Interval,
		0
end

Go

grant EXECUTE on p_GetQueryOverviewStoredProcedures to [SQLdmConsoleUser]

go

if (object_id('p_GetQueryOverviewStatements') is not null)
begin
drop procedure p_GetQueryOverviewStatements
end
go
-- @Interval - Granularity of calculation:
--	0 - Minutes
--	1 - Hours
--	2 - Days
--	3 - Months
--	4 - Years
create procedure [dbo].p_GetQueryOverviewStatements
	@SQLServerID int,
	@StartDateTime datetime = null,
	@EndDateTime datetime = null,
	@UtcOffset int = 0,
	@Interval int
as 
begin
	
	exec p_GetQueryOverview
		@SQLServerID,
		@StartDateTime,
		@EndDateTime,
		@UtcOffset,
		@Interval,
		1
end

Go

grant EXECUTE on p_GetQueryOverviewStatements to [SQLdmConsoleUser]

go

if (object_id('p_GetQueryOverviewBatches') is not null)
begin
drop procedure p_GetQueryOverviewBatches
end
go
-- @Interval - Granularity of calculation:
--	0 - Minutes
--	1 - Hours
--	2 - Days
--	3 - Months
--	4 - Years
create procedure [dbo].p_GetQueryOverviewBatches
	@SQLServerID int,
	@StartDateTime datetime = null,
	@EndDateTime datetime = null,
	@UtcOffset int = 0,
	@Interval int
as 
begin
	
	exec p_GetQueryOverview
		@SQLServerID,
		@StartDateTime,
		@EndDateTime,
		@UtcOffset,
		@Interval,
		2
end

Go

grant EXECUTE on p_GetQueryOverviewBatches to [SQLdmConsoleUser]

GO
 
GO 

---------- P_GETQUERYPLAN.SQL
-- SQLdm 9.0 (Abhishek Joshi)
-- retrieves the query plan for a QueryStatisticsID

-- @QueryStatisticsID is the QueryStatisticsID column of the QueryMonitorStatistics table

-- exec p_GetQueryPlan @QueryStatisticsID = 7

if (object_id('p_GetQueryPlan') is not null)
begin
	drop procedure [p_GetQueryPlan]
end
go

create procedure [dbo].[p_GetQueryPlan]
	@QueryStatisticsID int -- SQLdm 9.0 (Ankit Srivastava) - Query Plan Grpahical View - Changed the paramter from statementid to statisticsid
as
begin
	SELECT 
		SQP.PlanID, 
		SQP.SQLStatementID, 
		-- Start -SQLdm 9.0 (Ankit Srivastava) - Query Plan Grpahical View - Changed the selected column and the where condition
		CASE 
			WHEN SQP.Overflow=0
				THEN SQP.PlanXML
			ELSE 
				SQPO.PlanXMLOverflow
		END
		AS PlanXML, 
		SQP.IsActualPlan --SQLdm 10.0 (Tarun Sapra) - Display estimated query plan - Flag to tell if the plan is actual or estimated one
	FROM 
		[QueryMonitorStatistics] QMS
		RIGHT JOIN SQLQueryPlans AS SQP ON SQP.PlanID=QMS.PlanID
		LEFT JOIN SQLQueryPlansOverflow AS SQPO ON SQP.PlanID = SQPO.PlanID
	WHERE 
		QMS.QueryStatisticsID = @QueryStatisticsID
	-- End -SQLdm 9.0 (Ankit Srivastava) - Query Plan Grpahical View - Changed the selected column and the where condition
end
go
 
GO 

---------- P_GETQUERYSTATISTICS.SQL
if (object_id('p_GetQueryStatistics') is not null)
begin
drop procedure p_GetQueryStatistics
end
go
-- @Interval - Granularity of calculation:
--	0 - Minutes
--	1 - Hours
--	2 - Days
--	3 - Months
--	4 - Years
--  5 - All Time
create procedure [dbo].p_GetQueryStatistics
	@SQLServerID int,
	@StartDateTime datetime = null,
	@EndDateTime datetime = null,
	@UTCOffset int = 0,
	@Interval int,
	@QueryText nvarchar(4000),
	@ApplicationName nvarchar(4000),
	@StatementType int,
	@DatabaseName sysname,
	@SignatureMode bit = 0,
	@CaseInsensitive bit = 0
as 
begin

	if @UTCOffset is null
		set @UTCOffset = datediff(mi,getutcdate(),getdate())

	if @CaseInsensitive = 1
	begin
		set @ApplicationName = lower(@ApplicationName)
		set @DatabaseName = lower(@DatabaseName)
		set @QueryText = lower(@QueryText)
	end
	
	declare @LenCompare int
	set @LenCompare = len(@QueryText)
	if @LenCompare < 1000 
		set @LenCompare = 1000

	if (@SignatureMode = 1)
	begin

	select
		FirstStartTime = min(FirstStartTime),
		LastEndTime = max(LastEndTime),
		MinDuration = min(MinDuration),
		MaxDuration = max(MaxDuration),
		SumDuration = sum(SumDuration),
		AvgDuration = cast(sum(SumDuration) as float) / nullif(sum([Count]),0),
		MinCPU = min(MinCPU),
		MaxCPU = max(MaxCPU),
		SumCPU = sum(SumCPU),
		AvgCPU = cast(sum(SumCPU) as float) / nullif(sum([Count]),0),
		MinReads = min(MinReads),
		MaxReads = max(MaxReads),
		SumReads = sum(SumReads),
		AvgReads = cast(sum(SumReads) as float) / nullif(sum([Count]),0),
		MinWrites = min(MinWrites),
		MaxWrites = max(MaxWrites),
		SumWrites = sum(SumWrites),
		AvgWrites = cast(sum(SumWrites) as float) / nullif(sum([Count]),0),
		[Count] = sum([Count])
	from
	(
	select
		FirstStartTime = min(dateadd(mi,@UTCOffset,StatementUTCStartTime)),
		LastEndTime = max(dateadd(mi,@UTCOffset,CompletionTime)),
		MinDuration = min(DurationMilliseconds),
		MaxDuration = max(DurationMilliseconds),
		SumDuration = sum(DurationMilliseconds),
		MinCPU = min(CPUMilliseconds),
		MaxCPU = max(CPUMilliseconds),
		SumCPU = sum(CPUMilliseconds),
		MinReads = min(Reads),
		MaxReads = max(Reads),
		SumReads = sum(Reads),
		MinWrites = min(Writes),
		MaxWrites = max(Writes),
		SumWrites = sum(Writes),
		[Count] = count(*)
	from
		dbo.QueryMonitorStatistics qm (nolock)
		inner join dbo.SQLServerDatabaseNames d (nolock) on qm.DatabaseID = d.DatabaseID
		inner join ApplicationNames an on qm.ApplicationNameID = an.ApplicationNameID
		inner join AllSQLSignatures s on qm.SQLSignatureID = s.SQLSignatureID
	where
		qm.SQLServerID = @SQLServerID and
		rtrim(ltrim(case when @CaseInsensitive = 1 then lower(ApplicationName) else ApplicationName end)) like rtrim(ltrim(coalesce(@ApplicationName,case when @CaseInsensitive = 1 then lower(ApplicationName) else ApplicationName end))) and
		rtrim(ltrim(StatementType)) like coalesce(@StatementType,StatementType) and
		case when @CaseInsensitive = 1 then lower(d.DatabaseName) else d.DatabaseName end like coalesce(@DatabaseName,case when @CaseInsensitive = 1 then lower(d.DatabaseName) else d.DatabaseName end) and
		left(ltrim(case when @CaseInsensitive = 1 then lower(SQLSignature) else SQLSignature end),@LenCompare) = left(ltrim(@QueryText),@LenCompare) and
		isnull(@StartDateTime,'1 Jan 1900') <= StatementUTCStartTime and
		isnull(@EndDateTime,'1 Jan 2200') >= CompletionTime
	group by
		 case when isnull(@Interval,5) <= 4 then datepart(yy, dateadd(mi, @UTCOffset, dateadd(mi,@UTCOffset,CompletionTime))) else 1 end
		,case when isnull(@Interval,5) <= 3 then datepart(mm,dateadd(mi, @UTCOffset, dateadd(mi,@UTCOffset,CompletionTime))) else datepart(yy,dateadd(mi, @UTCOffset, dateadd(mi,@UTCOffset,CompletionTime))) end
		,case when isnull(@Interval,5) <= 2 then datepart(dd,dateadd(mi, @UTCOffset, dateadd(mi,@UTCOffset,CompletionTime))) else datepart(yy,dateadd(mi, @UTCOffset, dateadd(mi,@UTCOffset,CompletionTime))) end
		,case when isnull(@Interval,5) <= 1 then datepart(hh,dateadd(mi, @UTCOffset, dateadd(mi,@UTCOffset,CompletionTime))) else datepart(yy,dateadd(mi, @UTCOffset, dateadd(mi,@UTCOffset,CompletionTime))) end
		,case when isnull(@Interval,5) =  0 then datepart(mi,dateadd(mi, @UTCOffset, dateadd(mi,@UTCOffset,CompletionTime))) else datepart(yy,dateadd(mi, @UTCOffset, dateadd(mi,@UTCOffset,CompletionTime))) end
	union all
	select
		FirstStartTime = min(dateadd(mi,@UTCOffset,EventUTCStartTime)),
		LastEndTime = max(dateadd(mi,@UTCOffset,EventUTCStartTime)),
		MinDuration = min(TotalDurationMilliseconds),
		MaxDuration = max(TotalDurationMilliseconds),
		SumDuration = sum(TotalDurationMilliseconds),
		MinCPU = min(TotalCPUMilliseconds),
		MaxCPU = max(TotalCPUMilliseconds),
		SumCPU = sum(TotalCPUMilliseconds),
		MinReads = min(TotalReads),
		MaxReads = max(TotalReads),
		SumReads = sum(TotalReads),
		MinWrites = min(TotalWrites),
		MaxWrites = max(TotalWrites),
		SumWrites = sum(TotalWrites),
		[Count] = sum(QueryMonitorOccurrences)
	from
		dbo.QuerySignatureAggregation qm (nolock)
		inner join dbo.SQLServerDatabaseNames d (nolock) on qm.DatabaseID = d.DatabaseID
		inner join ApplicationNames an on qm.ApplicationNameID = an.ApplicationNameID
		inner join AllSQLSignatures s on qm.SQLSignatureID = s.SQLSignatureID
	where
		qm.SQLServerID = @SQLServerID and
		rtrim(ltrim(case when @CaseInsensitive = 1 then lower(ApplicationName) else ApplicationName end)) like rtrim(ltrim(coalesce(@ApplicationName,case when @CaseInsensitive = 1 then lower(ApplicationName) else ApplicationName end))) and
		rtrim(ltrim(StatementType)) like coalesce(@StatementType,StatementType) and
		case when @CaseInsensitive = 1 then lower(d.DatabaseName) else d.DatabaseName end like coalesce(@DatabaseName,case when @CaseInsensitive = 1 then lower(d.DatabaseName) else d.DatabaseName end) and
		left(ltrim(case when @CaseInsensitive = 1 then lower(SQLSignature) else SQLSignature end),@LenCompare) = left(ltrim(@QueryText),@LenCompare) and
		isnull(@StartDateTime,'1 Jan 1900') <= EventUTCStartTime and
		isnull(@EndDateTime,'1 Jan 2200') >= EventUTCStartTime
	group by
		 dateadd(mi,@UTCOffset,EventUTCStartTime)
	) as q
	group by
		 case when isnull(@Interval,5) <= 4 then datepart(yy, dateadd(mi, @UTCOffset, LastEndTime)) else 1 end
		,case when isnull(@Interval,5) <= 3 then datepart(mm,dateadd(mi, @UTCOffset, LastEndTime)) else datepart(yy,dateadd(mi, @UTCOffset, LastEndTime)) end
		,case when isnull(@Interval,5) <= 2 then datepart(dd,dateadd(mi, @UTCOffset, LastEndTime)) else datepart(yy,dateadd(mi, @UTCOffset, LastEndTime)) end
		,case when isnull(@Interval,5) <= 1 then datepart(hh,dateadd(mi, @UTCOffset, LastEndTime)) else datepart(yy,dateadd(mi, @UTCOffset, LastEndTime)) end
		,case when isnull(@Interval,5) =  0 then datepart(mi,dateadd(mi, @UTCOffset, LastEndTime)) else datepart(yy,dateadd(mi, @UTCOffset, LastEndTime)) end
end
else
begin

	select
		FirstStartTime = min(dateadd(mi,@UTCOffset,StatementUTCStartTime)),
		LastEndTime = max(dateadd(mi,@UTCOffset,CompletionTime)),
		MinDuration = min(DurationMilliseconds),
		MaxDuration = max(DurationMilliseconds),
		SumDuration = sum(DurationMilliseconds),
		AvgDuration = avg(cast(DurationMilliseconds as float)),
		MinCPU = min(CPUMilliseconds),
		MaxCPU = max(CPUMilliseconds),
		SumCPU = sum(CPUMilliseconds),
		AvgCPU = avg(cast(CPUMilliseconds as float)),
		MinReads = min(Reads),
		MaxReads = max(Reads),
		SumReads = sum(Reads),
		AvgReads = avg(cast(Reads as float)),
		MinWrites = min(Writes),
		MaxWrites = max(Writes),
		SumWrites = sum(Writes),
		AvgWrites = avg(cast(Writes as float)),
		[Count] = count(*)
	from
		dbo.QueryMonitorStatistics qm (nolock)
		inner join dbo.SQLServerDatabaseNames d (nolock) on qm.DatabaseID = d.DatabaseID
		inner join ApplicationNames an on qm.ApplicationNameID = an.ApplicationNameID
		inner join AllSQLStatements s on qm.SQLStatementID = s.SQLStatementID
	where
		qm.SQLServerID = @SQLServerID and
		rtrim(ltrim(case when @CaseInsensitive = 1 then lower(ApplicationName) else ApplicationName end)) like rtrim(ltrim(coalesce(@ApplicationName,case when @CaseInsensitive = 1 then lower(ApplicationName) else ApplicationName end))) and
		rtrim(ltrim(StatementType)) like coalesce(@StatementType,StatementType) and
		case when @CaseInsensitive = 1 then lower(d.DatabaseName) else d.DatabaseName end like coalesce(@DatabaseName,case when @CaseInsensitive = 1 then lower(d.DatabaseName) else d.DatabaseName end) and
		left(ltrim(case when @CaseInsensitive = 1 then lower(SQLStatement) else SQLStatement end),@LenCompare) = left(ltrim(@QueryText),@LenCompare) and
		isnull(@StartDateTime,'1 Jan 1900') <= StatementUTCStartTime and
		isnull(@EndDateTime,'1 Jan 2200') >= CompletionTime
	group by
		 case when isnull(@Interval,5) <= 4 then datepart(yy, dateadd(mi, @UTCOffset, CompletionTime)) else 1 end
		,case when isnull(@Interval,5) <= 3 then datepart(mm,dateadd(mi, @UTCOffset, CompletionTime)) else datepart(yy,dateadd(mi, @UTCOffset, CompletionTime)) end
		,case when isnull(@Interval,5) <= 2 then datepart(dd,dateadd(mi, @UTCOffset, CompletionTime)) else datepart(yy,dateadd(mi, @UTCOffset, CompletionTime)) end
		,case when isnull(@Interval,5) <= 1 then datepart(hh,dateadd(mi, @UTCOffset, CompletionTime)) else datepart(yy,dateadd(mi, @UTCOffset, CompletionTime)) end


end


end

GO

grant EXECUTE on p_GetQueryStatistics to [SQLdmConsoleUser]

GO


 
GO 

---------- P_GETQUERYWAITSTATISTICS.SQL

--Description : Added by Vineet Kumar in SQLDM 8.6 release For a new report Query Wait Statistics Report.

--This procedure fetches the Query Wait Statistics based on given filter criteria.

----Sample Execution


--DECLARE	@return_value int

--EXEC	@return_value = [dbo].[p_GetQueryWaitStatistics]
--		@SQLServerID = 9,
--		@DatabaseName = N'master',
--		@UTCStart = N'15-jul-2014',
--		@UTCEnd = N'16-jul-2014',
--		@UTCOffset = 0,
--		@WaitCategoryID = 9

--SELECT	'Return Value' = @return_value

--GO


if (object_id('p_GetQueryWaitStatistics') is not null)
begin
drop procedure p_GetQueryWaitStatistics
end
go
CREATE PROCEDURE [dbo].[p_GetQueryWaitStatistics]
	@SQLServerID int,
	@DatabaseName varchar(max),
	@UTCStart DateTime,
	@UTCEnd DateTime,
	@UTCOffset int = 0,
	@WaitCategoryID int = null
AS
begin

--Start : Getting SQL Servers as per user access
declare @SQLServers table(
		SQLServerID int,
		InstanceName nvarchar(256))

create table #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

insert into #SecureMonitoredSQLServers
exec [p_GetReportServers]
	
	insert into @SQLServers
		select smss.SQLServerID, smss.InstanceName
		from #SecureMonitoredSQLServers smss 
			inner join MonitoredSQLServers mss (nolock) on mss.SQLServerID = smss.SQLServerID
		where Active = 1 AND smss.SQLServerID = @SQLServerID
--END : Getting SQL Servers as per user access


IF(@WaitCategoryID =0)
BEGIN
	select ss.InstanceName,  an.ApplicationName, dbn.DatabaseName,
	wt.WaitType,aws.StatementUTCStartTime, aws.WaitDuration,ln.LoginName  from ActiveWaitStatistics aws
	INNER JOIN ApplicationNames an ON an.ApplicationNameID = aws.ApplicationNameID
	INNER JOIN WaitTypes wt ON wt.WaitTypeID = aws.WaitTypeID
	INNER JOIN WaitCategories wc ON wc.CategoryID = wt.CategoryID
	INNER JOIN SQLServerDatabaseNames dbn ON dbn.DatabaseID = aws.DatabaseID
	INNER JOIN LoginNames ln ON ln.LoginNameID = aws.LoginNameID
	INNER JOIN @SQLServers ss ON ss.SQLServerID = aws.SQLServerID
	WHERE aws.[UTCCollectionDateTime] between @UTCStart and @UTCEnd 
	AND aws.SQLServerID = @SQLServerID AND dbn.DatabaseName = @DatabaseName
END
ELSE
BEGIN
	select ss.InstanceName,  an.ApplicationName, dbn.DatabaseName,
	wt.WaitType,aws.StatementUTCStartTime, aws.WaitDuration,ln.LoginName  from ActiveWaitStatistics aws
	INNER JOIN ApplicationNames an ON an.ApplicationNameID = aws.ApplicationNameID
	INNER JOIN WaitTypes wt ON wt.WaitTypeID = aws.WaitTypeID
	INNER JOIN WaitCategories wc ON wc.CategoryID = wt.CategoryID
	INNER JOIN SQLServerDatabaseNames dbn ON dbn.DatabaseID = aws.DatabaseID
	INNER JOIN LoginNames ln ON ln.LoginNameID = aws.LoginNameID
	INNER JOIN @SQLServers ss ON ss.SQLServerID = aws.SQLServerID
	WHERE aws.[UTCCollectionDateTime] between @UTCStart and @UTCEnd 
	AND aws.SQLServerID = @SQLServerID AND dbn.DatabaseName = @DatabaseName
	AND wc.CategoryID = @WaitCategoryID
END
end
 
GO 

---------- P_GETRECOMMENDATIONHISTORY.SQL
if (object_id('p_GetRecommendationHistory') is not null)
begin
drop procedure [p_GetRecommendationHistory]
end
go

-- SQLdm 10.0 Srishti Purohit Doctor implementation in DM
create procedure [p_GetRecommendationHistory] 

    @SQLServerID int,
	@UTCSnapshotCollectionDateTime datetime = null
	--@HistoryInMinutes int = null
AS
BEGIN
	
set transaction isolation level read uncommitted
declare @err int
--declare @BeginDateTime datetime
declare @AnalysisCompletionDateTime datetime


--For excepttion handling
DECLARE
  @ErrorMessage   varchar(2000)
 ,@ErrorSeverity  tinyint
 ,@ErrorState     tinyint

if (@UTCSnapshotCollectionDateTime is null)
	select @AnalysisCompletionDateTime = (select max([UTCAnalysisCompleteTime]) from PrescriptiveAnalysis where [SQLServerID] = @SQLServerID)
else
	select @AnalysisCompletionDateTime = @UTCSnapshotCollectionDateTime
	PRINT @AnalysisCompletionDateTime
--if (@HistoryInMinutes is null)
--	select @BeginDateTime = @AnalysisCompletionDateTime
--else
--	select @BeginDateTime = dateadd(n, -@HistoryInMinutes, @AnalysisCompletionDateTime)

		-- get properties of recomms
		
		
		SELECT PARP.AnalysisRecommendationID, PropertyName, Value FROM PrescriptiveAnalysisRecommendationProperty PARP
		JOIN PrescriptiveRecommendationProperty PRP ON PARP.PropertyID = PRP.ID
		JOIN PrescriptiveAnalysisRecommendation PAR ON PARP.AnalysisRecommendationID = PAR.ID
		JOIN PrescriptiveAnalysisDetails PAD ON PAD.PrescriptiveAnalysisDetailsID = PAR.PrescriptiveAnalysisDetailsID
		JOIN PrescriptiveAnalysis PA ON PA.AnalysisID = PAD.AnalysisID
		WHERE PA.SQLServerID = @SQLServerID AND PA.[UTCAnalysisCompleteTime] --between @BeginDateTime and @AnalysisCompletionDateTime
		=  @AnalysisCompletionDateTime

		-- check if records for recommendation
	
		SELECT PAR.[RecommendationID]
   --   ,PR.[AdditionalConsiderations]
   --   ,PR.[bitly]
	  --,PRC.Name AS Category
   --   ,PR.[ConfidenceFactor]
   --   ,PAR.[Description]
   --   ,PAR.[Finding]
   --   ,PR.[ImpactExplanation]
   --   ,PR.[ImpactFactor]
   --   ,PR.[InfoLinks]
   --   ,PR.[PluralFormFinding]
   --   ,PR.[PluralFormImpactExplanation]
   --   ,PR.[PluralFormRecommendation]
   --   ,PAR.[ProblemExplanation]
   --   ,PAR.[Recommendation]
   --   ,PAR.[Relevance]
   --   ,PR.[Tags]
	  ,PAR.ComputedRankFactor
	  ,PAD.RecordCreatedTimestamp
	  ,PAD.AnalyzerID
	  ,PAR.ID AS AnalysisRecommendationID
	  ,PAD.Status
	  ,PA.RecommendationCount
	  ,PAR.IsFlagged
	  ,PAR.OptimizationStatusID
	  ,PAR.OptimizationErrorMessage
		FROM PrescriptiveRecommendation PR
		JOIN PrescriptiveAnalysisRecommendation PAR ON PAR.RecommendationID = PR.RecommendationID
		JOIN PrescriptiveAnalysisDetails PAD ON PAD.PrescriptiveAnalysisDetailsID = PAR.PrescriptiveAnalysisDetailsID
		JOIN PrescriptiveAnalysis PA ON PA.AnalysisID = PAD.AnalysisID
		JOIN PrescriptiveRecommendationCategory PRC ON PRC.CategoryID = PR.[CategoryID]
		WHERE PA.SQLServerID = @SQLServerID	AND PA.[UTCAnalysisCompleteTime] --between @BeginDateTime and @AnalysisCompletionDateTime
		= @AnalysisCompletionDateTime
		--Check for only active master recommendations
		AND PR.IsActive = 1
		ORDER BY PAR.ComputedRankFactor DESC

IF(@@ERROR <>0)
BEGIN
	
	 Print 'Error'
	 	SET @ErrorMessage  = ERROR_MESSAGE()
			SET @ErrorSeverity = ERROR_SEVERITY()
			SET @ErrorState    = ERROR_STATE()
			RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState)

END

END
 
GO 
 
GO 

---------- P_GETRECOMMENDATIONS.SQL
if (object_id('p_GetRecommendations') is not null)
begin
drop procedure [p_GetRecommendations]
end
go

-- SQLdm 10.0 Srishti Purohit Doctor implementation in DM
create procedure [p_GetRecommendations] 

@sqlServerId int,
@analysisCompletionTime datetime
AS
BEGIN
	
--For excepttion handling
DECLARE
  @ErrorMessage   varchar(2000)
 ,@ErrorSeverity  tinyint
 ,@ErrorState     tinyint
		-- check if records for recommendation

if @analysisCompletionTime IS NULL
BEGIN
SELECT NULL
END
		ELSE
		BEGIN

		
		SELECT PARP.AnalysisRecommendationID, PropertyName, Value FROM PrescriptiveAnalysisRecommendationProperty PARP
		JOIN PrescriptiveRecommendationProperty PRP ON PARP.PropertyID = PRP.ID
		JOIN PrescriptiveAnalysisRecommendation PAR ON PARP.AnalysisRecommendationID = PAR.ID
		JOIN PrescriptiveAnalysisDetails PAD ON PAD.PrescriptiveAnalysisDetailsID = PAR.PrescriptiveAnalysisDetailsID
		JOIN PrescriptiveAnalysis PA ON PA.AnalysisID = PAD.AnalysisID
		WHERE PA.SQLServerID = @sqlServerId AND PA.[UTCAnalysisCompleteTime] = @analysisCompletionTime

		SELECT PAR.[RecommendationID]
      --,PR.[AdditionalConsiderations]
   --   ,PR.[bitly]
	  --,PRC.Name
   --   ,PR.[ConfidenceFactor]
   --   ,PAR.[Description]
   --   ,PAR.[Finding]
   --   ,PR.[ImpactExplanation]
   --   ,PR.[ImpactFactor]
   --   ,PR.[InfoLinks]
   --   ,PR.[PluralFormFinding]
   --   ,PR.[PluralFormImpactExplanation]
   --   ,PR.[PluralFormRecommendation]
   --   ,PAR.[ProblemExplanation]
   --   ,PAR.[Recommendation]
   --   ,PAR.[Relevance]
   --   ,PR.[Tags]
	  ,PAR.ComputedRankFactor
	  ,PAD.RecordCreatedTimestamp
	  ,PAD.AnalyzerID
	  ,PAR.ID AS AnalysisRecommendationID
	  ,PAD.Status
	  ,PA.RecommendationCount
	  ,PAR.IsFlagged
	  ,PAR.OptimizationStatusID
	  ,PAR.OptimizationErrorMessage
		FROM PrescriptiveRecommendation PR
		JOIN PrescriptiveAnalysisRecommendation PAR ON PAR.RecommendationID = PR.RecommendationID
		JOIN PrescriptiveAnalysisDetails PAD ON PAD.PrescriptiveAnalysisDetailsID = PAR.PrescriptiveAnalysisDetailsID
		JOIN PrescriptiveAnalysis PA ON PA.AnalysisID = PAD.AnalysisID
		JOIN PrescriptiveRecommendationCategory PRC ON PRC.CategoryID = PR.[CategoryID]
		WHERE PA.SQLServerID = @sqlServerId	AND PA.[UTCAnalysisCompleteTime] = @analysisCompletionTime
		--Check for only active master recommendations
		AND PR.IsActive = 1
	END

IF(@@ERROR <>0)
BEGIN
	 Print 'Error while getting recommendations.'
	  -- Any Error Occurred during Transaction. Rollback
	  SET @ErrorMessage  = ERROR_MESSAGE()
			SET @ErrorSeverity = ERROR_SEVERITY()
			SET @ErrorState    = ERROR_STATE()
			RAISERROR('Unable to save analysis in PrescriptiveAnalysis.', @ErrorSeverity, @ErrorState)

END
END
 
GO 
 
GO 

---------- P_GETREPLICATIONCHARTMETRICS.SQL
if (object_id('p_GetReplicationChartMetrics') is not null)
begin
drop procedure p_GetReplicationChartMetrics
end
go

create procedure [dbo].[p_GetReplicationChartMetrics]
	@SQLServerID int,
	@UTCSnapshotCollectionDateTime datetime = null,
	@HistoryInMinutes int = null
as
begin
set transaction isolation level read uncommitted
declare @err int
declare @BeginDateTime datetime
declare @EndDateTime datetime

if (@UTCSnapshotCollectionDateTime is null)
	select @EndDateTime = (select max(UTCCollectionDateTime) 
	from [ServerStatistics] (nolock) 
	where [SQLServerID] = @SQLServerID)
else
	select @EndDateTime = @UTCSnapshotCollectionDateTime

if (@HistoryInMinutes is null)
	select @BeginDateTime = @EndDateTime
else
	select @BeginDateTime = dateadd(n, -@HistoryInMinutes, @EndDateTime)


select [UTCCollectionDateTime],
ReplicationLatencyInSeconds, 
DistributionLatencyInSeconds,
ReplicationSubscribed,
ReplicationUnsubscribed,
ReplicationUndistributed
from
	[ServerStatistics] (nolock)
	left join [MonitoredSQLServers] (nolock)
	on [ServerStatistics].[SQLServerID] = [MonitoredSQLServers].[SQLServerID]
where
	[ServerStatistics].[SQLServerID] = @SQLServerID
	and [ServerStatistics].[UTCCollectionDateTime] between @BeginDateTime and @EndDateTime
order by 
	[ServerStatistics].[UTCCollectionDateTime]
end	

GO


 
GO 

---------- P_GETREPLICATIONPARTICIPANTSFORSERVER.SQL
if (object_id('p_GetReplicationParticipantsForServer') is not null)
begin
drop procedure p_GetReplicationParticipantsForServer
end
go

CREATE procedure [dbo].[p_GetReplicationParticipantsForServer]
	@serverID int = null
as

begin
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
	select 
	rt.ArticleCount,
	isnull(rt.PublisherInstance, '') as PublisherInstance,
    isnull(rt.PublisherDB, '') as PublisherDB, 
    isnull(rt.DistributorInstance,'') as DistributorInstance, 
    isnull(rt.DistributorDB,'') as DistributorDB, 
	isnull(rt.SubscriberInstance,'') as SubscriberInstance,
	isnull(rt.SubscriberDB,'') as subscriberDB,
	rt.LastDistributorSnapshotDateTime, rt.SubscribedTransactions, rt.NonSubscribedTransactions, rt.NonDistributedTransactions, 
	rt.ReplicationLatency, rt.MaxSubscriptionLatency, rt.ReplicationType, rt.SubscriptionType, rt.LastSubscriberUpdate,
	rt.LastSyncStatus, rt.LastSyncSummary, rt.LastSyncTime, rt.SubscriptionStatus, 
	isnull(rt.Publication,'') as Publication, rt.PublicationDescription,
	pubdn.SQLServerID, distdn.SQLServerID,subdn.SQLServerID
	from ReplicationTopology rt 
	left join SQLServerDatabaseNames pubdn (nolock) on rt.PublisherDBID = pubdn.DatabaseID
	--left join MonitoredSQLServers ms1 on pubdn.SQLServerID = ms1.SQLServerID
	left join SQLServerDatabaseNames distdn (nolock) on rt.DistributorDBID = distdn.DatabaseID
	--left join MonitoredSQLServers ms2 on distdn.SQLServerID = ms2.SQLServerID
	left join SQLServerDatabaseNames subdn (nolock) on rt.SubscriberDBID = subdn.DatabaseID
	--left join MonitoredSQLServers ms3 on subdn.SQLServerID = ms3.SQLServerID
	where @serverID in (pubdn.SQLServerID, distdn.SQLServerID,subdn.SQLServerID) or @serverID is null
end
 
 
GO 

---------- P_GETREPLICATIONSUMMARY.SQL
if (object_id('[p_GetReplicationSummary]') is not null)
begin
drop procedure [p_GetReplicationSummary]
end
go
CREATE PROCEDURE [dbo].[p_GetReplicationSummary]
		@ServerID int,
		@UTCStart DateTime,
		@UTCEnd DateTime,
		@UTCOffset int,
		@Interval tinyint
AS
BEGIN

-- @Interval - Granularity of calculation:
--	0 - Minutes
--	1 - Hours
--	2 - Days
--	3 - Months
--	4 - Years

select m.InstanceName
		,dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime]))) as [LastCollectioninInterval],
		max(s1.[ReplicationLatencyInSeconds]) as ReplicationLatencyInSeconds,
		sum(s1.[ReplicationSubscribed] * TimeDeltaInSeconds) / nullif(sum(case when s1.[ReplicationSubscribed] is not null then TimeDeltaInSeconds else 0 end),0) as [ReplicationSubscribed],
		sum(s1.[ReplicationUndistributed] * TimeDeltaInSeconds) / nullif(sum(case when s1.[ReplicationUndistributed] is not null then TimeDeltaInSeconds else 0 end),0) as [ReplicationUndistributed],
		sum(s1.[ReplicationUnsubscribed] * TimeDeltaInSeconds) / nullif(sum(case when s1.[ReplicationUnsubscribed] is not null then TimeDeltaInSeconds else 0 end),0) as [ReplicationUnsubscribed],
		[ReplicationLatencyInSecondsBaseline] = (select TOP 1 Mean	--[ReplicationLatencyInSeconds] MetricID = 17
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = 17 AND dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc),
		[ReplicationSubscribedBaseline] = (select TOP 1 Mean	--[ReplicationSubscribed] MetricID = -1005
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -1005 AND dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc) * 60,
		[ReplicationUndistributedBaseline] = (select TOP 1 Mean	--[ReplicationUndistributed] MetricID = 4
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = 4 AND dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc),		
		[ReplicationUnsubscribedBaseline] = (select TOP 1 Mean --[ReplicationUnsubscribed] = 5
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = 5 AND dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc)
	from
		[MonitoredSQLServers] m (nolock)
		left join [ServerStatistics] s1 (nolock)
		on m.[SQLServerID] = s1.[SQLServerID]
	where
		s1.[SQLServerID] = @ServerID
		and dbo.fn_RoundDateTime(@Interval, s1.[UTCCollectionDateTime]) between @UTCStart and @UTCEnd
group by
		[InstanceName]
		-- Always group by year at the least
		,datepart(yy, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime]))
		-- Group by all intervals greater than or equal to the selected interval
		,case when @Interval <= 3 then datepart(mm,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
		,case when @Interval <= 2 then datepart(dd,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
		,case when @Interval <= 1 then datepart(hh,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
		,case when @Interval =  0 then datepart(mi,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
END
 
GO 

---------- P_GETREPORTPERIODINTERVALS.SQL
if (object_id('p_GetReportPeriodIntervals') is not null)
begin
drop procedure [p_GetReportPeriodIntervals]
end
go

CREATE PROCEDURE p_GetReportPeriodIntervals
	-- If you want a report to have an abscure period\interval then put
	-- the configuration in the reportperiodIntervals table
    -- and call this proc with that reports enum report number as the second parameter
	@period int,
	@reportNumber int = -1 -- -1 is for all defaults
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	select ri.Value, ri.Label from ReportPeriodIntervals pi (nolock)
	inner join ReportIntervals ri (nolock) on ri.Value = pi.IntervalValue
	inner join ReportPeriods rp (nolock) on rp.Value = pi.PeriodValue
	where pi.PeriodValue = @period 
	and pi.ReportNumber = coalesce(@reportNumber, pi.ReportNumber)
END
GO
 
GO 

---------- P_GETREPORTSERVERS.SQL
IF (object_id('p_GetReportServers') is not null)
BEGIN
drop procedure p_GetReportServers
END
GO

CREATE PROCEDURE [dbo].[p_GetReportServers]
	@VMOnly bit = 0,
	@MinimumServerVersion int = 8
AS
BEGIN

declare @IsSQLLogin bit, @SQLLoginName nvarchar(128),@WindowsSID varbinary(85)
select @IsSQLLogin = case when isnull(type,'N') = 'S' then 1 else 0 end from sys.server_principals where principal_id = suser_id()
select @SQLLoginName = suser_sname(), @WindowsSID = suser_sid()

exec p_GetUserTokenInternal @IsSQLLogin, @SQLLoginName, @WindowsSID, 1, @VMOnly, @MinimumServerVersion

END

GO

grant EXECUTE on [p_GetReportServers] to [SQLdmConsoleUser]
 
GO 

---------- P_GETRULENAMEAVAILABLE.SQL

/****** Object:  StoredProcedure [dbo].[p_GetRuleNameAvailable]    Script Date: 13-08-2015 18:41:55 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO
if (object_id('p_GetRuleNameAvailable') is not null)
begin
drop procedure [p_GetRuleNameAvailable]
end
go

--EXEC p_GetRuleNameAvailable 'SQL diagnostic manager Service Status testing',0
CREATE PROCEDURE [dbo].[p_GetRuleNameAvailable](
	@RuleName nvarchar(255) =NULL,
	@Available bit output
)
AS
begin
	declare @err int
	declare @Usages int
	declare @NRuleName varchar(255)
	
	select @NRuleName=Convert(xml,SerializedObject).value('(/NotificationRule/@Description)[1]', 'varchar(500)') 
	from NotificationRules
	where LOWER(RTRIM(LTRIM(Convert(xml,SerializedObject).value('(/NotificationRule/@Description)[1]', 'varchar(500)'))))= LOWER(RTRIM(LTRIM(@RuleName)))

	
	if (@NRuleName is NOT NULL)
		SET @Available= 0
	else 
		SET @Available= 1
						
	select @err = @@error
	return @err
END	















GO

 
GO 

---------- P_GETRUNQUERYSCRIPTS.SQL
if (object_id('p_GetRunQueryScripts') is not null)
begin
drop procedure [p_GetRunQueryScripts]
end
go

create procedure [p_GetRunQueryScripts]
as
begin
	SELECT
		ScriptID,
		Type,
		Name,
		ScriptText
	FROM RunQueryScripts
end
 
GO 

---------- P_GETSELECTEDCUSTOMREPORTCOUNTERS.SQL
if (object_id('[p_GetSelectedCustomReportCounters]') is not null)
begin
drop procedure [p_GetSelectedCustomReportCounters]
end
go

create proc p_GetSelectedCustomReportCounters(@reportName nvarchar(255) = null)
as
begin
--declare @ID int
--select @ID = ID from CustomReports where reportName = @reportName
--
--select @ID as ID, GraphNumber, CounterShortDescription, CounterName, Aggregation
-- from CustomReportsCounters
--where ID = @ID

select crc.ID, crc.GraphNumber, crc.CounterShortDescription, crc.CounterName, crc.Aggregation, cr.reportName, cml.CounterType, cr.reportShortDescription 
from CustomReports cr inner join CustomReportsCounters crc on cr.ID = crc.ID
inner join CounterMasterList cml on crc.CounterName = cml.CounterName
where cr.reportName = coalesce(@reportName,cr.reportName)
union
select crc.ID, crc.GraphNumber, crc.CounterShortDescription, replace(mi.Name, ' ', '_') as CounterName, crc.Aggregation, cr.reportName, 2, cr.reportShortDescription 
from CustomReports cr inner join CustomReportsCounters crc on cr.ID = crc.ID
inner join MetricInfo mi on replace(mi.Name, ' ', '_') = crc.CounterName
where cr.reportName = coalesce(@reportName,cr.reportName)
and mi.Metric >= 1000
order by crc.GraphNumber asc

end
 
GO 

---------- P_GETSERVERACTIVITY.SQL
if (object_id('p_GetServerActivity') is not null)
begin
drop procedure p_GetServerActivity
end
go
create procedure p_GetServerActivity
	@SQLServerID int,
	@StartDateTime datetime = null,
	@EndDateTime datetime = null,
	@ColumnBitMask int = 7, -- SQLServerID + UTCCollectionDateTime + StateOverview 
	@RefreshType int = 0
as
begin

-- column bit mask
-- 1   = SQLServerID (always returned)
-- 2   = UTCCollectionDateTime (always returned)
-- 4   = StateOverview
-- 8   = SystemProcesses
-- 16  = SessionList
-- 32  = LockStatistics
-- 64  = LockList
-- 128 = ResponseTime

declare @err int
declare @start datetime
declare @end datetime

select @start = @StartDateTime
if (@start is null)
	select @start = min([UTCCollectionDateTime]) from ServerActivity (NOLOCK) where [SQLServerID] = @SQLServerID

select @end = @EndDateTime
if (@end is null)
	select @end = max([UTCCollectionDateTime]) from ServerActivity (NOLOCK)  where [SQLServerID] = @SQLServerID

-- if no timestamp is supplied then return list of available snapshots
if (@ColumnBitMask & 128 = 0)
begin
	SELECT 
		[SQLServerID],
		[UTCCollectionDateTime],
		case when @ColumnBitMask & 4 <> 0 then [StateOverview] else null end,
		case when @ColumnBitMask & 8 <> 0 then [SystemProcesses] else null end,
		case when @ColumnBitMask & 16 <> 0 then [SessionList] else null end,
		case when @ColumnBitMask & 32 <> 0 then [LockStatistics] else null end,
		case when @ColumnBitMask & 64 <> 0 then [LockList] else null end,
		null
	FROM [ServerActivity] (NOLOCK)
	WHERE [SQLServerID] = @SQLServerID and 
		isnull([RefreshType],0) = @RefreshType and
		[UTCCollectionDateTime] >= @start and
		[UTCCollectionDateTime] <= @end
	ORDER BY [UTCCollectionDateTime]
end
else
begin
	SELECT 
		[ServerActivity].[SQLServerID],
		[ServerActivity].[UTCCollectionDateTime],
		case when @ColumnBitMask & 4 <> 0 then [ServerActivity].[StateOverview] else null end,
		case when @ColumnBitMask & 8 <> 0 then [ServerActivity].[SystemProcesses] else null end,
		case when @ColumnBitMask & 16 <> 0 then [ServerActivity].[SessionList] else null end,
		case when @ColumnBitMask & 32 <> 0 then [ServerActivity].[LockStatistics] else null end,
		case when @ColumnBitMask & 64 <> 0 then [ServerActivity].[LockList] else null end,
		[ServerStatistics].[ResponseTimeInMilliseconds]
	FROM [ServerActivity] (NOLOCK)
	LEFT JOIN [ServerStatistics] (NOLOCK) ON 
		[ServerStatistics].[SQLServerID] = [ServerActivity].[SQLServerID] and
		[ServerStatistics].[UTCCollectionDateTime] = [ServerActivity].[UTCCollectionDateTime]
	WHERE [ServerActivity].[SQLServerID] = @SQLServerID and 
		isnull([RefreshType],0) = @RefreshType and
		[ServerActivity].[UTCCollectionDateTime] >= @start and
		[ServerActivity].[UTCCollectionDateTime] <= @end
	ORDER BY [ServerActivity].[UTCCollectionDateTime]
end

SELECT @err = @@error
	
RETURN @err

end
 
GO 

---------- P_GETSERVERDASHBOARDLAYOUT.SQL
if (object_id('p_GetServerDashboardLayout') is not null)
begin
drop procedure [p_GetServerDashboardLayout]
end
go

create procedure [p_GetServerDashboardLayout] 
	@LoginName nvarchar(256),
	@SQLServerID int
as
begin
	declare @ID int
	
	select @ID = 0

	-- get the default dashboard for the server for this user
	select @ID = l.DashboardLayoutID
		from [DashboardLayouts] l
			inner join [DashboardDefaults] d on l.DashboardLayoutID = d.DashboardLayoutID
		where d.LoginName = @LoginName
			and d.SQLServerID = @SQLServerID
	
	-- otherwise get the users default
	if (@ID = 0)
		select @ID = l.DashboardLayoutID
			from [DashboardLayouts] l
				inner join [DashboardDefaults] d on l.DashboardLayoutID = d.DashboardLayoutID
			where d.LoginName = @LoginName
				and d.SQLServerID is null

	-- otherwise get the system default
	if (@ID = 0)
	begin
		declare @version nvarchar(30)
		select @version = ServerVersion from MonitoredSQLServers where SQLServerID = @SQLServerID
		select @ID = case when @version is not null and left(@version, 1) = '8' then 2 else 1 end
	end

	-- return the configuration
	select DashboardLayoutID, LoginName, Name, Configuration
		from [DashboardLayouts]
		where DashboardLayoutID = @ID

end	
 
GO 

---------- P_GETSERVERINVENTORY.SQL
if (object_id('p_GetServerInventory') is not null)
begin
drop procedure [p_GetServerInventory]
end
go
CREATE procedure [dbo].[p_GetServerInventory]
				@ServerName nvarchar(256) = null,
				@ServerVersion nvarchar(30) = null,
				@OSVersion nvarchar(256) = null,
				@NumberOfProcessors int = null,
				@PhysicalMemory bigint = null,
				@Clustered bit = null,
				@Owner nvarchar(256) = null,
				@TagId int = null,
				@SQLServerIDs nvarchar(max) = null
as
begin
	declare @xmlDoc int

	declare @SQLServers table(SQLServerID int, InstanceName nvarchar(256), UTCCollectionDateTime datetime NULL) 

	if @NumberOfProcessors < 1
	 set @NumberOfProcessors = null

	if @PhysicalMemory < 1
	 set @PhysicalMemory = null

	if len(@ServerName) < 1
	 set @ServerName = null

	if len(@ServerVersion) < 1
	 set @ServerVersion = null

	if len(@OSVersion) < 1
	 set @OSVersion = null

	if len(@Owner) < 1
	 set @Owner = null

	if @TagId < 1
		set @TagId = null
		
		
	create table #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

	insert into #SecureMonitoredSQLServers
	exec [p_GetReportServers]		

	if @SQLServerIDs is not null 
	Begin
		-- Prepare XML document if there is one
		exec sp_xml_preparedocument @xmlDoc output, @SQLServerIDs

		insert into @SQLServers
		select ID, [InstanceName], (select max(ss.[UTCCollectionDateTime]) from ServerStatistics ss (nolock) where ss.SQLServerID = ms.SQLServerID)
		from openxml(@xmlDoc, '//Srvr', 1) with (ID int)
			join #SecureMonitoredSQLServers ms (nolock) on ID = SQLServerID
		where lower(ms.InstanceName) like lower(coalesce(@ServerName, ms.InstanceName)) and
			  (@TagId is null or SQLServerID in (select SQLServerId from ServerTags (nolock) where TagId = @TagId))

		exec sp_xml_removedocument @xmlDoc
	end
	else 
	begin
		insert into @SQLServers
		select ms.SQLServerID, ms.InstanceName, (select max(ss.[UTCCollectionDateTime]) from ServerStatistics ss (nolock) where ss.SQLServerID = ms.SQLServerID)
		from #SecureMonitoredSQLServers ms (nolock)
		where lower(ms.InstanceName) collate database_default like lower(coalesce(@ServerName, ms.InstanceName)) collate database_default and
			  (@TagId is null or ms.SQLServerID in (select SQLServerId from ServerTags (nolock) where TagId = @TagId))
	end

	select	ms.InstanceName 
			,max(ss.SQLServerID) as SQLServerID
			,max(ss.ServerVersion) as ServerVersion
			,max(WindowsVersion) as OSVersion
			,max(ProcessorCount) as ProcessorCount
			,IsClustered
			--,Owner
			--,ServerTag
			,max(PhysicalMemoryInKilobytes) as PhysicalMemoryKB
	from @SQLServers ms 
		 left join ServerStatistics ss (nolock) on  ss.SQLServerID = ms.SQLServerID 
												and ss.UTCCollectionDateTime = ms.UTCCollectionDateTime
	where 
		lower(WindowsVersion) like lower(coalesce(@OSVersion, WindowsVersion))
		and [dbo].[fn_ServerVersionnVarcharToBigInt](ss.ServerVersion) <= coalesce([dbo].[fn_ServerVersionnVarcharToBigInt](@ServerVersion), [dbo].[fn_ServerVersionnVarcharToBigInt](ss.ServerVersion))
		and ProcessorCount <= coalesce(@NumberOfProcessors, ProcessorCount)
		and IsClustered = coalesce(@Clustered, IsClustered)
		and PhysicalMemoryInKilobytes <= coalesce(@PhysicalMemory, PhysicalMemoryInKilobytes)
	group by InstanceName, IsClustered
end
 
GO 

---------- P_GETSERVEROVERVIEW.SQL
if (object_id('[p_GetServerOverview]') is not null)
begin
drop procedure p_GetServerOverview 
end
go
create procedure [dbo].p_GetServerOverview
	@SQLServerID int,
	@SampleTime datetime = null
as
begin

	select top 1
		s.[UTCCollectionDateTime] as [UTCCollectionDateTime]
		,[InstanceName]
		,[BlockedProcesses]
		,[BufferCacheHitRatioPercentage]
		,[BufferCacheSizeInKilobytes]
		,[ClientComputers]
		,[CPUActivityPercentage]
		,[DatabaseCount]
		,[DataFileCount]
		,[DataFileSpaceAllocatedInKilobytes]
		,[DataFileSpaceUsedInKilobytes]
		,[DiskQueueLength]
		,[LogFileCount]
		,[LogFileSpaceAllocatedInKilobytes]
		,[LogFileSpaceUsedInKilobytes]
		,[LogFlushes]
		,[LogFlushes] / nullif(TimeDeltaInSeconds,0) as [LogFlushesPerSecond]
		,[PacketErrors] 
		,[PacketErrors] / nullif(TimeDeltaInSeconds,0) as [PacketErrorsPerSecond]
		,[PacketsReceived] 
		,[PacketsReceived] / nullif(TimeDeltaInSeconds,0) as [PacketsReceivedPerSecond]
		,[PacketsSent]
		,[PacketsSent] / nullif(TimeDeltaInSeconds,0) as [PacketsSentPerSecond]
		,[PagesPerSecond]
		,[PageReads]
		,[PageReads] / nullif(TimeDeltaInSeconds,0) as [PageReadsPerSecond]
		,[PageWrites]
		,[PageWrites] / nullif(TimeDeltaInSeconds,0) as [PageWritesPerSecond]
		,[ProcedureCacheHitRatioPercentage]
		,[ProcedureCacheSizeInKilobytes]
		,[ProcessorQueueLength]
		,[ResponseTimeInMilliseconds]
		,[SqlCompilations]
		,[SqlCompilations] / nullif(TimeDeltaInSeconds,0) as [SqlCompilationsPerSecond]
		,[SqlRecompilations]
		,[SqlRecompilations] / nullif(TimeDeltaInSeconds,0) as [SqlRecompilationsPerSecond]
		,[SqlMemoryAllocatedInKilobytes]
		,[SqlMemoryUsedInKilobytes]
		,[SystemProcesses]
		,[SystemProcessesConsumingCPU]
		,s.[ServerVersion]
		,[Transactions]
		,[Transactions] / nullif(TimeDeltaInSeconds,0) as [TransactionsPerSecond]
		,[UserProcesses]
		,[UserProcessesConsumingCPU]
		,[Batches]
		,[Batches] / nullif(TimeDeltaInSeconds,0) as [BatchesPerSecond]
	from
		ServerStatistics s
		left join [MonitoredSQLServers] m
		on m.[SQLServerID] = s.[SQLServerID]
		left join [OSStatistics] o
		on o.[SQLServerID] = s.[SQLServerID]  and o.[UTCCollectionDateTime] = s.[UTCCollectionDateTime]
	where 
		s.[SQLServerID] = @SQLServerID
		and s.[UTCCollectionDateTime] = coalesce(@SampleTime,s.[UTCCollectionDateTime])
	order by
		s.[UTCCollectionDateTime] desc

end
 
GO 

---------- P_GETSERVEROVERVIEWHISTORY.SQL
if (object_id('p_GetServerOverviewHistory') is not null)
begin
drop procedure p_GetServerOverviewHistory
end
go

CREATE PROCEDURE [dbo].p_GetServerOverviewHistory(
	@SQLServerID int,
	@UTCSnapshotCollectionDateTime datetime = null,
	@HistoryInMinutes int = null
)
AS
begin
declare @BeginDateTime datetime
declare @EndDateTime datetime

if (@UTCSnapshotCollectionDateTime is null)
	select @EndDateTime = (select max([UTCCollectionDateTime]) from [ServerStatistics] (NOLOCK) where [SQLServerID] = @SQLServerID)
else
	select @EndDateTime = @UTCSnapshotCollectionDateTime

if (@HistoryInMinutes is null)
	select @BeginDateTime = @EndDateTime
else
	select @BeginDateTime = dateadd(n, -@HistoryInMinutes, @EndDateTime)
	
	select

		s.[UTCCollectionDateTime] as [UTCCollectionDateTime]

		,s.[SQLServerID] as [SQLServerID]

		,[InstanceName]

		,[BlockedProcesses]

		,[BufferCacheHitRatioPercentage]

		,[BufferCacheSizeInKilobytes]

		,[ClientComputers]

		,[CPUActivityPercentage]

		,[IdleTimePercentage]

		,[DatabaseCount]

		,[DataFileCount]

		,[DataFileSpaceAllocatedInKilobytes]

		,[DataFileSpaceUsedInKilobytes]
		
		,[DiskQueueLength]

		,[LogFileCount]

		,[LogFileSpaceAllocatedInKilobytes]

		,[LogFileSpaceUsedInKilobytes]

		,[LogFlushes]

		,[LogFlushes] / nullif(TimeDeltaInSeconds,0) as [LogFlushesPerSecond]

		,[PacketErrors] 

		,[PacketErrors] / nullif(TimeDeltaInSeconds,0) as [PacketErrorsPerSecond]

		,[PacketsReceived] 

		,[PacketsReceived] / nullif(TimeDeltaInSeconds,0) as [PacketsReceivedPerSecond]

		,[PacketsSent]

		,[PacketsSent] / nullif(TimeDeltaInSeconds,0) as [PacketsSentPerSecond]

		,[PagesPerSecond]
		
		,[PageReads]
				
		,[PageReads] / nullif(TimeDeltaInSeconds,0) as [PageReadsPerSecond]
		
		,[PageWrites]
		
		,[PageWrites] / nullif(TimeDeltaInSeconds,0) as [PageWritesPerSecond]
		
		,[ProcedureCacheHitRatioPercentage]
				
		,[ProcedureCacheSizeInKilobytes]
		
		,[ProcessorQueueLength]

		,[ResponseTimeInMilliseconds]

		,[SqlCompilations]

		,[SqlCompilations] / nullif(TimeDeltaInSeconds,0) as [SqlCompilationsPerSecond]
				
		,[SqlRecompilations]
		
		,[SqlRecompilations] / nullif(TimeDeltaInSeconds,0) as [SqlRecompilationsPerSecond]
		
		,[SqlMemoryAllocatedInKilobytes]
		
		,[SqlMemoryUsedInKilobytes]
		
		,[SystemProcesses]
		
		,[SystemProcessesConsumingCPU]
		
		,s.[ServerVersion]
		
		,[Transactions]
		
		,[Transactions] / nullif(TimeDeltaInSeconds,0) as [TransactionsPerSecond]
		
		,[UserProcesses]
		
		,[UserProcessesConsumingCPU]
		
		,[Batches]
		
		,[Batches] / nullif(TimeDeltaInSeconds,0) as [BatchesPerSecond]

		,[DiskTimePercent] 

		,[OSAvailableMemoryInKilobytes]

		,[OSTotalPhysicalMemoryInKilobytes]

	from

		ServerStatistics s (NOLOCK)

		left join [MonitoredSQLServers] m (NOLOCK)

		on m.[SQLServerID] = s.[SQLServerID]

		left join [OSStatistics] o (NOLOCK)

		on o.[SQLServerID] = s.[SQLServerID]  and o.[UTCCollectionDateTime] = s.[UTCCollectionDateTime]

	where 

		s.[SQLServerID] = @SQLServerID
		
		and s.[UTCCollectionDateTime] between coalesce(@BeginDateTime,s.[UTCCollectionDateTime]) and coalesce(@EndDateTime,s.[UTCCollectionDateTime])

	order by

		s.[UTCCollectionDateTime] desc
			
END	
 
GO 

---------- P_GETSERVEROVERVIEWSTATISTICS.SQL
if (object_id('[p_GetServerOverviewStatistics]') is not null)
begin
drop procedure p_GetServerOverviewStatistics
end
go

create procedure [dbo].p_GetServerOverviewStatistics
	@SQLServerID int,
	@StartDate datetime,
	@EndDate datetime
as
begin

select 
	convert(dec(20,1),avg(BlockedProcesses) + (stdev(BlockedProcesses))) as [BlockedProcesses Upper Bound], convert(dec(20,1),avg(BlockedProcesses) - (stdev(BlockedProcesses))) as [BlockedProcesses Lower Bound],
	convert(dec(20,1),avg(BufferCacheHitRatioPercentage) + (stdev(BufferCacheHitRatioPercentage))) as [BufferCacheHitRatioPercentage Upper Bound], convert(dec(20,1),avg(BufferCacheHitRatioPercentage) - (stdev(BufferCacheHitRatioPercentage))) as [BufferCacheHitRatioPercentage Lower Bound],
	convert(dec(20,1),avg(BufferCacheSizeInKilobytes) + (stdev(BufferCacheSizeInKilobytes))) as [BufferCacheSizeInKilobytes Upper Bound], convert(dec(20,1),avg(BufferCacheSizeInKilobytes) - (stdev(BufferCacheSizeInKilobytes))) as [BufferCacheSizeInKilobytes Lower Bound],
	convert(dec(20,1),avg(CheckpointWrites/nullif(TimeDeltaInSeconds,0)) + stdev(CheckpointWrites/nullif(TimeDeltaInSeconds,0))) as [CheckpointWritesPerSecond Upper Bound], convert(dec(20,1),avg(CheckpointWrites/nullif(TimeDeltaInSeconds,0)) - stdev(CheckpointWrites/nullif(TimeDeltaInSeconds,0))) as [CheckpointWritesPerSecond Lower Bound],
	convert(dec(20,1),avg(ClientComputers) + (stdev(ClientComputers))) as [ClientComputers Upper Bound], convert(dec(20,1),avg(ClientComputers) - (stdev(ClientComputers))) as [ClientComputers Lower Bound],
	convert(dec(20,1),avg(CPUActivityPercentage) + (stdev(CPUActivityPercentage))) as [CPUActivityPercentage Upper Bound], convert(dec(20,1),avg(CPUActivityPercentage) - (stdev(CPUActivityPercentage))) as [CPUActivityPercentage Lower Bound],
	convert(dec(20,1),avg(DatabaseCount) + (stdev(DatabaseCount))) as [DatabaseCount Upper Bound], convert(dec(20,1),avg(DatabaseCount) - (stdev(DatabaseCount))) as [DatabaseCount Lower Bound],
	convert(dec(20,1),avg(DataFileCount) + (stdev(DataFileCount))) as [DataFileCount Upper Bound], convert(dec(20,1),avg(DataFileCount) - (stdev(DataFileCount))) as [DataFileCount Lower Bound],
	convert(dec(20,1),avg(DataFileSpaceAllocatedInKilobytes) + (stdev(DataFileSpaceAllocatedInKilobytes))) as [DataFileSpaceAllocatedInKilobytes Upper Bound], convert(dec(20,1),avg(DataFileSpaceAllocatedInKilobytes) - (stdev(DataFileSpaceAllocatedInKilobytes))) as [DataFileSpaceAllocatedInKilobytes Lower Bound],
	convert(dec(20,1),avg(DataFileSpaceUsedInKilobytes) + (stdev(DataFileSpaceUsedInKilobytes))) as [DataFileSpaceUsedInKilobytes Upper Bound], convert(dec(20,1),avg(DataFileSpaceUsedInKilobytes) - (stdev(DataFileSpaceUsedInKilobytes))) as [DataFileSpaceUsedInKilobytes Lower Bound],
	convert(dec(20,1),avg(DiskQueueLength) + (stdev(DiskQueueLength))) as [DiskQueueLength Upper Bound], convert(dec(20,1),avg(DiskQueueLength) - (stdev(DiskQueueLength))) as [DiskQueueLength Lower Bound],
	convert(dec(20,1),avg(DiskTimePercent) + (stdev(DiskTimePercent))) as [DiskTimePercent Upper Bound], convert(dec(20,1),avg(DiskTimePercent) - (stdev(DiskTimePercent))) as [DiskTimePercent Lower Bound],
	convert(dec(20,1),avg(FullScans/nullif(TimeDeltaInSeconds,0)) + stdev(FullScans/nullif(TimeDeltaInSeconds,0))) as [FullScansPerSecond Upper Bound], convert(dec(20,1),avg(FullScans/nullif(TimeDeltaInSeconds,0)) - stdev(FullScans/nullif(TimeDeltaInSeconds,0))) as [FullScansPerSecond Lower Bound],
	convert(dec(20,1),avg(IdleTimePercentage) + (stdev(IdleTimePercentage))) as [IdleTimePercentage Upper Bound], convert(dec(20,1),avg(IdleTimePercentage) - (stdev(IdleTimePercentage))) as [IdleTimePercentage Lower Bound],
	convert(dec(20,1),avg(IOActivityPercentage) + (stdev(IOActivityPercentage))) as [IOActivityPercentage Upper Bound], convert(dec(20,1),avg(IOActivityPercentage) - (stdev(IOActivityPercentage))) as [IOActivityPercentage Lower Bound],
	convert(dec(20,1),avg(LazyWriterWrites/nullif(TimeDeltaInSeconds,0)) + stdev(LazyWriterWrites/nullif(TimeDeltaInSeconds,0))) as [LazyWriterWritesPerSecond Upper Bound], convert(dec(20,1),avg(LazyWriterWrites/nullif(TimeDeltaInSeconds,0)) - stdev(LazyWriterWrites/nullif(TimeDeltaInSeconds,0))) as [LazyWriterWritesPerSecond Lower Bound],
	convert(dec(20,1),avg(LockWaits/nullif(TimeDeltaInSeconds,0)) + stdev(LockWaits/nullif(TimeDeltaInSeconds,0))) as [LockWaitsPerSecond Upper Bound], convert(dec(20,1),avg(LockWaits/nullif(TimeDeltaInSeconds,0)) - stdev(LockWaits/nullif(TimeDeltaInSeconds,0))) as [LockWaitsPerSecond Lower Bound],
	convert(dec(20,1),avg(LogFileCount) + (stdev(LogFileCount))) as [LogFileCount Upper Bound], convert(dec(20,1),avg(LogFileCount) - (stdev(LogFileCount))) as [LogFileCount Lower Bound],
	convert(dec(20,1),avg(LogFileSpaceAllocatedInKilobytes) + (stdev(LogFileSpaceAllocatedInKilobytes))) as [LogFileSpaceAllocatedInKilobytes Upper Bound], convert(dec(20,1),avg(LogFileSpaceAllocatedInKilobytes) - (stdev(LogFileSpaceAllocatedInKilobytes))) as [LogFileSpaceAllocatedInKilobytes Lower Bound],
	convert(dec(20,1),avg(LogFileSpaceUsedInKilobytes) + (stdev(LogFileSpaceUsedInKilobytes))) as [LogFileSpaceUsedInKilobytes Upper Bound], convert(dec(20,1),avg(LogFileSpaceUsedInKilobytes) - (stdev(LogFileSpaceUsedInKilobytes))) as [LogFileSpaceUsedInKilobytes Lower Bound],
	convert(dec(20,1),avg(LogFlushes/nullif(TimeDeltaInSeconds,0)) + stdev(LogFlushes/nullif(TimeDeltaInSeconds,0))) as [LogFlushesPerSecond Upper Bound], convert(dec(20,1),avg(LogFlushes/nullif(TimeDeltaInSeconds,0)) - stdev(LogFlushes/nullif(TimeDeltaInSeconds,0))) as [LogFlushesPerSecond Lower Bound],
	convert(dec(20,1),avg(Logins/nullif(TimeDeltaInSeconds,0)) + stdev(Logins/nullif(TimeDeltaInSeconds,0))) as [LoginsPerSecond Upper Bound], convert(dec(20,1),avg(Logins/nullif(TimeDeltaInSeconds,0)) - stdev(Logins/nullif(TimeDeltaInSeconds,0))) as [LoginsPerSecond Lower Bound],
	convert(dec(20,1),avg(OldestOpenTransactionsInMinutes) + (stdev(OldestOpenTransactionsInMinutes))) as [OldestOpenTransactionsInMinutes Upper Bound], convert(dec(20,1),avg(OldestOpenTransactionsInMinutes) - (stdev(OldestOpenTransactionsInMinutes))) as [OldestOpenTransactionsInMinutes Lower Bound],
	convert(dec(20,1),avg(OpenTransactions) + (stdev(OpenTransactions))) as [OpenTransactions Upper Bound], convert(dec(20,1),avg(OpenTransactions) - (stdev(OpenTransactions))) as [OpenTransactions Lower Bound],
	convert(dec(20,1),(avg(OSAvailableMemoryInKilobytes) + (stdev(OSAvailableMemoryInKilobytes)))/1024) as [OSAvailableMemoryInMegabytes Upper Bound], convert(dec(20,1), (avg(OSAvailableMemoryInKilobytes) - (stdev(OSAvailableMemoryInKilobytes)))/1024) as [OSAvailableMemoryInMegabytes Lower Bound],
	convert(dec(20,1),avg(OSTotalPhysicalMemoryInKilobytes) + (stdev(OSTotalPhysicalMemoryInKilobytes))) as [OSTotalPhysicalMemoryInKilobytes Upper Bound], convert(dec(20,1),avg(OSTotalPhysicalMemoryInKilobytes) - (stdev(OSTotalPhysicalMemoryInKilobytes))) as [OSTotalPhysicalMemoryInKilobytes Lower Bound],
	convert(dec(20,1),avg(PacketErrors/nullif(TimeDeltaInSeconds,0)) + stdev(PacketErrors/nullif(TimeDeltaInSeconds,0))) as [PacketErrorsPerSecond Upper Bound], convert(dec(20,1),avg(PacketErrors/nullif(TimeDeltaInSeconds,0)) - stdev(PacketErrors/nullif(TimeDeltaInSeconds,0))) as [PacketErrorsPerSecond Lower Bound],
	convert(dec(20,1),avg(PacketsReceived/nullif(TimeDeltaInSeconds,0)) + stdev(PacketsReceived/nullif(TimeDeltaInSeconds,0))) as [PacketsReceivedPerSecond Upper Bound], convert(dec(20,1),avg(PacketsReceived/nullif(TimeDeltaInSeconds,0)) - stdev(PacketsReceived/nullif(TimeDeltaInSeconds,0))) as [PacketsReceivedPerSecond Lower Bound],
	convert(dec(20,1),avg(PacketsSent/nullif(TimeDeltaInSeconds,0)) + stdev(PacketsSent/nullif(TimeDeltaInSeconds,0))) as [PacketsSentPerSecond Upper Bound], convert(dec(20,1),avg(PacketsSent/nullif(TimeDeltaInSeconds,0)) - stdev(PacketsSent/nullif(TimeDeltaInSeconds,0))) as [PacketsSentPerSecond Lower Bound],
	convert(dec(20,1),avg(PageErrors/nullif(TimeDeltaInSeconds,0)) + stdev(PageErrors/nullif(TimeDeltaInSeconds,0))) as [PageErrorsPerSecond Upper Bound], convert(dec(20,1),avg(PageErrors/nullif(TimeDeltaInSeconds,0)) - stdev(PageErrors/nullif(TimeDeltaInSeconds,0))) as [PageErrorsPerSecond Lower Bound],
	convert(dec(20,1),avg(PageLifeExpectancy) + (stdev(PageLifeExpectancy))) as [PageLifeExpectancy Upper Bound], convert(dec(20,1),avg(PageLifeExpectancy) - (stdev(PageLifeExpectancy))) as [PageLifeExpectancy Lower Bound],
	convert(dec(20,1),avg(PageLookups/nullif(TimeDeltaInSeconds,0)) + stdev(PageLookups/nullif(TimeDeltaInSeconds,0))) as [PageLookupsPerSecond Upper Bound], convert(dec(20,1),avg(PageLookups/nullif(TimeDeltaInSeconds,0)) - stdev(PageLookups/nullif(TimeDeltaInSeconds,0))) as [PageLookupsPerSecond Lower Bound],
	convert(dec(20,1),avg(PageReads/nullif(TimeDeltaInSeconds,0)) + stdev(PageReads/nullif(TimeDeltaInSeconds,0))) as [PageReadsPerSecond Upper Bound], convert(dec(20,1),avg(PageReads/nullif(TimeDeltaInSeconds,0)) - stdev(PageReads/nullif(TimeDeltaInSeconds,0))) as [PageReadsPerSecond Lower Bound],
	convert(dec(20,1),avg(PagesPerSecond) + (stdev(PagesPerSecond))) as [PagesPerSecond Upper Bound], convert(dec(20,1),avg(PagesPerSecond) - (stdev(PagesPerSecond))) as [PagesPerSecond Lower Bound],
	convert(dec(20,1),avg(PageSplits/nullif(TimeDeltaInSeconds,0)) + stdev(PageSplits/nullif(TimeDeltaInSeconds,0))) as [PageSplitsPerSecond Upper Bound], convert(dec(20,1),avg(PageSplits/nullif(TimeDeltaInSeconds,0)) - stdev(PageSplits/nullif(TimeDeltaInSeconds,0))) as [PageSplitsPerSecond Lower Bound],
	convert(dec(20,1),avg(PageWrites/nullif(TimeDeltaInSeconds,0)) + stdev(PageWrites/nullif(TimeDeltaInSeconds,0))) as [PageWritesPerSecond Upper Bound], convert(dec(20,1),avg(PageWrites/nullif(TimeDeltaInSeconds,0)) - stdev(PageWrites/nullif(TimeDeltaInSeconds,0))) as [PageWritesPerSecond Lower Bound],
	convert(dec(20,1),avg(PrivilegedTimePercent) + (stdev(PrivilegedTimePercent))) as [PrivilegedTimePercent Upper Bound], convert(dec(20,1),avg(PrivilegedTimePercent) - (stdev(PrivilegedTimePercent))) as [PrivilegedTimePercent Lower Bound],
	convert(dec(20,1),avg(ProcedureCacheHitRatioPercentage) + (stdev(ProcedureCacheHitRatioPercentage))) as [ProcedureCacheHitRatioPercentage Upper Bound], convert(dec(20,1),avg(ProcedureCacheHitRatioPercentage) - (stdev(ProcedureCacheHitRatioPercentage))) as [ProcedureCacheHitRatioPercentage Lower Bound],
	convert(dec(20,1),avg(ProcedureCacheSizeInKilobytes) + (stdev(ProcedureCacheSizeInKilobytes))) as [ProcedureCacheSizeInKilobytes Upper Bound], convert(dec(20,1),avg(ProcedureCacheSizeInKilobytes) - (stdev(ProcedureCacheSizeInKilobytes))) as [ProcedureCacheSizeInKilobytes Lower Bound],
	convert(dec(20,1),avg(ProcedureCacheSizePercent) + (stdev(ProcedureCacheSizePercent))) as [ProcedureCacheSizePercent Upper Bound], convert(dec(20,1),avg(ProcedureCacheSizePercent) - (stdev(ProcedureCacheSizePercent))) as [ProcedureCacheSizePercent Lower Bound],
	convert(dec(20,1),avg(ProcessorQueueLength) + (stdev(ProcessorQueueLength))) as [ProcessorQueueLength Upper Bound], convert(dec(20,1),avg(ProcessorQueueLength) - (stdev(ProcessorQueueLength))) as [ProcessorQueueLength Lower Bound],
	convert(dec(20,1),avg(ProcessorTimePercent) + (stdev(ProcessorTimePercent))) as [ProcessorTimePercent Upper Bound], convert(dec(20,1),avg(ProcessorTimePercent) - (stdev(ProcessorTimePercent))) as [ProcessorTimePercent Lower Bound],
	convert(dec(20,1),avg(ReadAheadPages/nullif(TimeDeltaInSeconds,0)) + stdev(ReadAheadPages/nullif(TimeDeltaInSeconds,0))) as [ReadAheadPagesPerSecond Upper Bound], convert(dec(20,1),avg(ReadAheadPages/nullif(TimeDeltaInSeconds,0)) - stdev(ReadAheadPages/nullif(TimeDeltaInSeconds,0))) as [ReadAheadPagesPerSecond Lower Bound],
	convert(dec(20,1),avg(ReplicationLatencyInSeconds) + (stdev(ReplicationLatencyInSeconds))) as [ReplicationLatencyInSeconds Upper Bound], convert(dec(20,1),avg(ReplicationLatencyInSeconds) - (stdev(ReplicationLatencyInSeconds))) as [ReplicationLatencyInSeconds Lower Bound],
	convert(dec(20,1),avg(ReplicationSubscribed) + (stdev(ReplicationSubscribed))) as [ReplicationSubscribed Upper Bound], convert(dec(20,1),avg(ReplicationSubscribed) - (stdev(ReplicationSubscribed))) as [ReplicationSubscribed Lower Bound],
	convert(dec(20,1),avg(ReplicationUndistributed) + (stdev(ReplicationUndistributed))) as [ReplicationUndistributed Upper Bound], convert(dec(20,1),avg(ReplicationUndistributed) - (stdev(ReplicationUndistributed))) as [ReplicationUndistributed Lower Bound],
	convert(dec(20,1),avg(ReplicationUnsubscribed) + (stdev(ReplicationUnsubscribed))) as [ReplicationUnsubscribed Upper Bound], convert(dec(20,1),avg(ReplicationUnsubscribed) - (stdev(ReplicationUnsubscribed))) as [ReplicationUnsubscribed Lower Bound],
	convert(dec(20,1),avg(ResponseTimeInMilliseconds) + (stdev(ResponseTimeInMilliseconds))) as [ResponseTimeInMilliseconds Upper Bound], convert(dec(20,1),avg(ResponseTimeInMilliseconds) - (stdev(ResponseTimeInMilliseconds))) as [ResponseTimeInMilliseconds Lower Bound],
	convert(dec(20,1),avg(SqlCompilations/nullif(TimeDeltaInSeconds,0)) + stdev(SqlCompilations/nullif(TimeDeltaInSeconds,0))) as [SqlCompilationsPerSecond Upper Bound], convert(dec(20,1),avg(SqlCompilations/nullif(TimeDeltaInSeconds,0)) - stdev(SqlCompilations/nullif(TimeDeltaInSeconds,0))) as [SqlCompilationsPerSecond Lower Bound],
	convert(dec(20,1),avg(SqlMemoryAllocatedInKilobytes) + (stdev(SqlMemoryAllocatedInKilobytes))) as [SqlMemoryAllocatedInKilobytes Upper Bound], convert(dec(20,1),avg(SqlMemoryAllocatedInKilobytes) - (stdev(SqlMemoryAllocatedInKilobytes))) as [SqlMemoryAllocatedInKilobytes Lower Bound],
	convert(dec(20,1),avg(SqlMemoryUsedInKilobytes) + (stdev(SqlMemoryUsedInKilobytes))) as [SqlMemoryUsedInKilobytes Upper Bound], convert(dec(20,1),avg(SqlMemoryUsedInKilobytes) - (stdev(SqlMemoryUsedInKilobytes))) as [SqlMemoryUsedInKilobytes Lower Bound],
	convert(dec(20,1),avg(SqlRecompilations/nullif(TimeDeltaInSeconds,0)) + stdev(SqlRecompilations/nullif(TimeDeltaInSeconds,0))) as [SqlRecompilationsPerSecond Upper Bound], convert(dec(20,1),avg(SqlRecompilations/nullif(TimeDeltaInSeconds,0)) - stdev(SqlRecompilations/nullif(TimeDeltaInSeconds,0))) as [SqlRecompilationsPerSecond Lower Bound],
	convert(dec(20,1),avg(SystemProcesses) + (stdev(SystemProcesses))) as [SystemProcesses Upper Bound], convert(dec(20,1),avg(SystemProcesses) - (stdev(SystemProcesses))) as [SystemProcesses Lower Bound],
	convert(dec(20,1),avg(SystemProcessesConsumingCPU) + (stdev(SystemProcessesConsumingCPU))) as [SystemProcessesConsumingCPU Upper Bound], convert(dec(20,1),avg(SystemProcessesConsumingCPU) - (stdev(SystemProcessesConsumingCPU))) as [SystemProcessesConsumingCPU Lower Bound],
	convert(dec(20,1),avg(TableLockEscalations/nullif(TimeDeltaInSeconds,0)) + (stdev(TableLockEscalations/nullif(TimeDeltaInSeconds,0)))) as [TableLockEscalationsPerSecond Upper Bound], convert(dec(20,1),avg(TableLockEscalations/nullif(TimeDeltaInSeconds,0)) - (stdev(TableLockEscalations/nullif(TimeDeltaInSeconds,0)))) as [TableLockEscalationsPerSecond Lower Bound],
	convert(dec(20,1),avg(TempDBSizeInKilobytes) + (stdev(TempDBSizeInKilobytes))) as [TempDBSizeInKilobytes Upper Bound], convert(dec(20,1),avg(TempDBSizeInKilobytes) - (stdev(TempDBSizeInKilobytes))) as [TempDBSizeInKilobytes Lower Bound],
	convert(dec(20,1),avg(TempDBSizePercent) + (stdev(TempDBSizePercent))) as [TempDBSizePercent Upper Bound], convert(dec(20,1),avg(TempDBSizePercent) - (stdev(TempDBSizePercent))) as [TempDBSizePercent Lower Bound],
	convert(dec(20,1),avg(Batches/nullif(TimeDeltaInSeconds,0)) + (stdev(Batches/nullif(TimeDeltaInSeconds,0)))) as [BatchesPerSecond Upper Bound], convert(dec(20,1),avg(Batches/nullif(TimeDeltaInSeconds,0)) - (stdev(Batches/nullif(TimeDeltaInSeconds,0)))) as [BatchesPerSecond Lower Bound],
	convert(dec(20,4),avg(1 - (convert(dec(20,4),OSAvailableMemoryInKilobytes )/ nullif(OSTotalPhysicalMemoryInKilobytes,0)))) + (stdev(1 - (convert(dec(20,4),OSAvailableMemoryInKilobytes) / nullif(OSTotalPhysicalMemoryInKilobytes,0)))) as [UsedMemoryPercent Upper Bound], convert(dec(20,4),avg(1 - convert(dec(20,4),OSAvailableMemoryInKilobytes) / nullif(OSTotalPhysicalMemoryInKilobytes,0)) - (stdev(1 - convert(dec(20,4),OSAvailableMemoryInKilobytes) / nullif(OSTotalPhysicalMemoryInKilobytes,0)))) as [UsedMemoryPercent Lower Bound],	
	convert(dec(20,4),avg(convert(dec(20,4),SqlMemoryUsedInKilobytes) / nullif(OSTotalPhysicalMemoryInKilobytes,0)) + (stdev(convert(dec(20,4),SqlMemoryUsedInKilobytes) / nullif(OSTotalPhysicalMemoryInKilobytes,0)))) as [UsedSqlMemoryPercent Upper Bound], convert(dec(20,4),avg(convert(dec(20,4),SqlMemoryUsedInKilobytes) / nullif(OSTotalPhysicalMemoryInKilobytes,0)) - (stdev(convert(dec(20,4),SqlMemoryUsedInKilobytes) / nullif(OSTotalPhysicalMemoryInKilobytes,0)))) as [UsedSqlMemoryPercent Lower Bound],	
	convert(dec(20,1),avg(UserProcesses) + (stdev(UserProcesses))) as [UserProcesses Upper Bound], convert(dec(20,1),avg(UserProcesses) - (stdev(UserProcesses))) as [UserProcesses Lower Bound],
	convert(dec(20,1),avg(UserProcessesConsumingCPU) + (stdev(UserProcessesConsumingCPU))) as [UserProcessesConsumingCPU Upper Bound], convert(dec(20,1),avg(UserProcessesConsumingCPU) - (stdev(UserProcessesConsumingCPU))) as [UserProcessesConsumingCPU Lower Bound],
	convert(dec(20,1),avg(UserTimePercent) + (stdev(UserTimePercent))) as [UserTimePercent Upper Bound], convert(dec(20,1),avg(UserTimePercent) - (stdev(UserTimePercent))) as [UserTimePercent Lower Bound],
	convert(dec(20,1),avg(WorkFilesCreated/nullif(TimeDeltaInSeconds,0)) + stdev(WorkFilesCreated/nullif(TimeDeltaInSeconds,0))) as [WorkFilesCreatedPerSecond Upper Bound], convert(dec(20,1),avg(WorkFilesCreated/nullif(TimeDeltaInSeconds,0)) - stdev(WorkFilesCreated/nullif(TimeDeltaInSeconds,0))) as [WorkFilesCreatedPerSecond Lower Bound],
	convert(dec(20,1),avg(WorkTablesCreated/nullif(TimeDeltaInSeconds,0)) + stdev(WorkTablesCreated/nullif(TimeDeltaInSeconds,0))) as [WorkTablesCreatedPerSecond Upper Bound], convert(dec(20,1),avg(WorkTablesCreated/nullif(TimeDeltaInSeconds,0)) - stdev(WorkTablesCreated/nullif(TimeDeltaInSeconds,0))) as [WorkTablesCreatedPerSecond Lower Bound],
	convert(dec(20,1),avg(vs.CPUUsage) + stdev(vs.CPUUsage)) as [VMCPUUsage Upper Bound], convert(dec(20,1),avg(vs.CPUUsage) - stdev(vs.CPUUsage)) as [VMCPUUsage Lower Bound],
	convert(dec(20,1),avg(vs.CPUUsageMHz) + stdev(vs.CPUUsageMHz)) as [VMCPUUsageMHz Upper Bound], convert(dec(20,1),avg(vs.CPUUsageMHz) - stdev(vs.CPUUsageMHz)) as [VMCPUUsageMHz Lower Bound],
	convert(dec(20,1),avg(vs.CPUReady) + stdev(vs.CPUReady)) as [VMCPUReady Upper Bound], convert(dec(20,1),avg(vs.CPUReady) - stdev(vs.CPUReady)) as [VMCPUReady Lower Bound],
	convert(dec(20,1),avg(vs.CPUSwapWait) + stdev(vs.CPUSwapWait)) as [VMCPUSwapWait Upper Bound], convert(dec(20,1),avg(vs.CPUSwapWait) - stdev(vs.CPUSwapWait)) as [VMCPUSwapWait Lower Bound],
	convert(dec(20,1),avg(vs.MemSwapInRate) + stdev(vs.MemSwapInRate)) as [VMMemSwapInRate Upper Bound], convert(dec(20,1),avg(vs.MemSwapInRate) - stdev(vs.MemSwapInRate)) as [VMMemSwapInRate Lower Bound],
	convert(dec(20,1),avg(vs.MemSwapOutRate) + stdev(vs.MemSwapOutRate)) as [VMMemSwapOutRate Upper Bound], convert(dec(20,1),avg(vs.MemSwapOutRate) - stdev(vs.MemSwapOutRate)) as [VMMemSwapOutRate Lower Bound],
	convert(dec(20,1),avg(vs.MemSwapped) + stdev(vs.MemSwapped)) as [VMMemSwapped Upper Bound], convert(dec(20,1),avg(vs.MemSwapped) - stdev(vs.MemSwapped)) as [VMMemSwapped Lower Bound],
	convert(dec(20,1),avg(vs.MemActive) + stdev(vs.MemActive)) as [VMMemActive Upper Bound], convert(dec(20,1),avg(vs.MemActive) - stdev(vs.MemActive)) as [VMMemActive Lower Bound],
	convert(dec(20,1),avg(vs.MemConsumed) + stdev(vs.MemConsumed)) as [VMMemConsumed Upper Bound], convert(dec(20,1),avg(vs.MemConsumed) - stdev(vs.MemConsumed)) as [VMMemConsumed Lower Bound],
	convert(dec(20,1),avg(vs.MemGranted) + stdev(vs.MemGranted)) as [VMMemGranted Upper Bound], convert(dec(20,1),avg(vs.MemGranted) - stdev(vs.MemGranted)) as [VMMemGranted Lower Bound],
	convert(dec(20,1),avg(vs.MemBalooned) + stdev(vs.MemBalooned)) as [VMMemBalooned Upper Bound], convert(dec(20,1),avg(vs.MemBalooned) - stdev(vs.MemBalooned)) as [VMMemBalooned Lower Bound],
	convert(dec(20,1),avg(vs.MemUsage) + stdev(vs.MemUsage)) as [VMMemUsage Upper Bound], convert(dec(20,1),avg(vs.MemUsage) - stdev(vs.MemUsage)) as [VMMemUsage Lower Bound],
	convert(dec(20,1),avg(vs.DiskRead) + stdev(vs.DiskRead)) as [VMDiskRead Upper Bound], convert(dec(20,1),avg(vs.DiskRead) - stdev(vs.DiskRead)) as [VMDiskRead Lower Bound],
	convert(dec(20,1),avg(vs.DiskWrite) + stdev(vs.DiskWrite)) as [VMDiskWrite Upper Bound], convert(dec(20,1),avg(vs.DiskWrite) - stdev(vs.DiskWrite)) as [VMDiskWrite Lower Bound],
	convert(dec(20,1),avg(vs.DiskUsage) + stdev(vs.DiskUsage)) as [VMDiskUsage Upper Bound], convert(dec(20,1),avg(vs.DiskUsage) - stdev(vs.DiskUsage)) as [VMDiskUsage Lower Bound],
	convert(dec(20,1),avg(vs.NetUsage) + stdev(vs.NetUsage)) as [VMNetUsage Upper Bound], convert(dec(20,1),avg(vs.NetUsage) - stdev(vs.NetUsage)) as [VMNetUsage Lower Bound],
	convert(dec(20,1),avg(vs.NetTransmitted) + stdev(vs.NetTransmitted)) as [VMNetTransmitted Upper Bound], convert(dec(20,1),avg(vs.NetTransmitted) - stdev(vs.NetTransmitted)) as [VMNetTransmitted Lower Bound],
	convert(dec(20,1),avg(vs.NetReceived) + stdev(vs.NetReceived)) as [VMNetReceived Upper Bound], convert(dec(20,1),avg(vs.NetReceived) - stdev(vs.NetReceived)) as [VMNetReceived Lower Bound],
	convert(dec(20,1),avg(es.CPUUsage) + stdev(es.CPUUsage)) as [ESXCPUUsage Upper Bound], convert(dec(20,1),avg(es.CPUUsage) - stdev(es.CPUUsage)) as [ESXCPUUsage Lower Bound],
	convert(dec(20,1),avg(es.CPUUsageMHz) + stdev(es.CPUUsageMHz)) as [ESXCPUUsageMHz Upper Bound], convert(dec(20,1),avg(es.CPUUsageMHz) - stdev(es.CPUUsageMHz)) as [ESXCPUUsageMHz Lower Bound],
	convert(dec(20,1),avg(es.MemSwapInRate) + stdev(es.MemSwapInRate)) as [ESXMemSwapInRate Upper Bound], convert(dec(20,1),avg(es.MemSwapInRate) - stdev(es.MemSwapInRate)) as [ESXMemSwapInRate Lower Bound],
	convert(dec(20,1),avg(es.MemSwapOutRate) + stdev(es.MemSwapOutRate)) as [ESXMemSwapOutRate Upper Bound], convert(dec(20,1),avg(es.MemSwapOutRate) - stdev(es.MemSwapOutRate)) as [ESXMemSwapOutRate Lower Bound],
	convert(dec(20,1),avg(es.MemActive) + stdev(es.MemActive)) as [ESXMemActive Upper Bound], convert(dec(20,1),avg(es.MemActive) - stdev(es.MemActive)) as [ESXMemActive Lower Bound],
	convert(dec(20,1),avg(es.MemConsumed) + stdev(es.MemConsumed)) as [ESXMemConsumed Upper Bound], convert(dec(20,1),avg(es.MemConsumed) - stdev(es.MemConsumed)) as [ESXMemConsumed Lower Bound],
	convert(dec(20,1),avg(es.MemGranted) + stdev(es.MemGranted)) as [ESXMemGranted Upper Bound], convert(dec(20,1),avg(es.MemGranted) - stdev(es.MemGranted)) as [ESXMemGranted Lower Bound],
	convert(dec(20,1),avg(es.MemBalooned) + stdev(es.MemBalooned)) as [ESXMemBalooned Upper Bound], convert(dec(20,1),avg(es.MemBalooned) - stdev(es.MemBalooned)) as [ESXMemBalooned Lower Bound],
	convert(dec(20,1),avg(es.MemUsage) + stdev(es.MemUsage)) as [ESXMemUsage Upper Bound], convert(dec(20,1),avg(es.MemUsage) - stdev(es.MemUsage)) as [ESXMemUsage Lower Bound],
	convert(dec(20,1),avg(es.DiskRead) + stdev(es.DiskRead)) as [ESXDiskRead Upper Bound], convert(dec(20,1),avg(es.DiskRead) - stdev(es.DiskRead)) as [ESXDiskRead Lower Bound],
	convert(dec(20,1),avg(es.DiskWrite) + stdev(es.DiskWrite)) as [ESXDiskWrite Upper Bound], convert(dec(20,1),avg(es.DiskWrite) - stdev(es.DiskWrite)) as [ESXDiskWrite Lower Bound],
	convert(dec(20,1),avg(es.DiskUsage) + stdev(es.DiskUsage)) as [ESXDiskUsage Upper Bound], convert(dec(20,1),avg(es.DiskUsage) - stdev(es.DiskUsage)) as [ESXDiskUsage Lower Bound],
	convert(dec(20,1),avg(es.NetUsage) + stdev(es.NetUsage)) as [ESXNetUsage Upper Bound], convert(dec(20,1),avg(es.NetUsage) - stdev(es.NetUsage)) as [ESXNetUsage Lower Bound],
	convert(dec(20,1),avg(es.NetTransmitted) + stdev(es.NetTransmitted)) as [ESXNetTransmitted Upper Bound], convert(dec(20,1),avg(es.NetTransmitted) - stdev(es.NetTransmitted)) as [ESXNetTransmitted Lower Bound],
	convert(dec(20,1),avg(es.NetReceived) + stdev(es.NetReceived)) as [ESXNetReceived Upper Bound], convert(dec(20,1),avg(es.NetReceived) - stdev(es.NetReceived)) as [ESXNetReceived Lower Bound],
	convert(dec(20,1),avg(es.DiskDeviceLatency) + stdev(es.DiskDeviceLatency)) as [ESXDiskDeviceLatency Upper Bound], convert(dec(20,1),avg(es.DiskDeviceLatency) - stdev(es.DiskDeviceLatency)) as [ESXDiskDeviceLatency Lower Bound],
	convert(dec(20,1),avg(es.DiskKernelLatency) + stdev(es.DiskKernelLatency)) as [ESXDiskKernelLatency Upper Bound], convert(dec(20,1),avg(es.DiskKernelLatency) - stdev(es.DiskKernelLatency)) as [ESXDiskKernelLatency Lower Bound],
	convert(dec(20,1),avg(es.DiskQueueLatency) + stdev(es.DiskQueueLatency)) as [ESXDiskQueueLatency Upper Bound], convert(dec(20,1),avg(es.DiskQueueLatency) - stdev(es.DiskQueueLatency)) as [ESXDiskQueueLatency Lower Bound],
	convert(dec(20,1),avg(es.DiskTotalLatency) + stdev(es.DiskTotalLatency)) as [ESXDiskTotalLatency Upper Bound], convert(dec(20,1),avg(es.DiskTotalLatency) - stdev(es.DiskTotalLatency)) as [ESXDiskTotalLatency Lower Bound]
	into #TempStatistics
from
	[ServerStatistics] s1
	left join [MonitoredSQLServers] m
	on m.[SQLServerID] = s1.[SQLServerID]
	left join [OSStatistics] o
	on o.[SQLServerID] = s1.[SQLServerID] and o.[UTCCollectionDateTime] = s1.[UTCCollectionDateTime]
	left join [VMConfigData] vc
		on s1.SQLServerID = vc.SQLServerID and s1.UTCCollectionDateTime = vc.UTCCollectionDateTime
	left join [ESXConfigData] ec
		on s1.SQLServerID = ec.SQLServerID and s1.UTCCollectionDateTime = ec.UTCCollectionDateTime
	left join [VMStatistics] vs
		on s1.SQLServerID = vs.SQLServerID and s1.UTCCollectionDateTime = vs.UTCCollectionDateTime
	left join [ESXStatistics] es
		on s1.SQLServerID = es.SQLServerID and s1.UTCCollectionDateTime = es.UTCCollectionDateTime
where 
	s1.SQLServerID = @SQLServerID
	and s1.UTCCollectionDateTime >= @StartDate
	and s1.UTCCollectionDateTime <= @EndDate

select 
	[BlockedProcesses] = case when isnull([BlockedProcesses Lower Bound],-1) < 0 then '0' else cast([BlockedProcesses Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([BlockedProcesses Upper Bound],0) as nvarchar(50)),
	[BufferCacheHitRatioPercentage] = case when isnull([BufferCacheHitRatioPercentage Lower Bound],-1) < 0 then '0' else cast([BufferCacheHitRatioPercentage Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([BufferCacheHitRatioPercentage Upper Bound],0) as nvarchar(50)),
	[BufferCacheSizeInMegabytes] = case when isnull([BufferCacheSizeInKilobytes Lower Bound],-1)/1024 < 0 then '0' else cast(convert(dec(20,1),[BufferCacheSizeInKilobytes Lower Bound]/1024) as nvarchar(50)) end + ' - ' + cast(isnull(convert(dec(20,1),[BufferCacheSizeInKilobytes Upper Bound]/1024),0) as nvarchar(50)),
	[CheckpointWritesPerSecond] = case when isnull([CheckpointWritesPerSecond Lower Bound],-1) < 0 then '0' else cast([CheckpointWritesPerSecond Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([CheckpointWritesPerSecond Upper Bound],0) as nvarchar(50)),
	[ClientComputers] = case when isnull([ClientComputers Lower Bound],-1) < 0 then '0' else cast([ClientComputers Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([ClientComputers Upper Bound],0) as nvarchar(50)),
	[CPUActivityPercentage] = case when isnull([CPUActivityPercentage Lower Bound],-1) < 0 then '0' else cast([CPUActivityPercentage Lower Bound] as nvarchar(50)) end + ' - ' + case when [CPUActivityPercentage Upper Bound] > 100 then '100' else cast(isnull([CPUActivityPercentage Upper Bound],0) as nvarchar(50)) end,
	[DatabaseCount] = case when isnull([DatabaseCount Lower Bound],-1) < 0 then '0' else cast([DatabaseCount Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([DatabaseCount Upper Bound],0) as nvarchar(50)),
	[DataFileCount] = case when isnull([DataFileCount Lower Bound],-1) < 0 then '0' else cast([DataFileCount Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([DataFileCount Upper Bound],0) as nvarchar(50)),
	[DataFileSpaceAllocatedInMegabytes] = case when isnull([DataFileSpaceAllocatedInKilobytes Lower Bound]/1024,-1) < 0 then '0' else cast(convert(dec(20,1),[DataFileSpaceAllocatedInKilobytes Lower Bound]/1024) as nvarchar(50)) end + ' MB - ' + cast(isnull(convert(dec(20,1),[DataFileSpaceAllocatedInKilobytes Upper Bound]/1024),0) as nvarchar(50))  + ' MB',
	[DataFileSpaceUsedInMegabytes] = case when isnull([DataFileSpaceUsedInKilobytes Lower Bound]/1024,-1) < 0 then '0' else cast(convert(dec(20,1),[DataFileSpaceUsedInKilobytes Lower Bound]/1024) as nvarchar(50)) end + ' MB  - ' + cast(isnull(convert(dec(20,1),[DataFileSpaceUsedInKilobytes Upper Bound]/1024),0) as nvarchar(50))+ ' MB',
	[DiskQueueLength] = case when isnull([DiskQueueLength Lower Bound],-1) < 0 then '0' else cast([DiskQueueLength Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([DiskQueueLength Upper Bound],0) as nvarchar(50)),
	[DiskTimePercent] = case when isnull([DiskTimePercent Lower Bound],-1) < 0 then '0' else cast([DiskTimePercent Lower Bound] as nvarchar(50)) end + ' - ' + case when [DiskTimePercent Upper Bound] > 100 then '100' else cast(isnull([DiskTimePercent Upper Bound],0) as nvarchar(50)) end,
	[FullScansPerSecond] = case when isnull([FullScansPerSecond Lower Bound],-1) < 0 then '0' else cast([FullScansPerSecond Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([FullScansPerSecond Upper Bound],0) as nvarchar(50)),
	[IdleTimePercentage] = case when isnull([IdleTimePercentage Lower Bound],-1) < 0 then '0' else cast([IdleTimePercentage Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([IdleTimePercentage Upper Bound],0) as nvarchar(50)),
	[IOActivityPercentage] = case when isnull([IOActivityPercentage Lower Bound],-1) < 0 then '0' else cast([IOActivityPercentage Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([IOActivityPercentage Upper Bound],0) as nvarchar(50)),
	[LazyWriterWritesPerSecond] = case when isnull([LazyWriterWritesPerSecond Lower Bound],-1) < 0 then '0' else cast([LazyWriterWritesPerSecond Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([LazyWriterWritesPerSecond Upper Bound],0) as nvarchar(50)),
	[LockWaitsPerSecond] = case when isnull([LockWaitsPerSecond Lower Bound],-1) < 0 then '0' else cast([LockWaitsPerSecond Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([LockWaitsPerSecond Upper Bound],0) as nvarchar(50)),
	[LogFileCount] = case when isnull([LogFileCount Lower Bound],-1) < 0 then '0' else cast([LogFileCount Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([LogFileCount Upper Bound],0) as nvarchar(50)),
	[LogFileSpaceAllocatedInMegabytes] = case when isnull([LogFileSpaceAllocatedInKilobytes Lower Bound]/1024,-1) < 0 then '0' else cast(convert(dec(20,1),[LogFileSpaceAllocatedInKilobytes Lower Bound]/1024) as nvarchar(50)) end + ' MB - ' + cast(isnull(convert(dec(20,1),[LogFileSpaceAllocatedInKilobytes Upper Bound]/1024),0) as nvarchar(50))+ ' MB',
	[LogFileSpaceUsedInMegabytes] = case when isnull([LogFileSpaceUsedInKilobytes Lower Bound]/1024,-1) < 0 then '0' else cast(convert(dec(20,1),[LogFileSpaceUsedInKilobytes Lower Bound]/1024) as nvarchar(50)) end + ' MB - ' + cast(isnull(convert(dec(20,1),[LogFileSpaceUsedInKilobytes Upper Bound]/1024),0) as nvarchar(50))+ ' MB',
	[LogFlushesPerSecond] = case when isnull([LogFlushesPerSecond Lower Bound],-1) < 0 then '0' else cast([LogFlushesPerSecond Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([LogFlushesPerSecond Upper Bound],0) as nvarchar(50)),
	[LoginsPerSecond] = case when isnull([LoginsPerSecond Lower Bound],-1) < 0 then '0' else cast([LoginsPerSecond Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([LoginsPerSecond Upper Bound],0) as nvarchar(50)),
	[OldestOpenTransactionsInMinutes] = case when isnull([OldestOpenTransactionsInMinutes Lower Bound],-1) < 0 then '0' else cast([OldestOpenTransactionsInMinutes Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([OldestOpenTransactionsInMinutes Upper Bound],0) as nvarchar(50)),
	[OpenTransactions] = case when isnull([OpenTransactions Lower Bound],-1) < 0 then '0' else cast([OpenTransactions Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([OpenTransactions Upper Bound],0) as nvarchar(50)),
	[OSAvailableMemoryInMegabytes] = case when isnull([OSAvailableMemoryInMegabytes Lower Bound],-1) < 0 then '0' else cast([OSAvailableMemoryInMegabytes Lower Bound] as nvarchar(50)) end + ' MB - ' + cast(isnull([OSAvailableMemoryInMegabytes Upper Bound],0) as nvarchar(50)) + ' MB',
	[OSTotalPhysicalMemoryInMegabytes] = case when isnull([OSTotalPhysicalMemoryInKilobytes Lower Bound]/1024,-1) < 0 then '0' else cast(convert(dec(20,1),[OSTotalPhysicalMemoryInKilobytes Lower Bound]/1024) as nvarchar(50)) end + ' MB - ' + cast(isnull(convert(dec(20,1),[OSTotalPhysicalMemoryInKilobytes Upper Bound]/1024),0) as nvarchar(50))+ ' MB',
	[PacketErrorsPerSecond] = case when isnull([PacketErrorsPerSecond Lower Bound],-1) < 0 then '0' else cast([PacketErrorsPerSecond Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([PacketErrorsPerSecond Upper Bound],0) as nvarchar(50)),
	[PacketsReceivedPerSecond] = case when isnull([PacketsReceivedPerSecond Lower Bound],-1) < 0 then '0' else cast([PacketsReceivedPerSecond Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([PacketsReceivedPerSecond Upper Bound],0) as nvarchar(50)),
	[PacketsSentPerSecond] = case when isnull([PacketsSentPerSecond Lower Bound],-1) < 0 then '0' else cast([PacketsSentPerSecond Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([PacketsSentPerSecond Upper Bound],0) as nvarchar(50)),
	[PageErrorsPerSecond] = case when isnull([PageErrorsPerSecond Lower Bound],-1) < 0 then '0' else cast([PageErrorsPerSecond Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([PageErrorsPerSecond Upper Bound],0) as nvarchar(50)),
	[PageLifeExpectancy] = case when isnull([PageLifeExpectancy Lower Bound],-1) < 0 then '0' else cast([PageLifeExpectancy Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([PageLifeExpectancy Upper Bound],0) as nvarchar(50)),
	[PageLookupsPerSecond] = case when isnull([PageLookupsPerSecond Lower Bound],-1) < 0 then '0' else cast([PageLookupsPerSecond Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([PageLookupsPerSecond Upper Bound],0) as nvarchar(50)),
	[PageReadsPerSecond] = case when isnull([PageReadsPerSecond Lower Bound],-1) < 0 then '0' else cast([PageReadsPerSecond Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([PageReadsPerSecond Upper Bound],0) as nvarchar(50)),
	[PagesPerSecond] = case when isnull([PagesPerSecond Lower Bound],-1) < 0 then '0' else cast([PagesPerSecond Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([PagesPerSecond Upper Bound],0) as nvarchar(50)),
	[PageSplitsPerSecond] = case when isnull([PageSplitsPerSecond Lower Bound],-1) < 0 then '0' else cast([PageSplitsPerSecond Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([PageSplitsPerSecond Upper Bound],0) as nvarchar(50)),
	[PageWritesPerSecond] = case when isnull([PageWritesPerSecond Lower Bound],-1) < 0 then '0' else cast([PageWritesPerSecond Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([PageWritesPerSecond Upper Bound],0) as nvarchar(50)),
	[PrivilegedTimePercent] = case when isnull([PrivilegedTimePercent Lower Bound],-1) < 0 then '0' else cast([PrivilegedTimePercent Lower Bound] as nvarchar(50)) end + ' - ' + case when [PrivilegedTimePercent Upper Bound] > 100 then '100' else cast(isnull([PrivilegedTimePercent Upper Bound],0) as nvarchar(50)) end,
	[ProcedureCacheHitRatioPercentage] = case when isnull([ProcedureCacheHitRatioPercentage Lower Bound],-1) < 0 then '0' else cast([ProcedureCacheHitRatioPercentage Lower Bound] as nvarchar(50)) end + ' - ' + case when [ProcedureCacheHitRatioPercentage Upper Bound] > 100 then '100' else cast(isnull([ProcedureCacheHitRatioPercentage Upper Bound],0) as nvarchar(50)) end,
	[ProcedureCacheSizeInMegabytes] = case when isnull([ProcedureCacheSizeInKilobytes Lower Bound]/1024,-1) < 0 then '0' else cast(convert(dec(20,1),[ProcedureCacheSizeInKilobytes Lower Bound]/1024) as nvarchar(50)) end + ' MB - ' + cast(isnull(convert(dec(20,1),[ProcedureCacheSizeInKilobytes Upper Bound]/1024),0) as nvarchar(50))+ ' MB',
	[ProcedureCacheSizePercent] = case when isnull([ProcedureCacheSizePercent Lower Bound],-1) < 0 then '0' else cast([ProcedureCacheSizePercent Lower Bound] as nvarchar(50)) end + ' - ' + case when [ProcedureCacheSizePercent Upper Bound] > 100 then '100' else cast(isnull([ProcedureCacheSizePercent Upper Bound],0) as nvarchar(50)) end,
	[ProcessorQueueLength] = case when isnull([ProcessorQueueLength Lower Bound],-1) < 0 then '0' else cast([ProcessorQueueLength Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([ProcessorQueueLength Upper Bound],0) as nvarchar(50)),
	[ProcessorTimePercent] = case when isnull([ProcessorTimePercent Lower Bound],-1) < 0 then '0' else cast([ProcessorTimePercent Lower Bound] as nvarchar(50)) end + ' - ' + case when [ProcessorTimePercent Upper Bound] > 100 then '100' else cast(isnull([ProcessorTimePercent Upper Bound],0) as nvarchar(50)) end,
	[ReadAheadPagesPerSecond] = case when isnull([ReadAheadPagesPerSecond Lower Bound],-1) < 0 then '0' else cast([ReadAheadPagesPerSecond Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([ReadAheadPagesPerSecond Upper Bound],0) as nvarchar(50)),
	[ReplicationLatencyInSeconds] = case when isnull([ReplicationLatencyInSeconds Lower Bound],-1) < 0 then '0' else cast([ReplicationLatencyInSeconds Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([ReplicationLatencyInSeconds Upper Bound],0) as nvarchar(50)),
	[ReplicationSubscribed] = case when isnull([ReplicationSubscribed Lower Bound],-1) < 0 then '0' else cast([ReplicationSubscribed Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([ReplicationSubscribed Upper Bound],0) as nvarchar(50)),
	[ReplicationUndistributed] = case when isnull([ReplicationUndistributed Lower Bound],-1) < 0 then '0' else cast([ReplicationUndistributed Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([ReplicationUndistributed Upper Bound],0) as nvarchar(50)),
	[ReplicationUnsubscribed] = case when isnull([ReplicationUnsubscribed Lower Bound],-1) < 0 then '0' else cast([ReplicationUnsubscribed Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([ReplicationUnsubscribed Upper Bound],0) as nvarchar(50)),
	[ResponseTimeInMilliseconds] = case when isnull([ResponseTimeInMilliseconds Lower Bound],-1) < 0 then '0' else cast([ResponseTimeInMilliseconds Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([ResponseTimeInMilliseconds Upper Bound],0) as nvarchar(50)),
	[SqlCompilationsPerSecond] = case when isnull([SqlCompilationsPerSecond Lower Bound],-1) < 0 then '0' else cast([SqlCompilationsPerSecond Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([SqlCompilationsPerSecond Upper Bound],0) as nvarchar(50)),
	[SqlMemoryAllocatedInMegabytes] = case when isnull([SqlMemoryAllocatedInKilobytes Lower Bound]/1024,-1) < 0 then '0' else cast(convert(dec(20,1),[SqlMemoryAllocatedInKilobytes Lower Bound]/1024) as nvarchar(50)) end + ' MB - ' + cast(isnull(convert(dec(20,1),[SqlMemoryAllocatedInKilobytes Upper Bound]/1024),0) as nvarchar(50))+ ' MB',
	[SqlMemoryUsedInMegabytes] = case when isnull([SqlMemoryUsedInKilobytes Lower Bound]/1024,-1) < 0 then '0' else cast(convert(dec(20,1),[SqlMemoryUsedInKilobytes Lower Bound]/1024) as nvarchar(50)) end + ' MB - ' + cast(isnull(convert(dec(20,1),[SqlMemoryUsedInKilobytes Upper Bound]/1024),0) as nvarchar(50))+ ' MB',
	[SqlRecompilationsPerSecond] = case when isnull([SqlRecompilationsPerSecond Lower Bound],-1) < 0 then '0' else cast([SqlRecompilationsPerSecond Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([SqlRecompilationsPerSecond Upper Bound],0) as nvarchar(50)),
	[SystemProcesses] = case when isnull([SystemProcesses Lower Bound],-1) < 0 then '0' else cast([SystemProcesses Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([SystemProcesses Upper Bound],0) as nvarchar(50)),
	[SystemProcessesConsumingCPU] = case when isnull([SystemProcessesConsumingCPU Lower Bound],-1) < 0 then '0' else cast([SystemProcessesConsumingCPU Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([SystemProcessesConsumingCPU Upper Bound],0) as nvarchar(50)),
	[TableLockEscalationsPerSecond] = case when isnull([TableLockEscalationsPerSecond Lower Bound],-1) < 0 then '0' else cast([TableLockEscalationsPerSecond Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([TableLockEscalationsPerSecond Upper Bound],0) as nvarchar(50)),
	[TempDBSizeInKilobytes] = case when isnull([TempDBSizeInKilobytes Lower Bound],-1) < 0 then '0' else cast([TempDBSizeInKilobytes Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([TempDBSizeInKilobytes Upper Bound],0) as nvarchar(50)),
	[TempDBSizePercent] = case when isnull([TempDBSizePercent Lower Bound],-1) < 0 then '0' else cast([TempDBSizePercent Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([TempDBSizePercent Upper Bound],0) as nvarchar(50)),
	[BatchesPerSecond] = case when isnull([BatchesPerSecond Lower Bound],-1) < 0 then '0' else cast([BatchesPerSecond Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([BatchesPerSecond Upper Bound],0) as nvarchar(50)),
	[UserProcesses] = case when isnull([UserProcesses Lower Bound],-1) < 0 then '0' else cast([UserProcesses Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([UserProcesses Upper Bound],0) as nvarchar(50)),
	[UserProcessesConsumingCPU] = case when isnull([UserProcessesConsumingCPU Lower Bound],-1) < 0 then '0' else cast([UserProcessesConsumingCPU Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([UserProcessesConsumingCPU Upper Bound],0) as nvarchar(50)),
	[UserTimePercent] = case when isnull([UserTimePercent Lower Bound],-1) < 0 then '0' else cast([UserTimePercent Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([UserTimePercent Upper Bound],0) as nvarchar(50)),
	[UsedMemoryPercent] = case when isnull([UsedMemoryPercent Lower Bound],-1) < 0 then '0' else cast(convert(dec(20,1),[UsedMemoryPercent Lower Bound]*100) as nvarchar(50)) end + ' - ' + case when [UsedMemoryPercent Upper Bound] > 1 then '100' else cast(isnull(convert(dec(20,1),[UsedMemoryPercent Upper Bound]*100),0) as nvarchar(50)) end,
	[UsedSqlMemoryPercent] = case when isnull([UsedSqlMemoryPercent Lower Bound],-1) < 0 then '0' else cast(convert(dec(20,1),[UsedSqlMemoryPercent Lower Bound]*100) as nvarchar(50)) end + ' - ' + case when [UsedSqlMemoryPercent Upper Bound] > 1 then '100' else cast(isnull(convert(dec(20,1),[UsedSqlMemoryPercent Upper Bound]*100),0) as nvarchar(50)) end,
	[WorkFilesCreatedPerSecond] = case when isnull([WorkFilesCreatedPerSecond Lower Bound],-1) < 0 then '0' else cast([WorkFilesCreatedPerSecond Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([WorkFilesCreatedPerSecond Upper Bound],0) as nvarchar(50)),
	[WorkTablesCreatedPerSecond] = case when isnull([WorkTablesCreatedPerSecond Lower Bound],-1) < 0 then '0' else cast([WorkTablesCreatedPerSecond Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([WorkTablesCreatedPerSecond Upper Bound],0) as nvarchar(50)),
	[VMCPUUsage] = case when isnull([VMCPUUsage Lower Bound],-1) < 0 then '0' else cast([VMCPUUsage Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([VMCPUUsage Upper Bound],0) as nvarchar(50)),
	[VMCPUUsageMHz] = case when isnull([VMCPUUsageMHz Lower Bound],-1) < 0 then '0' else cast([VMCPUUsageMHz Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([VMCPUUsageMHz Upper Bound],0) as nvarchar(50)),
	[VMCPUReady] = case when isnull([VMCPUReady Lower Bound],-1) < 0 then '0' else cast([VMCPUReady Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([VMCPUReady Upper Bound],0) as nvarchar(50)),
	[VMCPUSwapWait] = case when isnull([VMCPUSwapWait Lower Bound],-1) < 0 then '0' else cast([VMCPUSwapWait Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([VMCPUSwapWait Upper Bound],0) as nvarchar(50)),
	[VMMemSwapInRate] = case when isnull([VMMemSwapInRate Lower Bound],-1) < 0 then '0' else cast([VMMemSwapInRate Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([VMMemSwapInRate Upper Bound],0) as nvarchar(50)),
	[VMMemSwapOutRate] = case when isnull([VMMemSwapOutRate Lower Bound],-1) < 0 then '0' else cast([VMMemSwapOutRate Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([VMMemSwapOutRate Upper Bound],0) as nvarchar(50)),
	[VMMemSwapped] = case when isnull([VMMemSwapped Lower Bound]/1024,-1) < 0 then '0' else cast(convert(dec(20,1),[VMMemSwapped Lower Bound]/1024) as nvarchar(50)) end + ' MB - ' + cast(isnull(convert(dec(20,1),[VMMemSwapped Upper Bound]/1024),0) as nvarchar(50)) + ' MB',
	[VMMemActive] = case when isnull([VMMemActive Lower Bound]/1024,-1) < 0 then '0' else cast(convert(dec(20,1),[VMMemActive Lower Bound]/1024) as nvarchar(50)) end + ' MB - ' + cast(isnull(convert(dec(20,1),[VMMemActive Upper Bound]/1024),0) as nvarchar(50)) + ' MB',
	[VMMemConsumed] = case when isnull([VMMemConsumed Lower Bound]/1024,-1) < 0 then '0' else cast(convert(dec(20,1),[VMMemConsumed Lower Bound]/1024) as nvarchar(50)) end + ' MB - ' + cast(isnull(convert(dec(20,1),[VMMemConsumed Upper Bound]/1024),0) as nvarchar(50)) + ' MB',
	[VMMemGranted] = case when isnull([VMMemGranted Lower Bound]/1024,-1) < 0 then '0' else cast(convert(dec(20,1),[VMMemGranted Lower Bound]/1024) as nvarchar(50)) end + ' MB - ' + cast(isnull(convert(dec(20,1),[VMMemGranted Upper Bound]/1024),0) as nvarchar(50)) + ' MB',
	[VMMemBalooned] = case when isnull([VMMemBalooned Lower Bound]/1024,-1) < 0 then '0' else cast(convert(dec(20,1),[VMMemBalooned Lower Bound]/1024) as nvarchar(50)) end + ' MB - ' + cast(isnull(convert(dec(20,1),[VMMemBalooned Upper Bound]/1024),0) as nvarchar(50)) + ' MB',
	[VMMemUsage] = case when isnull([VMMemUsage Lower Bound],-1) < 0 then '0' else cast([VMMemUsage Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([VMMemUsage Upper Bound],0) as nvarchar(50)),
	[VMDiskRead] = case when isnull([VMDiskRead Lower Bound],-1) < 0 then '0' else cast([VMDiskRead Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([VMDiskRead Upper Bound],0) as nvarchar(50)),
	[VMDiskWrite] = case when isnull([VMDiskWrite Lower Bound],-1) < 0 then '0' else cast([VMDiskWrite Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([VMDiskWrite Upper Bound],0) as nvarchar(50)),
	[VMDiskUsage] = case when isnull([VMDiskUsage Lower Bound],-1) < 0 then '0' else cast([VMDiskUsage Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([VMDiskUsage Upper Bound],0) as nvarchar(50)),
	[VMNetUsage] = case when isnull([VMNetUsage Lower Bound],-1) < 0 then '0' else cast([VMNetUsage Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([VMNetUsage Upper Bound],0) as nvarchar(50)),
	[VMNetTransmitted] = case when isnull([VMNetTransmitted Lower Bound],-1) < 0 then '0' else cast([VMNetTransmitted Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([VMNetTransmitted Upper Bound],0) as nvarchar(50)),
	[VMNetReceived] = case when isnull([VMNetReceived Lower Bound],-1) < 0 then '0' else cast([VMNetReceived Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([VMNetReceived Upper Bound],0) as nvarchar(50)),
	[ESXCPUUsage] = case when isnull([ESXCPUUsage Lower Bound],-1) < 0 then '0' else cast([ESXCPUUsage Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([ESXCPUUsage Upper Bound],0) as nvarchar(50)),
	[ESXCPUUsageMHz] = case when isnull([ESXCPUUsageMHz Lower Bound],-1) < 0 then '0' else cast([ESXCPUUsageMHz Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([ESXCPUUsageMHz Upper Bound],0) as nvarchar(50)),
	[ESXMemSwapInRate] = case when isnull([ESXMemSwapInRate Lower Bound],-1) < 0 then '0' else cast([ESXMemSwapInRate Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([ESXMemSwapInRate Upper Bound],0) as nvarchar(50)),
	[ESXMemSwapOutRate] = case when isnull([ESXMemSwapOutRate Lower Bound],-1) < 0 then '0' else cast([ESXMemSwapOutRate Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([ESXMemSwapOutRate Upper Bound],0) as nvarchar(50)),
	[ESXMemActive] = case when isnull([ESXMemActive Lower Bound]/1024,-1) < 0 then '0' else cast(convert(dec(20,1),[ESXMemActive Lower Bound]/1024) as nvarchar(50)) end + ' MB - ' + cast(isnull(convert(dec(20,1),[ESXMemActive Upper Bound]/1024),0) as nvarchar(50)) + ' MB',
	[ESXMemConsumed] = case when isnull([ESXMemConsumed Lower Bound]/1024,-1) < 0 then '0' else cast(convert(dec(20,1),[ESXMemConsumed Lower Bound]/1024) as nvarchar(50)) end + ' MB - ' + cast(isnull(convert(dec(20,1),[ESXMemConsumed Upper Bound]/1024),0) as nvarchar(50)) + ' MB',
	[ESXMemGranted] = case when isnull([ESXMemGranted Lower Bound]/1024,-1) < 0 then '0' else cast(convert(dec(20,1),[ESXMemGranted Lower Bound]/1024) as nvarchar(50)) end + ' MB - ' + cast(isnull(convert(dec(20,1),[ESXMemGranted Upper Bound]/1024),0) as nvarchar(50)) + ' MB',
	[ESXMemBalooned] = case when isnull([ESXMemBalooned Lower Bound]/1024,-1) < 0 then '0' else cast(convert(dec(20,1),[ESXMemBalooned Lower Bound]/1024) as nvarchar(50)) end + ' MB - ' + cast(isnull(convert(dec(20,1),[ESXMemBalooned Upper Bound]/1024),0) as nvarchar(50)) + ' MB',
	[ESXMemUsage] = case when isnull([ESXMemUsage Lower Bound],-1) < 0 then '0' else cast([ESXMemUsage Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([ESXMemUsage Upper Bound],0) as nvarchar(50)),
	[ESXDiskRead] = case when isnull([ESXDiskRead Lower Bound],-1) < 0 then '0' else cast([ESXDiskRead Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([ESXDiskRead Upper Bound],0) as nvarchar(50)),
	[ESXDiskWrite] = case when isnull([ESXDiskWrite Lower Bound],-1) < 0 then '0' else cast([ESXDiskWrite Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([ESXDiskWrite Upper Bound],0) as nvarchar(50)),
	[ESXDiskUsage] = case when isnull([ESXDiskUsage Lower Bound],-1) < 0 then '0' else cast([ESXDiskUsage Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([ESXDiskUsage Upper Bound],0) as nvarchar(50)),
	[ESXNetUsage] = case when isnull([ESXNetUsage Lower Bound],-1) < 0 then '0' else cast([ESXNetUsage Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([ESXNetUsage Upper Bound],0) as nvarchar(50)),
	[ESXNetTransmitted] = case when isnull([ESXNetTransmitted Lower Bound],-1) < 0 then '0' else cast([ESXNetTransmitted Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([ESXNetTransmitted Upper Bound],0) as nvarchar(50)),
	[ESXNetReceived] = case when isnull([ESXNetReceived Lower Bound],-1) < 0 then '0' else cast([ESXNetReceived Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([ESXNetReceived Upper Bound],0) as nvarchar(50)),
	[ESXDiskDeviceLatency] = case when isnull([ESXDiskDeviceLatency Lower Bound],-1) < 0 then '0' else cast([ESXDiskDeviceLatency Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([ESXDiskDeviceLatency Upper Bound],0) as nvarchar(50)),
	[ESXDiskKernelLatency] = case when isnull([ESXDiskKernelLatency Lower Bound],-1) < 0 then '0' else cast([ESXDiskKernelLatency Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([ESXDiskKernelLatency Upper Bound],0) as nvarchar(50)),
	[ESXDiskQueueLatency] = case when isnull([ESXDiskQueueLatency Lower Bound],-1) < 0 then '0' else cast([ESXDiskQueueLatency Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([ESXDiskQueueLatency Upper Bound],0) as nvarchar(50)),
	[ESXDiskTotalLatency] = case when isnull([ESXDiskTotalLatency Lower Bound],-1) < 0 then '0' else cast([ESXDiskTotalLatency Lower Bound] as nvarchar(50)) end + ' - ' + cast(isnull([ESXDiskTotalLatency Upper Bound],0) as nvarchar(50))
from #TempStatistics

drop table #TempStatistics

end
go

 
GO 

---------- P_GETSERVERSUMMARY.SQL
if (object_id('[p_GetServerSummary]') is not null)
begin
drop procedure [p_GetServerSummary]
end
go
create procedure [dbo].[p_GetServerSummary]
	@SQLServerID int,
	@UTCSnapshotCollectionDateTime datetime = null,
	@HistoryInMinutes int = null
as
begin
set transaction isolation level read uncommitted
declare @err int
declare @BeginDateTime datetime
declare @EndDateTime datetime

if (@UTCSnapshotCollectionDateTime is null)
	select @EndDateTime = (select max(UTCCollectionDateTime) from [ServerStatistics] where [SQLServerID] = @SQLServerID)
else
	select @EndDateTime = @UTCSnapshotCollectionDateTime

if (@HistoryInMinutes is null)
	select @BeginDateTime = @EndDateTime
else
	select @BeginDateTime = dateadd(n, -@HistoryInMinutes, @EndDateTime)

-- Get state overview data
select 
	[StateOverview] 
from 
	[ServerActivity] 
where 
	[SQLServerID] = @SQLServerID
	and [UTCCollectionDateTime] = @EndDateTime

-- Get trend data

;with cte_waitdata as
(
select
	pvt.UTCCollectionDateTime,
	[I/O],
	[Lock],
	[Memory],
	[Transaction Log],
	[Other],
	[Signal] = sum(WaitTimeInMilliseconds-ResourceWaitTimeInMilliseconds) / nullif(TimeDeltaInSeconds,0)
from
	(
	select
		UTCCollectionDateTime,
		Category = case when Category in ('I/O','Lock','Memory','Transaction Log') then Category else 'Other' end,
		ResourceWaitTimeMSPerSec = sum(ResourceWaitTimeInMilliseconds) / nullif(TimeDeltaInSeconds,0)
	from
		WaitStatisticsDetails wsd
		inner join WaitStatistics ws
		on wsd.WaitStatisticsID = ws.WaitStatisticsID
		inner join WaitTypes wt
		on wsd.WaitTypeID = wt.WaitTypeID
		inner join WaitCategories wc
		on wt.CategoryID = wc.CategoryID
	where
		wc.ExcludeFromCollection = 0 and
		[SQLServerID] = @SQLServerID and
		[UTCCollectionDateTime] between @BeginDateTime and @EndDateTime
	group by
		case when Category in ('I/O','Lock','Memory','Transaction Log') then Category else 'Other' end,
		UTCCollectionDateTime,
		TimeDeltaInSeconds
	) as PivotSource
pivot
	(
	sum(ResourceWaitTimeMSPerSec)
	for Category 
	in([I/O],[Lock],[Memory],[Transaction Log],[Other])
	) as pvt
inner join WaitStatistics ws2
on pvt.UTCCollectionDateTime = ws2.UTCCollectionDateTime
inner join WaitStatisticsDetails wsd2
on ws2.WaitStatisticsID = wsd2.WaitStatisticsID
group by
	ws2.UTCCollectionDateTime, 
	ws2.TimeDeltaInSeconds,
	pvt.UTCCollectionDateTime,
	[I/O],
	[Lock],
	[Memory],
	[Transaction Log],
	[Other]
), cte_TempdbFileData (UTCCollectionDateTime, UserObjectsInKilobytes, InternalObjectsInKilobytes,VersionStoreInKilobytes,MixedExtentsInKilobytes,UnallocatedSpaceInKilobytes)as
(
select
TempdbFileData.UTCCollectionDateTime,
sum(UserObjectsInKilobytes),
sum(InternalObjectsInKilobytes),
sum(VersionStoreInKilobytes),
sum(MixedExtentsInKilobytes),
sum(UnallocatedSpaceInKilobytes)
from TempdbFileData	
inner join DatabaseFiles on TempdbFileData.FileID = DatabaseFiles.FileID
inner join SQLServerDatabaseNames on SQLServerDatabaseNames.DatabaseID = DatabaseFiles.DatabaseID
where
	SQLServerID = @SQLServerID and
	TempdbFileData.UTCCollectionDateTime between @BeginDateTime and @EndDateTime
group by
UTCCollectionDateTime
)
select
	[InstanceName]
	,[ServerStatistics].[UTCCollectionDateTime] as [CollectionDateTime]
	,[ActiveProcesses]
	,[AgentServiceStatus]
	,[BlockedProcesses]
	,[BufferCacheHitRatioPercentage]
	,[BufferCacheSizeInKilobytes]
	,[CheckpointWrites] = isnull([CheckpointWrites],0)
	,[ClientComputers]
	,[CommittedInKilobytes]
	,[ConnectionMemoryInKilobytes]
	,[CPUActivityPercentage]
	,[CPUTimeDelta]
	,[CPUTimeRaw]
	,[DatabaseCount]
	,[DataFileCount]
	,[DataFileSpaceAllocatedInKilobytes]
	,[DataFileSpaceUsedInKilobytes]
	,[DiskTimePercent]
	,[DiskQueueLength]
	,[DistributionLatencyInSeconds]
	,[DTCServiceStatus]
	,[FreeCachePagesInKilobytes]
	,[CachePagesInKilobytes]
	,[FreePagesInKilobytes]
	,[FullScans]
	,[FullTextSearchStatus]
	,[GrantedWorkspaceMemoryInKilobytes]
	,[IdleTimeDelta]
	,[IdleTimePercentage]
	,[IdleTimeRaw]
	,[IOActivityPercentage]
	,[IOTimeDelta]
	,[IOTimeRaw]
	,[IsClustered]
	,[ClusterNodeName]
	,[LazyWriterWrites] = isnull([LazyWriterWrites],0)
	,[LeadBlockers]
	,[LockMemoryInKilobytes]
	,[LockStatistics]
	,[LockWaits]
	,[Logins]
	,[LogFileCount]
	,[LogFileSpaceAllocatedInKilobytes]
	,[LogFileSpaceUsedInKilobytes]
	,[LogFlushes]
	,[MaxConnections]
	,[OldestOpenTransactionsInMinutes]
	,[OpenTransactions]
	,[OptimizerMemoryInKilobytes]
	,[OSAvailableMemoryInKilobytes]
	,[OsStatisticAvailability]
	,[OSTotalPhysicalMemoryInKilobytes]
	,[PacketErrors]
	,[PacketsReceived]
	,[PacketsSent]
	,[PageErrors]
	,[PageLifeExpectancy]
	,[PageLookups]
	,[PageReads] = isnull([PageReads],0)
	,[PagesPerSecond]
	,[PageSplits]
	,[PageWrites] = isnull([PageWrites],0)
	,[PrivilegedTimePercent]
	,[ProcedureCacheHitRatioPercentage]
	,[ProcedureCacheSizeInKilobytes]
	,[ProcedureCacheSizePercent]
	,[ProcessorCount]
	,[ProcessorsUsed]
	,[ProcessorTimePercent]
	,[ProcessorQueueLength]
	,[ReadAheadPages] = isnull([ReadAheadPages],0)
	,[ServerHostName]
	,[ServerStatistics].[RealServerName]
	,[ReplicationLatencyInSeconds]
	,[ReplicationSubscribed]
	,[ReplicationUndistributed]
	,[ReplicationUnsubscribed]
	,[ResponseTimeInMilliseconds]
	,[RunningSince]
	,[ServerStatistics].[ServerVersion]
	,[SqlCompilations]
	,[SqlMemoryAllocatedInKilobytes]
	,[SqlMemoryUsedInKilobytes]
	,[SqlRecompilations]
	,[SqlServerEdition]
	,[SqlServerServiceStatus]
	,[ServerStatistics].[SystemProcesses]
	,[SystemProcessesConsumingCPU]
	,[TableLockEscalations]
	,[TempDBSizeInKilobytes]
	,[TempDBSizePercent]
	,[TimeDeltaInSeconds]
	,[TotalLocks]
	,[Transactions]
	,[Batches]
	,[UserProcesses]
	,[UserProcessesConsumingCPU]
	,[UserTimePercent]
	,[WindowsVersion]
	,[WorkFilesCreated]
	,[WorkTablesCreated]
	,[I/O]
	,[Lock]
	,[Memory]
	,[Transaction Log]
	,[Other]
	,[Signal]
	,[VMConfigData].UUID as [vmUUID]
	,[VMConfigData].VMHeartBeat as [vmHeartBeat]
	,[VMConfigData].VMName as [vmName] 
	,[VMConfigData].BootTime as [vmBootTime]
	,[VMConfigData].CPULimit as [vmCPULimit] 
	,[VMConfigData].CPUReserve as [vmCPUReserve]
	,[VMConfigData].DomainName as [vmDomainName]
	,[VMConfigData].MemLimit as [vmMemLimit]
	,[VMConfigData].MemReserve as [vmMemReserve]
	,[VMConfigData].MemSize as [vmMemSize]
	,[VMConfigData].NumCPUs as [vmNumCPUs]
	,[VMStatistics].CPUReady as [vmCPUReady]
	,[VMStatistics].CPUSwapWait as [vmCPUSwapWait]
	,[VMStatistics].CPUUsage as [vmCPUUsage]
	,[VMStatistics].CPUUsageMHz as [vmCPUUsageMHz]
	,[VMStatistics].DiskRead as [vmDiskRead]
	,[VMStatistics].DiskUsage as [vmDiskUsage]
	,[VMStatistics].DiskWrite as [vmDiskWrite]
	,[VMStatistics].MemActive as [vmMemActive]
	,[VMStatistics].MemBalooned as [vmMemBallooned]
	,[VMStatistics].MemConsumed as [vmMemConsumed]
	,[VMStatistics].MemGranted as [vmMemGranted]
	,[VMStatistics].MemSwapInRate as [vmMemSwapInRate]
	,[VMStatistics].MemSwapOutRate as [vmMemSwapOutRate]
	,[VMStatistics].MemSwapped as [vmMemSwapped]
	,[VMStatistics].MemUsage as [vmMemUsage]
	,[VMStatistics].NetReceived as [vmNetReceived]
	,[VMStatistics].NetTransmitted as [vmNetTransmitted]
	,[VMStatistics].NetUsage as [vmNetUsage]
	,[VMStatistics].PagePerSecVM as [PagePerSecVM]
	,[VMStatistics].AvailableByteVm as [AvailableByteVm]
	,[ESXConfigData].HostName as [esxHostName]
	,[ESXConfigData].Status as [esxStatus]
	,[ESXConfigData].BootTime as [esxBootTime]
	,[ESXConfigData].CPUMHz as [esxCPUMHz]
	,[ESXConfigData].DomainName as [esxDomainName]
	,[ESXConfigData].MemorySize as [esxMemSize]
	,[ESXConfigData].NumCPUCores as [esxNumCPUCores]
	,[ESXConfigData].NumCPUPkgs as [esxNumCPUPkgs]
	,[ESXConfigData].NumCPUThreads as [esxNumCPUThreads]
	,[ESXConfigData].NumNICs as [esxNumNICs]
	,[ESXStatistics].CPUUsage as [esxCPUUsage]
	,[ESXStatistics].CPUUsageMHz as [esxCPUUsageMHz]
	,[ESXStatistics].DiskDeviceLatency as [esxDeviceLatency]
	,[ESXStatistics].DiskKernelLatency as [esxKernelLatency]
	,[ESXStatistics].DiskQueueLatency as [esxQueueLatency]
	,[ESXStatistics].DiskRead as [esxDiskRead]
	,[ESXStatistics].DiskTotalLatency as [esxTotalLatency]
	,[ESXStatistics].DiskUsage as [esxDiskUsage]
	,[ESXStatistics].DiskWrite as [esxDiskWrite]
	,[ESXStatistics].MemActive as [esxMemActive]
	,[ESXStatistics].MemBalooned as [esxMemBallooned]
	,[ESXStatistics].MemConsumed as [esxMemConsumed]
	,[ESXStatistics].MemGranted as [esxMemGranted]
	,[ESXStatistics].MemSwapInRate as [esxMemSwapInRate]
	,[ESXStatistics].MemSwapOutRate as [esxMemSwapOutRate]
	,[ESXStatistics].MemUsage as [esxMemUsage]
	,[ESXStatistics].NetReceived as [esxNetReceived]
	,[ESXStatistics].NetTransmitted as [esxNetTransmitted]
	,[ESXStatistics].NetUsage as [esxNetUsage]
	,[ESXStatistics].MemPagePerSec as [pagePerSecHost]
	,[ESXStatistics].AvailableMemBytes as [availableByteHost]
	,TempdbUserObjectsInMegabytes = [cte_TempdbFileData].UserObjectsInKilobytes / 1024.0
	,TempdbInternalObjectsInMegabytes = [cte_TempdbFileData].InternalObjectsInKilobytes / 1024.0
	,TempdbVersionStoreInMegabytes = [cte_TempdbFileData].VersionStoreInKilobytes / 1024.0
	,TempdbMixedExtentsInMegabytes = [cte_TempdbFileData].MixedExtentsInKilobytes / 1024.0
	,TempdbUnallocatedSpaceInMegabytes = [cte_TempdbFileData].UnallocatedSpaceInKilobytes / 1024.0
	,TempdbPFSWaitTimeMilliseconds
	,TempdbGAMWaitTimeMilliseconds
	,TempdbSGAMWaitTimeMilliseconds
	,VersionStoreGenerationKilobytesPerSec = VersionStoreGenerationKilobytes / nullif(TimeDeltaInSeconds,0)
	,VersionStoreCleanupKilobytesPerSec = VersionStoreCleanupKilobytes  / nullif(TimeDeltaInSeconds,0)
from
	[ServerStatistics]
	left join [MonitoredSQLServers]
	on [ServerStatistics].[SQLServerID] = [MonitoredSQLServers].[SQLServerID]
	left join [OSStatistics]
	on [ServerStatistics].[SQLServerID] = [OSStatistics].[SQLServerID]
	and [ServerStatistics].[UTCCollectionDateTime] = [OSStatistics].[UTCCollectionDateTime]
	left join [ServerActivity]
	on [ServerStatistics].[SQLServerID] = [OSStatistics].[SQLServerID]
	and [ServerStatistics].[UTCCollectionDateTime] = [ServerActivity].[UTCCollectionDateTime]
	left join cte_waitdata
	on [ServerStatistics].[UTCCollectionDateTime] = cte_waitdata.[UTCCollectionDateTime]
	left join [VMConfigData]
		on [ServerStatistics].[SQLServerID] = [VMConfigData].[SQLServerID] 
		and [ServerStatistics].[UTCCollectionDateTime] = [VMConfigData].[UTCCollectionDateTime] 
	left join [VMStatistics] 
		on [ServerStatistics].SQLServerID = [VMStatistics].SQLServerID 
		and [ServerStatistics].UTCCollectionDateTime = [VMStatistics].UTCCollectionDateTime 
	left join [ESXConfigData]
		on [ServerStatistics].SQLServerID = [ESXConfigData].SQLServerID 
		and [ServerStatistics].UTCCollectionDateTime = [ESXConfigData].UTCCollectionDateTime 
	left join [ESXStatistics] 
		on [ServerStatistics].SQLServerID = [ESXStatistics].SQLServerID 
		and [ServerStatistics].UTCCollectionDateTime = [ESXStatistics].UTCCollectionDateTime 
	left join cte_TempdbFileData
		on [ServerStatistics].[UTCCollectionDateTime] = cte_TempdbFileData.UTCCollectionDateTime
where
	[ServerStatistics].[SQLServerID] = @SQLServerID
	and [ServerStatistics].[UTCCollectionDateTime] between @BeginDateTime and @EndDateTime
order by 
	[ServerStatistics].[UTCCollectionDateTime]

-- Get distinct disk drives
select distinct [DriveName] from [DiskDrives] where [SQLServerID] = @SQLServerID

-- Get per disk metrics
select
	[UTCCollectionDateTime] as [CollectionDateTime],
	[DriveName],
	[UnusedSizeKB],
	[TotalSizeKB],
	[DiskIdlePercent],
	[AverageDiskQueueLength],
	[AverageDiskMillisecondsPerRead],
	[AverageDiskMillisecondsPerTransfer],
	[AverageDiskMillisecondsPerWrite],
	[DiskReadsPerSecond],
	[DiskTransfersPerSecond],
	[DiskWritesPerSecond],
	(100 - [DiskIdlePercent]) as [DiskBusyPercent]
from 
	[DiskDrives]
where
	[SQLServerID] = @SQLServerID and
	[UTCCollectionDateTime] between @BeginDateTime and @EndDateTime
order by 
	[UTCCollectionDateTime]


select @err = @@error
return @err
end
 
GO 

---------- P_GETSERVERSUMMARYREPORT.SQL
if (object_id('p_GetServerSummaryReport') is not null)
begin
drop procedure [p_GetServerSummaryReport]
end
go
create procedure [dbo].[p_GetServerSummaryReport]
				@ServerID int,
				@UTCOffset int = null,
				@StartTime DateTime = null,
				@EndTime DateTime = null
as
begin
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

set @EndTime = ISNULL(@EndTime, GetutcDate())
set @UTCOffset = ISNULL(@UTCOffset, datediff(mi, getutcdate(), getdate()))
set @StartTime = ISNULL(@StartTime, CONVERT(CHAR(8),getutcdate(),112))

-- @Interval - Granularity of calculation:
--	0 - Minutes
--	1 - Hours
--	2 - Days
--	3 - Months
--	4 - Years
	select
		@ServerID as ServerID
		,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime]) as [LastCollectioninInterval]
		,CPUActivityPercentage
		,DiskTimePercent
		,[OSTotalPhysicalMemoryInKilobytes] - [OSAvailableMemoryInKilobytes] as [MemoryAvailable]
		,[ResponseTimeInMilliseconds]
		,[SystemProcesses] + UserProcesses as SessionCount
	from
		[ServerStatistics] s1 (nolock)
		left join [MonitoredSQLServers] m (nolock)
		on m.[SQLServerID] = s1.[SQLServerID]
		left join [OSStatistics] o (nolock)
		on o.[SQLServerID] = s1.[SQLServerID] and o.[UTCCollectionDateTime] = s1.[UTCCollectionDateTime]
	where
		s1.[SQLServerID] = @ServerID
		and m.[Active] = 1
		and s1.[UTCCollectionDateTime] between @StartTime and @EndTime
	order by
		s1.[UTCCollectionDateTime]
end
 
GO 

---------- P_GETSERVERSWITHTAGID.SQL
IF (object_id('p_GetServersWithTagId') IS NOT NULL)
BEGIN
DROP PROCEDURE p_GetServersWithTagId
END
GO

CREATE PROCEDURE [dbo].[p_GetServersWithTagId]
(
	@TagId INT,
	@addSelectRequest bit = 0
)
AS
BEGIN
	create table #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

	insert into #SecureMonitoredSQLServers
	exec [p_GetReportServers]
	
	if @addSelectRequest=1
	begin
		if @TagId = 0
		begin
			SELECT 0 as 'SQLServerId','< All Servers >' as 'InstanceName'
			union
			SELECT ms.[SQLServerID], ms.[InstanceName]
			FROM #SecureMonitoredSQLServers ms (nolock)
		end
	else 
        begin
			SELECT 0 as 'SQLServerId','< All Servers >' as 'InstanceName'
			union
			SELECT ms.[SQLServerID], [InstanceName]
			FROM [ServerTags] st (nolock)
			LEFT JOIN #SecureMonitoredSQLServers ms (nolock)
			ON st.SQLServerId = ms.SQLServerID
			WHERE st.[TagId] = @TagId
	     end
	end 
	else
		SELECT ms.[SQLServerID], [InstanceName]
		FROM [ServerTags] st (nolock)
		LEFT JOIN #SecureMonitoredSQLServers ms (nolock)
		ON st.SQLServerId = ms.SQLServerID
		WHERE st.[TagId] = @TagId
END
 
GO 

---------- P_GETSERVERTAGS.SQL
IF (object_id('p_GetServerTags') IS NOT NULL)
BEGIN
DROP PROCEDURE p_GetServerTags
END
GO

CREATE PROCEDURE [dbo].[p_GetServerTags]
(
	@SQLServerId INT
)
AS
BEGIN
	SELECT [TagId], [Name] as [TagName]
	FROM [ServerTags]
	LEFT JOIN [Tags]
	ON TagId = Id
	WHERE [SQLServerId] = @SQLServerId
END
 
GO 

---------- P_GETSERVERTIMELINE.SQL
if (object_id('p_GetServerTimeline') is not null)
begin
drop procedure [p_GetServerTimeline]
end
go

create procedure [p_GetServerTimeline]
	@ServerName nvarchar(256),
	@UTCStart DateTime,
	@UTCEnd DateTime
as
begin
	
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	
	select 
		top 1000
		AlertID,
		UTCOccurrenceDateTime,
		DatabaseName,
		TableName,
		Active,
		Category,
		A.Metric,
		Severity,
		Rank,
		StateEvent,
		Value,
		Heading
		
	from Alerts A
		inner join MetricInfo I
			on I.Metric = A.Metric
		
	where 
		--Active = 1
		ServerName = @ServerName				
		and UTCOccurrenceDateTime between @UTCStart and @UTCEnd

	order by UTCOccurrenceDateTime desc, Severity desc, Rank desc
	
end
 
GO 

---------- P_GETSERVERWIDESTATISTICS.SQL
if (object_id('[p_GetServerWideStatistics]') is not null)
begin
drop procedure [p_GetServerWideStatistics]
end
go
create procedure [dbo].[p_GetServerWideStatistics]
	@XmlDocument nvarchar(max) = null,
	@IncludeActiveOnly bit = 1,
	@SQLServerID int = null,
	@StartTime datetime = null,
	@EndTime datetime = null
as
begin
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

declare @SQLServers table(
			SQLServerID int,
			InstanceName nvarchar(256),
			LastScheduledCollectionTime datetime,
			primary key (InstanceName)) 

declare @xmlDoc int
declare @ServerCount int
set @ServerCount = 0

if @XmlDocument is not null 
begin
	-- Prepare XML document if there is one
	exec sp_xml_preparedocument @xmlDoc output, @XmlDocument

	insert into @SQLServers
	select 
		X.[SQLServerID],MSS.[InstanceName],MSS.[LastScheduledCollectionTime]
	from MonitoredSQLServers MSS, 
		openxml(@xmlDoc, '//SQLServer', 1)
		with (SQLServerID int) X
		where X.SQLServerID = MSS.SQLServerID

	set @ServerCount = @@ROWCOUNT

	exec sp_xml_removedocument @xmlDoc
end

if @SQLServerID is not null
begin
	insert into @SQLServers 
		select [SQLServerID],[InstanceName],[LastScheduledCollectionTime] from [MonitoredSQLServers]
			where [SQLServerID] = @SQLServerID and			
				((@IncludeActiveOnly is null or @IncludeActiveOnly = 0) or ([Active] = 1))

	set @ServerCount = @ServerCount + 1
end

if (@ServerCount = 0)
begin
	insert into @SQLServers 
		select [SQLServerID],[InstanceName],[LastScheduledCollectionTime] from [MonitoredSQLServers]
			where ((@IncludeActiveOnly is null or @IncludeActiveOnly = 0) or ([Active] = 1))
end

if (@StartTime is null) and (@EndTime is null)
begin
	select
		S.[SQLServerID]
		,[InstanceName]
		,SS.[UTCCollectionDateTime]
		,[AgentServiceStatus]
		,[BlockedProcesses]
		,[BufferCacheHitRatioPercentage]
		,[CheckpointWrites]
		,[ClientComputers]
		,[CPUActivityPercentage]
		,[CPUTimeDelta]
		,[CPUTimeRaw]
		,[DiskQueueLength]
		,[DiskTimePercent]
		,[DTCServiceStatus]
		,[FullScans]
		,[FullTextSearchStatus]
		,[IdleTimeDelta]
		,[IdleTimePercentage]
		,[IdleTimeRaw]
		,[IOActivityPercentage]
		,[IOTimeDelta]
		,[IOTimeRaw]
		,[LazyWriterWrites]
		,[LockWaits]
		,[Logins]
		,[LogFlushes]
		,[OldestOpenTransactionsInMinutes]
		,[OpenTransactions]
		,[OSAvailableMemoryInKilobytes]
		,[OSTotalPhysicalMemoryInKilobytes]  
		,[PacketErrors]
		,[PacketsReceived]
		,[PacketsSent]
		,[PageErrors]
		,[PageLifeExpectancy]
		,[PageLookups]
		,[PageReads]
		,[PagesPerSecond] 
		,[PageSplits]
		,[PageWrites]
		,[PrivilegedTimePercent]
		,[ProcedureCacheHitRatioPercentage]
		,[ProcedureCacheSizeInKilobytes]
		,[ProcedureCacheSizePercent]
		,[ProcessorQueueLength]
		,[ProcessorTimePercent]
		,[ReadAheadPages]
		,[ReplicationLatencyInSeconds]
		,[ReplicationSubscribed]
		,[ReplicationUndistributed]
		,[ReplicationUnsubscribed]
		,[ResponseTimeInMilliseconds]
		,SS.[ServerVersion]
		,[SqlCompilations]
		,([SqlMemoryAllocatedInKilobytes]/1024) as [SqlMemoryAllocatedInMegabytes]
		,([SqlMemoryUsedInKilobytes]/1024) as [SqlMemoryUsedInMegabytes]
		,[SqlRecompilations]
		,[SqlServerServiceStatus]
		,[SystemProcesses]
		,[SystemProcessesConsumingCPU]
		,[TableLockEscalations]
		,[TempDBSizeInKilobytes]
		,[TempDBSizePercent]
		,[Batches]
		,[UserProcesses]
		,[UserProcessesConsumingCPU]
		,[UserTimePercent]
		,[WorkFilesCreated]
		,[WorkTablesCreated]
		,[SQLBrowserServiceStatus]     --SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --fetch the status of SQL Browser service
		,[SQLActiveDirectoryHelperServiceStatus]  --SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --fetch the status of SQL Active Directory Helper service
	from
		@SQLServers S
		join [ServerStatistics] SS on S.SQLServerID = SS.SQLServerID
		left join [OSStatistics] 
			on SS.[SQLServerID] = [OSStatistics].[SQLServerID] and
			   SS.[UTCCollectionDateTime] = [OSStatistics].[UTCCollectionDateTime]
	where
		SS.[UTCCollectionDateTime] = S.[LastScheduledCollectionTime]
--		SS.[UTCCollectionDateTime] = (select max(S2.[UTCCollectionDateTime]) from [ServerStatistics] S2 where SS.[SQLServerID] = S2.[SQLServerID])
	order by 
		[InstanceName],
		SS.[UTCCollectionDateTime]
end
else
	select
		SS.[SQLServerID]
		,[InstanceName]
		,SS.[UTCCollectionDateTime]
		,[AgentServiceStatus]
		,[BlockedProcesses]
		,[BufferCacheHitRatioPercentage]
		,[CheckpointWrites]
		,[ClientComputers]
		,[CPUActivityPercentage]
		,[CPUTimeDelta]
		,[CPUTimeRaw]
		,[DiskQueueLength]
		,[DiskTimePercent]
		,[DTCServiceStatus]
		,[FullScans]
		,[FullTextSearchStatus]
		,[IdleTimeDelta]
		,[IdleTimePercentage]
		,[IdleTimeRaw]
		,[IOActivityPercentage]
		,[IOTimeDelta]
		,[IOTimeRaw]
		,[LazyWriterWrites]
		,[LockWaits]
		,[Logins]
		,[LogFlushes]
		,[OldestOpenTransactionsInMinutes]
		,[OpenTransactions]
		,[OSAvailableMemoryInKilobytes]
		,[OSTotalPhysicalMemoryInKilobytes]  
		,[PacketErrors]
		,[PacketsReceived]
		,[PacketsSent]
		,[PageErrors]
		,[PageLifeExpectancy]
		,[PageLookups]
		,[PageReads]
		,[PagesPerSecond] 
		,[PageSplits]
		,[PageWrites]
		,[PrivilegedTimePercent]
		,[ProcedureCacheHitRatioPercentage]
		,[ProcedureCacheSizeInKilobytes]
		,[ProcedureCacheSizePercent]
		,[ProcessorQueueLength]
		,[ProcessorTimePercent]
		,[ReadAheadPages]
		,[ReplicationLatencyInSeconds]
		,[ReplicationSubscribed]
		,[ReplicationUndistributed]
		,[ReplicationUnsubscribed]
		,[ResponseTimeInMilliseconds]
		,SS.[ServerVersion]
		,[SqlCompilations]
		,([SqlMemoryAllocatedInKilobytes]/1024) as [SqlMemoryAllocatedInMegabytes]
		,([SqlMemoryUsedInKilobytes]/1024) as [SqlMemoryUsedInMegabytes]
		,[SqlRecompilations]
		,[SqlServerServiceStatus]
		,[SystemProcesses]
		,[SystemProcessesConsumingCPU]
		,[TableLockEscalations]
		,[TempDBSizeInKilobytes]
		,[TempDBSizePercent]
		,[Batches]
		,[UserProcesses]
		,[UserProcessesConsumingCPU]
		,[UserTimePercent]
		,[WorkFilesCreated]
		,[WorkTablesCreated]
		,[SQLBrowserServiceStatus]     --SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --fetch the status of SQL Browser service
		,[SQLActiveDirectoryHelperServiceStatus]  --SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --fetch the status of SQL Active Directory Helper service
	from
		@SQLServers S
		join [ServerStatistics] SS on S.SQLServerID = SS.SQLServerID
		left join [OSStatistics] 
			on SS.[SQLServerID] = [OSStatistics].[SQLServerID] and
			   SS.[UTCCollectionDateTime] = [OSStatistics].[UTCCollectionDateTime]
	where
		SS.[UTCCollectionDateTime] <= coalesce(@EndTime,SS.[UTCCollectionDateTime]) and
		SS.[UTCCollectionDateTime] >= coalesce(@StartTime,SS.[UTCCollectionDateTime])
	order by 
		[InstanceName],
		SS.[UTCCollectionDateTime]

end
 
GO 

---------- P_GETSESSIONLIST.SQL
--SQLdm 9.1 (Sanjali Makkar)
--To get Session List

IF (object_id('p_GetSessionList') IS NOT NULL)
BEGIN
	DROP PROCEDURE [p_GetSessionList]
END
GO

-- EXEC [p_GetSessionList] 1

CREATE PROCEDURE [dbo].[p_GetSessionList]
@SQLServerID INT = NULL 
AS
BEGIN

	;WITH MaxCollTime (SQLServerID,UTCCollectionDateTime) AS (
	  SELECT MS.SQLServerID, MAX(SA.UTCCollectionDateTime)
	  FROM [ServerActivity] SA (nolock)
		JOIN MonitoredSQLServers MS (nolock)
		  ON SA.SQLServerID = MS.SQLServerID
	  WHERE MS.Active = 1 AND (@SQLServerID IS NULL OR SA.SQLServerID = @SQLServerID)
	  GROUP BY MS.SQLServerID
		)
	SELECT
		SA.SQLServerID, MS.InstanceName, SA.UTCCollectionDateTime, SA.SessionList
	FROM
	 	MaxCollTime MCT (nolock) INNER JOIN  [ServerActivity] SA (nolock) 
		ON  MCT.SQLServerID = SA.SQLServerID AND MCT.UTCCollectionDateTime = SA.UTCCollectionDateTime
		JOIN MonitoredSQLServers MS ON MS.SQLServerID = MCT.SQLServerID 
END
 
GO

 
GO 

---------- P_GETSESSIONSDETAILS.SQL
if (object_id('[p_GetSessionsDetails]') is not null)
begin
drop procedure [p_GetSessionsDetails]
end
go

create procedure [dbo].[p_GetSessionsDetails]
	@SQLServerID int,
	@UTCSnapshotCollectionDateTime datetime = null
as
begin
set transaction isolation level read uncommitted
declare @err int

if (@UTCSnapshotCollectionDateTime is null)
	select @UTCSnapshotCollectionDateTime = (select max(UTCCollectionDateTime) from [ServerActivity] where [SQLServerID] = @SQLServerID)

select
	[InstanceName]
	,[UTCCollectionDateTime]
	,[SessionList]
from
	[ServerActivity]
	left join [MonitoredSQLServers]
	on [ServerActivity].[SQLServerID] = [MonitoredSQLServers].[SQLServerID]
where
	[ServerActivity].[SQLServerID] = @SQLServerID
	and [ServerActivity].[UTCCollectionDateTime] = @UTCSnapshotCollectionDateTime

select @err = @@error
return @err
end
go
 
GO 

---------- P_GETSESSIONSSUMMARY.SQL
if (object_id('[p_GetSessionsSummary]') is not null)
begin
drop procedure [p_GetSessionsSummary]
end
go
CREATE PROCEDURE [dbo].[p_GetSessionsSummary]
		@ServerID int,
		@UTCStart DateTime,
		@UTCEnd DateTime,
		@UTCOffset int,
		@Interval tinyint
AS
BEGIN

-- @Interval - Granularity of calculation:
--	0 - Minutes
--	1 - Hours
--	2 - Days
--	3 - Months
--	4 - Years

select m.InstanceName
		,dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime]))) as [LastCollectioninInterval],
		sum(s1.[ClientComputers] * TimeDeltaInSeconds) / nullif(sum(case when s1.[ClientComputers] is not null then TimeDeltaInSeconds else 0 end),0) as ClientComputers,
		sum(s1.[UserProcesses] * TimeDeltaInSeconds) / nullif(sum(case when s1.[UserProcesses] is not null then TimeDeltaInSeconds else 0 end),0) as UserProcesses,
		sum(convert(float,s1.[Logins])) / nullif((sum(convert(float,case when s1.[Logins] is not null then TimeDeltaInSeconds else 0 end)) / 60) ,0)as Logins,
		sum(convert(float,s1.[PacketErrors])) / nullif((sum(convert(float,case when s1.[PacketErrors] is not null then TimeDeltaInSeconds else 0 end)) / 60) ,0)as PacketErrors,
		sum(convert(float,s1.[PacketsReceived])) / nullif((sum(convert(float,case when s1.[PacketsReceived] is not null then TimeDeltaInSeconds else 0 end)) / 60) ,0)as PacketsReceived,
		sum(convert(float,s1.[PacketsSent])) / nullif((sum(convert(float,case when s1.[PacketsSent] is not null then TimeDeltaInSeconds else 0 end)) / 60) ,0)as PacketsSent,
		sum(convert(float,s1.[Transactions])) / nullif((sum(convert(float,case when s1.[Transactions] is not null then TimeDeltaInSeconds else 0 end)) / 60) ,0)as Transactions,
		max(s1.[OldestOpenTransactionsInMinutes]) as OldestOpenTransactionsInMinutes,
		ClientComputersMean = (select TOP 1 Mean	--'%ClientComputers%' -- 57
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = 57 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc),
		UserProcessesMean = (select TOP 1 Mean	--'%UserProcesses%' -- -78
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -78 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc),		
		LoginsMean = (select TOP 1 Mean --'%Logins%' -- -137
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -137 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc),
		PacketErrorsMean = (select TOP 1 Mean	--'%PacketErrors%' -- -43
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = -43 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc) * 60,
		PacketsReceivedMean = (select TOP 1 Mean	--'%PacketsReceived%' -- -45
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = -45 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc) * 60,		
		PacketsSentMean = (select TOP 1 Mean --'%PacketsSent%' -- -47
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = -47 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc) * 60,				
		TransactionsMean = (select TOP 1 Mean	--'%Transactions%' -- -7
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = -7 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc),
		OldestOpenTransactionsInMinutesMean = (select TOP 1 Mean	--'%OldestOpenTransactionsInMinutes%' -- 6
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = 6 and dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, UTCCalculation)) = MAX(dbo.fn_RoundDateTime(2, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])))
				order by UTCCalculation desc)				

	from
		[MonitoredSQLServers] m (nolock)
		left join [ServerStatistics] s1 (nolock)
		on m.[SQLServerID] = s1.[SQLServerID]
	where
		s1.[SQLServerID] = @ServerID
		and dbo.fn_RoundDateTime(@Interval, s1.[UTCCollectionDateTime]) between @UTCStart and @UTCEnd
group by
		[InstanceName]
		-- Always group by year at the least
		,datepart(yy, dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime]))
		-- Group by all intervals greater than or equal to the selected interval
		,case when @Interval <= 3 then datepart(mm,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
		,case when @Interval <= 2 then datepart(dd,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
		,case when @Interval <= 1 then datepart(hh,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
		,case when @Interval =  0 then datepart(mi,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, s1.[UTCCollectionDateTime])) end
END
 
GO 

---------- P_GETSESSIONSTATISTICSFORWEBCONSOLE.SQL
if (object_id('p_GetSessionStatisticsForWebConsole') is not null)
begin
drop procedure p_GetSessionStatisticsForWebConsole
end
GO

create procedure [dbo].[p_GetSessionStatisticsForWebConsole]
	@SQLServerID int,
	@HistoryInMinutes int = null
as
begin
set transaction isolation level read uncommitted
declare @err int

declare @BeginDateTime datetime
declare @EndDateTime datetime  
SELECT @EndDateTime= (select max(UTCCollectionDateTime) from [ServerActivity] (NOLOCK) where [SQLServerID] = @SQLServerID)

if (@HistoryInMinutes is null)
	select @BeginDateTime = @EndDateTime
else
	select @BeginDateTime = dateadd(n, -@HistoryInMinutes, @EndDateTime)

-- Get session and lock list for requested snapshot
select
	ss.SQLServerID
	,mss.InstanceName
	,ss.UTCCollectionDateTime
	,ss.ResponseTimeInMilliseconds
	,ss.UserProcesses
	,sa.SessionList
	,sa.LockStatistics
from 
	[ServerActivity] sa (NOLOCK)
	LEFT JOIN ServerStatistics ss (NOLOCK) ON sa.SQLServerID = ss.SQLServerID 
		AND sa.UTCCollectionDateTime = ss.UTCCollectionDateTime
	INNER join [MonitoredSQLServers] mss (NOLOCK)
	on sa.SQLServerID = mss.SQLServerID
where 
	sa.[SQLServerID] = @SQLServerID
	and sa.[UTCCollectionDateTime] between @BeginDateTime and @EndDateTime

select @err = @@error
return @err
end
GO

 
GO 

---------- P_GETSESSIONSUMMARYBASELINE.SQL
if (object_id('p_GetSessionSummaryBaseline') is not null)
begin
drop procedure [p_GetSessionSummaryBaseline]
end
go

CREATE PROCEDURE [dbo].[p_GetSessionSummaryBaseline]
		@ServerID int,
		@UTCStart DateTime,
		@UTCEnd DateTime,
		@UTCOffset int,
		@Interval tinyint
AS
BEGIN
		SELECT		
		UTCCalculation = dbo.fn_RoundDateTime(1, max(dateadd(mi, @UTCOffset, UTCCalculation))),
		ClientComputersMean = (select TOP 1 Mean	--'%ClientComputers%' -- 57
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = 57 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc),
		OldestOpenTransactionsInMinutesMean = (select TOP 1 Mean	--'%OldestOpenTransactionsInMinutes%' -- 6
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = 6 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc),
		UserProcessesMean = (select TOP 1 Mean	--'%UserProcesses%' -- -78
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -78 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc),		
		LoginsMean = (select TOP 1 Mean --'%Logins%' -- -137
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -137 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc),
		PacketErrorsMean = (select TOP 1 Mean	--'%PacketErrors%' -- -43
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = -43 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc) * 60,
		PacketsReceivedMean = (select TOP 1 Mean	--'%PacketsReceived%' -- -45
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -45 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc) * 60,		
		PacketsSentMean = (select TOP 1 Mean --'%PacketsSent%' -- -47
				from BaselineStatistics
				where SQLServerID = @ServerID AND  MetricID = -47 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc) * 60,				
		TransactionsMean = (select TOP 1 Mean	--'%Transactions%' -- -7
				from BaselineStatistics
				where SQLServerID = @ServerID AND MetricID = -7 and dbo.fn_RoundDateTime(2, UTCCalculation) = dbo.fn_RoundDateTime(2, bs.UTCCalculation)
				order by UTCCalculation desc)		
		FROM		
			[BaselineStatistics] bs (nolock)
		WHERE bs.[SQLServerID] = @ServerID and bs.UTCCalculation between @UTCStart and @UTCEnd
		GROUP BY dbo.fn_RoundDateTime(2, bs.UTCCalculation)

END
 
GO 

---------- P_GETSNOOZEDALERTS.SQL
if (object_id('p_GetSnoozedAlerts') is not null)
begin
drop procedure [p_GetSnoozedAlerts]
end
go

create procedure [p_GetSnoozedAlerts]
	@SQLServerID int
as
begin
	DECLARE @err int
	DECLARE @Now datetime

	set @Now = GetUTCDate()

	select MT.[Metric],MI.[Name] 
		from MetricThresholds MT (nolock) 
		inner join MetricInfo MI (nolock) on MI.[Metric] = MT.[Metric]
	where
	(@SQLServerID = MT.SQLServerID) and
	(UTCSnoozeEnd > @Now)

	select @err = @@error

	return @err
end
 
GO 

---------- P_GETSQLAGENTRUNNING.SQL
if (object_id('p_GetSqlAgentRunning') is not null)
begin
drop procedure p_GetSqlAgentRunning
end
go
create procedure p_GetSqlAgentRunning
	@AgentIsRunning bit output
as
begin

	declare 
		@service_status int,
		@slashpos int, 
		@agentservicename varchar(50),
		@servername varchar(255)

	select @servername = upper(cast(serverproperty('servername')  as nvarchar(255))) 

	select @slashpos = charindex('\', @servername)  

	if @slashpos <> 0 
		begin 
			select @agentservicename = 'SQLAGENT$' + substring(@servername, @slashpos + 1, 30) 
		end  
	else 
		begin 

			select @agentservicename = 'SQLSERVERAGENT' 
		end  

	create Table #runStatus(service_status nvarchar(100))

	insert #runStatus
		exec master..xp_servicecontrol N'querystate', @agentservicename 

	if exists(select * from #runStatus where rtrim(lower(service_status)) like 'running.')
		set @AgentIsRunning = 1
	else
		set @AgentIsRunning = 0

	drop table #runStatus

end


 
GO 

---------- P_GETSQLDRIVES.SQL
if (object_id('p_GetSQLDrives') is not null)
begin
drop procedure [p_GetSQLDrives]
end
go
create procedure [dbo].[p_GetSQLDrives]
as
begin
	if (select isnull(object_id('tempdb..#disk_drives'), 0)) = 0 
	begin 
		create table #disk_drives (
			drive_letter nvarchar(256), 
			unused_size dec(38,0)
		)
	end
	else
	begin
		truncate table #disk_drives
	end
	
	-- Populate unused disk space stats
	insert into #disk_drives(drive_letter, unused_size)  exec master..xp_fixeddrives   -- Fixed
	insert into #disk_drives(drive_letter, unused_size)  exec master..xp_fixeddrives 1 -- Remote
	
	select drive_letter from #disk_drives
end

 
GO 

---------- P_GETSQLSERVERUSERS.SQL
--SQLdm 9.0 (Ankit Srivastava) - User Sync with CWF - Created new procedure to get the users in accoradance with the CWF Sync
-- EXEC [p_GetSQLServerUsers] 1
if (object_id('p_GetSQLServerUsers') is not null)
begin
drop procedure [p_GetSQLServerUsers]
end
go
CREATE PROCEDURE [dbo].[p_GetSQLServerUsers]
@ShouldBeSysAdmin BIT
AS
BEGIN
	declare @e int

	-- Get all users belonging to sysadmin role, these permissions are system defined
	-- and cannot be edited.   These users have administrator power in SQLdm.
	declare @securityEnabled bit

	-- check if security is enabled, and return flags.
	if ((select count([Internal_Value]) from dbo.[RepositoryInfo] where [Name] = 'ApplicationSecurityEnabled' and [Internal_Value] != 0) = 1)
		set @securityEnabled = 1
						else 
		set @securityEnabled = 0
	

		Declare @Users Table
		(
			[Login] nvarchar(100),
			[LoginSID] varbinary(85),
			[LoginType] nvarchar(1)

		)

		Insert into @Users
		select
			sl.[name] as [Login],
			sl.sid  as [LoginSID],
			case sl.[isntgroup]
				when 0 then 'U' -- windows user
				else 'G' -- windows group
			end
			
		from [master]..[syslogins] as sl
		where sl.sysadmin = CASE 
								WHEN @ShouldBeSysAdmin=1
									THEN 1
								ELSE
									sl.sysadmin
							END
					and sl.isntname=1

		if(@securityEnabled = 0)
		BEGIN
			Select [Login]COLLATE DATABASE_DEFAULT,[LoginSID],[LoginType]  from @Users -- SQLdm 9.0 (Ankit Srivastava) Added Collation 
		END
		ELSE
		BEGIN
			Select [Login]COLLATE DATABASE_DEFAULT,[LoginSID],[LoginType] from @Users -- SQLdm 9.0 (Ankit Srivastava) Added Collation 
			union
			Select 
			sl.[name] as [Login],
			p.[LoginSID] as [LoginSID],
			[LoginType] = case sl.[isntgroup]
								when 0 then 'U' -- windows user
								else 'G' -- windows group
						end
							
			from [dbo].[Permission] as p 
			join [master]..[syslogins] as sl on (p.[LoginSID] = sl.[sid])
			where p.[Enabled]=1 and p.[WebAppPermission]=1
			and sl.isntname=1
		END


	
	select @e = @@error
	return @e
END
 
GO 

---------- P_GETSQLTEXT.SQL
if (object_id('p_GetSQLText') is not null)
begin
drop procedure p_GetSQLText 
end
go
create procedure p_GetSQLText
	@SQLStatementHash nvarchar(30) = null,
	@SQLStatementID bigint = null,
	@SQLSignatureHash nvarchar(30) = null,
	@SQLSignatureID bigint = null
as
begin

	declare @RC int
	set @RC = 0
	
	if (@SQLStatementHash is not null)
	begin
		select 
			ID = SQLStatementID,
			SQLText = SQLStatement 
		from 
			AllSQLStatements 
		where
			SQLStatementHash = @SQLStatementHash

		set @RC = @@rowcount
	end

	if (@RC = 0 and @SQLStatementID is not null)
	begin
		select 
			ID = SQLStatementID,
			SQLText = SQLStatement 
		from 
			AllSQLStatements 
		where
			SQLStatementID = @SQLStatementID

		set @RC = @@rowcount
	end

	if (@RC = 0 and @SQLSignatureHash is not null)
	begin
		select 
			ID = SQLSignatureID,
			SQLText = SQLSignature
		from 
			AllSQLSignatures 
		where
			SQLSignatureHash = @SQLSignatureHash

		set @RC = @@rowcount
	end

	if (@RC = 0 and @SQLSignatureID is not null)
	begin
		select 
			ID = SQLSignatureID,
			SQLText = SQLSignature
		from 
			AllSQLSignatures 
		where
			SQLSignatureID = @SQLSignatureID

		set @RC = @@rowcount
	end

	if (@RC = 0)
		select 'Not found'
end
 
GO 

---------- P_GETSTATEOVERVIEW.SQL
if (object_id('p_GetStateOverview') is not null)
begin
drop procedure [p_GetStateOverview]
end
go
create procedure [dbo].[p_GetStateOverview]
	@SQLServerID int,
	@UTCSnapshotCollectionDateTime datetime = null
as
begin
set transaction isolation level read uncommitted
declare @err int

if (@UTCSnapshotCollectionDateTime is null)
	select @UTCSnapshotCollectionDateTime = (select max(UTCCollectionDateTime) from [ServerActivity] where [SQLServerID] = @SQLServerID)

select
	[UTCCollectionDateTime]
	,[StateOverview]
from 
	[ServerActivity]
where 
	[SQLServerID] = @SQLServerID
	and [UTCCollectionDateTime] = @UTCSnapshotCollectionDateTime

select @err = @@error
return @err
end
 
GO 

---------- P_GETTABLEFRAGMENTATION.SQL
if (object_id('[p_GetTableFragmentation]') is not null)
begin
drop procedure [p_GetTableFragmentation]
end
go
create procedure [dbo].[p_GetTableFragmentation]
	@SQLServerID int = null,
	@DatabaseName nvarchar(510) = null
as
begin

declare 
	@DatabaseID int

select 
	@DatabaseID = DatabaseID
from 
	SQLServerDatabaseNames
where 
	SQLServerID = @SQLServerID
	and DatabaseName = @DatabaseName

select 
	isnull(SchemaName,'') + '.' + isnull(TableName,''),
	Fragmentation = LogicalFragmentation,
	UTCCollectionDateTime,
	SystemTable
from 
	TableReorganization tr
	left join SQLServerTableNames tn on tr.TableID = tn.TableID
where 
	tn.DatabaseID = isnull(@DatabaseID,0)
	and UTCCollectionDateTime = 
	(
		select max(UTCCollectionDateTime) 
		from TableReorganization tr2
		where 
			tr.TableID = tr2.TableID
	)
end
 
GO 

---------- P_GETTABLES.SQL
if (object_id('p_GetTables') is not null)
begin
drop procedure p_GetTables
end
go
CREATE PROCEDURE [dbo].p_GetTables(
	@InstanceId int,
	@DatabaseName nvarchar(255)
)
AS
BEGIN
	--- Gets the list of databases for the instance id and db name
	SELECT 
		[TableID],
		[TableName],
		[SchemaName],
		[SystemTable]
	FROM SQLServerTableNames t, SQLServerDatabaseNames d
	WHERE	d.[SQLServerID] = @InstanceId
		AND	d.[DatabaseName] = @DatabaseName
		AND d.[DatabaseID] = t.[DatabaseID]
END
 
GO 

---------- P_GETTAGASSOCIATIONS.SQL
IF (object_id('p_GetTagAssociations') IS NOT NULL)
BEGIN
DROP PROCEDURE p_GetTagAssociations
END
GO

CREATE PROCEDURE [dbo].[p_GetTagAssociations]
(
	@TagId int,
	@IncludeServerTags bit,
	@IncludeCustomCounterTags bit,
	@IncludePermissionTags bit
)
AS
BEGIN

	if (@IncludeServerTags = 1)
	begin
		SELECT [SQLServerId], [TagId]
		FROM [ServerTags]
		WHERE (@TagId is NULL or [TagId] = @TagId)
	end

	if (@IncludeCustomCounterTags = 1)
	begin
		SELECT [Metric], [TagId]
		FROM [CustomCounterTags]
		WHERE (@TagId is NULL or [TagId] = @TagId)
	end

	if (@IncludePermissionTags = 1)
	begin
		SELECT [PermissionId], [TagId]
		FROM [PermissionTags]
		WHERE (@TagId is NULL or [TagId] = @TagId)
	end

END
 
GO 

---------- P_GETTAGCONFIGURATION.SQL
IF (object_id('p_GetTagConfiguration') IS NOT NULL)
BEGIN
DROP PROCEDURE p_GetTagConfiguration
END
GO

CREATE PROCEDURE [dbo].[p_GetTagConfiguration]
(
	@TagId INT
)
AS
BEGIN
	-- Get Servers
	SELECT [SQLServerId], [InstanceName]
	FROM [ServerTags] st
	LEFT JOIN [MonitoredSQLServers] ms
	ON st.SQLServerId = ms.SQLServerID
	WHERE [TagId] = @TagId

	-- Get Custom Counters
	SELECT [Metric]
	FROM [CustomCounterTags]
	WHERE [TagId] = @TagId

	-- Get Permissions
	SELECT [PermissionId]
	FROM [PermissionTags]
	WHERE [TagId] = @TagId
END
 
GO 

---------- P_GETTAGS.SQL
IF (object_id('p_GetTags') IS NOT NULL)
BEGIN
DROP PROCEDURE p_GetTags
END
GO

CREATE PROCEDURE [dbo].[p_GetTags]
	@addSelectRequest bit = 0
AS
BEGIN
	if @addSelectRequest=1
	begin
       SELECT 0 as 'Id','< All >' as 'Name',0 as 'Servers',0 as 'CustomCounters', 0 as 'Permissions'
	   union
	   SELECT 
		[Id],
		[Name],
		[Servers] = (SELECT COUNT(*) FROM ServerTags WHERE TagId = Tags.Id),
		[CustomCounters] = (SELECT COUNT(*) FROM CustomCounterTags WHERE TagId = Tags.Id),
		[Permissions] = (SELECT COUNT(*) FROM PermissionTags WHERE TagId = Tags.Id)
	   FROM 
		[Tags] (nolock)
	end
	else
	SELECT 
		[Id],
		[Name],
		[Servers] = (SELECT COUNT(*) FROM ServerTags WHERE TagId = Tags.Id),
		[CustomCounters] = (SELECT COUNT(*) FROM CustomCounterTags WHERE TagId = Tags.Id),
		[Permissions] = (SELECT COUNT(*) FROM PermissionTags WHERE TagId = Tags.Id)
	FROM 
		[Tags] (nolock)

	SELECT [SQLServerId], [TagId]
	FROM [ServerTags] (nolock)

	SELECT [Metric], [TagId]
	FROM [CustomCounterTags] (nolock)

	SELECT [PermissionId], [TagId]
	FROM [PermissionTags] (nolock)
END
 
GO 

---------- P_GETTAGSERVERSASXML.SQL
IF (object_id('p_GetTagServersAsXML') IS NOT NULL)
BEGIN
DROP PROCEDURE p_GetTagServersAsXML
END
GO

create proc [dbo].[p_GetTagServersAsXML]
	@TagID int = null,
	@ServerID int = null
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	select @TagID= coalesce(@TagID, 0)
	select @ServerID= coalesce(@ServerID, 0)
	
	create table #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

	insert into #SecureMonitoredSQLServers
	exec [p_GetReportServers]

	if @ServerID = 0 -- if no server has been selected
	begin
		--We are here if a valid server id has not been entered
		if @TagID = 0
			begin -- no tag selected so do not join to server tags
					select [SQLServerID] as [@ID]
					from #SecureMonitoredSQLServers ms (nolock)
					for xml path('Srvr'),root('Srvrs')
			end
		else --tagid has been selected so we get servers for that tag
			begin
				select Srvrs.[SQLServerId] as [@ID]
				from [ServerTags] Srvrs (nolock) 
				inner join #SecureMonitoredSQLServers ms (nolock)
				on Srvrs.SQLServerId = ms.SQLServerID
				where [TagId] = isnull(@TagID,Srvrs.[TagId])
				for xml path('Srvr'),root('Srvrs')
		end
	end
	else
	--We can only be here if a server if has been entered then regardless of tag we populate the server
	begin
			select @ServerID as [@ID] 
			for xml path('Srvr'),root('Srvrs')
	end
END
 
GO 

---------- P_GETTAGSWITHMIRROREDSERVERS.SQL
IF (object_id('p_GetTagsWithMirroredServers') IS NOT NULL)
BEGIN
DROP PROCEDURE p_GetTagsWithMirroredServers
END
GO

CREATE PROCEDURE [dbo].p_GetTagsWithMirroredServers
	@addSelectRequest bit = 0
AS
BEGIN
	set nocount on
	
	create table #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

	insert into #SecureMonitoredSQLServers
	exec [p_GetReportServers]
	
	create table #MirroredServers(Server nvarchar(256), id int)
		insert #MirroredServers
		select distinct smss.InstanceName, smss.SQLServerID 
		from MirroringParticipants mp (nolock)
		inner join SQLServerDatabaseNames dbs (nolock) on mp.DatabaseID = dbs.DatabaseID
		inner join #SecureMonitoredSQLServers smss (nolock) on smss.SQLServerID = dbs.SQLServerID

	if @addSelectRequest=1
	begin
		SELECT 0 as 'Id','< All >' as 'Name'
		union
		select t.Id, t.Name from Tags t where exists(select st.TagId as Id
		  from #MirroredServers ms
		inner join ServerTags st (nolock) on st.SQLServerId = ms.id
		where t.Id = st.TagId)
	end
	else
    begin
		select t.Id, t.Name from Tags t where exists(select st.TagId as Id
		  from #MirroredServers ms
		inner join ServerTags st (nolock) on st.SQLServerId = ms.id
		where t.Id = st.TagId)
	end
	drop table #MirroredServers
END
 
GO 

---------- P_GETTASKS.SQL
-- Get desired to-do items from Tasks table.
if (object_id('p_GetTasks') is not null)
begin
drop procedure p_GetTasks
end
go
CREATE PROCEDURE [dbo].p_GetTasks(
	@FromDate datetime,
	@Status TINYINT , -- A bitmap of desired states.
	@Severity tinyint,  -- A bitmap of desired severities.
	@ServerXML nvarchar(max), -- Null for all????
	@Owner nvarchar(256) = null -- Null for all
)
AS
begin

	declare @IntermediateTable table(InstanceName nvarchar(255))
	declare @xmlDoc int

	exec sp_xml_preparedocument @xmlDoc output, @ServerXML

	insert into @IntermediateTable
	select InstanceName
		from openxml(@xmlDoc, '//Server', 1) with (InstanceName nvarchar(255)) 

	exec sp_xml_removedocument @xmlDoc


	SELECT	T.[TaskID], T.[Status], T.[Subject], T.[Message], T.[ServerName],
			T.[Comments], T.[Owner], T.[CreatedOn], T.[CompletedOn],
			T.[Metric], T.[Severity], T.[Value], T.[EventID]
	FROM [Tasks] T
	LEFT OUTER JOIN [MonitoredSQLServers] M ON
		T.[ServerName] = M.[InstanceName]
	INNER JOIN [MetricMetaData] MD ON
		T.[Metric] = MD.[Metric]
	WHERE ( 
			(M.Active is null or M.[Active] = 1) and 
			[CreatedOn] >= @FromDate and
			[Status] & @Status <> 0 and
			[Severity] & @Severity <> 0 and
			(@Owner is null or LOWER([Owner]) = LOWER(@Owner)) and
			(T.[Metric] = 52 or [ServerName] collate database_default in (select InstanceName collate database_default from @IntermediateTable)) and
			MD.[Deleted] = 0
	)
end

-- go
--exec [p_GetTasks] 0, 24, 2, null, null
 
GO 

---------- P_GETTEMPDBFILEDATA.SQL
if (object_id('[p_GetTempdbFileData]') is not null)
begin
drop procedure [p_GetTempdbFileData]
end
go
create procedure [dbo].[p_GetTempdbFileData]
	@SQLServerID int,
	@UTCSnapshotCollectionDateTime datetime = null,
	@HistoryInMinutes int = null
as
begin
set transaction isolation level read uncommitted
declare @err int
declare @BeginDateTime datetime
declare @EndDateTime datetime

if (@UTCSnapshotCollectionDateTime is null)
	select @EndDateTime = (select max(UTCCollectionDateTime) from [ServerStatistics] where [SQLServerID] = @SQLServerID)
else
	select @EndDateTime = @UTCSnapshotCollectionDateTime

if (@HistoryInMinutes is null)
	select @BeginDateTime = @EndDateTime
else
	select @BeginDateTime = dateadd(n, -@HistoryInMinutes, @EndDateTime)
	

;with cte_max(MaxDateTime) as 
(
	select 
		max(UTCCollectionDateTime)
	from TempdbFileData	
		inner join DatabaseFiles on TempdbFileData.FileID = DatabaseFiles.FileID
		inner join SQLServerDatabaseNames on SQLServerDatabaseNames.DatabaseID = DatabaseFiles.DatabaseID
	where 
		UTCCollectionDateTime between @BeginDateTime and @EndDateTime
)
select
	TempdbFileData.UTCCollectionDateTime,
	FileName,
	FilePath,
	UserObjectsInMB = UserObjectsInKilobytes / 1024.0, 
	InternalObjectsInMB = InternalObjectsInKilobytes / 1024.0,
	VersionStoreInMB = VersionStoreInKilobytes / 1024.0,
	MixedExtentsInMB = MixedExtentsInKilobytes / 1024.0,
	UnallocatedSpaceInMB = UnallocatedSpaceInKilobytes / 1024.0
	from TempdbFileData	
	inner join DatabaseFiles on TempdbFileData.FileID = DatabaseFiles.FileID
	inner join SQLServerDatabaseNames on SQLServerDatabaseNames.DatabaseID = DatabaseFiles.DatabaseID
	inner join cte_max on TempdbFileData.UTCCollectionDateTime = cte_max.MaxDateTime
where
	SQLServerID = @SQLServerID and
	DatabaseName = 'tempdb' and
	TempdbFileData.UTCCollectionDateTime = MaxDateTime


		
end	
 
GO 

---------- P_GETTEMPDBOVERALL.SQL
if (object_id('p_GetTempdbOverall') is not null)
begin
drop procedure [p_GetTempdbOverall]
end
go

-- @OrderBy
--	0 - Size
--	1 - Growth Rate
--	2 - Reads 
--	3 - Writes
--	4 - Transactions
CREATE procedure [dbo].[p_GetTempdbOverall]
	@ServerId int,	
	@UTCStart DateTime,
	@UTCEnd DateTime,
	@UTCOffset int = 0,
	@MinSizeMB decimal = null,
	@MinGrowthPercent bigint = null,
	@MinTransactionsPerSecond bigint = null,
	@MinReadsPerSecond bigint = null,
	@MinWritesPerSecond bigint = null,
	@TopN bigint = 10,
	@OrderBy tinyint = 0,
	@IncludeSystem bit = 1
as
begin

set rowcount 0

declare @TempdbDatabaseID int 

select @TempdbDatabaseID = DatabaseID
from
      [SQLServerDatabaseNames] names (nolock)   
where
      names.SQLServerID = @ServerId
      and names.DatabaseName = 'tempdb'   


declare @StartSize decimal, @EndSize decimal
	
select	
	@StartSize = sum(tdb.FileSizeInKilobytes)
from
	DatabaseFiles files 
	left join TempdbFileData tdb on (tdb.FileID = files.FileID)	
where
	files.DatabaseID = @TempdbDatabaseID
	and
	tdb.[UTCCollectionDateTime] =
	(		
		select 
			min([UTCCollectionDateTime]) 
		from 
			DatabaseFiles dfiles (nolock)
			inner join TempdbFileData tdb on (dfiles.FileID = tdb.FileID)
		where 
			tdb.[UTCCollectionDateTime] between @UTCStart and @UTCEnd
			and dfiles.DatabaseID = @TempdbDatabaseID
	)			

select	
	@EndSize = sum(tdb.FileSizeInKilobytes )
from	
	DatabaseFiles files 
	left join TempdbFileData tdb on (tdb.FileID = files.FileID)	
where
	files.DatabaseID = @TempdbDatabaseID
	and
	tdb.[UTCCollectionDateTime] =
	(		
		select 
			max([UTCCollectionDateTime]) 
		from 
			DatabaseFiles dfiles (nolock)
			inner join TempdbFileData tdb on (dfiles.FileID = tdb.FileID)
		where 
			tdb.[UTCCollectionDateTime] between @UTCStart and @UTCEnd
			and dfiles.DatabaseID = @TempdbDatabaseID
	)			


set rowcount @TopN

select 
	DatabaseName = 'tempdb',
	[LastCollectioninInterval] = max(dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])),	
	DataSizeMb = max(@EndSize) / 1024,
	GrowthOverPeriod = max(@EndSize / nullif(@StartSize,0)) - 1,
	KBReadPerSecond = sum(convert(float,ds.BytesRead) / 1024) / nullif(sum(case when ds.BytesRead is not null then ds.TimeDeltaInSeconds else 0 end),0),
	KBWrittenPerSecond = sum(convert(float,ds.BytesWritten) / 1024) / nullif(sum(case when ds.BytesWritten is not null then ds.TimeDeltaInSeconds else 0 end) ,0),
	TransactionsPerSecond = sum(convert(float,ds.Transactions)) / nullif(sum(case when ds.Transactions is not null then ds.TimeDeltaInSeconds else 0 end)  ,0)
from
	[DatabaseStatistics] ds (nolock)
where 
	ds.[UTCCollectionDateTime] between @UTCStart and @UTCEnd
	and ds.DatabaseID = @TempdbDatabaseID
	and isnull(@EndSize,0) / 1024 >= isnull(@MinSizeMB,0)
having
	(@MinGrowthPercent is null or isnull(max(@EndSize / nullif(@StartSize,0)),0) >= isnull((cast(@MinGrowthPercent as float) / 100) + case @MinGrowthPercent when 0 then 0 else 1 end,1)) 
	and isnull(sum(convert(float,ds.Transactions)) / nullif(sum(case when ds.Transactions is not null then ds.TimeDeltaInSeconds else 0 end)  ,0),0) >= isnull(@MinTransactionsPerSecond,0)
	and isnull(sum(convert(float,ds.BytesRead) / 1024) / nullif(sum(case when ds.BytesRead is not null then ds.TimeDeltaInSeconds else 0 end),0),0) >= isnull(@MinReadsPerSecond,0)
	and isnull(sum(convert(float,ds.BytesWritten) / 1024) / nullif(sum(case when ds.BytesWritten is not null then ds.TimeDeltaInSeconds else 0 end) ,0),0) >= isnull(@MinWritesPerSecond,0)


set rowcount 0

end
 
GO 

---------- P_GETTEMPDBSTATISTICS.SQL
if (object_id('p_GetTempdbStatistics') is not null)
begin
drop procedure [p_GetTempdbStatistics]
end
go

-- @Interval - Granularity of calculation:
--	0 - Minutes
--	1 - Hours
--	2 - Days
--	3 - Months
--	4 - Years
--  5 - All Time
CREATE procedure [dbo].[p_GetTempdbStatistics]
	@ServerId int,	
	@UTCStart DateTime,
	@UTCEnd DateTime,	
	@UTCOffset int = 0,
	@Interval int
as
begin
set ansi_warnings off
set ansi_nulls off

set rowcount 0

declare @TempdbDatabaseID int

select @TempdbDatabaseID = DatabaseID
from
	[SQLServerDatabaseNames] names (nolock)	
where
	names.SQLServerID = @ServerId
	and names.DatabaseName = 'tempdb' 	



create table #DbStatistics(	
	LastCollectioninInterval datetime,
	IntervalNumber int,
	AverageDataFileSizeMb float,
	GrowthOverPeriod decimal(38, 2),
	KBReadPerSecond float,
	KBWrittenPerSecond float,
	TransactionsPerSecond float,
	RowNumber int identity primary key clustered,
	IntervalTemp bigint,
	UserObjectsMB float,
	InternalObjectsMB float,
	VersionStoreMB float,
	MixedExtentsMB float,
	CountDataFiles int
) 

;with
FileCountCTE
as
(
	select
		FileCount = count(tdb.FileID),
		UTCCollectionDateTime,
		FileSizeInKilobytes = sum(FileSizeInKilobytes),
		TimeDeltaInSeconds = min(TimeDeltaInSeconds),
		UserObjectsInKilobytes = sum(UserObjectsInKilobytes),
		InternalObjectsInKilobytes = sum(InternalObjectsInKilobytes),
		VersionStoreInKilobytes = sum(VersionStoreInKilobytes),
		MixedExtentsInKilobytes = sum(MixedExtentsInKilobytes)
	from
		DatabaseFiles files
		inner join TempdbFileData tdb
		on tdb.FileID = files.FileID
	where 
		files.DatabaseID = @TempdbDatabaseID	
		and tdb.[UTCCollectionDateTime] BETWEEN @UTCStart and @UTCEnd
	group by
		UTCCollectionDateTime
)
insert into #DbStatistics(LastCollectioninInterval, IntervalTemp, AverageDataFileSizeMb, KBReadPerSecond, KBWrittenPerSecond, TransactionsPerSecond, UserObjectsMB, InternalObjectsMB, VersionStoreMB, MixedExtentsMB, CountDataFiles)
select 	
	[LastCollectioninInterval] = max(dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])),
	IntervalTemp = case
				 when isnull(@Interval,5) = 5
						then 0
				 when isnull(@Interval,5) = 4
						then datediff(yyyy, @UTCStart, max(dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])))
				 when isnull(@Interval,5) = 3
						then datediff(mm, @UTCStart, max(dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])))
				 when isnull(@Interval,5) = 2
						then datediff(dd, @UTCStart, max(dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])))
				 when isnull(@Interval,5) = 1
						then datediff(hh, @UTCStart, max(dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])))
				 when isnull(@Interval,5) =  0
						then datediff(mi, @UTCStart, max(dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])))
				 end,
	AverageDataFileSizeMb = (sum(fc.FileSizeInKilobytes * (case fc.TimeDeltaInSeconds when 0 then 1 else fc.TimeDeltaInSeconds end)) / 
		nullif(sum(case when fc.FileSizeInKilobytes is not null then (case fc.TimeDeltaInSeconds when 0 then 1 else fc.TimeDeltaInSeconds end) else 0 end),0)) / 1024,
	KBReadPerSecond = sum(convert(float,ds.BytesRead) / 1024) / nullif(sum(case when ds.BytesRead is not null then (case ds.TimeDeltaInSeconds when 0 then 1 else ds.TimeDeltaInSeconds end) else 0 end),0),
	KBWrittenPerSecond = sum(convert(float,ds.BytesWritten) / 1024) / nullif(sum(case when ds.BytesWritten is not null then (case ds.TimeDeltaInSeconds when 0 then 1 else ds.TimeDeltaInSeconds end) else 0 end) ,0),
	TransactionsPerSecond = sum(convert(float,ds.Transactions)) / nullif(sum(case when ds.Transactions is not null then (case ds.TimeDeltaInSeconds when 0 then 1 else ds.TimeDeltaInSeconds end) else 0 end)  ,0),
	UserObjectsMB = round((sum(fc.UserObjectsInKilobytes * (case fc.TimeDeltaInSeconds when 0 then 1 else fc.TimeDeltaInSeconds end)) / 
		nullif(sum(case when fc.UserObjectsInKilobytes is not null then (case fc.TimeDeltaInSeconds when 0 then 1 else fc.TimeDeltaInSeconds end) else 0 end),0)) / 1024, 2),
	InternalObjectsMB = round((sum(fc.InternalObjectsInKilobytes * (case fc.TimeDeltaInSeconds when 0 then 1 else fc.TimeDeltaInSeconds end)) / 
		nullif(sum(case when fc.InternalObjectsInKilobytes is not null then (case fc.TimeDeltaInSeconds when 0 then 1 else fc.TimeDeltaInSeconds end) else 0 end),0)) / 1024, 2),
	VersionStoreMB = round((sum(fc.VersionStoreInKilobytes * (case fc.TimeDeltaInSeconds when 0 then 1 else fc.TimeDeltaInSeconds end)) / 
		nullif(sum(case when fc.VersionStoreInKilobytes is not null then (case fc.TimeDeltaInSeconds when 0 then 1 else fc.TimeDeltaInSeconds end) else 0 end),0)) / 1024, 2),
	MixedExtentsMB = round((sum(fc.MixedExtentsInKilobytes * (case fc.TimeDeltaInSeconds when 0 then 1 else fc.TimeDeltaInSeconds end)) / 
		nullif(sum(case when fc.MixedExtentsInKilobytes is not null then (case fc.TimeDeltaInSeconds when 0 then 1 else fc.TimeDeltaInSeconds end) else 0 end),0)) / 1024, 2),
	CountDataFiles = max(fc.FileCount)
from	
	FileCountCTE fc left join 
	DatabaseStatistics (nolock) ds on (ds.DatabaseID = @TempdbDatabaseID and ds.UTCCollectionDateTime = fc.UTCCollectionDateTime)
group by
	 case when isnull(@Interval,5) <= 4 then datepart(yy, dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])) else 1 end
	,case when isnull(@Interval,5) <= 3 then datepart(mm,dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])) end
	,case when isnull(@Interval,5) <= 2 then datepart(dd,dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])) end
	,case when isnull(@Interval,5) <= 1 then datepart(hh,dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])) end
	,case when isnull(@Interval,5) =  0 then datepart(mi,dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])) end

order by
	IntervalTemp asc	

	
declare @MainPrev float, @rownum int, @intervalcounter int, @previnterval bigint
select 
	@MainPrev = null, 
	@rownum = isnull(min(RowNumber),-1) ,
	@intervalcounter = 0,
	@previnterval = 0
from #DbStatistics
while @rownum > 0
begin

	update #DbStatistics
		set GrowthOverPeriod = (AverageDataFileSizeMb /  nullif(@MainPrev,0) ) - 1,
			IntervalNumber = case when IntervalTemp = @previnterval then @intervalcounter else @intervalcounter + 1 end
	where RowNumber = @rownum

	select
		@MainPrev = AverageDataFileSizeMb,		
		@intervalcounter = case when IntervalTemp = @previnterval then @intervalcounter else @intervalcounter + 1 end,
		@previnterval = IntervalTemp
	from #DbStatistics
	where RowNumber = @rownum

	select @rownum = isnull(min(RowNumber),-1) 
	from #DbStatistics
	where RowNumber > @rownum
end


select 	
	LastCollectioninInterval,
	IntervalNumber,
	AverageDataFileSizeMb,
	GrowthOverPeriod,
	KBReadPerSecond,
	KBWrittenPerSecond,
	TransactionsPerSecond,
	UserObjectsMB,
	InternalObjectsMB,
	VersionStoreMB,
	MixedExtentsMB,
	CountDataFiles
from #DbStatistics
order by
	IntervalNumber asc

end
 
GO 

---------- P_GETTEMPDBSUMMARYDATA.SQL
if (object_id('[p_GetTempdbSummaryData]') is not null)
begin
drop procedure [p_GetTempdbSummaryData]
end
go
create procedure [dbo].[p_GetTempdbSummaryData]
	@SQLServerID int,
	@UTCSnapshotCollectionDateTime datetime = null,
	@HistoryInMinutes int = null
as
begin
set transaction isolation level read uncommitted
declare @err int
declare @BeginDateTime datetime
declare @EndDateTime datetime

if (@UTCSnapshotCollectionDateTime is null)
	select @EndDateTime = (select max(UTCCollectionDateTime) from [ServerStatistics] where [SQLServerID] = @SQLServerID)
else
	select @EndDateTime = @UTCSnapshotCollectionDateTime

if (@HistoryInMinutes is null)
	select @BeginDateTime = @EndDateTime
else
	select @BeginDateTime = dateadd(n, -@HistoryInMinutes, @EndDateTime)
	
;with cte_FileData (UTCCollectionDateTime, UserObjectsInKilobytes, InternalObjectsInKilobytes,VersionStoreInKilobytes,MixedExtentsInKilobytes,UnallocatedSpaceInKilobytes)as
(
select
TempdbFileData.UTCCollectionDateTime,
sum(UserObjectsInKilobytes),
sum(InternalObjectsInKilobytes),
sum(VersionStoreInKilobytes),
sum(MixedExtentsInKilobytes),
sum(UnallocatedSpaceInKilobytes)
from TempdbFileData	 (NOLOCK)
inner join DatabaseFiles (NOLOCK) on TempdbFileData.FileID = DatabaseFiles.FileID
inner join SQLServerDatabaseNames (NOLOCK) on SQLServerDatabaseNames.DatabaseID = DatabaseFiles.DatabaseID
where
	SQLServerID = @SQLServerID and
	TempdbFileData.UTCCollectionDateTime between @BeginDateTime and @EndDateTime
group by
UTCCollectionDateTime
)
select
	ServerStatistics.UTCCollectionDateTime, 
	UserObjectsInMB = UserObjectsInKilobytes / 1024.0, 
	InternalObjectsInMB = InternalObjectsInKilobytes / 1024.0,
	VersionStoreInMB = VersionStoreInKilobytes / 1024.0,
	MixedExtentsInMB = MixedExtentsInKilobytes / 1024.0,
	UnallocatedSpaceInMB = UnallocatedSpaceInKilobytes / 1024.0,
	TempdbPFSWaitTimeMilliseconds = TempdbPFSWaitTimeMilliseconds,
	TempdbGAMWaitTimeMilliseconds =	TempdbGAMWaitTimeMilliseconds,
	TempdbSGAMWaitTimeMilliseconds = TempdbSGAMWaitTimeMilliseconds,
	VersionStoreGenerationKilobytesPerSec = VersionStoreGenerationKilobytes / nullif(TimeDeltaInSeconds,0),
	VersionStoreCleanupKilobytesPerSec = VersionStoreCleanupKilobytes  / nullif(TimeDeltaInSeconds,0)
from	
	ServerStatistics (NOLOCK)
	left join cte_FileData fd
	on [ServerStatistics].UTCCollectionDateTime = fd.UTCCollectionDateTime
where
	[ServerStatistics].[SQLServerID] = @SQLServerID
	and [ServerStatistics].[UTCCollectionDateTime] between @BeginDateTime and @EndDateTime
order by 
	[ServerStatistics].[UTCCollectionDateTime]
		
end	
 
GO 

---------- P_GETTHEPRODUCTREGISTRATIONINFORMATION.SQL
-- SQLdm 9.0 (Abhishek Joshi)

-- CWF Registration
-- get the product's web framework registration information

-- exec p_GetTheProductRegistrationInformation

if (object_id('p_GetTheProductRegistrationInformation') is not null)
begin
	drop procedure [p_GetTheProductRegistrationInformation]
end
go

create procedure [dbo].[p_GetTheProductRegistrationInformation]
as
begin
	select top 1
		WebFrameworkID,
		HostName,
		Port,
		UserName,
		Password,
		InstanceName,
		ProductID   
	from 
		[WebFramework]
end
go
 
GO 

---------- P_GETTOPBLOCKEDSESSIONCOUNT.SQL
-- SQLDM 8.5:Mahesh : Added for Rest service consumption
if (object_id('p_GetTopBlockedSessionCount') is not null)
begin
drop procedure p_GetTopBlockedSessionCount
end
go
-- exec p_GetTopBlockedSessionCount 30
CREATE PROCEDURE [dbo].[p_GetTopBlockedSessionCount]
@TopX INT = NULL
AS
BEGIN
	DECLARE @Threshold TABLE(SQLServerID INT, MetricID INT, WarningThreshold NUMERIC, CriticalThreshold NUMERIC, InfoThreshold NUMERIC)
	DECLARE @MetricID INT;
	SET @MetricID = 58; --this is the metric id for blocked session count
	
	INSERT INTO @Threshold EXEC p_PopulateMetricThresholds @MetricID;
	


	IF @TopX IS NOT null AND @TopX > 0
		SET ROWCOUNT @TopX;	

	WITH picked([UTCCollectionDateTime],SQLServerID) AS
	( Select max([UTCCollectionDateTime]), SQLServerID from ServerStatistics (nolock) group by SQLServerID) 


	SELECT
	 MSS.[InstanceName]
	,SS.[UTCCollectionDateTime]
	,SS.[SQLServerID]
	,SS.[BlockedProcesses] as [BlockedSessionCount]
	,dbo.fn_GetSeverityByMetricValue(T.CriticalThreshold,T.WarningThreshold,T.InfoThreshold,[BlockedProcesses],default,default,default,default,default) Severity 
	--,[LeadBlockers] as [Lead Blockers]
    --,[LockStatistics] as [Lock Statistics]
from
	picked 
	left join [ServerStatistics] SS (nolock) on picked.[SQLServerID] = SS.[SQLServerID] and picked.[UTCCollectionDateTime] = SS.[UTCCollectionDateTime]
	--left join [ServerActivity] SA (nolock) on SA.[SQLServerID] = SS.[SQLServerID] and SA.[UTCCollectionDateTime] = SS.[UTCCollectionDateTime]
	left join [MonitoredSQLServers] MSS (nolock) on MSS.[SQLServerID]=SS.[SQLServerID]
	left JOIN @Threshold T ON T.SQLServerID = SS.SQLServerID	 
WHERE MSS.Active = 1
Order by 
	[BlockedProcesses] DESC
END
 
GO 

---------- P_GETTOPDATABASEAPPLICATIONS.SQL
if (object_id('p_GetTopDatabaseApplications') is not null)
begin
drop procedure p_GetTopDatabaseApplications
end
go
-- @OrderBy
--	0 - CPU
--	1 - Reads
--	2 - Writes
create procedure [dbo].p_GetTopDatabaseApplications
	@SQLServerID int,
	@DatabaseName sysname = null,
	@StartDateTime datetime = null,
	@EndDateTime datetime = null,
	@UtcOffset int = null,
	@MinReads bigint = null,
	@MinWrites bigint = null,
	@MinCPU bigint = null,
	@TopN bigint = 10,
	@OrderBy tinyint = 0
as
begin
set ansi_warnings off
set ansi_nulls off

if @DatabaseName is null or len(@DatabaseName) = 0
	set @DatabaseName = '%'

if @UtcOffset is null
	set @UtcOffset = datediff(mi,getutcdate(),getdate())

declare @DatabaseIds table (Id int, DatabaseName sysname)

insert into @DatabaseIds
select isnull(DatabaseID,-1), DatabaseName
from
	SQLServerDatabaseNames (nolock)
where
	SQLServerID = @SQLServerID
	and DatabaseName like @DatabaseName

set rowcount @TopN

select -- top @TopN
	DatabaseName,
	ApplicationName,
	SumCPU = sum(SumCPU),
	SumReads = sum(SumReads),
	SumWrites = sum(SumWrites),
	SumEvents = sum(SumEvents),
	AvgDuration = sum(TotalDuration) / nullif(sum(SumEvents),0)
from
(
select 
	DatabaseName,
	ApplicationNameID,
	SumCPU = sum(CPUMilliseconds),
	SumReads = sum(Reads),
	SumWrites = sum(Writes),
	SumEvents = count(*),
	TotalDuration = sum(DurationMilliseconds)
from
	@DatabaseIds d 
	join dbo.QueryMonitorStatistics qm (nolock) on qm.DatabaseID = d.Id
where
	SQLServerID = @SQLServerID and
	isnull(@StartDateTime,'1 Jan 1900') <= StatementUTCStartTime and
	isnull(@EndDateTime,'1 Jan 2200') >= case when DurationMilliseconds < 2147483648 then dateadd(ms, DurationMilliseconds,  StatementUTCStartTime) else dateadd(s, DurationMilliseconds / 1000,  StatementUTCStartTime) end
group by
	DatabaseName,
	ApplicationNameID
union all
select 
	DatabaseName,
	ApplicationNameID,
	SumCPU = sum(TotalCPUMilliseconds),
	SumReads = sum(TotalReads),
	SumWrites = sum(TotalWrites),
	SumEvents = sum(QueryMonitorOccurrences),
	TotalDuration = sum(TotalDurationMilliseconds)
from
	@DatabaseIds d 
	join dbo.QuerySignatureAggregation qm (nolock) on qm.DatabaseID = d.Id
where
	SQLServerID = @SQLServerID and
	isnull(@StartDateTime,'1 Jan 1900') <= EventUTCStartTime and
	isnull(@EndDateTime,'1 Jan 2200') >= EventUTCStartTime
group by
	DatabaseName,
	ApplicationNameID
) as data
inner join ApplicationNames an
on data.ApplicationNameID = an.ApplicationNameID
group by
	DatabaseName,
	ApplicationName
having
	sum(SumReads) >= isnull(@MinReads,0) and
	sum(SumWrites) >= isnull(@MinWrites,0) and
	sum(SumCPU) >= isnull(@MinCPU,0)
order by
	case 
		when @OrderBy = 0 then avg(SumCPU)
		when @OrderBy = 1 then avg(SumReads)
		when @OrderBy = 2 then avg(SumWrites)
		else  count(*)
	end 
	desc
end

Go

grant EXECUTE on p_GetTopDatabaseApplications to [SQLdmConsoleUser]
 
GO 

---------- P_GETTOPDATABASEBYACTIVITY.SQL
IF (OBJECT_ID('p_GetTopDatabaseByActivity') IS NOT NULL)
BEGIN
  DROP PROC [p_GetTopDatabaseByActivity]
END
GO
-- [p_GetTopDatabaseByActivity] 30
CREATE PROCEDURE [dbo].[p_GetTopDatabaseByActivity]
@TopX INT = NULL
AS
BEGIN

DECLARE @Threshold TABLE(SQLServerID INT, MetricID INT, WarningThreshold NUMERIC, CriticalThreshold NUMERIC, InfoThreshold NUMERIC)
	DECLARE @MetricID INT;
	SET @MetricID = 0; --this is the metric id for database activity
	
	INSERT INTO @Threshold EXEC p_PopulateMetricThresholds @MetricID;	

IF @TopX IS NOT null AND @TopX > 0
  SET ROWCOUNT @TopX;
  

with DBMaxCollTime (SQLServerID, InstanceName, DatabaseID, DatabaseName, UTCCollectionDateTime) as (
  select MS.SQLServerID, MS.InstanceName, DS.DatabaseID, names.DatabaseName, MAX(UTCCollectionDateTime)
  from DatabaseStatistics DS (nolock)
    JOIN [SQLServerDatabaseNames] names (nolock) 
      ON DS.DatabaseID = names.DatabaseID
    JOIN MonitoredSQLServers MS (nolock)
      ON names.SQLServerID = MS.SQLServerID
  WHERE MS.Active = 1
  GROUP BY MS.SQLServerID, MS.InstanceName, DS.DatabaseID, names.DatabaseName
)

	SELECT
		O.InstanceName, 
		O.UTCCollectionDateTime,
		O.SQLServerID, 
		O.DatabaseName, 
		O.TransactionsPerSecond,
		dbo.fn_GetSeverityByMetricValue(T.CriticalThreshold,T.WarningThreshold,T.InfoThreshold,O.TransactionsPerSecond,default,default,default,default,default) Severity 
	FROM (
			SELECT dct.UTCCollectionDateTime,
				dct.SQLServerID, 
				dct.InstanceName, 
				dct.DatabaseName,
				sum(convert(float,ds.Transactions)) / nullif(sum(case when ds.Transactions is not null then ds.TimeDeltaInSeconds else 0 end)  ,0) TransactionsPerSecond
	FROM DBMaxCollTime dct
		JOIN DatabaseStatistics ds (nolock) ON ds.DatabaseID = dct.DatabaseID AND ds.UTCCollectionDateTime = ds.UTCCollectionDateTime
	group by dct.UTCCollectionDateTime, dct.SQLServerID, dct.InstanceName, dct.DatabaseName
	) O 	
	JOIN @Threshold T ON T.SQLServerID = O.SQLServerID
	ORDER BY O.TransactionsPerSecond DESC
END
 
GO 

---------- P_GETTOPDATABASEBYPROJECTEDGROWTH.SQL
IF (OBJECT_ID('p_GetTopDatabaseByProjectedGrowth') IS NOT NULL)
BEGIN
  DROP PROC p_GetTopDatabaseByProjectedGrowth
END
GO
-- p_GetTopDatabaseByProjectedGrowth 20,null,1000
CREATE  PROCEDURE [dbo].[p_GetTopDatabaseByProjectedGrowth]
	@TopX INT = NULL,
	@UTCSnapshotCollectionDateTime datetime = null,
	@HistoryInDays int = null
AS
BEGIN	
declare @err int

declare @BeginDateTime datetime
declare @EndDateTime datetime
if (@UTCSnapshotCollectionDateTime is null)
	select @EndDateTime = (select max(UTCCollectionDateTime) from [DatabaseSize])
else
	select @EndDateTime = @UTCSnapshotCollectionDateTime

if (@HistoryInDays is null)
	select @BeginDateTime = @EndDateTime;
else
	select @BeginDateTime = dateadd(DAY, -@HistoryInDays, @EndDateTime);

IF @TopX IS NOT null AND @TopX > 0
  SET ROWCOUNT @TopX;
  
with DBCollectionRange (SQLServerID, InstanceName, DatabaseID, DatabaseName, MaxCollectionTime, MinCollectionTime) as (
	select MS.SQLServerID, MS.InstanceName, DS.DatabaseID, names.DatabaseName, MAX(UTCCollectionDateTime), MIN(UTCCollectionDateTime)
	from DatabaseSize DS (nolock)
		Join [SQLServerDatabaseNames] names (nolock) 
			on DS.DatabaseID = names.DatabaseID
		Join MonitoredSQLServers MS (nolock)
			on names.SQLServerID = MS.SQLServerID
			   and MS.Active = 1
	where UTCCollectionDateTime >= @BeginDateTime
	group by MS.SQLServerID, MS.InstanceName, DS.DatabaseID, names.DatabaseName
)

select
	dcr.[SQLServerID],
	dcr.[InstanceName],
	dcr.[DatabaseID],
	dcr.[DatabaseName],	
	(
	    (select (isnull(DataSizeInKilobytes,0) + isnull(IndexSizeInKilobytes,0) + isnull(TextSizeInKilobytes,0)) as TotalSizeKb 
	    from DatabaseSize ds1
		where ds1.DatabaseID = dcr.DatabaseID
      		  and ds1.UTCCollectionDateTime = dcr.MaxCollectionTime)
          -
          (select (isnull(DataSizeInKilobytes,0) + isnull(IndexSizeInKilobytes,0) + isnull(TextSizeInKilobytes,0)) as TotalSizeKb 
	    from DatabaseSize ds1
		where ds1.DatabaseID = dcr.DatabaseID
      		  and ds1.UTCCollectionDateTime = dcr.MinCollectionTime)
	) as TotalSizeDiffKb,
	dcr.MaxCollectionTime as UTCCollectionDateTime,
	dcr.MinCollectionTime
from
	DBCollectionRange dcr
ORDER BY TotalSizeDiffKb desc
	
	select @err = @@error
return @err

END
 
GO 

---------- P_GETTOPDATABASES.SQL
if (object_id('p_GetTopDatabases') is not null)
begin
drop procedure p_GetTopDatabases
end
go
-- @OrderBy
--	0 - Size
--	1 - Growth Rate
--	2 - Reads 
--	3 - Writes
--	4 - Transactions
create procedure [dbo].p_GetTopDatabases
	@ServerId int,
	@DatabaseNameFilter sysname = null,
	@UTCStart DateTime,
	@UTCEnd DateTime,
	@UTCOffset int = 0,
	@MinSizeMB decimal = null,
	@MinGrowthPercent bigint = null,
	@MinTransactionsPerSecond bigint = null,
	@MinReadsPerSecond bigint = null,
	@MinWritesPerSecond bigint = null,
	@TopN bigint = 10,
	@OrderBy tinyint = 0,
	@IncludeSystem bit = 1
as
begin


set rowcount 0

create table #DatabaseInfo
(
	DatabaseID int primary key clustered, 
	DatabaseName nvarchar(255),
	StartTime datetime,
	EndTime datetime,
	StartTotalDataSizeInKilobytes decimal,
	EndDataFileSizeInKilobytes decimal,
	EndLogFileSizeInKilobytes decimal,
	EndTotalDataSizeInKilobytes decimal,
	UTCStart datetime,
	UTCEnd datetime)


if @DatabaseNameFilter is null or len(@DatabaseNameFilter) = 0
begin
	insert into #DatabaseInfo(DatabaseID,DatabaseName, StartTime, EndTime,UTCStart,UTCEnd)
		select 
			names.DatabaseID,
			DatabaseName,
			min(UTCCollectionDateTime),
			max(UTCCollectionDateTime) ,
			@UTCStart,
			@UTCEnd
		from 
			[dbo].[SQLServerDatabaseNames] names (nolock)
			left join DatabaseSize (nolock) ds
			on ds.DatabaseID = names.DatabaseID
		where
			names.[SQLServerID] = @ServerId
			and (@IncludeSystem = 1 or names.SystemDatabase = 0)
			and dbo.fn_RoundDateTime(0, [UTCCollectionDateTime]) between @UTCStart and @UTCEnd
		group by
			names.DatabaseID,
			DatabaseName
end		
else
begin
	insert into #DatabaseInfo(DatabaseID,DatabaseName, StartTime, EndTime,UTCStart,UTCEnd)
		select 
			names.DatabaseID,
			DatabaseName,
			min(UTCCollectionDateTime),
			max(UTCCollectionDateTime) ,
			@UTCStart,
			@UTCEnd
		from 
			[dbo].[SQLServerDatabaseNames] names (nolock)
			left join DatabaseSize (nolock) ds
			on ds.DatabaseID = names.DatabaseID
		where
			names.[SQLServerID] = @ServerId
			and names.[DatabaseName] like @DatabaseNameFilter	
			and (@IncludeSystem = 1 or names.SystemDatabase = 0)
			and dbo.fn_RoundDateTime(0, [UTCCollectionDateTime]) between @UTCStart and @UTCEnd
		group by
			names.DatabaseID,
			DatabaseName
end		

update #DatabaseInfo
set 
	StartTotalDataSizeInKilobytes = isnull(DataSizeInKilobytes,0)
from
	#DatabaseInfo di inner join 
	[DatabaseSize] ds (nolock)
	on di.DatabaseID = ds.DatabaseID
where
	[UTCCollectionDateTime] = StartTime
	
update #DatabaseInfo
set 
	StartTotalDataSizeInKilobytes = isnull(DataSizeInKilobytes,0)
from
	#DatabaseInfo di inner join 
	[DatabaseSize] ds (nolock)
	on di.DatabaseID = ds.DatabaseID
where
	[UTCCollectionDateTime] = StartTime
	

update #DatabaseInfo
set 
	EndDataFileSizeInKilobytes = DataFileSizeInKilobytes,
	EndLogFileSizeInKilobytes = LogFileSizeInKilobytes,
	EndTotalDataSizeInKilobytes = isnull(DataSizeInKilobytes,0)
from
	#DatabaseInfo di inner join 
	[DatabaseSize] ds (nolock)
	on di.DatabaseID = ds.DatabaseID
where
	[UTCCollectionDateTime] =  EndTime
	
if (@MinSizeMB is not null)
begin	
	delete from #DatabaseInfo
	where
	isnull(EndTotalDataSizeInKilobytes,0) / 1024 < @MinSizeMB	
end

if (@MinGrowthPercent is not null)
begin
	delete from #DatabaseInfo
	where DatabaseID in(
	select DatabaseID 
	from #DatabaseInfo
	group by DatabaseID
	having
	isnull(max(EndTotalDataSizeInKilobytes / nullif(StartTotalDataSizeInKilobytes,0)),0) < isnull((cast(@MinGrowthPercent as float) / 100) + case @MinGrowthPercent when 0 then 0 else 1 end,1))
end

set rowcount @TopN




select 
	[DatabaseName],
	[LastCollectioninInterval] = max(dateadd(mi, @UTCOffset, ds.[UTCCollectionDateTime])),
	DataFileSizeMb = max(EndDataFileSizeInKilobytes) / 1024,  -- Max here is to avoid duplication
	LogFileSizeMb = max(EndLogFileSizeInKilobytes) /1024, 
	DataSizeMb = max(EndTotalDataSizeInKilobytes) / 1024,
	GrowthOverPeriod = max(EndTotalDataSizeInKilobytes / nullif(StartTotalDataSizeInKilobytes,0)) - 1,
	KBReadPerSecond = sum(convert(float,ds.BytesRead) / 1024) / nullif(sum(case when ds.BytesRead is not null then ds.TimeDeltaInSeconds else 0 end),0),
	KBWrittenPerSecond = sum(convert(float,ds.BytesWritten) / 1024) / nullif(sum(case when ds.BytesWritten is not null then ds.TimeDeltaInSeconds else 0 end) ,0),
	TransactionsPerSecond = sum(convert(float,ds.Transactions)) / nullif(sum(case when ds.Transactions is not null then ds.TimeDeltaInSeconds else 0 end)  ,0)
from
	#DatabaseInfo di (nolock)
	left join [DatabaseStatistics] ds (nolock)
	on di.DatabaseID = ds.[DatabaseID]
where 
	ds.[UTCCollectionDateTime] between di.UTCStart and di.UTCEnd
group by
	[DatabaseName]
having
	isnull(sum(convert(float,ds.Transactions)) / nullif(sum(case when ds.Transactions is not null then ds.TimeDeltaInSeconds else 0 end)  ,0),0) >= isnull(@MinTransactionsPerSecond,0)
	and isnull(sum(convert(float,ds.BytesRead) / 1024) / nullif(sum(case when ds.BytesRead is not null then ds.TimeDeltaInSeconds else 0 end),0),0) >= isnull(@MinReadsPerSecond,0)
	and isnull(sum(convert(float,ds.BytesWritten) / 1024) / nullif(sum(case when ds.BytesWritten is not null then ds.TimeDeltaInSeconds else 0 end) ,0),0) >= isnull(@MinWritesPerSecond,0)
order by
	case 
	when @OrderBy = 0 then max(EndTotalDataSizeInKilobytes) / 1024
	when @OrderBy = 1 then max(EndTotalDataSizeInKilobytes / nullif(StartTotalDataSizeInKilobytes,0)) - 1
	when @OrderBy = 2 then sum(convert(float,ds.BytesRead)) / nullif((sum(convert(float,ds.TimeDeltaInSeconds)) / 1024 / 60) ,0)
	when @OrderBy = 3 then sum(convert(float,ds.BytesWritten)) / nullif((sum(convert(float,ds.TimeDeltaInSeconds)) / 1024 / 60) ,0)
	when @OrderBy = 4 then sum(convert(float,ds.Transactions)) / nullif((sum(convert(float,ds.TimeDeltaInSeconds)) / 60) ,0)
	else max(EndTotalDataSizeInKilobytes) / 1024
	end 
	desc

drop table #DatabaseInfo

set rowcount 0

end

Go

grant EXECUTE on [p_GetTopDatabases] to [SQLdmConsoleUser]

go

if (object_id('p_GetTopDatabasesBySize') is not null)
begin
drop procedure p_GetTopDatabasesBySize
end
go
create procedure [dbo].p_GetTopDatabasesBySize
	@ServerId int,
	@DatabaseNameFilter sysname = null,
	@UTCStart DateTime,
	@UTCEnd DateTime,
	@UTCOffset int = 0,
	@MinSizeMB decimal = null,
	@MinGrowthPercent bigint = null,
	@MinTransactionsPerSecond bigint = null,
	@MinReadsPerSecond bigint = null,
	@MinWritesPerSecond bigint = null,
	@TopN bigint = 10,
	@IncludeSystem bit = 1
as
begin

	exec p_GetTopDatabases
		@ServerId,
		@DatabaseNameFilter,
		@UTCStart,
		@UTCEnd,
		@UTCOffset,
		@MinSizeMB,
		@MinGrowthPercent,
		@MinTransactionsPerSecond,
		@MinReadsPerSecond,
		@MinWritesPerSecond,
		@TopN,
		0,
		@IncludeSystem
end

Go

grant EXECUTE on [p_GetTopDatabasesBySize] to [SQLdmConsoleUser]

go

if (object_id('p_GetTopDatabasesByGrowth') is not null)
begin
drop procedure p_GetTopDatabasesByGrowth
end
go
create procedure [dbo].p_GetTopDatabasesByGrowth
	@ServerId int,
	@DatabaseNameFilter sysname = null,
	@UTCStart DateTime,
	@UTCEnd DateTime,
	@UTCOffset int = 0,
	@MinSizeMB decimal = null,
	@MinGrowthPercent bigint = null,
	@MinTransactionsPerSecond bigint = null,
	@MinReadsPerSecond bigint = null,
	@MinWritesPerSecond bigint = null,
	@TopN bigint = 10,
	@IncludeSystem bit = 1
as
begin

	exec p_GetTopDatabases
		@ServerId,
		@DatabaseNameFilter,
		@UTCStart,
		@UTCEnd,
		@UTCOffset,
		@MinSizeMB,
		@MinGrowthPercent,
		@MinTransactionsPerSecond,
		@MinReadsPerSecond,
		@MinWritesPerSecond,
		@TopN,
		1,
		@IncludeSystem
end

Go

grant EXECUTE on [p_GetTopDatabasesByGrowth] to [SQLdmConsoleUser]

go

if (object_id('p_GetTopDatabasesByReads') is not null)
begin
drop procedure p_GetTopDatabasesByReads
end
go
create procedure [dbo].p_GetTopDatabasesByReads
	@ServerId int,
	@DatabaseNameFilter sysname = null,
	@UTCStart DateTime,
	@UTCEnd DateTime,
	@UTCOffset int = 0,
	@MinSizeMB decimal = null,
	@MinGrowthPercent bigint = null,
	@MinTransactionsPerSecond bigint = null,
	@MinReadsPerSecond bigint = null,
	@MinWritesPerSecond bigint = null,
	@TopN bigint = 10,
	@IncludeSystem bit = 1
as
begin

	exec p_GetTopDatabases
		@ServerId,
		@DatabaseNameFilter,
		@UTCStart,
		@UTCEnd,
		@UTCOffset,
		@MinSizeMB,
		@MinGrowthPercent,
		@MinTransactionsPerSecond,
		@MinReadsPerSecond,
		@MinWritesPerSecond,
		@TopN,
		2,
		@IncludeSystem
end

Go

grant EXECUTE on [p_GetTopDatabasesByReads] to [SQLdmConsoleUser]

go

if (object_id('p_GetTopDatabasesByWrites') is not null)
begin
drop procedure p_GetTopDatabasesByWrites
end
go
create procedure [dbo].p_GetTopDatabasesByWrites
	@ServerId int,
	@DatabaseNameFilter sysname = null,
	@UTCStart DateTime,
	@UTCEnd DateTime,
	@UTCOffset int = 0,
	@MinSizeMB decimal = null,
	@MinGrowthPercent bigint = null,
	@MinTransactionsPerSecond bigint = null,
	@MinReadsPerSecond bigint = null,
	@MinWritesPerSecond bigint = null,
	@TopN bigint = 10,
	@IncludeSystem bit = 1
as
begin

	exec p_GetTopDatabases
		@ServerId,
		@DatabaseNameFilter,
		@UTCStart,
		@UTCEnd,
		@UTCOffset,
		@MinSizeMB,
		@MinGrowthPercent,
		@MinTransactionsPerSecond,
		@MinReadsPerSecond,
		@MinWritesPerSecond,
		@TopN,
		3,
		@IncludeSystem
end

Go

grant EXECUTE on [p_GetTopDatabasesByWrites] to [SQLdmConsoleUser]

go

if (object_id('p_GetTopDatabasesByTransactions') is not null)
begin
drop procedure p_GetTopDatabasesByTransactions
end
go
create procedure [dbo].p_GetTopDatabasesByTransactions
	@ServerId int,
	@DatabaseNameFilter sysname = null,
	@UTCStart DateTime,
	@UTCEnd DateTime,
	@UTCOffset int = 0,
	@MinSizeMB decimal = null,
	@MinGrowthPercent bigint = null,
	@MinTransactionsPerSecond bigint = null,
	@MinReadsPerSecond bigint = null,
	@MinWritesPerSecond bigint = null,
	@TopN bigint = 10,
	@IncludeSystem bit = 1
as
begin

	exec p_GetTopDatabases
		@ServerId,
		@DatabaseNameFilter,
		@UTCStart,
		@UTCEnd,
		@UTCOffset,
		@MinSizeMB,
		@MinGrowthPercent,
		@MinTransactionsPerSecond,
		@MinReadsPerSecond,
		@MinWritesPerSecond,
		@TopN,
		4,
		@IncludeSystem
end

Go

grant EXECUTE on [p_GetTopDatabasesByTransactions] to [SQLdmConsoleUser]
 
GO 

---------- P_GETTOPDATABASESBYALERTS.SQL
if (object_id('p_GetTopDatabasesByAlerts') is not null)
begin
drop procedure p_GetTopDatabasesByAlerts
end
GO

/*-- 
SQLdm 8.5 (Ankit Srivastava): for Top X API- Databases by most alerts
EXEC  [p_GetTopDatabasesByAlerts] 100
--*/

Create PROCEDURE [dbo].[p_GetTopDatabasesByAlerts](
  @TopX int=null
)
AS
BEGIN

IF @TopX IS NOT null AND @TopX > 0
  SET ROWCOUNT @TopX

SELECT  mss.SQLServerID, a.DatabaseName, mss.InstanceName, count(1) as NumOfAlerts, MAX(a.Severity) as MaxSeverity
FROM Alerts a WITH (NOLOCK)
left outer join DBMetrics DBM (nolock) on DBM.MetricID = a.[Metric]
LEFT OUTER JOIN MonitoredSQLServers mss (nolock)
ON mss.InstanceName = a.ServerName
   and (
   		(DBM.MetricID is NULL AND mss.LastScheduledCollectionTime = a.UTCOccurrenceDateTime)
        or 
        (DBM.MetricID is NOT NULL AND mss.LastDatabaseCollectionTime = a.UTCOccurrenceDateTime))
where mss.Active=1 and a.Active = 1 and DatabaseName is not null and mss.InstanceName is not null
group by DatabaseName ,mss.InstanceName,mss.SQLServerID
order by NumOfAlerts DESC

end




GO

 
GO 

---------- P_GETTOPDATABASESBYQUERYWAITS.SQL
-- Created by Aditya Shukla for SQLdm 8.6
-- This procedure is used to fetch data for the Query Waits section in Top databases report

--exec [p_GetTopDatabasesByQueryWaits] 9, null, '2013-7-24 00:00:00', '2014-7-24 00:00:00', 330.0, 0, 0, 0, 0, 0, 5, 1, 2000 

if (object_id('p_GetTopDatabasesByQueryWaits') is not null)
begin
drop procedure [p_GetTopDatabasesByQueryWaits]
end
go

create procedure [dbo].[p_GetTopDatabasesByQueryWaits]
	@ServerId int,
	@DatabaseNameFilter sysname = null,
	@UTCStart DateTime,
	@UTCEnd DateTime,
	@UTCOffset int = 0,
	@MinSizeMB decimal = null,
	@MinGrowthPercent bigint = null,
	@MinTransactionsPerSecond bigint = null,
	@MinReadsPerSecond bigint = null,
	@MinWritesPerSecond bigint = null,
	@TopN bigint = 10,
	@IncludeSystem bit = 1,
	@threshold bigint = 0 -- a value in milliseconds
as
begin

	set rowcount 0

	create table #DatabaseInfo
	(
		DatabaseID int primary key clustered, 
		DatabaseName nvarchar(255),
		StartTime datetime,
		EndTime datetime,
		StartTotalDataSizeInKilobytes decimal,
		EndDataFileSizeInKilobytes decimal,
		EndLogFileSizeInKilobytes decimal,
		EndTotalDataSizeInKilobytes decimal,
		UTCStart datetime,
		UTCEnd datetime
	)

	--Applying the @DatabaseName filter if any. Provided by user on the UI
	if @DatabaseNameFilter is null or len(rtrim(ltrim(@DatabaseNameFilter))) = 0
	begin
		insert into #DatabaseInfo(DatabaseID,DatabaseName, StartTime, EndTime,UTCStart,UTCEnd)
			select 
				names.DatabaseID,
				DatabaseName,
				min(UTCCollectionDateTime),
				max(UTCCollectionDateTime) ,
				@UTCStart,
				@UTCEnd
			from 
				[dbo].[SQLServerDatabaseNames] names (nolock)
				left join DatabaseSize (nolock) ds
				on ds.DatabaseID = names.DatabaseID
			where
				names.[SQLServerID] = @ServerId
				and (@IncludeSystem = 1 or names.SystemDatabase = 0)
				and dbo.fn_RoundDateTime(0, [UTCCollectionDateTime]) between @UTCStart and @UTCEnd
			group by
				names.DatabaseID,
				DatabaseName
	end		
	else
	begin
		insert into #DatabaseInfo(DatabaseID,DatabaseName, StartTime, EndTime,UTCStart,UTCEnd)
			select 
				names.DatabaseID,
				DatabaseName,
				min(UTCCollectionDateTime),
				max(UTCCollectionDateTime) ,
				@UTCStart,
				@UTCEnd
			from 
				[dbo].[SQLServerDatabaseNames] names (nolock)
				left join DatabaseSize (nolock) ds
				on ds.DatabaseID = names.DatabaseID
			where
				names.[SQLServerID] = @ServerId
				and names.[DatabaseName] like @DatabaseNameFilter	
				and (@IncludeSystem = 1 or names.SystemDatabase = 0)
				and dbo.fn_RoundDateTime(0, [UTCCollectionDateTime]) between @UTCStart and @UTCEnd
			group by
				names.DatabaseID,
				DatabaseName
	end		

	update #DatabaseInfo
	set 
		StartTotalDataSizeInKilobytes = isnull(DataSizeInKilobytes,0)
	from
		#DatabaseInfo di inner join 
		[DatabaseSize] ds (nolock)
		on di.DatabaseID = ds.DatabaseID
	where
		[UTCCollectionDateTime] = StartTime

	update #DatabaseInfo
	set 
		EndDataFileSizeInKilobytes = DataFileSizeInKilobytes,
		EndLogFileSizeInKilobytes = LogFileSizeInKilobytes,
		EndTotalDataSizeInKilobytes = isnull(DataSizeInKilobytes,0)
	from
		#DatabaseInfo di inner join 
		[DatabaseSize] ds (nolock)
		on di.DatabaseID = ds.DatabaseID
	where
		[UTCCollectionDateTime] =  EndTime
	
	--Applying the Size filter 
	if (@MinSizeMB is not null)
	begin	
		delete from #DatabaseInfo
		where
		isnull(EndTotalDataSizeInKilobytes,0) / 1024 < @MinSizeMB	
	end

	--Applying Growth filter
	if (@MinGrowthPercent is not null)
	begin
		delete from #DatabaseInfo
		where DatabaseID in(
		select DatabaseID 
		from #DatabaseInfo
		group by DatabaseID
		having
		isnull(max(EndTotalDataSizeInKilobytes / nullif(StartTotalDataSizeInKilobytes,0)),0) < isnull((cast(@MinGrowthPercent as float) / 100) + case @MinGrowthPercent when 0 then 0 else 1 end,1))
	end

	--Assigning row numbers to rows of sets partitioned by database name and ordered by wait desc 
	select aws.SQLServerID,
		di.DatabaseName, 
		aws.WaitTypeID, 
		aws.LoginNameID, 
		aws.WaitDuration, 
		aws.WaitDuration - @threshold as [difference], 
		aws.StatementUTCStartTime,
		row_number() over (partition by aws.[DatabaseID] order by aws.WaitDuration desc) as rankNumber 
	into #RankedData
	from #DatabaseInfo di inner join ActiveWaitStatistics aws (nolock)
		on di.DatabaseID = aws.DatabaseID
	where aws.[UTCCollectionDateTime] between @UTCStart and @UTCEnd
	and aws.WaitDuration > @threshold

	--This ensures that only @TopN rows are selected
	set rowcount @TopN

	--Selecting the top row from each of the partitioned sets while the row count is less than @TopN
	select 
		rd.DatabaseName [DatabaseName], 
		wt.WaitType [WaitType],
		rd.StatementUTCStartTime [StatementUTCStartTime],
		rd.WaitDuration [WaitDuration],
		rd.[difference] [ExceededThresholdBy],
		ln.LoginName [LoginName]
	from #RankedData rd left join LoginNames ln (nolock) 
	on rd.LoginNameID = ln.LoginNameID
	left join WaitTypes wt (nolock)
	on wt.WaitTypeID = rd.WaitTypeID
	where rankNumber = 1
	order by rd.WaitDuration desc

	set rowcount 0
end
GO

 
GO 

---------- P_GETTOPDATABASESBYSIZEFORWEBCONSOLE.SQL
IF (OBJECT_ID('p_GetTopDatabasesBySizeForWebConsole') IS NOT NULL)
BEGIN
  DROP PROCEDURE [p_GetTopDatabasesBySizeForWebConsole]
END
GO
-- [p_GetTopDatabasesBySizeForWebConsole] 30
CREATE PROCEDURE [dbo].[p_GetTopDatabasesBySizeForWebConsole]
@TopX INT = NULL
AS
BEGIN
	DECLARE @Threshold TABLE(SQLServerID INT, MetricID INT, WarningThreshold NUMERIC, CriticalThreshold NUMERIC, InfoThreshold NUMERIC,InstanceName varchar(255))
	DECLARE @MetricID INT;
	SET @MetricID = 109; --this is the metric id for database size
	
	INSERT INTO @Threshold EXEC p_PopulateMetricThresholdsNew @MetricID;
	
	IF @TopX IS NOT null AND @TopX > 0
		SET ROWCOUNT @TopX;
		
	with DBMaxCollTime (SQLServerID, InstanceName, DatabaseID, DatabaseName, MaxCollectionTime) as (
		select MS.SQLServerID, MS.InstanceName, DS.DatabaseID, names.DatabaseName, MAX(UTCCollectionDateTime)
		from @Threshold MS
			Join [SQLServerDatabaseNames] names (nolock) 
				on MS.SQLServerID = names.SQLServerID 
			Join DatabaseSize DS (nolock)
				on names.DatabaseID = DS.DatabaseID
	    group by MS.SQLServerID, MS.InstanceName, DS.DatabaseID, names.DatabaseName
	)
	SELECT mct.SQLServerID InstanceID,
		mct.DatabaseID,
		mct.DatabaseName,
		mct.InstanceName, 
		mct.MaxCollectionTime as UTCCollectionDateTime,
		(SS.DataFileSizeInKilobytes/1024) DataFileSizeMB,
		dbo.fn_GetSeverityByMetricValue(T.CriticalThreshold,T.WarningThreshold,T.InfoThreshold,(SS.DataFileSizeInKilobytes/1024),default,default,default,default,default) Severity 
	FROM @Threshold T 
		JOIN DBMaxCollTime mct  (nolock)
			ON T.SQLServerID = mct.SQLServerID
		JOIN DatabaseSize SS  (nolock)
			ON mct.DatabaseID = SS.DatabaseID AND SS.UTCCollectionDateTime = mct.MaxCollectionTime
	ORDER BY DataFileSizeMB DESC
END
 
GO 

---------- P_GETTOPINSTANCESBYALERTS.SQL
if (object_id('p_GetTopInstancesByAlerts') is not null)
begin
drop procedure p_GetTopInstancesByAlerts
end
GO


/*-- 
SQLdm 8.5 (Ankit Srivastava): for Top X API- Most Instance Alerts for last 7 days
EXEC  [p_GetTopInstancesByAlerts] 1
--*/

Create PROCEDURE [dbo].[p_GetTopInstancesByAlerts](
  @TopX int=NULL
)
AS
BEGIN

IF @TopX IS NOT null AND @TopX > 0
  SET ROWCOUNT @TopX


  SELECT mss.SQLServerID , mss.InstanceName, count(a.AlertID) as NumOfAlerts, max(a.Severity) as MaxSeverity
  FROM Alerts a WITH(NOLOCK)
  left outer join DBMetrics DBM (nolock) on DBM.MetricID = a.[Metric]
    INNER join MonitoredSQLServers mss WITH(NOLOCK)
  ON mss.InstanceName = a.ServerName
     and (
      (DBM.MetricID is NULL AND mss.LastScheduledCollectionTime = a.UTCOccurrenceDateTime)
        or 
        (DBM.MetricID is NOT NULL AND mss.LastDatabaseCollectionTime = a.UTCOccurrenceDateTime))
  WHERE mss.Active=1 and a.Active=1
  group by mss.InstanceName, mss.SQLServerID 
  order by NumOfAlerts desc 

END
GO

 
GO 

---------- P_GETTOPINSTANCESBYCONNECTIONS.SQL
IF (OBJECT_ID('p_GetTopInstancesByConnections') IS NOT NULL)
BEGIN
  DROP PROCEDURE [p_GetTopInstancesByConnections]
END
GO
-- [p_GetTopInstancesByConnections] 30
CREATE PROCEDURE [dbo].[p_GetTopInstancesByConnections]
@TopX INT = NULL
AS
BEGIN
DECLARE @Threshold TABLE(SQLServerID INT, MetricID INT, WarningThreshold NUMERIC, CriticalThreshold NUMERIC, InfoThreshold NUMERIC,InstanceName nvarchar(256))		
	DECLARE @MetricID INT;
	SET @MetricID = 57; --this is the metric id for database connections
	
	INSERT INTO @Threshold EXEC p_PopulateMetricThresholdsNew @MetricID;
	
	IF @TopX IS NOT null AND @TopX > 0
		SET ROWCOUNT @TopX;
	
	
	with MaxCollTime (SQLServerID, MaxCollectionTime, InstanceName) as 
		(select MS.SQLServerID, MAX(UTCCollectionDateTime), MS.InstanceName
			from @Threshold MS
				Join [ServerStatistics] SS (nolock) 
                    on MS.SQLServerID = SS.SQLServerID 
                    group by MS.SQLServerID, MS.InstanceName
        )
				
	SELECT O.SQLServerID,O.InstanceName, O.MaxCollectionTime,O.Logins,dbo.fn_GetSeverityByMetricValue(T.CriticalThreshold,T.WarningThreshold,T.InfoThreshold,O.Logins,default,default,default,default,default) Severity 
	FROM (
	SELECT mct.MaxCollectionTime,
			mct.SQLServerID, 
			mct.InstanceName, 
			SS.Logins
	FROM MaxCollTime mct 
		JOIN ServerStatistics SS (nolock) ON mct.SQLServerID = SS.SQLServerID
		    AND mct.MaxCollectionTime = SS.UTCCollectionDateTime		
	) O 
	JOIN @Threshold T ON T.SQLServerID = O.SQLServerID
	ORDER BY O.Logins DESC
END

 
GO 

---------- P_GETTOPINSTANCESBYCPUUSAGE.SQL
IF (object_id('p_GetTopInstancesByCPUUsage') is not null)
BEGIN
drop procedure p_GetTopInstancesByCPUUsage
END
GO

/*-- 
SQLdm 8.5 (Ankit Srivastava): for Top X API- CPU Load Usage
EXEC  [p_GetTopInstancesByCPUUsage] 100
--*/

Create PROCEDURE [dbo].[p_GetTopInstancesByCPUUsage](
	@TopX int=NULL
)
AS
BEGIN
DECLARE @Threshold TABLE(SQLServerID INT, MetricID INT, WarningThreshold NUMERIC, CriticalThreshold NUMERIC, InfoThreshold NUMERIC, InstanceName nvarchar(256))
DECLARE @MetricID INT;
SET @MetricID = 30; -- SQL Server CPU Usage (Percent)

INSERT INTO @Threshold EXEC p_PopulateMetricThresholdsNew @MetricID;

IF @TopX IS NOT null AND @TopX > 0
	SET ROWCOUNT @TopX;

;with MaxCollectionDate (SQLServerID, MaxCollectionTime, InstanceName) as 
(select MS.SQLServerID, MAX(UTCCollectionDateTime), MS.InstanceName
		from @Threshold MS
			Join [ServerStatistics] SS (nolock) 
                  on MS.SQLServerID = SS.SQLServerID 
            group by MS.SQLServerID, MS.InstanceName
)		

SELECT O.SQLServerID,O.InstanceName, O.CPUActivityPercentage, dbo.fn_GetSeverityByMetricValue(T.CriticalThreshold,T.WarningThreshold,T.InfoThreshold,O.CPUActivityPercentage,default,default,default,default,default) Severity 
FROM(
 SELECT mcd.SQLServerID,mcd.InstanceName,CPUActivityPercentage
 FROM MaxCollectionDate mcd
 INNER JOIN ServerStatistics ss WITH (NOLOCK) ON mcd.SQLServerID = ss.SQLServerID AND mcd.MaxCollectionTime = ss.UTCCollectionDateTime
 --GROUP BY mss.SQLServerID,mss.InstanceName, mcd.UTCCollectionDateTime,CPUActivityPercentage
 ) O
 INNER JOIN @Threshold T ON T.SQLServerID = O.SQLServerID
 order by CPUActivityPercentage desc

End
 
GO 

---------- P_GETTOPINSTANCESBYDISKSPACE.SQL
IF (object_id('p_GetTopInstancesByDiskSpace') is not null)
BEGIN
drop procedure p_GetTopInstancesByDiskSpace
END
GO

/*-- 
SQLdm 8.5 (Ankit Srivastava): for Top X API- Disk Space
EXEC  [p_GetTopInstancesByDiskSpace] 30
--*/

Create PROCEDURE [dbo].[p_GetTopInstancesByDiskSpace]
	@TopX int=NULL
AS
BEGIN
	DECLARE @Threshold TABLE(SQLServerID INT, MetricID INT, WarningThreshold NUMERIC, CriticalThreshold NUMERIC, InfoThreshold NUMERIC)
	DECLARE @MetricID INT;
	SET @MetricID = 59; --this is the metric id for OS Disk Free Space
	
	INSERT INTO @Threshold EXEC p_PopulateMetricThresholds @MetricID;
	
	IF @TopX IS NOT null AND @TopX > 0
		SET ROWCOUNT @TopX;

	with MaxCollTime (SQLServerID, InstanceName, UTCCollectionDateTime) as (
	  select MS.SQLServerID, MS.InstanceName, MAX(UTCCollectionDateTime)
	  from DiskDrives DS (nolock)
		JOIN MonitoredSQLServers MS (nolock)
		  ON DS.SQLServerID = MS.SQLServerID
	  WHERE MS.Active = 1
	  GROUP BY MS.SQLServerID, MS.InstanceName
	)
	SELECT O.InstanceName, O.UTCCollectionDateTime,O.SQLServerID,  O.DiskUtilizationPercentage,	
	dbo.fn_GetSeverityByMetricValue(T.CriticalThreshold,T.WarningThreshold,T.InfoThreshold,O.DiskUtilizationPercentage,default,default,default,default,default) Severity 
	FROM (	
	SELECT mct.UTCCollectionDateTime, mct.SQLServerID, mct.InstanceName,
		round(avg(((TotalSizeKB - UnusedSizeKB)/TotalSizeKB)*100),2) as DiskUtilizationPercentage
	FROM MaxCollTime mct (nolock)
	JOIN  DiskDrives DD WITH (NOLOCK) ON DD.SQLServerID = mct.SQLServerID AND DD.UTCCollectionDateTime = mct.UTCCollectionDateTime
	GROUP BY mct.UTCCollectionDateTime, mct.SQLServerID, mct.InstanceName
	) O 
	JOIN @Threshold T ON T.SQLServerID = O.SQLServerID
	ORDER BY O.DiskUtilizationPercentage DESC
	--SQLdm 9.0 (Vineet Kumar) (Web Console Improvements) -- Fixing DE42810. Changed order by from UTCCollectionDateTime to DiskUtilizationPercentage
END


 
GO 

---------- P_GETTOPINSTANCESBYIO.SQL
IF (object_id('p_GetTopInstancesByIO') is not null)
BEGIN
drop procedure p_GetTopInstancesByIO
END
GO

/*-- 
SQLdm 8.5 (Ankit Srivastava): for Top X API- IO
EXEC  [p_GetTopInstancesByIO] 100
--*/

Create PROCEDURE [dbo].[p_GetTopInstancesByIO](
  @TopX int=NULL
)
AS
BEGIN

IF @TopX IS NOT null AND @TopX > 0
  SET ROWCOUNT @TopX;

with DBMaxCollTime (SQLServerID, MaxCollectionTime, InstanceName) as (
  select MS.SQLServerID, MAX(DS.UTCCollectionDateTime), MS.InstanceName

  from [SQLServerDatabaseNames] names (nolock) 
    JOIN DatabaseStatistics DS (nolock) ON names.DatabaseID = DS.DatabaseID
    JOIN MonitoredSQLServers MS (nolock) ON MS.SQLServerID = names.SQLServerID
  WHERE MS.Active = 1
  GROUP BY MS.SQLServerID,MS.InstanceName
)

SELECT mct.SQLServerID,
					mct.InstanceName,
					SUM((NumberReads+NumberWrites) / TimeDeltaInSeconds) as SQLPhysicalIO,
					3 as Severity
  FROM DBMaxCollTime mct 
			JOIN DatabaseStatistics ds (nolock) ON mct.MaxCollectionTime = ds.UTCCollectionDateTime
			INNER JOIN [SQLServerDatabaseNames] names (NOLOCK) ON  names.DatabaseID = ds.DatabaseID 
			group by mct.SQLServerID,mct.InstanceName

ORDER BY SQLPhysicalIO desc
End
 
GO 

---------- P_GETTOPINSTANCESBYQUERIES.SQL
IF (object_id('p_GetTopInstancesByQueries') is not null)
BEGIN
drop procedure p_GetTopInstancesByQueries
END
GO

/*-- 
SQLdm 8.5 (Ankit Srivastava): for Top X API- Query Monitor Event
EXEC  [p_GetTopInstancesByQueries] '2014-05-07 10:24:29.587','2014-05-07 15:24:29.587',1
--*/

Create PROCEDURE [dbo].[p_GetTopInstancesByQueries](
	--@ServerId int=null,
	@UTCStartTime DateTime,
	@UTCEndTime DateTime,
	@TopX int=0
)
AS
BEGIN


	select Top (@TopX)  qms.SQLServerID , mss.InstanceName, count(qms.QueryStatisticsID) as NumOfQueries
	from QueryMonitorStatistics qms WITH(NOLOCK)
	left join MonitoredSQLServers mss WITH(NOLOCK) on mss.SQLServerID = qms.SQLServerID
	where mss.Active=1 
	and qms.UTCCollectionDateTime  between @UTCStartTime and @UTCEndTime
	group by qms.SQLServerID,mss.InstanceName
	order by NumOfQueries desc 

END


 
GO 

---------- P_GETTOPINSTANCESBYQUERYCOUNT.SQL
IF (OBJECT_ID('p_GetTopInstancesByQueryCount') IS NOT NULL)
BEGIN
  DROP PROC [p_GetTopInstancesByQueryCount]
END
GO
-- [p_GetTopInstancesByQueryCount] 30
CREATE PROCEDURE [dbo].[p_GetTopInstancesByQueryCount]
@TopX INT = NULL
AS
BEGIN

DECLARE @Threshold TABLE(SQLServerID INT, MetricID INT, WarningThreshold NUMERIC, CriticalThreshold NUMERIC, InfoThreshold NUMERIC)
	DECLARE @MetricID INT;
	SET @MetricID = 51; --this is the metric id for query count
	
	DECLARE @MaxCollectionDate TABLE(sqlserverId int, UTCCollectionDateTime Datetime)
	insert into @MaxCollectionDate
	select q.SQLServerID, max(q.UTCCollectionDateTime)
	FROM QueryMonitorStatistics q (nolock)
	group by q.SQLServerID	

	INSERT INTO @Threshold EXEC p_PopulateMetricThresholds @MetricID;	

	IF @TopX IS NOT null AND @TopX > 0
	SET ROWCOUNT @TopX;
  

	SELECT O.InstanceName, O.UTCCollectionDateTime,O.SQLServerID,  O.SqlQueryCount,
	dbo.fn_GetSeverityByMetricValue(T.CriticalThreshold,T.WarningThreshold,T.InfoThreshold,O.SqlQueryCount,default,default,default,default,default) Severity 
	FROM (SELECT qm.UTCCollectionDateTime,MS.SQLServerID, MS.InstanceName, 
	count(qm.SQLStatementID) as SqlQueryCount
	FROM MonitoredSQLServers MS (nolock)
	INNER JOIN [QueryMonitorStatistics] qm (nolock) ON qm.SQLServerID = MS.SQLServerID
	INNER JOIN @MaxCollectionDate m on m.sqlserverId = MS.SQLServerID
			AND qm.UTCCollectionDateTime = m.UTCCollectionDateTime
	WHERE MS.Active = 1	
	GROUP BY qm.UTCCollectionDateTime,MS.SQLServerID, MS.InstanceName
	) O 	
	JOIN @Threshold T ON T.SQLServerID = O.SQLServerID
	ORDER BY O.SqlQueryCount DESC
END
 
GO 

---------- P_GETTOPINSTANCESBYQUERYDURATION.SQL
IF (OBJECT_ID('p_GetTopInstancesByQueryDuration') IS NOT NULL)
BEGIN
  DROP PROC [p_GetTopInstancesByQueryDuration]
END
GO
-- [p_GetTopInstancesByQueryDuration] 30
CREATE PROCEDURE [dbo].[p_GetTopInstancesByQueryDuration]
@TopX INT = NULL,
@NumDays INT = 24
AS
BEGIN

	DECLARE @EndDate DATETIME 
	SELECT @EndDate=MAX(qm.UTCCollectionDateTime) FROM QueryMonitorStatistics qm (NOLOCK)
	DECLARE @StartDate DATETIME 
	SELECT @StartDate= DATEADD(DD, -1*@NumDays, @EndDate)
	
	IF @TopX IS NOT null AND @TopX > 0
		SET ROWCOUNT @TopX
	ELSE
		SET ROWCOUNT 1000
	
	SELECT MS.InstanceName, qm.UTCCollectionDateTime, MS.SQLServerID, d.DatabaseName, 
		qm.DurationMilliseconds,qm.CPUMilliseconds, qm.Reads,qm.Writes,s.SQLSignature
	FROM MonitoredSQLServers MS (nolock)
	JOIN [SQLServerDatabaseNames] d (nolock) ON d.SQLServerID = MS.SQLServerID
	JOIN [QueryMonitorStatistics] qm (nolock) ON qm.DatabaseID = d.DatabaseID
	JOIN AllSQLSignatures s (nolock) on qm.SQLSignatureID = s.SQLSignatureID
	WHERE MS.Active = 1	
	and qm.UTCCollectionDateTime  between @StartDate and @EndDate
	ORDER BY qm.DurationMilliseconds DESC
END
 
GO 

---------- P_GETTOPINSTANCESBYRESPONSETIME.SQL
IF (OBJECT_ID('p_GetTopInstancesByResponseTime') IS NOT NULL)
BEGIN
  DROP PROCEDURE [p_GetTopInstancesByResponseTime]
END
GO
-- [p_GetTopInstancesByResponseTime] 30
CREATE PROCEDURE [dbo].[p_GetTopInstancesByResponseTime]
@TopX INT = NULL
AS
BEGIN
	DECLARE @Threshold TABLE(SQLServerID INT, MetricID INT, WarningThreshold NUMERIC, CriticalThreshold NUMERIC, InfoThreshold NUMERIC, InstanceName varchar(255))
	DECLARE @MetricID INT;
	SET @MetricID = 22; --this is the metric id for Server Response Time
	
	INSERT INTO @Threshold EXEC p_PopulateMetricThresholdsNew @MetricID;
	
	IF @TopX IS NOT null AND @TopX > 0
		SET ROWCOUNT @TopX

	SELECT O.InstanceName, O.UTCCollectionDateTime,O.SQLServerID,  O.ResponseTimeInMilliseconds,dbo.fn_GetSeverityByMetricValue(T.CriticalThreshold,T.WarningThreshold,T.InfoThreshold,O.ResponseTimeInMilliseconds,default,default,default,default,default) Severity 
	FROM (SELECT SS.UTCCollectionDateTime,MS.SQLServerID, MS.InstanceName, ResponseTimeInMilliseconds
        FROM MonitoredSQLServers MS (nolock) 
		JOIN ServerStatistics SS (nolock) 
		ON MS.SQLServerID = SS.SQLServerID
        WHERE MS.Active = 1 and MS.LastScheduledCollectionTime = SS.UTCCollectionDateTime
	) O 
	JOIN @Threshold T ON T.SQLServerID = O.SQLServerID
	ORDER BY O.ResponseTimeInMilliseconds DESC
END
 
GO 

---------- P_GETTOPINSTANCESBYSESSIONCOUNT.SQL
IF (OBJECT_ID('p_GetTopInstancesBySessionCount') IS NOT NULL)
BEGIN
  DROP PROC [p_GetTopInstancesBySessionCount]
END
GO
-- [p_GetTopInstancesBySessionCount] 30
CREATE PROCEDURE [dbo].[p_GetTopInstancesBySessionCount]
AS
BEGIN

	with MaxCollTime (SQLServerID, InstanceName, UTCCollectionDateTime) as (
	  select MS.SQLServerID, MS.InstanceName, MAX(SA.UTCCollectionDateTime)
	  from [ServerActivity] SA (nolock)
		JOIN MonitoredSQLServers MS (nolock)
		  ON SA.SQLServerID = MS.SQLServerID
	  WHERE MS.Active = 1
	  GROUP BY MS.SQLServerID, MS.InstanceName
	)
	SELECT mct.SQLServerID, mct.InstanceName, mct.UTCCollectionDateTime,
		SA.SessionList
	FROM MaxCollTime mct (nolock)
	JOIN [ServerActivity] SA (nolock) ON SA.SQLServerID = mct.SQLServerID AND SA.UTCCollectionDateTime = mct.UTCCollectionDateTime

END
 
GO 

---------- P_GETTOPINSTANCESBYSQLMEMORY.SQL
IF (object_id('p_GetTopInstancesBySQLMemory') is not null)
BEGIN
drop procedure p_GetTopInstancesBySQLMemory
END
GO

/*-- 
SQLdm 8.5 (Ankit Srivastava): for Top X API- Instance by SQL Memory Usage
EXEC  [p_GetTopInstancesBySQLMemory] 100
--*/

Create PROCEDURE [dbo].[p_GetTopInstancesBySQLMemory](
	@TopX int=NULL
)
AS
BEGIN

DECLARE @Threshold TABLE(SQLServerID INT, MetricID INT, WarningThreshold NUMERIC, CriticalThreshold NUMERIC, InfoThreshold NUMERIC,InstanceName varchar(255))
DECLARE @MetricID INT;
SET @MetricID = 13; -- SQL Server Memory Usage (Percent)
INSERT INTO @Threshold EXEC p_PopulateMetricThresholdsNew @MetricID;

IF @TopX IS NOT null AND @TopX > 0
	SET ROWCOUNT @TopX;

	
with MaxCollectionDate (SQLServerID, MaxCollectionTime, InstanceName) as (
		select MS.SQLServerID, MAX(UTCCollectionDateTime), MS.InstanceName
		from @Threshold MS
			Join ServerStatistics (nolock) ST ON MS.SQLServerID = ST.SQLServerID
	    group by MS.SQLServerID, MS.InstanceName
	)	
	
SELECT O.SQLServerID,O.InstanceName, O.SqlMemoryUsedInMB, 
	O.SqlMemoryAllocatedInMB, dbo.fn_GetSeverityByMetricValue(T.CriticalThreshold,T.WarningThreshold,T.InfoThreshold,
		O.SqlMemoryUsedInMB,default,default,default,default,default) Severity 
FROM(
SELECT mcd.SQLServerID,
	mcd.InstanceName,
	max((ss.SqlMemoryUsedInKilobytes/1024)) as SqlMemoryUsedInMB,
	max((SqlMemoryAllocatedInKilobytes/1024)) as SqlMemoryAllocatedInMB, 
	3 as Severity
FROM MaxCollectionDate mcd
	INNER JOIN ServerStatistics ss (NOLOCK) ON mcd.SQLServerID = ss.SQLServerID AND mcd.MaxCollectionTime = ss.UTCCollectionDateTime
GROUP BY mcd.SQLServerID,mcd.InstanceName, mcd.MaxCollectionTime, SqlMemoryUsedInKilobytes
 ) O 
 INNER JOIN @Threshold T ON T.SQLServerID = O.SQLServerID 
 order by SqlMemoryUsedInMB desc

End
 
GO 

---------- P_GETTOPQUERIES.SQL
--Modified SQL DM 8.6 (Vineet Kumar) -- Fixing defect DE41457. After deploying on SSRS Top Queries report gives error.
--sp [p_GetTopQueries] is called by several other stored procedures at same time. [p_GetTopQueries] makes use of global temp tables. When it gets called by 5-6 other procs at same time, the scope of these temp tables gets into conflict.
--Solution
--Global temptables(##) are changed to local temp tables(#), so the scope of table exists within the proc call itself. 
--Now local temptables can not be accessed outside the p_GetTopQueries. So at the end of proc, select statement is used. In the proc(such as 'p_GetTopQueriesByFrequency')  calling it, we create a local temptable with scope to this particular proc. Then insert data of p_GetTopQueries in this table and perform the required select statement.

if (object_id('p_GetTopQueries') is not null)
begin
drop procedure p_GetTopQueries
end
go
-- @OrderBy
--	0 - Frequency
--	1 - Duration
--	2 - CPU
--	3 - Reads
--	4 - Writes
create procedure [dbo].p_GetTopQueries
	@SQLServerID int,
	@StartDateTime datetime = null,
	@EndDateTime datetime = null,
	@UtcOffset int = null,
	@IncludeStoredProcedures bit = 1,
	@IncludeSQLStatements bit = 1,
	@IncludeSQLBatches bit = 1,
	@MinExecutions bigint = null,
	@MinDuration bigint = null,
	@MinReads bigint = null,
	@MinWrites bigint = null,
	@MinCPU bigint = null,
	@TopN bigint = 10,
	@SignatureMode bit = 0,
	@OrderBy tinyint = 0,
	@CaseInsensitive bit = 0,
	@ApplLike nvarchar(255) = null,
	@ApplNotLike nvarchar(255) = null,
	@ClientLike nvarchar(255) = null,
	@ClientNotLike nvarchar(255) = null,
	@DatabaseLike nvarchar(255) = null,
	@DatabaseNotLike nvarchar(255) = null,
	@SQLTextLike nvarchar(255) = null,
	@SQLTextNotLike nvarchar(255) = null, 
	@UserLike nvarchar(255) = null, 
	@UserNotLike nvarchar(255) = null
as
begin
set ansi_warnings off
set ansi_nulls off

if @UtcOffset is null
	set @UtcOffset = datediff(mi,getutcdate(),getdate())

declare @IntermediateTable table(DatabaseID int, DatabaseName nvarchar(255))

declare @AllTypes bit 
if @IncludeStoredProcedures = 1 AND @IncludeSQLStatements = 1 AND @IncludeSQLBatches = 1
	set @AllTypes = 1
else
	set @AllTypes = 0

if @CaseInsensitive = 1
begin
	select @SQLTextLike = lower(@SQLTextLike),
		@SQLTextNotLike = lower(@SQLTextNotLike),
		@ApplLike = lower(@ApplLike),
		@ApplNotLike = lower(@ApplNotLike),
		@ClientLike = lower(@ClientLike),
		@ClientNotLike = lower(@ClientNotLike),
		@DatabaseLike = lower(@DatabaseLike),
		@DatabaseNotLike = lower(@DatabaseNotLike)
end

insert into @IntermediateTable(DatabaseID, DatabaseName)
	select DatabaseID, DatabaseName
	from
		[SQLServerDatabaseNames] d (nolock)
	where
		d.SQLServerID = @SQLServerID
		and (@DatabaseNotLike is null or rtrim(ltrim(case when @CaseInsensitive = 1 then lower(DatabaseName) else DatabaseName end)) not like @DatabaseNotLike collate SQL_Latin1_General_CP1_CI_AS)
		and (rtrim(ltrim(case when @CaseInsensitive = 1 then lower(DatabaseName) else DatabaseName end)) like isnull(@DatabaseLike, '%') collate SQL_Latin1_General_CP1_CI_AS)

-- Create a temporal table to contains the result of the query
--Start : Modified SQL DM 8.6 (Vineet Kumar) -- Fixing defect DE41457. -- Changed global temptable to local temptable
if (object_id('tempdb..#TmpTopQueriesCaseSensitive') is not null)
begin
    drop table #TmpTopQueriesCaseSensitive
end

-- Create a temporal table to contains the result of the query
if (object_id('tempdb..#TmpTopQueriesNoCaseSensitive') is not null)
begin
    drop table #TmpTopQueriesNoCaseSensitive
end
--End : Modified SQL DM 8.6 (Vineet Kumar) -- Fixing defect DE41457. -- Changed global temptable to local temptable

if (@SignatureMode = 1)
begin

select
	DatabaseName,
	FirstStartTime = min(FirstStartTime),
	LastEndTime = max(LastEndTime),
	AverageDuration = floor(sum(TotalDuration) / nullif(sum([Count]),0)),
	AverageCPU = floor(sum(TotalCPU) / nullif(sum([Count]),0)),
	AverageReads = floor(sum(TotalReads) / nullif(sum([Count]),0)),
	AverageWrites = floor(sum(TotalWrites) / nullif(sum([Count]),0)),
	ApplicationName,
	StatementType,
	StatementText,
	[Count] = sum([Count])

into #TmpTopQueriesCaseSensitive

from
(
select 
	DatabaseName = d.DatabaseName,
	FirstStartTime = min(dateadd(mi,@UtcOffset,StatementUTCStartTime)),
	LastEndTime = max(dateadd(mi,@UtcOffset,CompletionTime)),
	TotalDuration = sum(DurationMilliseconds),
	TotalCPU = sum(CPUMilliseconds),
	TotalReads = sum(Reads),
	TotalWrites = sum(Writes),
	ApplicationName,
	StatementType,
	StatementText = SQLSignature,
	[Count] = count(*)
from
	dbo.QueryMonitorStatistics qm (nolock)
	inner join @IntermediateTable d on qm.DatabaseID = d.DatabaseID
	inner join ApplicationNames an (nolock) on qm.ApplicationNameID = an.ApplicationNameID
	inner join AllSQLSignatures s (nolock) on qm.SQLSignatureID = s.SQLSignatureID
	inner join HostNames hn (nolock) on qm.HostNameID = hn.HostNameID
	inner join LoginNames ln (nolock) on qm.LoginNameID = ln.LoginNameID
where
	qm.SQLServerID = @SQLServerID and
	(
		@AllTypes = 1
		OR
		qm.StatementType = 0 and @IncludeStoredProcedures = 1
		OR
		qm.StatementType = 1 and @IncludeSQLStatements = 1
		OR
		qm.StatementType = 2 and @IncludeSQLBatches = 1
	) and
	isnull(dbo.fn_RoundDateTime(0, @StartDateTime),'1 Jan 1900') <= StatementUTCStartTime and
	isnull(dbo.fn_RoundDateTime(0, @EndDateTime),'1 Jan 2200') >= CompletionTime
	and (@ApplNotLike is null or isnull(rtrim(ltrim(case when @CaseInsensitive = 1 then lower(ApplicationName) else ApplicationName end)),'') not like @ApplNotLike collate SQL_Latin1_General_CP1_CI_AS)
	and isnull(rtrim(ltrim(case when @CaseInsensitive = 1 then lower(ApplicationName) else ApplicationName end)),'') like isnull(@ApplLike,'%' collate SQL_Latin1_General_CP1_CI_AS)
	and (@ClientNotLike is null or isnull(rtrim(ltrim(case when @CaseInsensitive = 1 then lower(HostName) else HostName end)),'') not like @ClientNotLike collate SQL_Latin1_General_CP1_CI_AS)
	and isnull(rtrim(ltrim(case when @CaseInsensitive = 1 then lower(HostName) else HostName end)),'') like isnull(@ClientLike,'%' collate SQL_Latin1_General_CP1_CI_AS)
	and (@UserNotLike is null or isnull(rtrim(ltrim(case when @CaseInsensitive = 1 then lower(LoginName) else LoginName end)),'') not like @UserNotLike collate SQL_Latin1_General_CP1_CI_AS)
	and isnull(rtrim(ltrim(case when @CaseInsensitive = 1 then lower(LoginName) else LoginName end)),'') like isnull(@UserLike,'%' collate SQL_Latin1_General_CP1_CI_AS)
	and (@SQLTextNotLike is null or case when @CaseInsensitive = 1 then isnull(lower(SQLSignature),'') else isnull(SQLSignature,'') end not like @SQLTextNotLike collate SQL_Latin1_General_CP1_CI_AS)
	and case when @CaseInsensitive = 1 then isnull(lower(SQLSignature),'') else isnull(SQLSignature,'') end like isnull(@SQLTextLike,'%' collate SQL_Latin1_General_CP1_CI_AS)
group by
	StatementType,
	SQLSignature,
	d.DatabaseName,
	ApplicationName

union all

select 
	DatabaseName = d.DatabaseName,
	FirstStartTime = min(dateadd(mi,@UtcOffset,EventUTCStartTime)),
	LastEndTime = max(dateadd(mi,@UtcOffset,EventUTCStartTime)),
	TotalDuration = sum(TotalDurationMilliseconds),
	TotalCPU = sum(TotalCPUMilliseconds),
	TotalReads = sum(TotalReads),
	TotalWrites = sum(TotalWrites),
	ApplicationName,
	StatementType,
	StatementText = SQLSignature,
	sum(QueryMonitorOccurrences) AS [Count]
from
	dbo.QuerySignatureAggregation qm (nolock)
	inner join @IntermediateTable d on qm.DatabaseID = d.DatabaseID
	inner join ApplicationNames an (nolock) on qm.ApplicationNameID = an.ApplicationNameID
	inner join AllSQLSignatures s (nolock) on qm.SQLSignatureID = s.SQLSignatureID
where

	qm.SQLServerID = @SQLServerID and
	(
		@AllTypes = 1
		OR
		qm.StatementType = 0 and @IncludeStoredProcedures = 1
		OR
		qm.StatementType = 1 and @IncludeSQLStatements = 1
		OR
		qm.StatementType = 2 and @IncludeSQLBatches = 1
	) and
	isnull(dbo.fn_RoundDateTime(0, @StartDateTime),'1 Jan 1900') <= EventUTCStartTime and
	isnull(dbo.fn_RoundDateTime(0, @EndDateTime),'1 Jan 2200') >= EventUTCStartTime
	and (@ApplNotLike is null or isnull(rtrim(ltrim(case when @CaseInsensitive = 1 then lower(ApplicationName) else ApplicationName end)),'') not like @ApplNotLike collate SQL_Latin1_General_CP1_CI_AS)
	and isnull(rtrim(ltrim(case when @CaseInsensitive = 1 then lower(ApplicationName) else ApplicationName end)),'') like isnull(@ApplLike,'%' collate SQL_Latin1_General_CP1_CI_AS)
	and (@SQLTextNotLike is null or case when @CaseInsensitive = 1 then isnull(lower(SQLSignature),'') else isnull(SQLSignature,'') end not like @SQLTextNotLike collate SQL_Latin1_General_CP1_CI_AS)
	and case when @CaseInsensitive = 1 then isnull(lower(SQLSignature),'') else isnull(SQLSignature,'') end like isnull(@SQLTextLike,'%' collate SQL_Latin1_General_CP1_CI_AS)
group by
	StatementType,
	SQLSignature,
	DatabaseName,
	ApplicationName
)
as q
group by
	StatementType,
	StatementText,
	DatabaseName,
	ApplicationName
having
	sum([Count]) >= isnull(@MinExecutions,0) and
	(sum(TotalDuration) / nullif(sum([Count]),0)) >= isnull(@MinDuration,0) and
	(sum(TotalReads) / nullif(sum([Count]),0)) >= isnull(@MinReads,0) and
	(sum(TotalWrites) / nullif(sum([Count]),0)) >= isnull(@MinWrites,0) and
	(sum(TotalCPU) / nullif(sum([Count]),0)) >= isnull(@MinCPU,0)
order by
	case 
		when @OrderBy = 1 then (sum(TotalDuration) / nullif(sum([Count]),0))
		when @OrderBy = 2 then (sum(TotalCPU) / nullif(sum([Count]),0))
		when @OrderBy = 3 then (sum(TotalReads) / nullif(sum([Count]),0))
		when @OrderBy = 4 then (sum(TotalWrites) / nullif(sum([Count]),0))
	end 
	desc

end
else
begin

select 
	DatabaseName,
	FirstStartTime = min(dateadd(mi,@UtcOffset,StatementUTCStartTime)),
	LastEndTime = max(dateadd(mi,@UtcOffset,CompletionTime)),
	AverageDuration = avg(DurationMilliseconds),
	AverageCPU = avg(CPUMilliseconds),
	AverageReads = avg(Reads),
	AverageWrites = avg(Writes),
	ApplicationName,
	StatementType,
	StatementText = SQLStatement,
	[Count] = count(*)

into #TmpTopQueriesNoCaseSensitive

from
	dbo.QueryMonitorStatistics qm (nolock)
	inner join @IntermediateTable d on qm.DatabaseID = d.DatabaseID
	inner join ApplicationNames an (nolock) on qm.ApplicationNameID = an.ApplicationNameID
	inner join AllSQLStatements s (nolock) on qm.SQLStatementID = s.SQLStatementID
	inner join HostNames hn (nolock) on qm.HostNameID = hn.HostNameID
	inner join LoginNames ln (nolock) on qm.LoginNameID = ln.LoginNameID

where
	qm.SQLServerID = @SQLServerID and
	(
		@AllTypes = 1
		OR
		qm.StatementType = 0 and @IncludeStoredProcedures = 1
		OR
		qm.StatementType = 1 and @IncludeSQLStatements = 1
		OR
		qm.StatementType = 2 and @IncludeSQLBatches = 1
	) and
	isnull(dbo.fn_RoundDateTime(0, @StartDateTime),'1 Jan 1900') <= StatementUTCStartTime and
	isnull(dbo.fn_RoundDateTime(0, @EndDateTime),'1 Jan 2200') >= CompletionTime
	and (@ApplNotLike is null or isnull(ApplicationName,'') not like @ApplNotLike collate SQL_Latin1_General_CP1_CI_AS)
	and isnull(rtrim(ltrim(case when @CaseInsensitive = 1 then lower(ApplicationName) else ApplicationName end)),'') like isnull(@ApplLike,'%' collate SQL_Latin1_General_CP1_CI_AS)
	and (@ClientNotLike is null or isnull(rtrim(ltrim(case when @CaseInsensitive = 1 then lower(HostName) else HostName end)),'') not like @ClientNotLike collate SQL_Latin1_General_CP1_CI_AS)
	and isnull(rtrim(ltrim(case when @CaseInsensitive = 1 then lower(HostName) else HostName end)),'') like isnull(@ClientLike,'%' collate SQL_Latin1_General_CP1_CI_AS)
	and (@UserNotLike is null or isnull(rtrim(ltrim(case when @CaseInsensitive = 1 then lower(LoginName) else LoginName end)),'') not like @UserNotLike collate SQL_Latin1_General_CP1_CI_AS)
	and isnull(rtrim(ltrim(case when @CaseInsensitive = 1 then lower(LoginName) else LoginName end)),'') like isnull(@UserLike,'%' collate SQL_Latin1_General_CP1_CI_AS)
	and (@SQLTextNotLike is null or case when @CaseInsensitive = 1 then isnull(lower(SQLStatement),'') else isnull(SQLStatement,'') end not like @SQLTextNotLike collate SQL_Latin1_General_CP1_CI_AS)
	and case when @CaseInsensitive = 1 then isnull(lower(SQLStatement),'') else isnull(SQLStatement,'') end like isnull(@SQLTextLike,'%' collate SQL_Latin1_General_CP1_CI_AS)
group by
	StatementType,
	SQLStatement,
	DatabaseName,
	ApplicationName
having
	count(*) >= isnull(@MinExecutions,0) and
	avg(DurationMilliseconds) >= isnull(@MinDuration,0) and
	avg(Reads) >= isnull(@MinReads,0) and
	avg(Writes) >= isnull(@MinWrites,0) and
	avg(CPUMilliseconds) >= isnull(@MinCPU,0)
order by
	case
		when @OrderBy = 1 then avg(DurationMilliseconds)
		when @OrderBy = 2 then avg(CPUMilliseconds)
		when @OrderBy = 3 then avg(Reads)
		when @OrderBy = 4 then avg(Writes)
	end 
	desc

end

--Start : Modified SQL DM 8.6 (Vineet Kumar) -- This select query added because local temptable cannot be accessed outside this proc
if (@SignatureMode = 1)
select * from #TmpTopQueriesCaseSensitive
else 
select * from #TmpTopQueriesNoCaseSensitive
--End : Modified SQL DM 8.6 (Vineet Kumar) -- This select query added because local temptable cannot be accessed outside this proc

end

Go

grant EXECUTE on p_GetTopQueries to [SQLdmConsoleUser]

go


if (object_id('p_GetTopQueriesByFrequency') is not null)
begin
drop procedure p_GetTopQueriesByFrequency
end
go
create procedure [dbo].p_GetTopQueriesByFrequency
	@SQLServerID int,
	@StartDateTime datetime = null,
	@EndDateTime datetime = null,
	@UtcOffset int = null,
	@IncludeStoredProcedures bit = 1,
	@IncludeSQLStatements bit = 1,
	@IncludeSQLBatches bit = 1,
	@MinExecutions bigint = null,
	@MinDuration bigint = null,
	@MinReads bigint = null,
	@MinWrites bigint = null,
	@MinCPU bigint = null,
	@TopN bigint = 10,
	@SignatureMode bit = 0,
	@CaseInsensitive bit = 0,
	@ApplLike nvarchar(255) = null,
	@ApplNotLike nvarchar(255) = null,
	@ClientLike nvarchar(255) = null,
	@ClientNotLike nvarchar(255) = null,
	@DatabaseLike nvarchar(255) = null,
	@DatabaseNotLike nvarchar(255) = null,
	@SQLTextLike nvarchar(255) = null,
	@SQLTextNotLike nvarchar(255) = null, 
	@UserLike nvarchar(255) = null, 
	@UserNotLike nvarchar(255) = null
as
begin
--Modified SQL DM 8.6 (Vineet Kumar) -- Local temptable created and inserts output of p_GetTopQueries into this
CREATE TABLE #TempTableForData
(
DatabaseName varchar(255),
	FirstStartTime DATETIME,
	LastEndTime DATETIME,
	AverageDuration INT,
	AverageCPU INT,
	AverageReads INT,
	AverageWrites INT,
	ApplicationName varchar(255),
	StatementType BIT,
	StatementText varchar(max),
	[Count] INT

)
INSERT INTO #TempTableForData
	exec p_GetTopQueries
		@SQLServerID,
		@StartDateTime,
		@EndDateTime,
		@UtcOffset,
		@IncludeStoredProcedures,
		@IncludeSQLStatements,
		@IncludeSQLBatches,
		@MinExecutions,
		@MinDuration,
		@MinReads,
		@MinWrites,
		@MinCPU,
		@TopN,
		@SignatureMode,
		0,
		@CaseInsensitive,
		@ApplLike,
		@ApplNotLike,
		@ClientLike,
		@ClientNotLike,
		@DatabaseLike,
		@DatabaseNotLike,
		@SQLTextLike,
		@SQLTextNotLike,
		@UserLike,
		@UserNotLike

    -- Sort acording [Count] column.
    set rowcount @TopN

	select distinct * from #TempTableForData order by [Count] desc

end

Go

grant EXECUTE on p_GetTopQueriesByFrequency to [SQLdmConsoleUser]

go

if (object_id('p_GetTopQueriesByDuration') is not null)
begin
drop procedure p_GetTopQueriesByDuration
end
go
create procedure [dbo].p_GetTopQueriesByDuration
	@SQLServerID int,
	@StartDateTime datetime = null,
	@EndDateTime datetime = null,
	@UtcOffset int = null,
	@IncludeStoredProcedures bit = 1,
	@IncludeSQLStatements bit = 1,
	@IncludeSQLBatches bit = 1,
	@MinExecutions bigint = null,
	@MinDuration bigint = null,
	@MinReads bigint = null,
	@MinWrites bigint = null,
	@MinCPU bigint = null,
	@TopN bigint = 10,
	@SignatureMode bit = 0,
	@CaseInsensitive bit = 0,
	@ApplLike nvarchar(255) = null,
	@ApplNotLike nvarchar(255) = null,
	@ClientLike nvarchar(255) = null,
	@ClientNotLike nvarchar(255) = null,
	@DatabaseLike nvarchar(255) = null,
	@DatabaseNotLike nvarchar(255) = null,
	@SQLTextLike nvarchar(255) = null,
	@SQLTextNotLike nvarchar(255) = null, 
	@UserLike nvarchar(255) = null, 
	@UserNotLike nvarchar(255) = null
as
begin
--Modified SQL DM 8.6 (Vineet Kumar) -- Local temptable created and inserts output of p_GetTopQueries into this
	CREATE TABLE #TempTableForData
(
DatabaseName varchar(255),
	FirstStartTime DATETIME,
	LastEndTime DATETIME,
	AverageDuration INT,
	AverageCPU INT,
	AverageReads INT,
	AverageWrites INT,
	ApplicationName varchar(255),
	StatementType BIT,
	StatementText varchar(max),
	[Count] INT

)
INSERT INTO #TempTableForData
	exec p_GetTopQueries
		@SQLServerID,
		@StartDateTime,
		@EndDateTime,
		@UtcOffset,
		@IncludeStoredProcedures,
		@IncludeSQLStatements,
		@IncludeSQLBatches,
		@MinExecutions,
		@MinDuration,
		@MinReads,
		@MinWrites,
		@MinCPU,
		@TopN,
		@SignatureMode,
		1,
		@CaseInsensitive,
		@ApplLike,
		@ApplNotLike,
		@ClientLike,
		@ClientNotLike,
		@DatabaseLike,
		@DatabaseNotLike,
		@SQLTextLike,
		@SQLTextNotLike,
		@UserLike,
		@UserNotLike

    set rowcount @TopN

	select distinct * from #TempTableForData
end

Go

grant EXECUTE on p_GetTopQueriesByDuration to [SQLdmConsoleUser]

go

if (object_id('p_GetTopQueriesByCPU') is not null)
begin
drop procedure p_GetTopQueriesByCPU
end
go
create procedure [dbo].p_GetTopQueriesByCPU
	@SQLServerID int,
	@StartDateTime datetime = null,
	@EndDateTime datetime = null,
	@UtcOffset int = null,
	@IncludeStoredProcedures bit = 1,
	@IncludeSQLStatements bit = 1,
	@IncludeSQLBatches bit = 1,
	@MinExecutions bigint = null,
	@MinDuration bigint = null,
	@MinReads bigint = null,
	@MinWrites bigint = null,
	@MinCPU bigint = null,
	@TopN bigint = 10,
	@SignatureMode bit = 0,
	@CaseInsensitive bit = 0,
	@ApplLike nvarchar(255) = null,
	@ApplNotLike nvarchar(255) = null,
	@ClientLike nvarchar(255) = null,
	@ClientNotLike nvarchar(255) = null,
	@DatabaseLike nvarchar(255) = null,
	@DatabaseNotLike nvarchar(255) = null,
	@SQLTextLike nvarchar(255) = null,
	@SQLTextNotLike nvarchar(255) = null, 
	@UserLike nvarchar(255) = null, 
	@UserNotLike nvarchar(255) = null
as
begin
--Modified SQL DM 8.6 (Vineet Kumar) -- Local temptable created and inserts output of p_GetTopQueries into this
	CREATE TABLE #TempTableForData
(
DatabaseName varchar(255),
	FirstStartTime DATETIME,
	LastEndTime DATETIME,
	AverageDuration INT,
	AverageCPU INT,
	AverageReads INT,
	AverageWrites INT,
	ApplicationName varchar(255),
	StatementType BIT,
	StatementText varchar(max),
	[Count] INT

)
INSERT INTO #TempTableForData
	exec p_GetTopQueries
		@SQLServerID,
		@StartDateTime,
		@EndDateTime,
		@UtcOffset,
		@IncludeStoredProcedures,
		@IncludeSQLStatements,
		@IncludeSQLBatches,
		@MinExecutions,
		@MinDuration,
		@MinReads,
		@MinWrites,
		@MinCPU,
		@TopN,
		@SignatureMode,
		2,
		@CaseInsensitive,
		@ApplLike,
		@ApplNotLike,
		@ClientLike,
		@ClientNotLike,
		@DatabaseLike,
		@DatabaseNotLike,
		@SQLTextLike,
		@SQLTextNotLike,
		@UserLike,
		@UserNotLike

    set rowcount @TopN

	select distinct * from #TempTableForData 
end

Go

grant EXECUTE on p_GetTopQueriesByCPU to [SQLdmConsoleUser]

go

if (object_id('p_GetTopQueriesByReads') is not null)
begin
drop procedure p_GetTopQueriesByReads
end
go
create procedure [dbo].p_GetTopQueriesByReads
	@SQLServerID int,
	@StartDateTime datetime = null,
	@EndDateTime datetime = null,
	@UtcOffset int = null,
	@IncludeStoredProcedures bit = 1,
	@IncludeSQLStatements bit = 1,
	@IncludeSQLBatches bit = 1,
	@MinExecutions bigint = null,
	@MinDuration bigint = null,
	@MinReads bigint = null,
	@MinWrites bigint = null,
	@MinCPU bigint = null,
	@TopN bigint = 10,
	@SignatureMode bit = 0,
	@CaseInsensitive bit = 0,
	@ApplLike nvarchar(255) = null,
	@ApplNotLike nvarchar(255) = null,
	@ClientLike nvarchar(255) = null,
	@ClientNotLike nvarchar(255) = null,
	@DatabaseLike nvarchar(255) = null,
	@DatabaseNotLike nvarchar(255) = null,
	@SQLTextLike nvarchar(255) = null,
	@SQLTextNotLike nvarchar(255) = null, 
	@UserLike nvarchar(255) = null, 
	@UserNotLike nvarchar(255) = null
as
begin
--Modified SQL DM 8.6 (Vineet Kumar) -- Local temptable created and inserts output of p_GetTopQueries into this
	CREATE TABLE #TempTableForData
(
DatabaseName varchar(255),
	FirstStartTime DATETIME,
	LastEndTime DATETIME,
	AverageDuration INT,
	AverageCPU INT,
	AverageReads INT,
	AverageWrites INT,
	ApplicationName varchar(255),
	StatementType BIT,
	StatementText varchar(max),
	[Count] INT

)
INSERT INTO #TempTableForData
	exec p_GetTopQueries
		@SQLServerID,
		@StartDateTime,
		@EndDateTime,
		@UtcOffset,
		@IncludeStoredProcedures,
		@IncludeSQLStatements,
		@IncludeSQLBatches,
		@MinExecutions,
		@MinDuration,
		@MinReads,
		@MinWrites,
		@MinCPU,
		@TopN,
		@SignatureMode,
		3,
		@CaseInsensitive,
		@ApplLike,
		@ApplNotLike,
		@ClientLike,
		@ClientNotLike,
		@DatabaseLike,
		@DatabaseNotLike,
		@SQLTextLike,
		@SQLTextNotLike,
		@UserLike,
		@UserNotLike

    set rowcount @TopN

	select distinct * from #TempTableForData 
end

Go

grant EXECUTE on p_GetTopQueriesByReads to [SQLdmConsoleUser]

go

if (object_id('p_GetTopQueriesByWrites') is not null)
begin
drop procedure p_GetTopQueriesByWrites
end
go
create procedure [dbo].p_GetTopQueriesByWrites
	@SQLServerID int,
	@StartDateTime datetime = null,
	@EndDateTime datetime = null,
	@UtcOffset int = null,
	@IncludeStoredProcedures bit = 1,
	@IncludeSQLStatements bit = 1,
	@IncludeSQLBatches bit = 1,
	@MinExecutions bigint = null,
	@MinDuration bigint = null,
	@MinReads bigint = null,
	@MinWrites bigint = null,
	@MinCPU bigint = null,
	@TopN bigint = 10,
	@SignatureMode bit = 0,
	@CaseInsensitive bit = 0,
	@ApplLike nvarchar(255) = null,
	@ApplNotLike nvarchar(255) = null,
	@ClientLike nvarchar(255) = null,
	@ClientNotLike nvarchar(255) = null,
	@DatabaseLike nvarchar(255) = null,
	@DatabaseNotLike nvarchar(255) = null,
	@SQLTextLike nvarchar(255) = null,
	@SQLTextNotLike nvarchar(255) = null, 
	@UserLike nvarchar(255) = null, 
	@UserNotLike nvarchar(255) = null
as
begin
--Modified SQL DM 8.6 (Vineet Kumar) -- Local temptable created and inserts output of p_GetTopQueries into this
	CREATE TABLE #TempTableForData
(
DatabaseName varchar(255),
	FirstStartTime DATETIME,
	LastEndTime DATETIME,
	AverageDuration INT,
	AverageCPU INT,
	AverageReads INT,
	AverageWrites INT,
	ApplicationName varchar(255),
	StatementType BIT,
	StatementText varchar(max),
	[Count] INT

)
INSERT INTO #TempTableForData
	exec p_GetTopQueries
		@SQLServerID,
		@StartDateTime,
		@EndDateTime,
		@UtcOffset,
		@IncludeStoredProcedures,
		@IncludeSQLStatements,
		@IncludeSQLBatches,
		@MinExecutions,
		@MinDuration,
		@MinReads,
		@MinWrites,
		@MinCPU,
		@TopN,
		@SignatureMode,
		4,
		@CaseInsensitive,
		@ApplLike,
		@ApplNotLike,
		@ClientLike,
		@ClientNotLike,
		@DatabaseLike,
		@DatabaseNotLike,
		@SQLTextLike,
		@SQLTextNotLike,
		@UserLike,
		@UserNotLike

    set rowcount @TopN

	select distinct * from #TempTableForData 
end

Go

grant EXECUTE on p_GetTopQueriesByWrites to [SQLdmConsoleUser]

GO
 
GO 

---------- P_GETTOPSERVERBYTEMPDBUTILIZATION.SQL

IF (object_id('p_GetTopXServerByTempDbUtilization') is not null)
BEGIN
drop procedure p_GetTopXServerByTempDbUtilization
END
GO

/*-- 
SQLdm 8.5 (Ashutosh Upadhyay): for Top X API- Tempdb Utilization
EXEC  [p_GetTopXServerByTempDbUtilization] '2013-05-14 10:24:29.587','2014-05-14 10:24:29.587',1
--*/

Create PROCEDURE [dbo].[p_GetTopXServerByTempDbUtilization](
	@TopX int=NULL
)
AS
BEGIN

	IF @TopX IS NOT null AND @TopX > 0
		SET ROWCOUNT @TopX;
	
	WITH MaxCollectionDate (SQLServerID, UTCCollectionDateTime)
	AS (
		SELECT ss.SQLServerID, MAX(ss.UTCCollectionDateTime)
		FROM ServerStatistics ss (nolock)
		GROUP BY ss.SQLServerID
	)
	SELECT SS.UTCCollectionDateTime,MS.SQLServerID, MS.InstanceName, SS.TempDBSizeInKilobytes
	FROM MonitoredSQLServers MS  (nolock)
	INNER JOIN ServerStatistics SS (nolock) ON MS.SQLServerID = SS.SQLServerID
	INNER JOIN MaxCollectionDate mcd (nolock) ON SS.SQLServerID = mcd.SQLServerID AND SS.UTCCollectionDateTime = mcd.UTCCollectionDateTime
	WHERE MS.Active = 1
	ORDER BY SS.TempDBSizeInKilobytes DESC
END

GO

 
GO 

---------- P_GETTOPSERVERSFORCUSTOMCOUNTERSDATASET.SQL
IF (OBJECT_ID('p_GetTopServersForCustomCountersDataSet') IS NOT NULL)
BEGIN
DROP PROCEDURE p_GetTopServersForCustomCountersDataSet
END
GO
--exec p_GetTopServersForCustomCountersDataSet 3,'2015-09-01 14:10:19.983','2015-09-10 14:10:19.983','r7'
CREATE proc [dbo].[p_GetTopServersForCustomCountersDataSet]
(
--START: SP Params
@NumServers INT, --= 3;
@UTCStart DateTime, --= '2015-09-01 14:10:19.983';
@UTCEnd DateTime, --= '2015-09-10 14:10:19.983';
@reportName nvarchar(255) --= 'fifth'
--END: SP Params
) AS
BEGIN

	DECLARE @maxCounterTemplate nvarchar(500)
	DECLARE @perMinuteCounterTemplate nvarchar(500)
	DECLARE @counterSQLWeightedAverage nvarchar(max)
	DECLARE @counterSQLMax nvarchar(max)
	DECLARE @counterSQLPerMinute nvarchar(max)
	DECLARE @ParmDefinition nvarchar(500)
	declare @weightedAverageCounterTemplate nvarchar(500)
	declare @virtualizationWeightedAverageCounterTemplate nvarchar(500)
	Declare @virtualizationPerMinuteCounterTemplate nvarchar(500)
	DECLARE @counterSource int
	declare @counterAggregation int
	declare @counterName nvarchar(256)
	declare @counterID int
	DECLARE @tempQuery nvarchar(max)
	

	--final table which would be returned by this sp having metrics info containing top servers
	IF OBJECT_ID('tempdb..#resultTable') IS NOT NULL
	drop table #resultTable
	create table #resultTable(SQLServerID int,InstanceName nvarchar(256), CounterName nvarchar(256), Value float)

	--for aggregation type = 0, and non custom counters
	select @maxCounterTemplate = 'select top '+CONVERT(nvarchar(10),@NumServers)+' m.SQLServerID,m.InstanceName,'
	+ ' @CounterName as CounterName,'
	+ ' round(max(convert(float,{prefix}.{metric})),2) as Value'
	+ ' from  {prefix} (nolock)'
	+ ' inner join MonitoredSQLServers m (nolock) on {prefix}.SQLServerID = m.SQLServerID'
	+ ' {getTimeDeltaInSeconds}' --template for the counters whose value need 'TimeDeltaInSeconds' during expression calculation
	+ ' where {prefix}.[UTCCollectionDateTime] between @UTCStart and @UTCEnd'
	+ ' group by m.SQLServerID,m.InstanceName'
	+ ' order by Value desc'

	--for aggregation type = 2, and server,os counters
	select @perMinuteCounterTemplate = 'select top '+CONVERT(nvarchar(10),@NumServers)+' m.SQLServerID,m.InstanceName,'
	+ ' @CounterName as CounterName,'
	+ ' round(sum(convert(float,{prefix}.{metric})) / nullif((sum(convert(float,case when {prefix}.{metric} is not null then TimeDeltaInSeconds else 0 end)) / 60) ,0),2) as Value'
	+ ' from  {prefix} (nolock)'
	+ ' inner join MonitoredSQLServers m (nolock) on {prefix}.SQLServerID = m.SQLServerID'
	+ ' {getTimeDeltaInSeconds}'
	+ ' where {prefix}.[UTCCollectionDateTime] between @UTCStart and @UTCEnd'
	+ ' group by m.SQLServerID,m.InstanceName'
	+ ' order by Value desc'

	--for aggregation type = 1, and virtual counters
	select @virtualizationPerMinuteCounterTemplate = 'select top '+CONVERT(nvarchar(10),@NumServers)+' m.SQLServerID,m.InstanceName,'
	+ ' @CounterName as CounterName,'
	+ ' round(avg(convert(float,{prefix}.{metric})),2) as Value'
	+ ' from  {prefix} (nolock)'
	+ ' inner join MonitoredSQLServers m (nolock) on {prefix}.SQLServerID = m.SQLServerID'
	+ ' {getTimeDeltaInSeconds}'
	+ ' where {prefix}.[UTCCollectionDateTime] between @UTCStart and @UTCEnd'
	+ ' group by m.SQLServerID,m.InstanceName'
	+ ' order by Value desc'

	--for aggregation type = 1, and custom counters
	select @counterSQLWeightedAverage = 'select top '+CONVERT(nvarchar(10),@NumServers)+' m.SQLServerID,m.InstanceName,'
	+ ' @CounterName as CounterName,'
	+ ' sum(((case ccd.CalculationType when 0 then ccs.RawValue else ccs.DeltaValue end) * ccd.Scale) * ccs.TimeDeltaInSeconds) / nullif(sum(case when ccs.RawValue is not null then ccs.TimeDeltaInSeconds else 0 end),0) as Value ' 
	+ ' from  CustomCounterStatistics ccs (nolock)'
	+ ' inner join MonitoredSQLServers m (nolock) on ccs.SQLServerID = m.SQLServerID'
	+ ' inner join CustomCounterDefinition ccd (nolock) on ccd.Metric = ccs.MetricID'
	+ ' where ccs.[UTCCollectionDateTime] between @UTCStart and @UTCEnd'
	+ ' and ccs.MetricID = @CounterID'
	+ ' group by m.SQLServerID,m.InstanceName'
	+ ' order by Value desc'

	--for aggregation type = 0, and custom counters
	select @counterSQLMax = 'select top '+CONVERT(nvarchar(10),@NumServers)+' m.SQLServerID,m.InstanceName,'
	+ ' @CounterName as CounterName,'
	+ ' max((case ccd.CalculationType when 0 then ccs.RawValue else ccs.DeltaValue end) * ccd.Scale) as Value ' 
	+ ' from  CustomCounterStatistics ccs (nolock)'
	+ ' inner join MonitoredSQLServers m (nolock) on ccs.SQLServerID = m.SQLServerID'
	+ ' inner join CustomCounterDefinition ccd (nolock) on ccd.Metric = ccs.MetricID'
	+ ' where ccs.[UTCCollectionDateTime] between @UTCStart and @UTCEnd'
	+ ' and ccs.MetricID = @CounterID'
	+ ' group by m.SQLServerID,m.InstanceName'
	+ ' order by Value desc'

	--for aggregation type = 2, and custom counters
	select @counterSQLPerMinute = 'select top '+CONVERT(nvarchar(10),@NumServers)+' m.SQLServerID,m.InstanceName,'
	+ ' @CounterName as CounterName,'
	+ ' sum(convert(float,((case ccd.CalculationType when 0 then ccs.RawValue else ccs.DeltaValue end) * ccd.Scale))) / nullif((sum(convert(float,case when ((case ccd.CalculationType when 0 then ccs.RawValue else ccs.DeltaValue end) * ccd.Scale) is not null then TimeDeltaInSeconds else 0 end)) / 60) ,0) as Value ' 
	+ ' from  CustomCounterStatistics ccs (nolock)'
	+ ' inner join MonitoredSQLServers m (nolock) on ccs.SQLServerID = m.SQLServerID'
	+ ' inner join CustomCounterDefinition ccd (nolock) on ccd.Metric = ccs.MetricID'
	+ ' where ccs.[UTCCollectionDateTime] between @UTCStart and @UTCEnd'
	+ ' and ccs.MetricID = @CounterID'
	+ ' group by m.SQLServerID,m.InstanceName'
	+ ' order by Value desc'

	SET @ParmDefinition = N'@UTCStart DateTime, @UTCEnd DateTime, @CounterName nvarchar(50), @CounterID int';


	declare customCounterCursor insensitive cursor for

	with DistinctMetrics(Metric, Name)as (
	select Metric = min(Metric),Name
	from MetricInfo
	group by Name
	)  

	select mi.Metric, crc.CounterName, crc.Aggregation, crc.Source
	from CustomReports cr inner join CustomReportsCounters crc on cr.ID = crc.ID
	left join DistinctMetrics mi on crc.CounterName = replace(mi.Name,' ','_') 
	where reportName = @reportName
	order by GraphNumber asc

	--NOTE: For Only Custom Counters, we want MetricID but for others it will have null value

	open customCounterCursor 
	fetch next from customCounterCursor into @counterID,@counterName, @counterAggregation, @counterSource

		declare @metricDeclaration nvarchar(80)
		declare @averageDivisor nvarchar(150)
	
		while @@fetch_status = 0
		begin
		
			-- If Metric SQLMemoryUsagePercent then we do not want to look for that column on ServerStatistics table.
			if (@counterName = 'SQLMemoryUsagePercent') 
			begin
				set @metricDeclaration = '{prefix}.SqlMemoryUsedInKilobytes * 100 / {prefix}.TotalServerMemoryInKilobytes'
				set @averageDivisor = 'nullif(sum(case when {prefix}.SqlMemoryUsedInKilobytes is not null AND {prefix}.TotalServerMemoryInKilobytes is not null then TimeDeltaInSeconds'
			end
			else
			begin
				set @metricDeclaration = '{prefix}.{metric}'
				set @averageDivisor = 'nullif(sum(case when {prefix}.{metric} is not null then TimeDeltaInSeconds'
			end
		
			--for aggregation type = 1, and os,servers counters
			select @weightedAverageCounterTemplate = 'select top '+CONVERT(nvarchar(10),@NumServers)+' m.SQLServerID,m.InstanceName,'
			+ ' @CounterName as CounterName,'
			+ ' round(sum(' + @metricDeclaration + ' * TimeDeltaInSeconds) / ' + @averageDivisor  + ' else 0 end),0),2) as Value'
			+ ' from  {prefix} (nolock)'
			+ ' inner join MonitoredSQLServers m (nolock) on {prefix}.SQLServerID = m.SQLServerID'
			+ ' {getTimeDeltaInSeconds}'
			+ ' where {prefix}.[UTCCollectionDateTime] between @UTCStart and @UTCEnd'
			+ ' group by m.SQLServerID,m.InstanceName'
			+ ' order by Value desc'
		
		
			--for aggregation type = 1, and virtual counters  
			select @virtualizationWeightedAverageCounterTemplate = 'select top '+CONVERT(nvarchar(10),@NumServers)+' m.SQLServerID,m.InstanceName,'
			+ ' @CounterName as CounterName,'
			+ ' round(avg(convert(float,{prefix}.{metric})),2) as Value'
			+ ' from  {prefix} (nolock)'
			+ ' inner join MonitoredSQLServers m (nolock) on {prefix}.SQLServerID = m.SQLServerID'
			+ ' {getTimeDeltaInSeconds}'
			+ ' where {prefix}.[UTCCollectionDateTime] between @UTCStart and @UTCEnd'
			+ ' group by m.SQLServerID,m.InstanceName'
			+ ' order by Value desc'

		
			if @counterSource = 0 --Server
			begin
				if @counterAggregation = 0--max
				begin
					select @tempQuery = replace(replace(replace(@maxCounterTemplate,'{prefix}','ServerStatistics'),'{metric}',@counterName),'{getTimeDeltaInSeconds}','')		
					insert into #resultTable						
					execute sp_executesql @tempQuery, @ParmDefinition, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterName = @counterName, @CounterID = @counterID
				end
				if(@counterAggregation = 1)--weighted average
				begin
					select @tempQuery = replace(replace(replace(@weightedAverageCounterTemplate,'{prefix}','ServerStatistics'),'{metric}',@counterName),'{getTimeDeltaInSeconds}','')	
					insert into #resultTable						
					execute sp_executesql @tempQuery, @ParmDefinition, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterName = @counterName, @CounterID = @counterID				
				end
				if @counterAggregation = 2--per minute
				begin
					select @tempQuery = replace(replace(replace(@perMinuteCounterTemplate,'{prefix}','ServerStatistics'),'{metric}',@counterName),'{getTimeDeltaInSeconds}','')	
					insert into #resultTable						
					execute sp_executesql @tempQuery, @ParmDefinition, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterName = @counterName, @CounterID = @counterID								
				end
			end
		
		
			if @counterSource = 1 --OS
			begin
				if @counterAggregation = 0--max
				begin
					select @tempQuery = replace(replace(replace(@maxCounterTemplate,'{prefix}','OSStatistics'),'{metric}',@counterName),'{getTimeDeltaInSeconds}','')	
					insert into #resultTable			
					execute sp_executesql @tempQuery, @ParmDefinition, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterName = @counterName, @CounterID = @counterID
				end
				if(@counterAggregation = 1)--weighted average
				begin
					select @tempQuery = replace(@weightedAverageCounterTemplate,'{metric}',@counterName)
					select @tempQuery = REPLACE(@tempQuery,'{getTimeDeltaInSeconds}',' right join ServerStatistics on ServerStatistics.[SQLServerID] = {prefix}.[SQLServerID] and ServerStatistics.[UTCCollectionDateTime] = {prefix}.[UTCCollectionDateTime]')
					select @tempQuery = REPLACE(@tempQuery,'{prefix}','OSStatistics')									
					insert into #resultTable			
					execute sp_executesql @tempQuery, @ParmDefinition, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterName = @counterName, @CounterID = @counterID			
				end
				if @counterAggregation = 2--per minute
				begin				
					select @tempQuery = replace(@perMinuteCounterTemplate,'{metric}',@counterName)
					select @tempQuery = REPLACE(@tempQuery,'{getTimeDeltaInSeconds}',' right join ServerStatistics on ServerStatistics.[SQLServerID] = {prefix}.[SQLServerID] and ServerStatistics.[UTCCollectionDateTime] = {prefix}.[UTCCollectionDateTime]')
					select @tempQuery = REPLACE(@tempQuery,'{prefix}','OSStatistics')
					insert into #resultTable			
					execute sp_executesql @tempQuery, @ParmDefinition, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterName = @counterName, @CounterID = @counterID							
				end
			end
		
			if @counterSource = 2 --Custom
			begin
				if @counterAggregation = 0--max
				begin
					insert into #resultTable		
					execute sp_executesql @counterSQLMax, @ParmDefinition, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterName = @counterName, @CounterID = @counterID
				end
				if(@counterAggregation = 1)--weighted average
				begin
					insert into #resultTable			
					execute sp_executesql @counterSQLWeightedAverage, @ParmDefinition, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterName = @counterName, @CounterID = @counterID			
				end
				if @counterAggregation = 2--per minute
				begin
					insert into #resultTable		
					execute sp_executesql @counterSQLPerMinute, @ParmDefinition, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterName = @counterName, @CounterID = @counterID								
				end
			end
		
			if @counterSource = 3 --Virtualization
			begin
				if @counterAggregation = 0--max
				begin			
					select @tempQuery = replace(replace(replace(@maxCounterTemplate,'{prefix}','VMStatistics'),'{metric}',@counterName),'{getTimeDeltaInSeconds}','')		
					insert into #resultTable	
					execute sp_executesql @tempQuery, @ParmDefinition, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterName = @counterName, @CounterID = @counterID
				end
				if(@counterAggregation = 1)--weighted average
				begin
					select @tempQuery = replace(replace(replace(@virtualizationWeightedAverageCounterTemplate,'{prefix}','VMStatistics'),'{metric}',@counterName),'{getTimeDeltaInSeconds}','')				
					insert into #resultTable
					execute sp_executesql @tempQuery, @ParmDefinition, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterName = @counterName, @CounterID = @counterID				
				end
				if @counterAggregation = 2--per minute
				begin
					select @tempQuery = replace(replace(replace(@virtualizationPerMinuteCounterTemplate,'{prefix}','VMStatistics'),'{metric}',@counterName),'{getTimeDeltaInSeconds}','')		
					insert into #resultTable
					execute sp_executesql @tempQuery, @ParmDefinition, @UTCStart = @UTCStart, @UTCEnd = @UTCEnd, @CounterName = @counterName, @CounterID = @counterID								
				end
			end
		
			fetch next from customCounterCursor
			into @counterID, @counterName,@counterAggregation, @counterSource
		end--while loop ends here
	close customCounterCursor
	deallocate customCounterCursor

	select SQLServerID,InstanceName,CounterName,ISNULL(Value,-1) AS Value from #resultTable

end--end of proc
 
GO 

---------- P_GETTOPSESSIONBYCPUUSAGE.SQL
-- SQLDM 8.5:Mahesh : Added for Rest service consumption
if (object_id('p_GetSessionByCPUUsage') is not null)
begin
drop procedure p_GetSessionByCPUUsage
end
go

CREATE PROCEDURE [dbo].[p_GetSessionByCPUUsage](

	@ServerId int = null,
	@StartDateTime datetime = null,
	@EndDateTime datetime = null,
	@TopN bigint = 10
)

AS

begin

	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

	declare @e int

	set rowcount @TopN

				select M.SQLServerID
				,M.InstanceName
				,D.DatabaseName
				,D.DatabaseID
				,QS.SessionID
				,max(QS.CPUMilliseconds) as CPUMilliseconds
				,H.HostName
				from 
				QueryMonitorStatistics QS (NOLOCK)
				Join MonitoredSQLServers M (NOLOCK)
				on M.SQLServerID = QS.SQLServerID
				and M.Active = 1
				Join SQLServerDatabaseNames D (nolock)
				on D.DatabaseID = QS.DatabaseID
				join HostNames H (NOLOCK)
				on H.HostNameID = QS.HostNameID
				Where QS.SessionID IS NOT NULL
				AND QS.UTCCollectionDateTime between ISNULL(@StartDateTime,QS.UTCCollectionDateTime) and ISNULL(@EndDateTime,QS.UTCCollectionDateTime) 
				Group by M.SQLServerID
				,M.InstanceName
				,D.DatabaseName
				,D.DatabaseID
				,QS.SessionID
				,H.HostName
				Having M.SQLServerID = ISNULL(@ServerId,M.SQLServerID)
				Order by CPUMilliseconds DESC

	SELECT @e = @@error

	RETURN @e

END	 

GO

 
GO 

---------- P_GETTOPSESSIONSBYCPUUSAGE.SQL
if (object_id('p_GetTopSessionsByCpuUsage') is not null)
begin
	drop procedure [p_GetTopSessionsByCpuUsage]
end
go

-- [p_GetTopSessionsByCpuUsage] 30
CREATE PROCEDURE [dbo].[p_GetTopSessionsByCpuUsage]
@TopX INT = NULL, 
@SQLServerID INT = NULL --SQLdm 9.1 (Sanjali Makkar) : Adding the filter of InstanceID
AS
BEGIN


	;with MaxCollTime (SQLServerID, UTCCollectionDateTime) as (
	  SELECT MS.SQLServerID, MAX(sa.UTCCollectionDateTime)
	  FROM [ServerActivity] sa (nolock)
		JOIN MonitoredSQLServers MS (nolock)
		  ON sa.SQLServerID = MS.SQLServerID
	  WHERE MS.Active = 1 AND (@SQLServerID IS NULL OR sa.SQLServerID = @SQLServerID) AND sa.SessionList IS NOT NULL
	  GROUP BY MS.SQLServerID
		)
	SELECT
		sa.SQLServerID, MS.InstanceName, sa.UTCCollectionDateTime, sa.SessionList
	FROM
	 	MaxCollTime mct (nolock) INNER JOIN  [ServerActivity] sa (nolock)
		ON  mct.SQLServerID = sa.SQLServerID
			AND mct.UTCCollectionDateTime = sa.UTCCollectionDateTime
		JOIN MonitoredSQLServers MS ON MS.SQLServerID = mct.SQLServerID WHERE sa.SessionList IS NOT NULL
END
 
GO
 
GO 

---------- P_GETTOPTABLESFRAGMENTATION.SQL
if (object_id('[p_GetTopTablesFragmentation]') is not null)
begin
drop procedure p_GetTopTablesFragmentation
end
go
-- @OrderBy
-- 0 - Scan Density
-- 1 - Logical Fragmentation
-- 2 - Total Size
create procedure [dbo].p_GetTopTablesFragmentation
	@ServerId int,
	@DatabaseNameFilter sysname = null,
	@UTCStart DateTime,
	@UTCEnd DateTime,
	@UTCOffset int = 0,
	@MinSizeMB decimal = null,
	@MaxSizeMB decimal = null,
	@MinLogicalFragmentation float = null,
	@MaxLogicalFragmentation float = null,
	@TopN bigint = 10,
	@OrderBy tinyint = 0,
	@PassthroughOnly bit = 0
as
begin

if len(@DatabaseNameFilter) = 0
	set @DatabaseNameFilter = null

set rowcount @TopN

if @PassthroughOnly = 1
begin
	select
		DatabaseName
		,[TableName] = isnull(SchemaName,'') + '.' + isnull(TableName,'')
		,[Id] = tnames.TableID
	from
		[SQLServerDatabaseNames] dbnames (nolock)
		join [SQLServerTableNames] tnames (nolock)
		on dbnames.[DatabaseID] = tnames.[DatabaseID]
		join [TableReorganization] tr (nolock)
		on tr.TableID = tnames.TableID
		join [TableGrowth] growth (nolock)
		on tnames.[TableID] = growth.[TableID]
	where 
		dbnames.SQLServerID = @ServerId and
		DatabaseName = coalesce(@DatabaseNameFilter,DatabaseName)
		and tr.UTCCollectionDateTime = 
			(
				select max(tr2.UTCCollectionDateTime) 
				from TableReorganization tr2 (nolock)
				where 
					tr2.[UTCCollectionDateTime] between @UTCStart and @UTCEnd and
					tr.TableID = tr2.TableID
			)
		and
		growth.[UTCCollectionDateTime] =
			(
				select max(growth2.UTCCollectionDateTime) 
				from [TableGrowth] growth2 (nolock)
				where 
					growth2.[UTCCollectionDateTime] between @UTCStart and @UTCEnd and
					growth.TableID = growth2.TableID
			)
		and isnull(LogicalFragmentation,0) between isnull(@MinLogicalFragmentation,-1) and isnull(@MaxLogicalFragmentation,100)
		and ( DataSize + [TextSize] + IndexSize )  / 1024 between isnull(@MinSizeMB,-1) and isnull(@MaxSizeMB,(DataSize + [TextSize] + IndexSize ) / 1024 + 1)
	order by
		case 
		when @OrderBy = 0 then 100 - ScanDensity
		when @OrderBy = 1 then LogicalFragmentation
		else  (DataSize + [TextSize] + IndexSize) / 1024
		end 
		desc
end
else
begin

	select 
		DatabaseName
		,[TableName] = isnull(SchemaName,'') + '.' + isnull(TableName,'')
		,dateadd(mi, @UTCOffset, tr.[UTCCollectionDateTime]) as LastCollectioninInterval
		,ScanDensity = 100 - ScanDensity
		,LogicalFragmentation = LogicalFragmentation
		,TotalSize = (DataSize + [TextSize] + IndexSize) / 1024
	from
		[SQLServerDatabaseNames] dbnames (nolock)
		join [SQLServerTableNames] tnames (nolock)
		on dbnames.[DatabaseID] = tnames.[DatabaseID]
		join [TableReorganization] tr (nolock)
		on tr.TableID = tnames.TableID
		join [TableGrowth] growth (nolock)
		on tnames.[TableID] = growth.[TableID]
	where 
		dbnames.SQLServerID = @ServerId and
		DatabaseName = coalesce(@DatabaseNameFilter,DatabaseName)
		and tr.UTCCollectionDateTime = 
			(
				select max(tr2.UTCCollectionDateTime) 
				from TableReorganization tr2 (nolock)
				where 
					tr2.[UTCCollectionDateTime] between @UTCStart and @UTCEnd and
					tr.TableID = tr2.TableID
			)
		and
		growth.[UTCCollectionDateTime] =
			(
				select max(growth2.UTCCollectionDateTime) 
				from [TableGrowth] growth2 (nolock)
				where 
					growth2.[UTCCollectionDateTime] between @UTCStart and @UTCEnd and
					growth.TableID = growth2.TableID
			)
		and (@OrderBy > 0 or ScanDensity is not null)
		and isnull(LogicalFragmentation,0) between isnull(@MinLogicalFragmentation,-1) and isnull(@MaxLogicalFragmentation,100)
		and ( DataSize + [TextSize] + IndexSize )  / 1024 between isnull(@MinSizeMB,-1) and isnull(@MaxSizeMB,(DataSize + [TextSize] + IndexSize ) / 1024 + 1)
	order by
		case 
		when @OrderBy = 0 then 100 - ScanDensity
		when @OrderBy = 1 then LogicalFragmentation
		else (DataSize + [TextSize] + IndexSize) / 1024
		end 
		desc

end

end

Go

grant EXECUTE on [p_GetTopTablesFragmentation] to [SQLdmConsoleUser]
 
GO 

---------- P_GETTOPTABLESFRAGMENTATIONCHART.SQL
if (object_id('[p_GetTopTablesFragmentationChart]') is not null)
begin
drop procedure p_GetTopTablesFragmentationChart
end
go
-- @Interval - Granularity of calculation:
--	0 - Minutes
--	1 - Hours
--	2 - Days
--	3 - Months
--	4 - Years
--  5 - All Time
-- @OrderBy
-- 0 - Scan Density
-- 1 - Logical Fragmentation
-- 2 - Data Size
create procedure [dbo].p_GetTopTablesFragmentationChart
	@ServerId int,
	@DatabaseNameFilter sysname = null,
	@UTCStart DateTime,
	@UTCEnd DateTime,
	@UTCOffset int = 0,
	@MinSizeMB decimal = null,
	@MaxSizeMB decimal = null,
	@MinLogicalFragmentation float = null,
	@MaxLogicalFragmentation float = null,
	@TopN bigint = 10,
	@ReturnData tinyint = 0,
	@Interval int
as
begin

set ansi_warnings off
set rowcount 0

create table #PassthroughData (DBName sysname, TableName nvarchar(200), Id bigint)

insert into #PassthroughData
	exec p_GetTopTablesFragmentation
	@ServerId = @ServerId,
	@DatabaseNameFilter = @DatabaseNameFilter,
	@UTCStart = @UTCStart,
	@UTCEnd = @UTCEnd,
	@UTCOffset = @UTCOffset,
	@MinSizeMB = @MinSizeMB,
	@MaxSizeMB = @MaxSizeMB,
	@MinLogicalFragmentation = @MinLogicalFragmentation,
	@MaxLogicalFragmentation = @MaxLogicalFragmentation,
	@TopN =  @TopN,
	@OrderBy = @ReturnData,
	@PassthroughOnly = 1

	select
		ObjectName = DBName + '.' + TableName,
		[LastCollectioninInterval] = dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, tr.[UTCCollectionDateTime]))),
		Data =
			case
			when @ReturnData = 0
				then 100 - sum(ScanDensity * tr.TimeDeltaInSeconds) / nullif(sum(tr.TimeDeltaInSeconds),0)
			when @ReturnData = 1
				then sum(LogicalFragmentation * tr.TimeDeltaInSeconds) / nullif(sum(tr.TimeDeltaInSeconds),0)
			when @ReturnData = 2
				then sum((DataSize + [TextSize] + IndexSize) * growth.TimeDeltaInSeconds) / nullif(sum(growth.TimeDeltaInSeconds),0)  /1024
			end
	from
		#PassthroughData p
		join [TableReorganization] tr (nolock)
		on tr.TableID = p.Id
		join [TableGrowth] growth (nolock)
		on p.Id = growth.[TableID]
	where
		tr.[UTCCollectionDateTime] between @UTCStart and @UTCEnd and
		growth.[UTCCollectionDateTime] between @UTCStart and @UTCEnd
	group by
	DBName + '.' + TableName
	,case when isnull(@Interval,5) <= 4 then datepart(yy, dateadd(mi, @UTCOffset, tr.[UTCCollectionDateTime])) else 1 end
	,case when isnull(@Interval,5) <= 3 then datepart(mm,dateadd(mi, @UTCOffset, tr.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, tr.[UTCCollectionDateTime])) end
	,case when isnull(@Interval,5) <= 2 then datepart(dd,dateadd(mi, @UTCOffset, tr.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, tr.[UTCCollectionDateTime])) end
	,case when isnull(@Interval,5) <= 1 then datepart(hh,dateadd(mi, @UTCOffset, tr.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, tr.[UTCCollectionDateTime])) end
	,case when isnull(@Interval,5) =  0 then datepart(mi,dateadd(mi, @UTCOffset, tr.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, tr.[UTCCollectionDateTime])) end
	order by 
	ObjectName,
	dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, tr.[UTCCollectionDateTime])))

drop table #PassthroughData

end

Go

grant EXECUTE on [p_GetTopTablesFragmentationChart] to [SQLdmConsoleUser]
 
GO 

---------- P_GETTOPTABLESGROWTH.SQL
if (object_id('[p_GetTopTablesGrowth]') is not null)
begin
drop procedure p_GetTopTablesGrowth
end
go
-- @OrderBy
-- 0 - Number of Rows
-- 1 - Data Size
-- 2 - Text Size
-- 3 - Index Size
-- 4 - Total Size
-- 5 - Table Growth
-- 6 - Row Growth
create procedure [dbo].p_GetTopTablesGrowth
	@ServerId int,
	@DatabaseNameFilter sysname = null,
	@UTCStart DateTime,
	@UTCEnd DateTime,
	@UTCOffset int = 0,
	@MinSizeMB decimal = null,
	@MaxSizeMB decimal = null,
	@MinRows bigint = null,
	@MaxRows bigint = null,
	@TopN bigint = 10,
	@OrderBy tinyint = 0,
	@PassthroughOnly bit = 0
as
begin
set ansi_warnings off
set rowcount 0

if len(@DatabaseNameFilter) = 0
	set @DatabaseNameFilter = null

declare @StartSizeTable table(TName nvarchar(500), DBName sysname, StartSizeId int, StartRows bigint, StartSize float)

insert into @StartSizeTable
select
	TName = isnull(SchemaName,'') + '.' + isnull(TableName,''),
	DBName = DatabaseName,
	StartSizeId = tnames.TableID,
	StartRows = NumberOfRows,
	StartSize = (DataSize + [TextSize] + IndexSize)
from
	[SQLServerDatabaseNames] dbnames (nolock)
	join [SQLServerTableNames] tnames (nolock)
	on dbnames.[DatabaseID] = tnames.[DatabaseID]
	join [TableGrowth] growth (nolock)
	on tnames.[TableID] = growth.[TableID]
where
	dbnames.SQLServerID = @ServerId and
	DatabaseName = coalesce(@DatabaseNameFilter,DatabaseName) and
	[UTCCollectionDateTime] =
	(
		select min([UTCCollectionDateTime]) 
		from [TableGrowth] growth2 (nolock)
		where 
		[UTCCollectionDateTime] between @UTCStart and @UTCEnd
		and growth.TableID = growth2.TableID)


set rowcount @TopN

if @PassthroughOnly = 1
begin
	select
		[DatabaseName] = DBName
		,[TableName] = TName
		,[Id] = ss.StartSizeId
	from
	@StartSizeTable ss
	join [TableGrowth] growth (nolock)
	on ss.StartSizeId = growth.[TableID]
where 
	growth.[UTCCollectionDateTime] = 
	(
		select max(growth2.UTCCollectionDateTime) 
		from [TableGrowth] growth2 (nolock)
		where 
			growth2.[UTCCollectionDateTime] between @UTCStart and @UTCEnd
			and growth.TableID = growth2.TableID
	)
	and NumberOfRows between isnull(@MinRows,-1) and isnull(@MaxRows,NumberOfRows + 1)
	and (DataSize + [TextSize] + IndexSize) / 1024between isnull(@MinSizeMB,-1) and isnull(@MaxSizeMB,(DataSize + [TextSize] + IndexSize) / 1024 + 1)
order by
	case 
	when @OrderBy = 0 then NumberOfRows
	when @OrderBy = 1 then DataSize / 1024
	when @OrderBy = 2 then [TextSize] / 1024
	when @OrderBy = 3 then IndexSize / 1024
	when @OrderBy = 4 then (DataSize + [TextSize] + IndexSize) / 1024
	when @OrderBy = 5 then isnull(( (DataSize + [TextSize] + IndexSize) / nullif(StartSize,0)) - 1,0)
	when @OrderBy = 6 then isnull((cast(NumberOfRows as float)/ nullif(StartRows,0)) - 1,0)
	else NumberOfRows
	end 
	desc

end
else
begin


select 
	[DatabaseName] = DBName
	,[TableName] = TName
	,dateadd(mi, @UTCOffset, growth.[UTCCollectionDateTime]) as [LastCollectioninInterval]
	,NumberOfRows 
	,DataSize = DataSize / 1024
	,[TextSize] = [TextSize] / 1024
	,IndexSize = IndexSize  / 1024
	,TotalSize = (DataSize + [TextSize] + IndexSize) / 1024
	,TableGrowth = isnull(( (DataSize + [TextSize] + IndexSize) / nullif(StartSize,0)) - 1,0)
	,RowGrowth = isnull((cast(NumberOfRows as float)/ nullif(StartRows,0)) - 1,0)
from
	@StartSizeTable ss
	join [TableGrowth] growth (nolock)
	on ss.StartSizeId = growth.[TableID]
where 
	growth.[UTCCollectionDateTime] = 
	(
		select max(growth2.UTCCollectionDateTime) 
		from [TableGrowth] growth2 (nolock)
		where 
			growth2.[UTCCollectionDateTime] between @UTCStart and @UTCEnd
			and growth.TableID = growth2.TableID
	)
	and NumberOfRows between isnull(@MinRows,-1) and isnull(@MaxRows,NumberOfRows + 1)
	and (DataSize + [TextSize] + IndexSize) / 1024between isnull(@MinSizeMB,-1) and isnull(@MaxSizeMB,(DataSize + [TextSize] + IndexSize) / 1024 + 1)
order by
	case 
	when @OrderBy = 0 then NumberOfRows
	when @OrderBy = 1 then DataSize / 1024
	when @OrderBy = 2 then [TextSize] / 1024
	when @OrderBy = 3 then IndexSize / 1024
	when @OrderBy = 4 then (DataSize + [TextSize] + IndexSize) / 1024
	when @OrderBy = 5 then isnull(( (DataSize + [TextSize] + IndexSize) / nullif(StartSize,0)) - 1,0)
	when @OrderBy = 6 then isnull((cast(NumberOfRows as float)/ nullif(StartRows,0)) - 1,0)
	else NumberOfRows
	end 
	desc

end

end

Go

grant EXECUTE on [p_GetTopTablesGrowth] to [SQLdmConsoleUser]

 
GO 

---------- P_GETTOPTABLESGROWTHCHART.SQL
if (object_id('[p_GetTopTablesGrowthChart]') is not null)
begin
drop procedure p_GetTopTablesGrowthChart
end
go
-- @Interval - Granularity of calculation:
--	0 - Minutes
--	1 - Hours
--	2 - Days
--	3 - Months
--	4 - Years
--  5 - All Time
-- @OrderBy
-- 0 - Number of Rows
-- 1 - Data Size
-- 2 - Text Size
-- 3 - Index Size
-- 4 - Total Size
-- 5 - Table Growth
-- 6 - Row Growth
create procedure [dbo].p_GetTopTablesGrowthChart
	@ServerId int,
	@DatabaseNameFilter sysname = null,
	@UTCStart DateTime,
	@UTCEnd DateTime,
	@UTCOffset int = 0,
	@MinSizeMB decimal = null,
	@MaxSizeMB decimal = null,
	@MinRows bigint = null,
	@MaxRows bigint = null,
	@TopN bigint = 10,
	@ReturnData tinyint = 0,
	@Interval int
as
begin

set ansi_warnings off
set rowcount 0

create table #PassthroughData (DBName sysname, TableName nvarchar(200), Id bigint)

insert into #PassthroughData
	exec p_GetTopTablesGrowth
	@ServerId = @ServerId,
	@DatabaseNameFilter = @DatabaseNameFilter,
	@UTCStart = @UTCStart,
	@UTCEnd = @UTCEnd,
	@UTCOffset = @UTCOffset,
	@MinSizeMB = @MinSizeMB,
	@MaxSizeMB = @MaxSizeMB,
	@MinRows = @MinRows,
	@MaxRows = @MaxRows,
	@TopN =  @TopN,
	@OrderBy = @ReturnData,
	@PassthroughOnly = 1

declare @OutputTable table(ObjectName nvarchar(200),LastCollectioninInterval datetime, Data dec(38,10), RowNumber int identity)

insert into @OutputTable (ObjectName, LastCollectioninInterval, Data)
	select
		ObjectName = DBName + '.' + TableName,
		[LastCollectioninInterval] = dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, [UTCCollectionDateTime]))),
		Data =
			case
			when @ReturnData = 0 or @ReturnData = 6
				then ceiling(sum(NumberOfRows * TimeDeltaInSeconds) / nullif(sum(TimeDeltaInSeconds),0))
			when @ReturnData = 1
				then sum(DataSize * TimeDeltaInSeconds) / nullif(sum(TimeDeltaInSeconds),0) / 1024
			when @ReturnData = 2
				then sum([TextSize] * TimeDeltaInSeconds) / nullif(sum(TimeDeltaInSeconds),0) / 1024
			when @ReturnData = 3
				then sum(IndexSize * TimeDeltaInSeconds) / nullif(sum(TimeDeltaInSeconds),0) / 1024
			when @ReturnData = 4 or @ReturnData = 5
				then sum((DataSize + [TextSize] + IndexSize) * TimeDeltaInSeconds) / nullif(sum(TimeDeltaInSeconds),0) / 1024
			end
	from
		#PassthroughData p
		join [TableGrowth] growth (nolock)
		on p.Id = growth.[TableID]
	where
		[UTCCollectionDateTime] between @UTCStart and @UTCEnd
	group by
	DBName + '.' + TableName
	,case when isnull(@Interval,5) <= 4 then datepart(yy, dateadd(mi, @UTCOffset, [UTCCollectionDateTime])) else 1 end
	,case when isnull(@Interval,5) <= 3 then datepart(mm,dateadd(mi, @UTCOffset, [UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, [UTCCollectionDateTime])) end
	,case when isnull(@Interval,5) <= 2 then datepart(dd,dateadd(mi, @UTCOffset, [UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, [UTCCollectionDateTime])) end
	,case when isnull(@Interval,5) <= 1 then datepart(hh,dateadd(mi, @UTCOffset, [UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, [UTCCollectionDateTime])) end
	,case when isnull(@Interval,5) =  0 then datepart(mi,dateadd(mi, @UTCOffset, [UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, [UTCCollectionDateTime])) end
	order by 
	ObjectName,
	dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, [UTCCollectionDateTime])))

if @ReturnData >= 5
begin
	declare @PrevValue float, @CurValue float, @rownum int, @CurObj nvarchar(255),@PrevObj nvarchar(255)

	select 
		@PrevValue = null,
		@rownum = isnull(min(RowNumber),-1),
		@PrevObj = null,
		@CurObj = null
	from @OutputTable

	while @rownum > 0
	begin
	
		select @CurValue = Data,
			   @CurObj = ObjectName
		from @OutputTable
		where RowNumber = @rownum	

		if @CurObj <> @PrevObj
			set @PrevValue = null

		update @OutputTable
			set Data = isnull((Data /  nullif(@PrevValue,0) ) - 1,0) * 100
		where RowNumber = @rownum

		select @PrevValue = @CurValue,
			   @PrevObj = @CurObj

		select @rownum = isnull(min(RowNumber),-1)
		from @OutputTable
			where RowNumber > @rownum
	end
end

select 
	ObjectName,
	LastCollectioninInterval, 
	Data
from @OutputTable

end

Go

grant EXECUTE on [p_GetTopTablesGrowthChart] to [SQLdmConsoleUser]
 
GO 

---------- P_GETUSERIDENTIFIERS.SQL
if (object_id('p_GetUserIdentifiers') is not null)
begin
drop procedure p_GetUserIdentifiers
end
go

CREATE PROCEDURE [dbo].[p_GetUserIdentifiers]
AS
BEGIN
	declare @securityEnabled bit
	declare @sysadmin bit
	declare @sqldmAdministrator bit
	declare @repositoryVersion int
	
	----------------------------------------------------------------------------------------------------
	-- initialize flags
	----------------------------------------------------------------------------------------------------
	set @securityEnabled = 0
	set @sysadmin = 0
	set @sqldmAdministrator = 0

	declare @temp_MatchingLogins table (MatchLoginSID varbinary(85) not null)
	
	----------------------------------------------------------------------------------------------------
	-- check if security is enabled
	-- if ApplicationSecurityEnabled flag is there, check if its set, else create the flag and clear it
	----------------------------------------------------------------------------------------------------
	if ((select count([Internal_Value]) from dbo.[RepositoryInfo] where [Name] = 'ApplicationSecurityEnabled') = 1)
	begin
		if ((select count([Internal_Value])  
			from dbo.[RepositoryInfo] 
				where [Name] = 'ApplicationSecurityEnabled' and [Internal_Value] != 0) = 1)
			set @securityEnabled = 1
		else
			set @securityEnabled = 0
	end
	else
	begin
		-- insert row for application security enabled flag and clear it
		insert into dbo.[RepositoryInfo]
		values ('ApplicationSecurityEnabled',0,'')		
		set @securityEnabled = 0
	end

	----------------------------------------------------------------------------------------------------
	-- check if user is sysadmin
	----------------------------------------------------------------------------------------------------
	if IS_SRVROLEMEMBER ('sysadmin') = 1
		set @sysadmin = 1
	else
		set @sysadmin = 0

	if (@securityEnabled = 0 or @sysadmin = 1)
	begin
		set @sqldmAdministrator = 1;
	end

	-- determine the version of SQLdm repository.
	select @repositoryVersion = CAST(SUBSTRING(CONVERT(char(20), SERVERPROPERTY('ProductVersion')),1,1) as int)
				
	select @securityEnabled, @sysadmin, @sqldmAdministrator, @repositoryVersion

	-- if SQL Server 2000, just insert the input windows user sid into temp table because
	-- SQL Server 2000 does not have support for getting the user token.
	-- if SQL Server 2005 or higher get the sids from the login token.
	if @repositoryVersion = 8
		select SYSTEM_USER, SUSER_SID(SYSTEM_USER)
	else				
		exec ('select name, sid from sys.login_token where type like ''% LOGIN'' or type like ''% GROUP''')					
END
 
GO 

---------- P_GETUSERSFORSERVER.SQL
--retrieves those users who fired at least one 
-- query on the given instance

-- @SQLServerID is the Instance ID
-- @StartIndex is the index from where users needs to be retrieved
-- @RecordsCount is the number of users to be retrieved

-- exec p_GetUsersForServer 9,2,1

if (object_id('p_GetUsersForServer') is not null)
begin
	drop procedure [p_GetUsersForServer]
end
go

create procedure [dbo].[p_GetUsersForServer]
	@SQLServerID int,
	@StartIndex int = 1,
	@RecordsCount int = -1
as
begin
	IF (@RecordsCount = -1)
		SELECT
			DISTINCT(QMS.LoginNameID) AS UserID,	
			LN.LoginName	AS UserName
		FROM
			[QueryMonitorStatistics] AS QMS 
			INNER JOIN 
			[LoginNames] AS LN
			ON QMS.LoginNameID = LN.LoginNameID
		WHERE
			QMS.SQLServerID = @SQLServerID
		ORDER BY
			LN.LoginName
	ELSE
		begin
			WITH UserNames AS
			(
				SELECT
					DISTINCT(QMS.LoginNameID) AS UserID,	
					LN.LoginName	AS UserName,
					DENSE_RANK() OVER (ORDER BY LN.LoginName) AS RecordRank
				FROM
					[QueryMonitorStatistics] AS QMS 
					INNER JOIN 
					[LoginNames] AS LN
					ON QMS.LoginNameID = LN.LoginNameID
				WHERE
					QMS.SQLServerID = @SQLServerID
			)

			SELECT
				UserID,
				UserName
			FROM
				UserNames
			WHERE
				RecordRank BETWEEN @StartIndex AND (@StartIndex + @RecordsCount - 1)
			ORDER BY
				UserName
		end
end
go
 
GO 

---------- P_GETUSERTOKEN.SQL


IF (object_id('p_GetUserTokenInternal') is not null)
BEGIN
drop procedure p_GetUserTokenInternal
END
GO

CREATE PROCEDURE [dbo].[p_GetUserTokenInternal]
	@IsSQLLogin bit,
	@SQLLoginName nvarchar(128),
	@WindowsSID varbinary(85),
	@ForReporting bit = 0,
	@VMOnly bit = 0,
	@MinimumServerVersion int = 8
AS
BEGIN
	declare @e int
	declare @securityEnabled bit
	declare @sysadmin bit
	declare @sqldmAdministrator bit
	declare @repositoryVersion int
	
	----------------------------------------------------------------------------------------------------
	-- create temp table to hold the list of assigned servers & matching logins
	----------------------------------------------------------------------------------------------------
	create table #temp_AssignedServers 
	(
		SQLServerID int not null,
		InstanceName nvarchar(256) not null,
		Active bit not null,
		Deleted bit not null,
		PermissionType int not null,
		Virtualized bit not null,
		ServerVersion nvarchar(30)
	)
	create table #temp_MatchingLogins
	(
		MatchLoginSID varbinary(85) not null
	)
	
	----------------------------------------------------------------------------------------------------
	-- initialize flags
	----------------------------------------------------------------------------------------------------
	set @securityEnabled = 0
	set @sysadmin = 0
	set @sqldmAdministrator = 0

	----------------------------------------------------------------------------------------------------
	-- check if security is enabled
	-- if ApplicationSecurityEnabled flag is there, check if its set, else create the flag and clear it
	----------------------------------------------------------------------------------------------------
	if ((select count([Internal_Value]) 
		from dbo.[RepositoryInfo] 
			where [Name] = 'ApplicationSecurityEnabled') = 1)
	begin
		if ((select count([Internal_Value]) 
			from dbo.[RepositoryInfo] 
				where [Name] = 'ApplicationSecurityEnabled' and [Internal_Value] != 0) = 1)
			set @securityEnabled = 1
		else
			set @securityEnabled = 0
	end
	else
	begin
		-- insert row for application security enabled flag and clear it
		insert into dbo.[RepositoryInfo]
		values ('ApplicationSecurityEnabled',0,'')
		
		set @securityEnabled = 0
	end

	----------------------------------------------------------------------------------------------------
	-- check if user is sysadmin
	----------------------------------------------------------------------------------------------------
	if IS_SRVROLEMEMBER ('sysadmin') = 1
		set @sysadmin = 1
	else
		set @sysadmin = 0
	----------------------------------------------------------------------------------------------------
	-- if security is not enabled set administrator flag because everyone is an administrator
	-- else get the permissions assigned to the user.
	----------------------------------------------------------------------------------------------------
	if @securityEnabled = 0
	begin
		set @sqldmAdministrator = 1
		
		-- fill temp assigned servers table with all monitored SQL Servers
		-- with admin (2) permission
		insert into #temp_AssignedServers
		select [SQLServerID], [InstanceName], [Active], [Deleted], cast (2 as int) as [PermissionType], case when [VmUID] is null then 0 else 1 end, [ServerVersion]
		from dbo.[MonitoredSQLServers] 
		where [Deleted] = 0
	end
	else
	begin
		-- if user is sysadmin they are administrator 
		-- else check the Permisssion table for administrator powers.
		if @sysadmin = 1
		begin
			-- set SQLdm admin flag
			set @sqldmAdministrator = 1
			
			-- fill temp assigned servers table with all monitored SQL Servers
			-- with admin (2) permission
			insert into #temp_AssignedServers
			select [SQLServerID], [InstanceName], [Active], [Deleted], cast (2 as int) as [PermissionType], case when [VmUID] is null then 0 else 1 end, [ServerVersion]
			from dbo.[MonitoredSQLServers] 
			where [Deleted] = 0
		end
		else
		begin
			-- determine matching logins
			if @IsSQLLogin = 1
			begin
				-- insert the matching login from syslogins table
				insert into #temp_MatchingLogins
				select sid from master..syslogins where name = @SQLLoginName and isntname = 0
			end
			else
			begin
				insert into #temp_MatchingLogins
					select sid from sys.login_token where type = 'WINDOWS LOGIN' or type = 'WINDOWS GROUP'			
			end
			
			-- if matching logins are available get token information
			if (select count(MatchLoginSID) from #temp_MatchingLogins) > 0
			begin

				-- check if user has administrator power
				if (select count(Permission) 
					from [dbo].[Permission]
						where Permission = 2 -- admin power
							and LoginSID in (select MatchLoginSID from #temp_MatchingLogins)
								and Enabled = 1) > 0
					set @sqldmAdministrator = 1
				else
					set @sqldmAdministrator = 0

				-- if user is administrator assign all servers with admin powers
				-- else get only those servers assigned to the user
				if @sqldmAdministrator = 1
				begin
					insert into #temp_AssignedServers
					select [SQLServerID], [InstanceName], [Active], [Deleted], cast (2 as int) as [PermissionType], case when [VmUID] is null then 0 else 1 end, [ServerVersion]
					from dbo.[MonitoredSQLServers]
					where [Deleted] = 0
				end
				else
				begin
					insert into #temp_AssignedServers
					select mss.SQLServerID, mss.InstanceName, mss.Active, mss.Deleted, p.Permission, case when mss.[VmUID] is null then 0 else 1 end, mss.ServerVersion
					from [dbo].[Permission] as p 
						join [dbo].[PermissionServers] as s on (p.[PermissionID] = s.[PermissionID])
							join [dbo].[MonitoredSQLServers] as mss on (s.[SQLServerID] = mss.[SQLServerID])
								where p.LoginSID in (select MatchLoginSID from #temp_MatchingLogins)
									and p.Enabled = 1 and mss.Deleted = 0
					-- get servers assigned via tags
					insert into #temp_AssignedServers
					select distinct mss.SQLServerID, mss.InstanceName, mss.Active, mss.Deleted, p.Permission, case when mss.[VmUID] is null then 0 else 1 end, mss.ServerVersion
					from [dbo].[Permission] as p 
						left outer join [dbo].[PermissionTags] pt on (p.[PermissionID] = pt.[PermissionId])
						left outer join [dbo].[ServerTags] st on (pt.[TagId] = st.[TagId])
						left outer join [dbo].[PermissionServers] s on (p.[PermissionID] = s.[PermissionID] and st.[SQLServerId] = s.[SQLServerID])
						join [dbo].[MonitoredSQLServers] as mss on (st.[SQLServerId] = mss.[SQLServerID])
								where p.LoginSID in (select MatchLoginSID from #temp_MatchingLogins)
									and p.Enabled = 1 and mss.Deleted = 0 
									and s.SQLServerID is null
				end
			end
		end
	end

	----------------------------------------------------------------------------------------------------
	-- select flags & assigned servers
	----------------------------------------------------------------------------------------------------
	if (isnull(@ForReporting,0) = 0)
	begin
		select @securityEnabled as SecurityEnabled, @sysadmin as SysAdmin, @sqldmAdministrator as SQLdmAdministrator
		select [SQLServerID], [InstanceName], [Active], [Deleted], [PermissionType]
		from #temp_AssignedServers where [Virtualized] >= @VMOnly
	end
	else
	begin
		select [InstanceName], [SQLServerID]
		from #temp_AssignedServers where [Virtualized] >= @VMOnly 
			and SUBSTRING(ServerVersion, 0, CHARINDEX('.', ServerVersion)) >= @MinimumServerVersion
	end
	
	select @e = @@error
	return @e
END
GO


IF (object_id('p_GetUserToken') is not null)
BEGIN
drop procedure p_GetUserToken
END
GO

CREATE PROCEDURE [dbo].[p_GetUserToken]
	@IsSQLLogin bit,
	@SQLLoginName nvarchar(128),
	@WindowsSID varbinary(85)
AS
BEGIN
	exec [p_GetUserTokenInternal] @IsSQLLogin, @SQLLoginName, @WindowsSID, 0
END

GO
 
GO 

---------- P_GETVIRTUALHOSTSERVERS.SQL
if (object_id('p_GetVirtualHostServers') is not null)
begin
drop procedure [p_GetVirtualHostServers]
end
go

CREATE PROCEDURE [dbo].[p_GetVirtualHostServers](
	@VcHostID int = null
)
AS
BEGIN
	DECLARE @error int

	SELECT [VHostID] as [vcHostID], [VHostName] as [vcName], [VHostAddress] as [vcAddress], [Username] as [vcUser], [Password] as [vcPassword], [ServerType] as [ServerType]
	FROM	[VirtualHostServers] 
	WHERE	(@VcHostID is null or @VcHostID = [VHostID])

	SELECT @error = @@error

	IF @error != 0 GOTO HANDLE_ERROR

	RETURN(0)

	HANDLE_ERROR:
		RAISERROR('An error occurred while retrieving the virtual host information.', 10, 1)
        RETURN(@error)
END
 
GO 

---------- P_GETVIRTUALHOSTSERVERSBYADDRESS.SQL
if (object_id('p_GetVirtualHostServersByAddress') is not null)
begin
drop procedure [p_GetVirtualHostServersByAddress]
end
go

CREATE PROCEDURE [dbo].[p_GetVirtualHostServersByAddress](
	@vcAddress nvarchar(256) = null
)
AS
BEGIN
	DECLARE @error int

	SELECT [VHostID] as [vcHostID], [VHostName] as [vcName], [VHostAddress] as [vcAddress], [Username] as [vcUser], [Password] as [vcPassword]
	FROM	[VirtualHostServers] 
	WHERE	(@vcAddress is null or @vcAddress = [VHostAddress])

	SELECT @error = @@error

	IF @error != 0 GOTO HANDLE_ERROR

	RETURN(0)

	HANDLE_ERROR:
		RAISERROR('An error occurred while retrieving the virtual host information.', 10, 1)
        RETURN(@error)
END
 
GO 

---------- P_GETVIRTUALIZATIONSTATISTICS.SQL
IF (object_id('p_GetVirtualizationStatistics') is not null)
BEGIN
drop procedure p_GetVirtualizationStatistics
END
GO

CREATE procedure [dbo].[p_GetVirtualizationStatistics]
	@SQLServerID int,
	@UTCStart Datetime,
	@UTCEnd Datetime,
	@UTCOffset int = 0,
	@Interval int
AS
BEGIN

SELECT 
      [UTCCollectionDateTime] = dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, vm.[UTCCollectionDateTime]))), 
      [VmName] = max(vmConfig.VMName),
      [EsxHostName] = max(esxConfig.HostName),
      [VmCPUUsage] = ROUND(AVG(vm.CPUUsage), 2), 
      [EsxCPUUsage] = ROUND(AVG(esx.CPUUsage), 2), 
      [VmCPUUsageMHz] = ROUND(AVG(vm.CPUUsageMHz), 2), 
      [EsxCPUUsageMHz] = ROUND(AVG(esx.CPUUsageMHz), 2), 
      [VmCPUReady] = ROUND(AVG(vm.CPUReady), 2),
      [VmCPUSwapWait] = ROUND(AVG(CPUSwapWait), 2), 
      [VmMemUsage] = ROUND(AVG(vm.MemUsage), 2), 
      [EsxMemUsage] = ROUND(AVG(esx.MemUsage), 2), 
      [VmMemSwapInRate] = ROUND(AVG(vm.MemSwapInRate), 2), 
      [EsxMemSwapInRate] = ROUND(AVG(esx.MemSwapInRate), 2), 
      [VmMemSwapOutRate] = ROUND(AVG(vm.MemSwapOutRate), 2), 
      [EsxMemSwapOutRate] = ROUND(AVG(esx.MemSwapOutRate), 2), 
      [VmMemGrantedMB] = ROUND(AVG(vm.MemGranted / 1024), 2), 
      [EsxMemGrantedMB] = ROUND(AVG(esx.MemGranted / 1024), 2), 
      [VmMemBaloonedMB] = ROUND(AVG(vm.MemBalooned / 1024), 2), 
      [EsxMemBaloonedMB] = ROUND(AVG(esx.MemBalooned / 1024), 2), 
      [VmMemActiveMB] = ROUND(AVG(vm.MemActive / 1024), 2), 
      [EsxMemActiveMB] = ROUND(AVG(esx.MemActive / 1024), 2), 
      [VmMemConsumedMB] = ROUND(AVG(vm.MemConsumed / 1024), 2), 
      [EsxMemConsumedMB] = ROUND(AVG(esx.MemConsumed / 1024), 2), 
      [VmDiskRead] = ROUND(AVG(vm.DiskRead), 2), 
      [EsxDiskRead] = ROUND(AVG(esx.DiskRead), 2), 
      [VmDiskWrite] = ROUND(AVG(vm.DiskWrite), 2), 
      [EsxDiskWrite] = ROUND(AVG(esx.DiskWrite), 2), 
      [VmNetReceived] = ROUND(AVG(vm.NetReceived), 2), 
      [EsxNetReceived] = ROUND(AVG(esx.NetReceived), 2), 
      [VmNetTransmitted] = ROUND(AVG(vm.NetTransmitted), 2),
      [EsxNetTransmitted] = ROUND(AVG(esx.NetTransmitted), 2),
      [VmPagePerSec] = ROUND(AVG(vm.PagePerSecVM), 2), 
      [EsxMemPagePerSec] = ROUND(AVG(esx.MemPagePerSec), 2), 
      [VmAvailableByte] = ROUND(AVG(vm.AvailableByteVm), 2), 
      [EsxAvailableMemBytes] = ROUND(AVG(esx.AvailableMemBytes), 2),
	  [ServerType] = max(vhs.ServerType)
FROM VMStatistics vm 
left join MonitoredSQLServers servers on servers.SQLServerID = vm.SQLServerID
left join VirtualHostServers vhs on servers.VHostID = vhs.VHostID
left join VMConfigData vmConfig on (vm.SQLServerID = vmConfig.SQLServerID and vm.UTCCollectionDateTime = vmConfig.UTCCollectionDateTime)
left join ESXStatistics esx on servers.SQLServerID = esx.SQLServerID and vm.UTCCollectionDateTime = esx.UTCCollectionDateTime
left join ESXConfigData esxConfig on (esx.SQLServerID = esxConfig.SQLServerID and esx.UTCCollectionDateTime = esxConfig.UTCCollectionDateTime)
WHERE servers.SQLServerID = @SQLServerID and dbo.fn_RoundDateTime(@Interval, esx.UTCCollectionDateTime) between @UTCStart and @UTCEnd
group by
      vmConfig.VMName,
      case when isnull(@Interval,5) <= 4 then datepart(yy, dateadd(mi, @UTCOffset, vm.[UTCCollectionDateTime])) else 1 end
      ,case when isnull(@Interval,5) <= 3 then datepart(mm,dateadd(mi, @UTCOffset, vm.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, vm.[UTCCollectionDateTime])) end
      ,case when isnull(@Interval,5) <= 2 then datepart(dd,dateadd(mi, @UTCOffset, vm.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, vm.[UTCCollectionDateTime])) end
      ,case when isnull(@Interval,5) <= 1 then datepart(hh,dateadd(mi, @UTCOffset, vm.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, vm.[UTCCollectionDateTime])) end
      ,case when isnull(@Interval,5) =  0 then datepart(mi,dateadd(mi, @UTCOffset, vm.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, vm.[UTCCollectionDateTime])) end

end
 
GO 

---------- P_GETVMCONFIGREPORT.SQL
if (object_id('p_GetVMConfigReport') is not null)
begin
drop procedure [p_GetVMConfigReport]
end
go


create procedure [dbo].[p_GetVMConfigReport]
				@ServerID int
as
begin
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

select top 1 
	a.InstanceName as [SqlInstanceName],
	b.VMName as [VmName], 
	b.DomainName as [VmDomainName], 
	b.NumCPUs as [vCPUs],
	b.MemSize as [VmMemSize],
	case when b.CPULimit < 0 then 'Unlimited' else cast(b.CPULimit as nvarchar(max)) end as [VmCpuLimit],
	b.CPUReserve as [VmCpuReserve],
	case when b.MemLimit < 0 then 'Unlimited' else CAST(b.MemLimit/1024 as nvarchar(max)) end as [VmMemLimit],
	b.MemReserve/1024 as [VmMemReserve],
	c.HostName as [EsxHostName],
	case c.[Status] 
		when 0 then 'Powered On'
		when 1 then 'Powered Off'
		when 2 then 'Standby'
		else 'Unknown'
	end as [EsxStatus],
	case b.[VMHeartBeat] 
		when 0 then 'Powered Off'
		when 1 then 'Powered On'
		when 2 then 'Suspended'
		else 'Unknown'
	end as [VmStatus],
	c.NumCPUCores as[ESXCPUCores],
	c.CPUMHz as [EsxCpuMhz],
	c.MemorySize/1024 as [EsxMemSize],
	c.NumNICs as [EsxNumNics],
	c.BootTime as [EsxBootTime],
	d.ServerType as [ServerType]
from 
	MonitoredSQLServers a 
	left join VMConfigData b 
		on a.SQLServerID = b.SQLServerID 
	left join ESXConfigData c 
		on a.SQLServerID = c.SQLServerID
	left join VirtualHostServers d 
		on a.VHostID = d.VHostID 
where 
	a.SQLServerID = @ServerID
order by 
	b.UTCCollectionDateTime desc
	
end
 
GO 

---------- P_GETVMSUMMARYREPORT.SQL
if (object_id('p_GetVMSummaryReport') is not null)
begin
drop procedure [p_GetVMSummaryReport]
end
go


create procedure [dbo].[p_GetVMSummaryReport]
				@ServerID int,
				@UTCOffset int = null,
				@StartTime DateTime = null,
				@EndTime DateTime = null
as
begin
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

set @EndTime = ISNULL(@EndTime, GetutcDate())
set @UTCOffset = ISNULL(@UTCOffset, datediff(mi, getutcdate(), getdate()))
set @StartTime = ISNULL(@StartTime, CONVERT(CHAR(8),getutcdate(),112))


select
	@ServerID as [ServerID]
	,DATEADD(mi, @UTCOffset, vs.UTCCollectionDateTime) as [LastCollectionInterval]
	,vs.[CPUUsage] as [VmCpuUsage]
	,es.[CPUUsage] as [EsxCpuUsage]
	,vs.[MemUsage] as [VmMemUsage]
	,es.[MemUsage] as [EsxMemUsage]
	,(ISNULL(vs.[DiskRead], 0) + ISNULL(vs.[DiskWrite], 0)) as [VmDiskUsage] 
	,(ISNULL(es.[DiskRead], 0) + ISNULL(es.[DiskWrite], 0)) as [EsxDiskUsage]
	,vs.[NetUsage] as [VmNetUsage]
	,es.[NetUsage] as [EsxNetUsage]
from
	[VMStatistics] vs
	left join [MonitoredSQLServers] ms 
		on vs.SQLServerID = ms.SQLServerID 
	left join [ESXStatistics] es
		on vs.[SQLServerID] = es.[SQLServerID] 
		and vs.[UTCCollectionDateTime] = es.[UTCCollectionDateTime] 
where
	ms.[SQLServerID] = @ServerID
	and ms.[Active] = 1
	and vs.[UTCCollectionDateTime] between @StartTime and @EndTime 
order by
	vs.[UTCCollectionDateTime] 

end

GO

 
GO 

---------- P_GETWAITCATEGORY.SQL
if (object_id('p_GetWaitCategory') is not null)
begin
drop procedure p_GetWaitCategory
end
go
create procedure p_GetWaitCategory
	@WaitType varchar(120),
	@ReturnID int output
as
begin

	declare @WaitCategory nvarchar(120), @WaitCategoryID int

	select @WaitCategory = 
	case
		when @WaitType = 'BAD_PAGE_PROCESS' then 'Excluded' 
		when @WaitType = 'BROKER_EVENTHANDLER' then 'Excluded' 
		when @WaitType = 'BROKER_RECEIVE_WAITFOR' then 'Excluded' 
		when @WaitType = 'BROKER_TASK_STOP' then 'Excluded' 
		when @WaitType = 'BROKER_TO_FLUSH' then 'Excluded' 
		when @WaitType = 'BROKER_TRANSMITTER' then 'Excluded' 
		when @WaitType = 'CHECKPOINT_QUEUE' then 'Excluded' 
		when @WaitType = 'CLR_SEMAPHORE' then 'Excluded' 
		when @WaitType = 'DBMIRROR_EVENTS_QUEUE' then 'Excluded' 
		when @WaitType = 'KSOURCE_WAKEUP' then 'Excluded' 
		when @WaitType = 'LAZYWRITER_SLEEP' then 'Excluded' 
		when @WaitType = 'LOGMGR_QUEUE' then 'Excluded' 
		when @WaitType = 'MISCELLANEOUS' then 'Excluded' 
		when @WaitType = 'ONDEMAND_TASK_QUEUE' then 'Excluded' 
		when @WaitType = 'REQUEST_FOR_DEADLOCK_SEARCH' then 'Excluded' 
		when @WaitType = 'RESOURCE_QUEUE' then 'Excluded' 
		when @WaitType = 'SLEEP_SYSTEMTASK' then 'Excluded' 
		when @WaitType = 'SLEEP_TASK' then 'Excluded' 
		when @WaitType = 'SQLTRACE_BUFFER_FLUSH' then 'Excluded' 
		when @WaitType = 'WAITFOR'  then 'Excluded' 
		when @WaitType = 'CHKPT' then 'Excluded'
		when @WaitType = 'FT_IFTS_SCHEDULER_IDLE_WAIT' then 'Excluded'
		when @WaitType = 'ASYNC_IO_COMPLETION' then 'I/O'
		when @WaitType = 'CXPACKET' then 'Other'
		when @WaitType = 'EXCHANGE' then 'Other'
		when @WaitType = 'PAGESUPP' then 'Other'
		when @WaitType = 'ASYNC_DISKPOOL_LOCK' then 'Other'
		when @WaitType = 'CURSOR' then 'Other'
		when @WaitType = 'PSS_CHILD' then 'Cursor'
		when @WaitType = 'DISKIO_SUSPEND' then 'Backup'
		when @WaitType = 'IO_COMPLETION' then 'I/O'
		when @WaitType = 'LOGBUFFER' then 'Transaction Log'
		when @WaitType = 'LOGMGR' then 'Transaction Log'
		when @WaitType = 'RESOURCE_QUERY_SEMAPHORE_COMPILE' then 'Query Compilation'
		when @WaitType = 'RESOURCE_SEMAPHORE' then 'Memory'
		when @WaitType = 'TEMPOBJ' then 'Other'
		when @WaitType = 'SOS_RESERVEDMEMBLOCKLIST' then 'Memory'
		when @WaitType = 'SOS_SCHEDULER_YIELD' then 'Other'
		when @WaitType = 'THREADPOOL' then 'Other'
		when @WaitType = 'WRITELOG' then 'Transaction Log'
		when @WaitType = 'XE_DISPATCHER_WAIT' then 'Excluded'
		when @WaitType = 'XE_TIMER_EVENT' then 'Excluded'
		when @WaitType = 'CMEMTHREAD' then 'Memory'
		when @WaitType = 'XACTLOCKINFO' then 'Lock'
		when @WaitType = 'ASYNC_DISKPOOL_LOCK' then 'I/O'
		when @WaitType = 'ASYNC_NETWORK_IO ' then 'Other'
		when @WaitType = 'BACKUP' then 'Backup'
		when @WaitType = 'FILESTREAM_WORKITEM_QUEUE' then 'Excluded'
		when @WaitType = 'SP_SERVER_DIAGNOSTICS_SLEEP' then 'Excluded'
		when @WaitType = 'DISPATCHER_QUEUE_SEMAPHORE' then 'Excluded'
		when @WaitType = 'FT_IFTSHC_MUTEX' then 'Excluded'
		when @WaitType like 'BACKUP%' then 'Backup'
		when @WaitType like 'XE_%' then 'Other'
		when @WaitType like 'SLEEP%' then 'Other'
		when @WaitType like 'PREEMPTIVE_%' then 'Other'
		when @WaitType like 'RESOURCE_SEMAPHORE%' then 'Memory'
		when @WaitType like 'LCK_%' then 'Lock'	
		when @WaitType like 'LATCH%' then 'Non-Page Latch'
		when @WaitType like 'PAGEIOLATCH%' then 'I/O'
		when @WaitType like 'TRAN_MARKLATCH%' then 'Non-Page Latch'
		when @WaitType like 'PAGELATCH%' then 'Non-I/O Page Latch'
		when @WaitType like 'BROKER%' then 'Other'
		else 'Other'
	end

	select @WaitCategoryID = CategoryID
	from [WaitCategories]
	where [Category] = @WaitCategory

	if @WaitCategoryID is null
	begin
		insert into [WaitCategories]
		(
			[Category]
		)
		values
		(
			@WaitCategory
		)

		select @WaitCategoryID = CategoryID
		from [WaitCategories]
		where [Category] = @WaitCategory
	end

	select @ReturnID = @WaitCategoryID

end
 
GO 

---------- P_GETWAITSBYINSTANCES.SQL
IF (object_id('p_GetWaitsByInstance') is not null)
BEGIN
drop procedure p_GetWaitsByInstance
END
GO

/*-- 
SQLdm 8.5 (Gaurav Karwal): for Top X API- Get Waits by Instance
EXEC  p_GetWaitsByInstance 10
--*/

CREATE PROCEDURE [dbo].p_GetWaitsByInstance
	@TopX int=NULL
AS
BEGIN

	IF @TopX IS NOT null AND @TopX > 0
		SET ROWCOUNT @TopX;	
	
	WITH MaxCollTimes(SQLServerID, UTCCollectionDateTime) AS 
	(SELECT ws.SQLServerID, MAX(ws.UTCCollectionDateTime) FROM WaitStatistics ws (NOLOCK) GROUP BY ws.SQLServerID)	
	SELECT MS.SQLServerID,
		MS.InstanceName,
		WD.WaitTypeID,
		WD.WaitTimeInMilliseconds,
		WT.WaitType,
		A.ApplicationName, 
		WS.UTCCollectionDateTime, 
		WS.TimeDeltaInSeconds
	 FROM WaitStatistics WS (NOLOCK)
	 JOIN WaitStatisticsDetails WD (NOLOCK) ON WD.[WaitStatisticsID] = WS.[WaitStatisticsID]
	 JOIN MonitoredSQLServers MS (NOLOCK) ON MS.SQLServerID = WS.SQLServerID
     JOIN ApplicationNames A (NOLOCK) ON WD.[WaitingTasks] = A.ApplicationNameID
     JOIN WaitTypes WT (NOLOCK) ON WD.WaitTypeID = WT.WaitTypeID 
     INNER JOIN MaxCollTimes mct (NOLOCK) ON mct.SQLServerID = WS.SQLServerID AND mct.UTCCollectionDateTime = WS.UTCCollectionDateTime
	 WHERE MS.Active = 1
	ORDER BY WD.WaitTimeInMilliseconds DESC
END
 
GO 

---------- P_GETWAITSTATISTICS.SQL
if (object_id('p_GetWaitStatistics') is not null)
begin
drop procedure p_GetWaitStatistics
end
go
create procedure p_GetWaitStatistics
	@SQLServerID int,
	@UTCSnapshotCollectionDateTime datetime = null,
	@HistoryInMinutes int = null,
	@CategoryName varchar(120) = null
as
begin
set transaction isolation level read uncommitted
declare @err int
declare @BeginDateTime datetime
declare @EndDateTime datetime

if (@UTCSnapshotCollectionDateTime is null)
	select @EndDateTime = (select max(UTCCollectionDateTime) from [WaitStatistics] (NOLOCK) where [SQLServerID] = @SQLServerID)
else
	select @EndDateTime = @UTCSnapshotCollectionDateTime

if (@HistoryInMinutes is null)
	select @BeginDateTime = @EndDateTime
else
	select @BeginDateTime = dateadd(n, -@HistoryInMinutes, @EndDateTime)

select
	[UTCCollectionDateTime]
	,[WaitType]
	,[Category]
	,[WaitingTasks]
	,[WaitTimeInMilliseconds]
	,[MaxWaitTimeInMilliseconds]
	,[ResourceWaitTimeInMilliseconds]
	,[SignalWaitTimeInMilliseconds] = [WaitTimeInMilliseconds] - [ResourceWaitTimeInMilliseconds]
	,[WaitingTasksPerSecond] = cast([WaitingTasks] as float) / nullif([TimeDeltaInSeconds],0)
	,[TotalWaitMillisecondsPerSecond] = [WaitTimeInMilliseconds] / nullif([TimeDeltaInSeconds],0)
	,[SignalWaitMillisecondsPerSecond] = cast(([WaitTimeInMilliseconds] - [ResourceWaitTimeInMilliseconds]) as float) / nullif([TimeDeltaInSeconds],0)
	,[ResourceWaitMillisecondsPerSecond] = cast([ResourceWaitTimeInMilliseconds] as float) / nullif([TimeDeltaInSeconds],0)
	,wt.Description
	,wt.HelpLink
from	
	[WaitStatistics] ws (NOLOCK)
	left join 
	[WaitStatisticsDetails] wsd (NOLOCK)
	on ws.[WaitStatisticsID]  = wsd.[WaitStatisticsID]
	inner join [WaitTypes] wt (NOLOCK)
	on wsd.[WaitTypeID] = wt.[WaitTypeID]
	inner join [WaitCategories] wc (NOLOCK)
	on wt.[CategoryID] = wc.[CategoryID]
where 
	ws.[SQLServerID] = @SQLServerID
	and wsd.[WaitStatisticsID] is not null
	and ws.[UTCCollectionDateTime] > @BeginDateTime 
	and ws.[UTCCollectionDateTime] <= @EndDateTime
	and wc.[Category] = isnull(@CategoryName,wc.[Category])



select @err = @@error
return @err
end
 
GO 

---------- P_GETWEBAPPLICATIONUSER.SQL
IF (OBJECT_ID('p_GetWebApplicationUser') IS NOT NULL)
BEGIN
DROP PROCEDURE p_GetWebApplicationUser
END
GO
--p_GetWebApplicationUser 'FREEDOM\admin'
CREATE PROCEDURE p_GetWebApplicationUser
@LoginName NVARCHAR(500)
AS
BEGIN
	DECLARE @LoginFullName NVARCHAR(500);
	DECLARE @AppSec TABLE(AppEnabled INT);
	DECLARE @IsAppSecEnabled INT;
	SET @LoginFullName = '';
	
	INSERT INTO @AppSec EXEC p_IsAppSecEnabled;
	SELECT @IsAppSecEnabled = ISNULL(AppEnabled,0) FROM @AppSec;
	
	SELECT @LoginFullName = CASE WHEN CHARINDEX('/',@LoginName) > 0 THEN @LoginName
								 ELSE CASE WHEN CHARINDEX('\',@LoginName) > 0 THEN 
										@LoginName
									  ELSE
										HOST_NAME() + '\' + @LoginName
									  END
								END
	IF @LoginName IS NOT NULL
  	BEGIN
  		DECLARE @SID VARBINARY(85),@IsWebAppAccessGranted INT;
  		IF @IsAppSecEnabled = 0	
  		BEGIN
  			SELECT TOP 1 Name, [Type],Type_Desc, SID, Principal_ID,IS_SRVROLEMEMBER('sysadmin',Name) IsSysAdmin 
  			FROM sys.server_principals SP (NOLOCK) WHERE is_disabled = 0 AND LOWER(NAME) COLLATE DATABASE_DEFAULT = LOWER(@LoginFullName) COLLATE DATABASE_DEFAULT AND [Type] IN ('U','G');
  		END
  		ELSE IF @IsAppSecEnabled = 1
  		BEGIN
  			--getting the sid for the user
  			SELECT @SID = [SID]
  			FROM sys.server_principals SP (NOLOCK) WHERE is_disabled = 0 AND LOWER(NAME) COLLATE DATABASE_DEFAULT = LOWER(@LoginFullName) COLLATE DATABASE_DEFAULT AND [Type] IN ('U','G');
  			
  			IF((SELECT COUNT(0) FROM Permission WHERE LoginSID = @SID) > 0)
  			BEGIN
  				SELECT @IsWebAppAccessGranted = ISNULL(WebAppPermission,0) FROM Permission (NOLOCK) WHERE LoginSID = @SID AND [Enabled] = 1 ;
  				IF @IsWebAppAccessGranted = 1
				BEGIN
					SELECT TOP 1 Name, [Type],Type_Desc, [SID], Principal_ID,IS_SRVROLEMEMBER('sysadmin',Name) IsSysAdmin 
  					FROM sys.server_principals SP (NOLOCK) WHERE is_disabled = 0 AND LOWER(NAME) COLLATE DATABASE_DEFAULT = LOWER(@LoginFullName) COLLATE DATABASE_DEFAULT AND [Type] IN ('U','G');	  			
  				END									  			
  			END
  			ELSE
  			BEGIN
  				SELECT TOP 1 Name, [Type],Type_Desc, SID, Principal_ID,IS_SRVROLEMEMBER('sysadmin',Name) IsSysAdmin 
  				FROM sys.server_principals SP (NOLOCK) WHERE is_disabled = 0 AND LOWER(NAME) COLLATE DATABASE_DEFAULT = LOWER(@LoginFullName) COLLATE DATABASE_DEFAULT AND [Type] IN ('U','G');	
  			END		
  			
  			
  			
  		END
  		
  		
  		--checking if a principal exists in user or group role
  		--SELECT TOP 1 Name, [Type],Type_Desc, SID, Principal_ID,IS_SRVROLEMEMBER('sysadmin',Name) IsSysAdmin 
  		--	FROM sys.server_principals SP 
  		--	LEFT OUTER JOIN Permission P ON SP.[SID] collate database_default = P.LoginSID collate database_default WHERE P.[Enabled ]= 1
  		--	AND is_disabled = 0 AND LOWER(NAME) COLLATE DATABASE_DEFAULT = LOWER(@LoginFullName) COLLATE DATABASE_DEFAULT AND [Type] IN ('U','G')
  		
  	END  	
END
 
GO 

---------- P_GETWIDGETSOFDASHBOARD.SQL
if (object_id('p_GetWidgetsofDashboard') is not null)
begin
drop procedure [p_GetWidgetsofDashboard]
end
go

create procedure [p_GetWidgetsofDashboard] 

@dashboardId int
AS
BEGIN
	
	declare @e int
	
	BEGIN TRANSACTION
	
	SET @e = @@error
	IF (@e = 0)
	BEGIN

	DECLARE @match int;
	SELECT @match = 0;

	SELECT widget.[WidgetID]
      ,[WidgetName]
      ,[WidgetTypeID]
      ,[MetricID]
      ,[MatchId]
      ,(SELECT STUFF((SELECT ', ' + CAST([TagId] AS VARCHAR(10)) [text()]
         FROM [WidgetTagMapping] 
         WHERE [WidgetID] = wtm.[WidgetID]
         FOR XML PATH(''), TYPE)
        .value('.','NVARCHAR(MAX)'),1,2,' ') List_Output
		FROM [WidgetTagMapping] wtm
		GROUP BY [WidgetID]
		HAVING widget.[WidgetID] = [WidgetID]) AS TagIds
      ,[RecordCreatedTimestamp]
      ,[RecordUpdateDateTimestamp]	
	  

	-- Get comma saparated surce ids. Depending upon MatchId
      ,
	  (CASE [MatchId]
      WHEN 4 THEN 
	  (SELECT STUFF((SELECT ', ' + CAST([SQLServerID] AS VARCHAR(10))[text()] FROM [MonitoredSQLServers] 
	  WHERE [Active] = 1 AND [Deleted] = 0 
	  FOR XML PATH(''), TYPE)
        .value('.','NVARCHAR(MAX)'),1,2,' ') List_Output
		) 
		ELSE
	  (SELECT STUFF((SELECT ', ' + CAST([SourceServerID] AS VARCHAR(10)) [text()]
         FROM [WidgetSourceMapping] 
         WHERE [WidgetID] = wsm.[WidgetID]
         FOR XML PATH(''), TYPE)
        .value('.','NVARCHAR(MAX)'),1,2,' ') List_Output
		FROM [WidgetSourceMapping] wsm
		GROUP BY [WidgetID]
		HAVING widget.[WidgetID] = [WidgetID]) 
		END) AS SourceIds
		  FROM [dbo].[CustomDashboardWidgets] as widget
		WHERE [DashboardID] = @dashboardId
	
	END
	IF (@e = 0)
		COMMIT
	ELSE
		ROLLBACK		

	return @e

END
 
GO 
 
GO 

---------- P_GETWIDGETTYPES.SQL
if (object_id('p_GetWidgetTypes') is not null)
begin
drop procedure [p_GetWidgetTypes]
end
go

create procedure [p_GetWidgetTypes] 

AS
BEGIN
	declare @e int
	
	BEGIN TRANSACTION
	
	SET @e = @@error
	IF (@e = 0)
	BEGIN
		-- check if records for UserSID
		SELECT [WidgetTypeID]
		,[WidgetType]
		FROM [dbo].[CustomDashboardWidgetTypes]
	
	END
	
	IF (@e = 0)
		COMMIT
	ELSE
		ROLLBACK		

	return @e

END
 
GO 
 
GO 

---------- P_GROOMACTIVEWAITSTATISTICS.SQL
if (object_id('Grooming.p_GroomActiveWaitStatistics') is not null)
begin
drop procedure Grooming.p_GroomActiveWaitStatistics
end
go
create procedure [Grooming].[p_GroomActiveWaitStatistics]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (StatementUTCStartTime datetime not null primary key)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'ActiveWaitStatistics'
	
if (@SQLServerID is not null)
begin

	set @cmd = N'Declare @KeysToDelete Table (StatementUTCStartTime datetime not null primary key)

			Insert Into @KeysToDelete
			Select Distinct dt.StatementUTCStartTime
			From (Select Top(@RecordsToDelete) StatementUTCStartTime
				From dbo.ActiveWaitStatistics with(nolock)
				Where SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And StatementUTCStartTime <= @CutoffDateTimeIn'
				Else N''
				End + N') As dt;
		
			-- This will cause a cascade delete in DeadlockProcesses
			Delete AWS
			From dbo.ActiveWaitStatistics AWS
			Inner Join @KeysToDelete K
				On K.StatementUTCStartTime = AWS.StatementUTCStartTime';
	set @parms = N'@SQLServerIDIn int,@CutoffDateTimeIn datetime,@RecordsToDelete int'	
				
					
	if @Deleted = 1
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
		
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Distinct dt.StatementUTCStartTime
			From (Select Top(@RecordsToDelete) StatementUTCStartTime
				From dbo.ActiveWaitStatistics with(nolock)
				Where StatementUTCStartTime <= @CutoffDateTime) As dt;
		
			-- This will cause a cascade delete in DeadlockProcesses
			Delete AWS
			From dbo.ActiveWaitStatistics AWS
			Inner Join @KeysToDelete K
				On K.StatementUTCStartTime = AWS.StatementUTCStartTime;
		
		end
		else
		begin
			exec sp_executesql @cmd, @parms, @SQLServerIDIn = @SQLServerID, @CutoffDateTimeIn = @CutoffDateTime, @RecordsToDelete = @RecordsToDelete;
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end


 
GO 

---------- P_GROOMALERTS.SQL
if (object_id('Grooming.p_GroomAlerts') is not null)
begin
drop procedure Grooming.p_GroomAlerts
end
go
create procedure [Grooming].[p_GroomAlerts]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (AlertID int not null primary key)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'Alerts'
	
if (@SQLServerID is not null)
begin
	Set @cmd = N'Declare @KeysToDelete Table (AlertID int not null primary key)

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) AlertID
			From dbo.Alerts with(nolock)
			Where ServerName = @SQLServerNameIn' +
				Case When @Deleted = 0 Then N'
				And UTCOccurrenceDateTime <= @CutoffDateTime'
				Else N''
				End + N';
		
			Delete A
			From dbo.Alerts A
			Where Exists (Select 1 From @KeysToDelete
						Where AlertID = A.AlertID);';
	set @parms = N'@SQLServerNameIn nvarchar(256),@CutoffDateTimeIn datetime,@RecordsToDelete int'	
				
					
	if @Deleted = 1
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) AlertID
			From dbo.Alerts with(nolock)
			Where UTCOccurrenceDateTime <= @CutoffDateTime;
		
			Delete A
			From dbo.Alerts A
			Where Exists (Select 1 From @KeysToDelete
						Where AlertID = A.AlertID);
	
		end
		else
		begin
			if (@SQLServerID < 0)
			begin
				Delete From @KeysToDelete;

				Insert Into @KeysToDelete
				Select Top(@RecordsToDelete) AlertID
				From dbo.Alerts with(nolock)
				Where UTCOccurrenceDateTime <= @CutoffDateTime
				And ServerName Is Null;
		
				Delete A
				From dbo.Alerts A
				Where Exists (Select 1 From @KeysToDelete
							Where AlertID = A.AlertID);
			end
			else
			begin
				exec sp_executesql @cmd, @parms, @SQLServerNameIn=@InstanceName,@CutoffDateTimeIn= @CutoffDateTime,@RecordsToDelete = @RecordsToDelete;
			end
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMALWAYSONAVAILABILITYGROUPTOPOLOGYXML.SQL

------------------------------------------------------------------------------
-- <copyright file="p_GroomAlwaysOnAvailabilityGroupTopologyXml.sql" company="Idera, Inc.">
--     Copyright (c) Idera, Inc. All rights reserved.
-- </copyright>
------------------------------------------------------------------------------
if (object_id('p_GroomAlwaysOnAvailabilityGroupTopologyXml') is not null)
begin
    drop procedure p_GroomAlwaysOnAvailabilityGroupTopologyXml
end
go
create procedure [dbo].p_GroomAlwaysOnAvailabilityGroupTopologyXml
as
begin
    -- Nolock transactions.
    set transaction isolation level read uncommitted

    -- Indicate which registeers will be deleted.
    declare @registersToDelete table (
        [GroupId] uniqueidentifier,
        [GroupName] sysname,
        [IsActive] int,
        [IsDelete] int
    )

    -- Get summary for the registers to delete.
    insert into @registersToDelete
    select 
            [Groups].[GroupId],
            [Groups].[GroupName],
            sum(convert(int, [Groups].[Active])) as [IsActive],
            sum(convert(int, [Groups].[Delete])) as [IsDelete]
        from [AlwaysOnAvailabilityGroups] as [Groups]
    group by 
        [Groups].[GroupId],
        [Groups].[GroupName]

    -- Iterate througth the table to set [Delete] = 0
    declare @groupIdCursor uniqueidentifier
    declare @isActive int
    declare @isDelete int
    set rowcount 0
    select 1 from @registersToDelete
    set rowcount 1

    -- Get cursor
    select @groupIdCursor = [GroupId] from @registersToDelete
    select @isActive = [IsActive] from @registersToDelete
    select @isDelete = [IsDelete] from @registersToDelete

    while @@rowcount <> 0
    begin
        set rowcount 0

        if @isActive = 0 and @isDelete = 0
        begin
            -- Update Delete column.
            update [AlwaysOnAvailabilityGroups]
                set
                    [Delete] = 1
            where
                [GroupId] = @groupIdCursor
        end

        delete from @registersToDelete where [GroupId] = @groupIdCursor
        set rowcount 1
        select @groupIdCursor = [GroupId] from @registersToDelete
        select @isActive = [IsActive] from @registersToDelete
        select @isDelete = [IsDelete] from @registersToDelete
    end

    set rowcount 0

    -- Call SP in order to update the Replicas topology.
    exec dbo.p_GroomAlwaysOnAvailabilityReplicaTopologyXml

    return null
end
 
GO 

---------- P_GROOMALWAYSONAVAILABILITYREPLICATOPOLOGYXML.SQL

------------------------------------------------------------------------------
-- <copyright file="p_GroomAlwaysOnAvailabilityReplicaTopologyXml.sql" company="Idera, Inc.">
--     Copyright (c) Idera, Inc. All rights reserved.
-- </copyright>
------------------------------------------------------------------------------
if (object_id('p_GroomAlwaysOnAvailabilityReplicaTopologyXml') is not null)
begin
    drop procedure p_GroomAlwaysOnAvailabilityReplicaTopologyXml
end
go
create procedure [dbo].p_GroomAlwaysOnAvailabilityReplicaTopologyXml
as
begin
    -- Nolock transactions.
    set transaction isolation level read uncommitted

    -- Indicate which registeers will be deleted.
    declare @registersToDelete table (
        [ReplicaId] uniqueidentifier,
        [ReplicaName] sysname,
        [IsActive] int,
        [IsDelete] int
    )

    -- Get summary for the registers to delete.
    insert into @registersToDelete
        select
            [Replicas].[ReplicaId],
            [Replicas].[ReplicaName],
            sum(convert(int, [Replicas].[Active])) as [IsActive],
            sum(convert(int, [Replicas].[Delete])) as [IsDelete]
        from [AlwaysOnReplicas] as [Replicas]
    group by 
        [Replicas].[ReplicaId],
        [Replicas].[ReplicaName]

    -- Iterate througth the table to set [Delete] = 1
    declare @replicaIdCursor uniqueidentifier
    declare @isActive int
    declare @isDelete int
    set rowcount 0
    select 1 from @registersToDelete
    set rowcount 1

    -- Get cursor
    select @replicaIdCursor = [ReplicaId] from @registersToDelete
    select @isActive = [IsActive] from @registersToDelete
    select @isDelete = [IsDelete] from @registersToDelete

    while @@rowcount <> 0
    begin
        set rowcount 0

        if @isActive = 0 and @isDelete = 0
        begin
            -- Update [Delete] column.
            update [AlwaysOnReplicas]
                set
                    [Delete] = 1
            where
                [ReplicaId] = @replicaIdCursor
        end

        delete from @registersToDelete where [ReplicaId] = @replicaIdCursor
        set rowcount 1
        select @replicaIdCursor = [ReplicaId] from @registersToDelete
        select @isActive = [IsActive] from @registersToDelete
        select @isDelete = [IsDelete] from @registersToDelete
    end

    set rowcount 0

    -- Goes through the table to get the inactive monitored SQL Servers for replicas.
    declare @inactiveMonitoredSQLServers table (
        [ReplicaTopologyId] bigint,
        [SQLServerID] int,
        [ServerSourceName] sysname,
        [ReplicaName] nvarchar(256)
    )

    -- Get all references for inactive monitored SQL Servers on [AlwaysOnReplicas].
    insert into @inactiveMonitoredSQLServers
    select
            [Replicas].[ReplicaTopologyId],
            [Replicas].[SQLServerID],
            [Replicas].[ServerSourceName],
            [Replicas].[ReplicaName]
        from [AlwaysOnReplicas] as [Replicas] 
            join [MonitoredSQLServers] as [SQLServers] on [Replicas].[SQLServerID] = [SQLServers].[SQLServerID]
            and [Replicas].[Active] = 1 and [SQLServers].[Deleted] = 1

    -- Get the cursor for [@inactiveMonitoredSQLServers]
    declare @replicaTopologyId bigint
    set rowcount 1
    select @replicaTopologyId = [ReplicaTopologyId] from @inactiveMonitoredSQLServers

    while @@rowcount <> 0
    begin
        set rowcount 0

        if @replicaTopologyId is not null
        begin
            -- Proced to update SQLServerId
            update [AlwaysOnReplicas]
                set
                    [SQLServerID] = -1
            where
                [ReplicaTopologyId] = @replicaTopologyId
        end

        delete @inactiveMonitoredSQLServers where [ReplicaTopologyId] = @replicaTopologyId
        set rowcount 1
        select @replicaTopologyId = [ReplicaTopologyId] from @inactiveMonitoredSQLServers
    end

    set rowcount 0

    return null
end
 
GO 

---------- P_GROOMALWAYSONDATABASETOPOLOGYXML.SQL

------------------------------------------------------------------------------
-- <copyright file="p_GroomAlwaysOnDatabaseTopologyXml.sql" company="Idera, Inc.">
--     Copyright (c) Idera, Inc. All rights reserved.
-- </copyright>
------------------------------------------------------------------------------
if (object_id('p_GroomAlwaysOnDatabaseTopologyXml') is not null)
begin
    drop procedure p_GroomAlwaysOnDatabaseTopologyXml
end
go
create procedure [dbo].p_GroomAlwaysOnDatabaseTopologyXml(
    @DatabaseItemsXml xml
)
as
begin
    -- Nolock transactions.
    set transaction isolation level read uncommitted

    declare @temporalTopologyTable table (
        AlwaysOnDatabaseId int,
        ReplicaId uniqueidentifier,
        GroupId uniqueidentifier,
        GroupDatabaseId uniqueidentifier,
        DatabaseId int,
        DatabaseName nvarchar(128),
        ServerSourceName sysname
    )

    -- Convert the XML document in a data model representation.
    declare @status int
    declare @docpointer int
    exec @status = sp_xml_preparedocument @docpointer output, @DatabaseItemsXml

    -- @status 0 (success) or >0 (failure)
    if @status = 0
    begin
        -- Fill temporal table
        insert into @temporalTopologyTable
        select * from openxml (@docpointer, '//DatabaseItems/AlwaysOnDatabase', 0)
        with(
            AlwaysOnDatabaseId int 'AlwaysOnDatabaseId',
            ReplicaId uniqueidentifier 'ReplicaId',
            GroupId uniqueidentifier 'GroupId',
            GroupDatabaseId uniqueidentifier 'GroupDatabaseId',
            DatabaseId int 'DatabaseId',
            DatabaseName nvarchar(128) 'DatabaseName',
            ServerSourceName sysname 'ServerSourceName'
            )

        -- Get all nodes on which is perfomr the grooming.
        declare @nodesSubSet table (
            ServerSourceName sysname
        )

        insert into @nodesSubSet
        select distinct [@temporalTopologyTable].[ServerSourceName] from @temporalTopologyTable

        -- Process XML
        declare @registersToRemove table (
            AlwaysOnDatabasesID bigint,
            DatabaseName nvarchar(128),
            ServerSourceName sysname
            )

        -- Get the registers to set delete.
        insert into @registersToRemove
        select [Databases].[AlwaysOnDatabasesID], [Databases].[DatabaseName], [Databases].[ServerSourceName]
            from [dbo].[AlwaysOnDatabases] as [Databases]
            left outer join @temporalTopologyTable on [Databases].[GroupId] = [@temporalTopologyTable].[GroupId]
                and [Databases].[ReplicaId] = [@temporalTopologyTable].[ReplicaId]
                and [Databases].[DatabaseID] = [@temporalTopologyTable].[DatabaseId]
                and [Databases].[ServerSourceName] = [@temporalTopologyTable].[ServerSourceName]
            left join @nodesSubSet on [@nodesSubSet].[ServerSourceName] = [Databases].[ServerSourceName]
        where ([Databases].[DatabaseID] <> [@temporalTopologyTable].[DatabaseId]
            or [@temporalTopologyTable].[DatabaseId] is null or [Databases].[DatabaseID] is null)
            and ([@nodesSubSet].[ServerSourceName] = [Databases].[ServerSourceName])
            and [Databases].[Delete] = 0

        -- Declare the cursor.
        declare @alwaysOnDatabaseCursor int
        set rowcount 0
        select 1 from @registersToRemove
        set rowcount 1

        select @alwaysOnDatabaseCursor = AlwaysOnDatabasesID from @registersToRemove

        -- Goes through all registers to set inactive.
        while @@rowcount <> 0
        begin
            set rowcount 0
            -- Get the database id for a row.
            declare @alwaysOnDatabaseId int
            select @alwaysOnDatabaseId = AlwaysOnDatabasesID from @registersToRemove

            if exists(select 1 from [dbo].[AlwaysOnDatabases]
                        where AlwaysOnDatabasesID = @alwaysOnDatabaseId)
            begin
                -- Update [Delete] field.
                update [dbo].[AlwaysOnDatabases]
                    set
                        [Delete] = 1
                where AlwaysOnDatabasesID = @alwaysOnDatabaseId
            end

            delete @registersToRemove where AlwaysOnDatabasesID = @alwaysOnDatabaseId

            set rowcount 1
            select @alwaysOnDatabaseId = AlwaysOnDatabasesID from @registersToRemove
        end

        set rowcount 0

    end
    else
    begin
        -- An error occurred
        select @DatabaseItemsXml
    end

    return @status
end
 
GO 

---------- P_GROOMALWAYSONSTATISTICS.SQL
if (object_id('Grooming.p_GroomAlwaysOnStatistics') is not null)
begin
drop procedure Grooming.p_GroomAlwaysOnStatistics
end
go
create procedure [Grooming].[p_GroomAlwaysOnStatistics]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (AlwaysOnStatisticsID bigint not null primary key)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'AlwaysOnStatistics'
	
if (@SQLServerID is not null)
begin
	Set @cmd = N'Declare @KeysToDelete Table (AlwaysOnStatisticsID bigint not null primary key)
			
			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) aos.AlwaysOnStatisticsID
			From dbo.AlwaysOnStatistics aos with(nolock)
			Inner Join SQLServerDatabaseNames dn on aos.DatabaseId = dn.DatabaseID
			Where aos.SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And aos.UTCCollectionDateTime <= @CutoffDateTimeIn'
				Else N''
				End + N';
		
			Delete AOS
			From dbo.AlwaysOnStatistics AOS
			Inner Join @KeysToDelete K
				On K.AlwaysOnStatisticsID = AOS.AlwaysOnStatisticsID;';
	set @parms = N'@SQLServerIDIn int,@CutoffDateTimeIn datetime,@RecordsToDelete int'	
				
					
	if @Deleted = 1
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin

			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) AlwaysOnStatisticsID
			From dbo.AlwaysOnStatistics with(nolock)
			Where UTCCollectionDateTime <= @CutoffDateTime;
		
			Delete AOS
			From dbo.AlwaysOnStatistics AOS
			Inner Join @KeysToDelete K
				On K.AlwaysOnStatisticsID = AOS.AlwaysOnStatisticsID;
		end
		else
		begin
			exec sp_executesql @cmd, @parms, @SQLServerIDIn = @SQLServerID,@CutoffDateTimeIn = @CutoffDateTime,@RecordsToDelete = @RecordsToDelete;
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMAPPLICATIONNAMES.SQL
if (object_id('Grooming.p_GroomApplicationNames') is not null)
begin
drop procedure Grooming.p_GroomApplicationNames
end
go
create procedure [Grooming].[p_GroomApplicationNames]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'ApplicationNames'		
		


if (GetUTCDate() > @TimeoutTime)           
	raiserror (N'Timeout in %s', 11, 1,@BlockName);
	
       
begin try
	create table #AllList(ApplicationNameID int primary key clustered)
	insert into #AllList
		select ApplicationNameID 
		from ApplicationNames
	
	create table #KeepList(ApplicationNameID int primary key clustered)
	insert into	#KeepList(ApplicationNameID)
		select ApplicationNameID
		from dbo.ActiveWaitStatistics
		where ApplicationNameID is not null
		union 
		select ApplicationNameID
		from dbo.QueryMonitorStatistics
		where ApplicationNameID is not null
		union 
		select ApplicationNameID
		from dbo.DeadlockProcesses
		where ApplicationNameID is not null
		union 
		select ApplicationNameID
		from dbo.BlockingSessionStatistics
		where ApplicationNameID is not null
		union  
		select ApplicationNameID
		from dbo.QuerySignatureAggregation
		where ApplicationNameID is not null	
		
	create table #DeleteList(ApplicationNameID int primary key clustered, deleteGroup int default(0))
	insert into	
		#DeleteList (ApplicationNameID)
		select allList.ApplicationNameID
		from #AllList allList
		left outer merge join #KeepList keepList
		on allList.ApplicationNameID = keepList.ApplicationNameID 
		where keepList.ApplicationNameID is null 

	
	drop table #AllList	
	drop table #KeepList
	
	select count(*) from #DeleteList
	
end try
begin catch

	set @ErrorMessage = @BlockName + ERROR_MESSAGE()
	exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, null

end catch
	
  
declare @deleteGroup int
declare @msg nvarchar(2048)
set @deleteGroup = 0
set @RowsAffected = @RecordsToDelete
	
if (select count(*) from #DeleteList) > 0
		begin		
	while @RowsAffected > 0
	begin

	begin try

		set @deleteGroup = @deleteGroup + 1

		update top (@RecordsToDelete) #DeleteList
		set deleteGroup = @deleteGroup
		where deleteGroup = 0
		
		if @@rowcount = 0
		begin
			select @deleteGroup = min(deleteGroup) from #DeleteList
			if @deleteGroup is not null
				begin
					set @msg = 'Retrying Group ' + cast(@deleteGroup as nvarchar(10)) 
					exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@msg, @RC, null
				end
		end
		
		delete top (@RecordsToDelete) appnames
		from	
			dbo.ApplicationNames appnames 
			inner merge join #DeleteList d 
			on appnames.ApplicationNameID = d.ApplicationNameID
		where
			d.deleteGroup = @deleteGroup
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
			
		delete from #DeleteList 
			where deleteGroup = @deleteGroup
			
	end try
	begin catch

		if	error_number() = 547
		begin
			
			set @msg = error_message();
			
			if @msg like '%ActiveWait%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.ActiveWaitStatistics aws on
							d.ApplicationNameID = aws.ApplicationNameID;
			
			if @msg like '%QueryMonitor%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.QueryMonitorStatistics qms on
							d.ApplicationNameID = qms.ApplicationNameID;
			
			if @msg like '%DeadlockProcesses%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.DeadlockProcesses dp on
							d.ApplicationNameID = dp.ApplicationNameID;
			
			if @msg like '%BlockingSession%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.BlockingSessionStatistics bss on
							d.ApplicationNameID = bss.ApplicationNameID;
		
			if @msg like '%QuerySignature%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.QuerySignatureAggregation qsa on
							d.ApplicationNameID = qsa.ApplicationNameID;		
							
			set @msg = 'Conflict detected: ' + cast(@@rowcount as nvarchar(10)) + ' rows affected. Will Retry Group ' + cast(@deleteGroup as nvarchar(10)) + ' (' + @msg + ')'
			exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@msg, @RC, null
		end
		else
		begin
			set @ErrorMessage = @BlockName + ERROR_MESSAGE()
			exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, null
			return @RC;
		end
	end catch


	end
end
drop table #DeleteList
	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, null

return @RC

end
 
GO 

---------- P_GROOMAUDITEDEVENTS.SQL
if (object_id('Grooming.p_GroomAuditedEvents') is not null)
begin
drop procedure Grooming.p_GroomAuditedEvents
end
go
create procedure [Grooming].[p_GroomAuditedEvents]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'AuditedEvents'
	
if (@SQLServerID is not null)
begin

	set @cmd = 'delete top (' + cast(@RecordsToDelete as nchar(50)) + ')
				from AuditableEvents
				where
				Name = @SQLServerNameIn'
	set @parms = N'@SQLServerNameIn sysname, @CutoffDateTimeIn datetime'	
				
					
	if @Deleted = 0
	begin
		set @cmd = @cmd + ' and DateTime <= @CutoffDateTimeIn'
	end
	else
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			delete top (@RecordsToDelete) 
			from AuditableEvents
			where DateTime <= @CutoffDateTime		
		end
		else
		begin
			exec sp_executesql @cmd, @parms, @SQLServerNameIn = @InstanceName, @CutoffDateTimeIn = @CutoffDateTime 
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end


 
GO 

---------- P_GROOMBASELINESTATISTICS.SQL
if (object_id('Grooming.p_GroomBaselineStatistics') is not null)
begin
drop procedure Grooming.p_GroomBaselineStatistics
end
go
create procedure [Grooming].[p_GroomBaselineStatistics]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (SQLServerID int not null,
	UTCCalculation datetime not null,
	TemplateID int not null,
	MetricID int not null,
	primary key(SQLServerID, UTCCalculation, TemplateID, MetricID))

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'BaselineStatistics'
	
if (@SQLServerID is not null)
begin
	Set @cmd = 'Declare @KeysToDelete Table (SQLServerID int not null,
			UTCCalculation datetime not null,
			TemplateID int not null,
			MetricID int not null,
			primary key(SQLServerID, UTCCalculation, TemplateID, MetricID))

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) SQLServerID, UTCCalculation, TemplateID, MetricID
			From dbo.BaselineStatistics with(nolock)
			Where SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And UTCCalculation <= @CutoffDateTime'
				Else N''
				End + N';
		
			Delete BS
			From dbo.BaselineStatistics BS
			Inner Join @KeysToDelete K
				On K.SQLServerID = BS.SQLServerID
					And K.UTCCalculation = BS.UTCCalculation
					And K.TemplateID = BS.TemplateID
					And K.MetricID = BS.MetricID;';
	set @parms = N'@SQLServerIDIn int,@CutoffDateTimeIn datetime,@RecordsToDelete int';	
					
	if @Deleted = 1
	begin
		set @BlockName = @BlockName + N' (deleting)';
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) SQLServerID, UTCCalculation, TemplateID, MetricID
			From dbo.BaselineStatistics with(nolock)
			Where UTCCalculation <= @CutoffDateTime;
		
			Delete BS
			From dbo.BaselineStatistics BS
			Inner Join @KeysToDelete K
				On K.SQLServerID = BS.SQLServerID
					And K.UTCCalculation = BS.UTCCalculation
					And K.TemplateID = BS.TemplateID
					And K.MetricID = BS.MetricID;		
		end
		else
		begin
			exec sp_executesql @cmd,
						@parms,
						@SQLServerIDIn = @SQLServerID,
						@CutoffDateTimeIn = @CutoffDateTime,
						@RecordsToDelete = @RecordsToDelete;
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMBASELINETEMPLATES.SQL
if (object_id('Grooming.p_GroomBaselineTemplates') is not null)
begin
drop procedure Grooming.p_GroomBaselineTemplates
end
go
create procedure [Grooming].[p_GroomBaselineTemplates]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'BaselineTemplates'		


if (GetUTCDate() > @TimeoutTime)           
	raiserror (N'Timeout in %s', 11, 1,@BlockName);

     
begin try
	create table #AllList(TemplateID int primary key clustered)
	insert into #AllList
		select TemplateID 
		from BaselineTemplates
	
	create table #KeepList(TemplateID int primary key clustered)
	insert into	#KeepList(TemplateID)
		select TemplateID
		from BaselineTemplates a
		where TemplateID = (select Max(TemplateID) from BaselineTemplates b where b.SQLServerID = a.SQLServerID)
			  or TemplateID in (select distinct(TemplateID) from BaselineStatistics)
		
	create table #DeleteList(TemplateID int primary key clustered, deleteGroup int default(0))
	insert into	
		#DeleteList (TemplateID)
		select allList.TemplateID
		from #AllList allList
		left outer merge join #KeepList keepList
		on allList.TemplateID = keepList.TemplateID 
		where keepList.TemplateID is null 

	
	drop table #AllList	
	drop table #KeepList
	
end try
begin catch

	set @ErrorMessage = @BlockName + ERROR_MESSAGE()
	exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, null

end catch

 
declare @deleteGroup int
declare @msg nvarchar(2048)
set @deleteGroup = 0
set @RowsAffected = @RecordsToDelete
	
if (select count(*) from #DeleteList) > 0
	begin	
			
	while @RowsAffected > 0
	begin

	begin try

		set @deleteGroup = @deleteGroup + 1

		update top (@RecordsToDelete) #DeleteList
		set deleteGroup = @deleteGroup
		where deleteGroup = 0
		
		if @@rowcount = 0
		begin
			select @deleteGroup = min(deleteGroup) from #DeleteList
			if @deleteGroup is not null
				begin
					set @msg = 'Retrying Group ' + cast(@deleteGroup as nvarchar(10)) 
					exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@msg, @RC, null
				end
		end
		
		delete top (@RecordsToDelete) templates
		from	
			dbo.BaselineTemplates templates 
			inner merge join #DeleteList d 
			on templates.TemplateID = d.TemplateID
		where
			d.deleteGroup = @deleteGroup
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
			
		delete from #DeleteList 
			where deleteGroup = @deleteGroup
			
	end try
	begin catch

		if	error_number() = 547
		begin
			
			set @msg = error_message();			
			
			if @msg like '%BaselineTemplates%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.BaselineTemplates t on
							d.TemplateID = t.TemplateID
						
			set @msg = 'Conflict detected: ' + cast(@@rowcount as nvarchar(10)) + ' rows affected. Will Retry Group ' + cast(@deleteGroup as nvarchar(10)) + ' (' + @msg + ')'
			exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@msg, @RC, null
		end
		else
		begin
			set @ErrorMessage = @BlockName + ERROR_MESSAGE()
			exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, null
			return @RC;
		end
	end catch


	end

end

drop table #DeleteList

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, null

return @RC

end
 
GO 

---------- P_GROOMBLOCKINGSESSIONSTATISTICS.SQL
if (object_id('Grooming.p_GroomBlockingSessionStatistics') is not null)
begin
drop procedure Grooming.p_GroomBlockingSessionStatistics
end
go
create procedure [Grooming].[p_GroomBlockingSessionStatistics]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (UTCCollectionDateTime datetime not null primary key)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'BlockingSessionStatistics'
	
if (@SQLServerID is not null)
begin

	Set @cmd = N'Declare @KeysToDelete Table (UTCCollectionDateTime datetime not null primary key)
			
			Insert Into @KeysToDelete
			Select Distinct dt.UTCCollectionDateTime
			From (Select Top(@RecordsToDelete) UTCCollectionDateTime
				From dbo.BlockingSessionStatistics with(nolock)
				Where SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And UTCCollectionDateTime <= @CutoffDateTime'
				Else N''
				End + N') As dt;
		
			Delete BWS
			From dbo.BlockingSessionStatistics BWS
			Inner Join @KeysToDelete K
				On K.UTCCollectionDateTime = BWS.UTCCollectionDateTime;';
	set @parms = N'@SQLServerIDIn int,@CutoffDateTimeIn datetime,@RecordsToDelete int'	
				
					
	if @Deleted = 1
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Distinct dt.UTCCollectionDateTime
			From (Select Top(@RecordsToDelete) UTCCollectionDateTime
				From dbo.BlockingSessionStatistics with(nolock)
				Where UTCCollectionDateTime <= @CutoffDateTime) As dt;
		
			Delete BWS
			From dbo.BlockingSessionStatistics BWS
			Inner Join @KeysToDelete K
				On K.UTCCollectionDateTime = BWS.UTCCollectionDateTime;		
		end
		else
		begin
			exec sp_executesql @cmd, @parms, @SQLServerIDIn=@SQLServerID,@CutoffDateTimeIn= @CutoffDateTime,@RecordsToDelete = @RecordsToDelete 
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMBLOCKS.SQL
if (object_id('Grooming.p_GroomBlocks') is not null)
begin
drop procedure Grooming.p_GroomBlocks
end
go
create procedure [Grooming].[p_GroomBlocks]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'Blocks'
	
if (@SQLServerID is not null)
begin

	set @cmd = 'delete top (' + cast(@RecordsToDelete as nchar(50)) + ')
				from Blocks
				where
				SQLServerID = @SQLServerIDIn'
	set @parms = N'@SQLServerIDIn int,@CutoffDateTimeIn datetime'	
				
					
	if @Deleted = 0
	begin
		set @cmd = @cmd + ' and UTCCollectionDateTime <= @CutoffDateTimeIn'
	end
	else
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			--this will cascade delete all records from BlockingSessions that have corresponsing xactid's			           
			delete top (@RecordsToDelete)
			from Blocks
			where UTCCollectionDateTime <= @CutoffDateTime
		
		end
		else
		begin
			exec sp_executesql @cmd, @parms, @SQLServerIDIn=@SQLServerID,@CutoffDateTimeIn= @CutoffDateTime 
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMCUSTOMCOUNTERSTATISTICS.SQL
if (object_id('Grooming.p_GroomCustomCounterStatistics') is not null)
begin
drop procedure Grooming.p_GroomCustomCounterStatistics
end
go
create procedure [Grooming].[p_GroomCustomCounterStatistics]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (SQLServerID int not null,
					UTCCollectionDateTime datetime not null,
					MetricID int not null,
					primary key(SQLServerID, UTCCollectionDateTime, MetricID))
select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'CustomCounterStatistics'
	
if (@SQLServerID is not null)
begin

	set @cmd = N'Declare @KeysToDelete Table (SQLServerID int not null,
					UTCCollectionDateTime datetime not null,
					MetricID int not null,
					primary key(SQLServerID, UTCCollectionDateTime, MetricID))
			
			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) SQLServerID, UTCCollectionDateTime, MetricID
			From dbo.CustomCounterStatistics with(nolock)
			Where SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And UTCCollectionDateTime <= @CutoffDateTime'
				Else N''
				End + N';
		
			Delete CCS
			From dbo.CustomCounterStatistics CCS
			Inner Join @KeysToDelete K
				On K.SQLServerID = CCS.SQLServerID
					And K.UTCCollectionDateTime = CCS.UTCCollectionDateTime
					And K.MetricID = CCS.MetricID;';
	set @parms = N'@SQLServerIDIn int,@CutoffDateTimeIn datetime,@RecordsToDelete int'	
				
					
	if @Deleted = 1
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) SQLServerID, UTCCollectionDateTime, MetricID
			From dbo.CustomCounterStatistics with(nolock)
			Where UTCCollectionDateTime <= @CutoffDateTime;
		
			Delete CCS
			From dbo.CustomCounterStatistics CCS
			Inner Join @KeysToDelete K
				On K.SQLServerID = CCS.SQLServerID
					And K.UTCCollectionDateTime = CCS.UTCCollectionDateTime
					And K.MetricID = CCS.MetricID;
		end
		else
		begin
			exec sp_executesql @cmd, @parms, @SQLServerIDIn=@SQLServerID,@CutoffDateTimeIn= @CutoffDateTime,@RecordsToDelete = @RecordsToDelete;
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch
		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMDATABASEFILEACTIVITY.SQL
if (object_id('Grooming.p_GroomDatabaseFileActivity') is not null)
begin
drop procedure Grooming.p_GroomDatabaseFileActivity
end
go
create procedure [Grooming].[p_GroomDatabaseFileActivity]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (UTCCollectionDateTime datetime not null,
						FileID int not null,
						primary key(UTCCollectionDateTime, FileID))

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'DatabaseFileActivity'
	
if (@SQLServerID is not null)
begin

	Set @cmd = N'Declare @KeysToDelete Table (UTCCollectionDateTime datetime not null,
						FileID int not null,
						primary key(UTCCollectionDateTime, FileID))
			
			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) dfa.UTCCollectionDateTime, dfa.FileID
			From dbo.DatabaseFileActivity dfa with(nolock)
			Inner Join DatabaseFiles df with(nolock) on dfa.FileID = df.FileID
			Inner Join SQLServerDatabaseNames dn with(nolock) on df.DatabaseID = dn.DatabaseID
			Where dn.SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And dfa.UTCCollectionDateTime <= @CutoffDateTimeIn'
				Else N''
				End + N';
		
			Delete DFA
			From dbo.DatabaseFileActivity DFA
			Inner Join @KeysToDelete K
				On K.UTCCollectionDateTime = DFA.UTCCollectionDateTime
					And K.FileID = DFA.FileID;';
	set @parms = N'@SQLServerIDIn int, @CutoffDateTimeIn datetime, @RecordsToDelete int'	
				
					
	if @Deleted = 0
	begin
		set @cmd = @cmd + ' and UTCCollectionDateTime <= @CutoffDateTimeIn'
	end
	else
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) UTCCollectionDateTime, FileID
			From dbo.DatabaseFileActivity with(nolock)
			Where UTCCollectionDateTime <= @CutoffDateTime;
		
			Delete DFA
			From dbo.DatabaseFileActivity DFA
			Inner Join @KeysToDelete K
				On K.UTCCollectionDateTime = DFA.UTCCollectionDateTime
					And K.FileID = DFA.FileID;
		end
		else
		begin
			exec sp_executesql @cmd, @parms, @SQLServerIDIn = @SQLServerID, @CutoffDateTimeIn = @CutoffDateTime, @RecordsToDelete = @RecordsToDelete;
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMDATABASEFILES.SQL
if (object_id('Grooming.p_GroomDatabaseFiles') is not null)
begin
drop procedure Grooming.p_GroomDatabaseFiles
end
go
create procedure [Grooming].[p_GroomDatabaseFiles]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (FileID int not null primary key)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'DatabaseFiles'

if @Deleted = 1
begin
	set @BlockName = @BlockName + ' (deleting)'
end
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is not null)
		begin
			Delete From @KeysToDelete;
							
			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) FileID
			From dbo.DatabaseFiles df with(nolock)
			    Inner Join SQLServerDatabaseNames dn (nolock) on df.DatabaseID = dn.DatabaseID
			Where dn.SQLServerID = @SQLServerID;
		
			Delete DF
			From dbo.DatabaseFiles DF
			Inner Join @KeysToDelete K
				On K.FileID = DF.FileID;
		end
		else
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) FileID
			From dbo.DatabaseFiles df with(nolock)
			Inner Join dbo.SQLServerDatabaseNames dn with(nolock)
				On df.DatabaseID = dn.DatabaseID
			Where dn.SQLServerID = @SQLServerID;
		
			Delete DF
			From dbo.DatabaseFiles DF
			Inner Join @KeysToDelete K
				On K.FileID = DF.FileID;
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMDATABASENAMES.SQL
if (object_id('Grooming.p_GroomDatabaseNames') is not null)
begin
drop procedure Grooming.p_GroomDatabaseNames
end
go
create procedure [Grooming].[p_GroomDatabaseNames]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'DatabaseNames'		


if (GetUTCDate() > @TimeoutTime)           
	raiserror (N'Timeout in %s', 11, 1,@BlockName);

     
begin try
	create table #AllList(DatabaseID int primary key clustered)
	insert into #AllList
		select DatabaseID 
		from SQLServerDatabaseNames
	
	create table #KeepList(DatabaseID int primary key clustered)
	insert into	#KeepList(DatabaseID)
		select DatabaseID
		from dbo.DatabaseFiles
		where DatabaseID is not null
		union
		select DatabaseID
		from dbo.DatabaseStatistics
		where DatabaseID is not null
		union
		select DatabaseID
		from dbo.DatabaseSize
		where DatabaseID is not null
		union
		select DatabaseID
		from dbo.SQLServerTableNames
		where DatabaseID is not null
		union
		select DatabaseID
		from dbo.MirroringParticipants
		where DatabaseID is not null
		union
		select DatabaseID
		from dbo.MirroringStatistics
		where DatabaseID is not null
		union
		select DatabaseID
		from dbo.ActiveWaitStatistics
		where DatabaseID is not null
		union
		select DatabaseID
		from dbo.QueryMonitorStatistics
		where DatabaseID is not null
		union
		select DatabaseID
		from dbo.BlockingSessionStatistics
		where DatabaseID is not null
		union
		select DatabaseID
		from dbo.DeadlockProcesses
		where DatabaseID is not null
		union
		select DatabaseID
		from dbo.QuerySignatureAggregation
		
	create table #DeleteList(DatabaseID int primary key clustered, deleteGroup int default(0))
	insert into	
		#DeleteList (DatabaseID)
		select allList.DatabaseID
		from #AllList allList
		left outer merge join #KeepList keepList
		on allList.DatabaseID = keepList.DatabaseID 
		where keepList.DatabaseID is null 

	
	drop table #AllList	
	drop table #KeepList
	
end try
begin catch

	set @ErrorMessage = @BlockName + ERROR_MESSAGE()
	exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, null

end catch

 
declare @deleteGroup int
declare @msg nvarchar(2048)
set @deleteGroup = 0
set @RowsAffected = @RecordsToDelete
	
if (select count(*) from #DeleteList) > 0
	begin	
			
	while @RowsAffected > 0
	begin

	begin try

		set @deleteGroup = @deleteGroup + 1

		update top (@RecordsToDelete) #DeleteList
		set deleteGroup = @deleteGroup
		where deleteGroup = 0
		
		if @@rowcount = 0
		begin
			select @deleteGroup = min(deleteGroup) from #DeleteList
			if @deleteGroup is not null
				begin
					set @msg = 'Retrying Group ' + cast(@deleteGroup as nvarchar(10)) 
					exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@msg, @RC, null
				end
		end
		
		delete top (@RecordsToDelete) dbNames
		from	
			dbo.SQLServerDatabaseNames dbNames 
			inner merge join #DeleteList d 
			on dbNames.DatabaseID = d.DatabaseID
		where
			d.deleteGroup = @deleteGroup
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
			
		delete from #DeleteList 
			where deleteGroup = @deleteGroup
			
	end try
	begin catch

		if	error_number() = 547
		begin
			
			set @msg = error_message();
			
			
			
			if @msg like '%DatabaseFiles%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.DatabaseFiles df on
							d.DatabaseID = df.DatabaseID;
							
			if @msg like '%DatabaseStatistics%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.DatabaseStatistics ds on
							d.DatabaseID = ds.DatabaseID;			


			if @msg like '%DatabaseSize%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.DatabaseSize ds on
							d.DatabaseID = ds.DatabaseID;			
							
			if @msg like '%SQLServerTableNames%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.SQLServerTableNames tn on
							d.DatabaseID = tn.DatabaseID;						
							
			if @msg like '%MirroringParticipants%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.MirroringParticipants mp on
							d.DatabaseID = mp.DatabaseID;				
							
			if @msg like '%MirroringStatistics%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.MirroringStatistics ms on
							d.DatabaseID = ms.DatabaseID;														


			if @msg like '%ActiveWait%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.ActiveWaitStatistics aws on
							d.DatabaseID = aws.DatabaseID;
			
			
			if @msg like '%QueryMonitor%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.QueryMonitorStatistics qms on
							d.DatabaseID = qms.DatabaseID;
			
			if @msg like '%DeadlockProcesses%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.DeadlockProcesses dp on
							d.DatabaseID = dp.DatabaseID;
			
			if @msg like '%BlockingSession%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.BlockingSessionStatistics bss on
							d.DatabaseID = bss.DatabaseID;
							
		
			if @msg like '%QuerySignature%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.QuerySignatureAggregation qsa on
							d.DatabaseID = qsa.DatabaseID;								
		
						
			set @msg = 'Conflict detected: ' + cast(@@rowcount as nvarchar(10)) + ' rows affected. Will Retry Group ' + cast(@deleteGroup as nvarchar(10)) + ' (' + @msg + ')'
			exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@msg, @RC, null
		end
		else
		begin
			set @ErrorMessage = @BlockName + ERROR_MESSAGE()
			exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, null
			return @RC;
		end
	end catch


	end

end

drop table #DeleteList

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, null

return @RC

end
 
GO 

---------- P_GROOMDATABASESIZE.SQL
if (object_id('Grooming.p_GroomDatabaseSize') is not null)
begin
drop procedure Grooming.p_GroomDatabaseSize
end
go
create procedure [Grooming].[p_GroomDatabaseSize]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (DatabaseSizeID bigint not null primary key)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'DatabaseSize'
	
if (@SQLServerID is not null)
begin
	Set @cmd = N'Declare @KeysToDelete Table (DatabaseSizeID bigint not null primary key)
			
			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) DatabaseSizeID
			From dbo.DatabaseSize ds with(nolock)
			Inner Join dbo.SQLServerDatabaseNames dn on ds.DatabaseID = dn.DatabaseID
			Where SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And ds.UTCCollectionDateTime <= @CutoffDateTime'
				Else N''
				End + N';
		
			Delete DS
			From dbo.DatabaseSize DS
			Inner Join @KeysToDelete K
				On K.DatabaseSizeID = DS.DatabaseSizeID;';
	set @parms = N'@SQLServerIDIn int,@CutoffDateTimeIn datetime,@RecordsToDelete int';
				
					
	if @Deleted = 1
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) DatabaseSizeID
			From dbo.DatabaseSize with(nolock)
			Where UTCCollectionDateTime <= @CutoffDateTime;
		
			Delete DS
			From dbo.DatabaseSize DS
			Inner Join @KeysToDelete K
				On K.DatabaseSizeID = DS.DatabaseSizeID;
		end
		else
		begin
			exec sp_executesql @cmd, @parms, @SQLServerIDIn=@SQLServerID,@CutoffDateTimeIn= @CutoffDateTime,@RecordsToDelete = @RecordsToDelete;
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMDATABASESTATISTICS.SQL
if (object_id('Grooming.p_GroomDatabaseStatistics') is not null)
begin
drop procedure Grooming.p_GroomDatabaseStatistics
end
go
create procedure [Grooming].[p_GroomDatabaseStatistics]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (DatabaseStatisticsID bigint not null primary key)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'DatabaseStatistics'
	
if (@SQLServerID is not null)
begin
	Set @cmd = N'Declare @KeysToDelete Table (DatabaseStatisticsID bigint not null primary key)
			
			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) DatabaseStatisticsID
			From dbo.DatabaseStatistics ds with(nolock)
			Inner Join SQLServerDatabaseNames dn on ds.DatabaseID = dn.DatabaseID
			Where SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And ds.UTCCollectionDateTime <= @CutoffDateTime'
				Else N''
				End + N';
		
			Delete DS
			From dbo.DatabaseStatistics DS
			Inner Join @KeysToDelete K
				On K.DatabaseStatisticsID = DS.DatabaseStatisticsID;';
	set @parms = N'@SQLServerIDIn int,@CutoffDateTimeIn datetime,@RecordsToDelete int'	
				
					
	if @Deleted = 1
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin

			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) DatabaseStatisticsID
			From dbo.DatabaseStatistics with(nolock)
			Where UTCCollectionDateTime <= @CutoffDateTime;
		
			Delete DS
			From dbo.DatabaseStatistics DS
			Inner Join @KeysToDelete K
				On K.DatabaseStatisticsID = DS.DatabaseStatisticsID;
		end
		else
		begin
			exec sp_executesql @cmd, @parms, @SQLServerIDIn=@SQLServerID,@CutoffDateTimeIn= @CutoffDateTime,@RecordsToDelete = @RecordsToDelete;
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMDATABASESTATISTICSSTAGING.SQL

If OBJECT_ID('Grooming.p_GroomDatabaseStatisticsStaging') Is Not Null
	Drop Procedure Grooming.p_GroomDatabaseStatisticsStaging;
Go

Create Procedure Grooming.p_GroomDatabaseStatisticsStaging (
	@run_id uniqueidentifier,
	@Sequence int out,
	@TimeoutTime datetime,
	@RecordsToDelete int = 1000,
	@CutoffDateTime datetime,
	@SQLServerID int = null,
	@InstanceName sysname = null,
	@Deleted bit = 0)
as
begin
--Delete from stageDatabaseStatistics where  UTCCollectionDateTime < dateadd(d,-1,getdate())

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (SourceID uniqueidentifier not null, ServerID int, DatabaseName nvarchar(255), UTCCollectionDateTime datetime)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'DatabaseStatisticsStaging'

while (1=1)
begin
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try

			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) SourceID, ServerID, DatabaseName, UTCCollectionDateTime
			From [dbo].[stageDatabaseStatistics] with(nolock)
			Where UTCCollectionDateTime <= @CutoffDateTime;
			
			Delete stage
			From [dbo].[stageDatabaseStatistics] stage
			Inner Join @KeysToDelete K
				On K.SourceID = stage.SourceID 
				and K.ServerID = stage.ServerID 
				and K.DatabaseName = stage.DatabaseName
				and K.UTCCollectionDateTime = stage.UTCCollectionDateTime
		
		set @RowsAffected = @@ROWCOUNT;
		set @RC = @RC + @RowsAffected;
		if (@RowsAffected < @RecordsToDelete)
			break;
	end try
	begin catch
		set @ErrorMessage = @BlockName + ERROR_MESSAGE();
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName;
		break;
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName;

return @RC;
	           
		
end
GO
 
GO 

---------- P_GROOMDATABASESTATISTICS_UPGRADE.SQL
if (object_id('Grooming.p_GroomDatabaseStatistics_upgrade') is not null)
begin
drop procedure Grooming.p_GroomDatabaseStatistics_upgrade
end
go
create procedure [Grooming].[p_GroomDatabaseStatistics_upgrade]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'DatabaseStatistics_upgrade'
	
exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

declare @RowsRemaining bigint

select 
	@RowsRemaining = sum(rows)
from
	sys.partitions
where
	object_id = object_id('DatabaseStatistics_upgrade')
	and index_id < 2 

-- Drop former upgrade script	
if (isnull(@RowsRemaining,0) <= 0)
begin

	if (object_id('p_UpgradeDatabaseStatistics') is not null)
	begin
	exec('drop procedure [p_UpgradeDatabaseStatistics]')
	end


	IF (OBJECT_ID('p_UpgradeDatabaseStatistics') is null)
	begin
	exec('
	create procedure [p_UpgradeDatabaseStatistics]
		@RowsRemaining bigint output
	as
	begin
		set @RowsRemaining = 0
		return @RowsRemaining
	end')
	
	if (object_id('DatabaseStatistics_upgrade') is not null)
	begin
		exec('drop table DatabaseStatistics_upgrade')
	end
end


end		

return @RC

end
 
GO 

---------- P_GROOMDEADLOCKS.SQL
if (object_id('Grooming.p_GroomDeadlocks') is not null)
begin
drop procedure Grooming.p_GroomDeadlocks
end
go
create procedure [Grooming].[p_GroomDeadlocks]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (DeadlockID uniqueidentifier not null primary key)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'Deadlocks'
	
if (@SQLServerID is not null)
begin
	Set @cmd = N'Declare @KeysToDelete Table (DeadlockID uniqueidentifier not null primary key)
		
			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) DeadlockID
			From dbo.Deadlocks with(nolock)
			Where SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And UTCCollectionDateTime <= @CutoffDateTime'
				Else N''
				End + N';
			
			-- This will cause a cascade delete in DeadlockProcesses
			Delete D
			From dbo.Deadlocks D
			Inner Join @KeysToDelete K
				On K.DeadlockID = D.DeadlockID;';
	set @parms = N'@SQLServerIDIn int,@CutoffDateTimeIn datetime,@RecordsToDelete int'	
				
					
	if @Deleted = 0
	begin
		set @cmd = @cmd + ' and UTCCollectionDateTime <= @CutoffDateTimeIn'
	end
	else
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) DeadlockID
			From dbo.Deadlocks with(nolock)
			Where UTCCollectionDateTime <= @CutoffDateTime;
			
			-- This will cause a cascade delete in DeadlockProcesses
			Delete D
			From dbo.Deadlocks D
			Inner Join @KeysToDelete K
				On K.DeadlockID = D.DeadlockID;
		end
		else
		begin
			exec sp_executesql @cmd, @parms, @SQLServerIDIn=@SQLServerID,@CutoffDateTimeIn= @CutoffDateTime,@RecordsToDelete = @RecordsToDelete;
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end


 
GO 

---------- P_GROOMDISKDRIVES.SQL
if (object_id('Grooming.p_GroomDiskDrives') is not null)
begin
drop procedure Grooming.p_GroomDiskDrives
end
go
create procedure [Grooming].[p_GroomDiskDrives]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (SQLServerID int not null,
							UTCCollectionDateTime datetime not null,
							DriveName nvarchar(256) not null,
							primary key(SQLServerID, UTCCollectionDateTime, DriveName))

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'DiskDrives'

if (@SQLServerID is not null)
begin
	Set @cmd = N'Declare @KeysToDelete Table (SQLServerID int not null,
							UTCCollectionDateTime datetime not null,
							DriveName nvarchar(256) not null,
							primary key(SQLServerID, UTCCollectionDateTime, DriveName))
			
			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) SQLServerID, UTCCollectionDateTime, DriveName
			From dbo.DiskDrives with(nolock)
			Where SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And UTCCollectionDateTime <= @CutoffDateTime'
				Else N''
				End + N';
			
			Delete D
			From dbo.DiskDrives D
			Inner Join @KeysToDelete K
				On K.SQLServerID = D.SQLServerID
					And K.UTCCollectionDateTime = D.UTCCollectionDateTime
					And K.DriveName = D.DriveName;';
	set @parms = N'@SQLServerIDIn int,@CutoffDateTimeIn datetime,@RecordsToDelete int'	
				
					
	if @Deleted = 0
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) SQLServerID, UTCCollectionDateTime, DriveName
			From dbo.DiskDrives with(nolock)
			Where UTCCollectionDateTime <= @CutoffDateTime;
			
			Delete D
			From dbo.DiskDrives D
			Inner Join @KeysToDelete K
				On K.SQLServerID = D.SQLServerID
					And K.UTCCollectionDateTime = D.UTCCollectionDateTime
					And K.DriveName = D.DriveName;
		end
		else
		begin
			exec sp_executesql @cmd, @parms, @SQLServerIDIn=@SQLServerID,@CutoffDateTimeIn= @CutoffDateTime,@RecordsToDelete = @RecordsToDelete;
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMDISKDRIVESTATISTICS.SQL
--SQLdm 9.1 (Ankit Srivastava) -- Filegroup and Mount Point Monitoring Improvements -- Added new procedure to groom disk drive stats
if (object_id('Grooming.p_GroomDiskDriveStatistics') is not null)
begin
drop procedure Grooming.p_GroomDiskDriveStatistics
end
go
create procedure [Grooming].[p_GroomDiskDriveStatistics]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (SQLServerID int not null,
							UTCCollectionDateTime datetime not null,
							DriveName nvarchar(256) not null,
							primary key(SQLServerID, UTCCollectionDateTime, DriveName))

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'DiskDriveStatistics'

if (@SQLServerID is not null)
begin
	Set @cmd = N'Declare @KeysToDelete Table (SQLServerID int not null,
							UTCCollectionDateTime datetime not null,
							DriveName nvarchar(256) not null,
							primary key(SQLServerID, UTCCollectionDateTime, DriveName))
			
			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) SQLServerID, UTCCollectionDateTime, DriveName
			From dbo.DiskDriveStatistics with(nolock)
			Where SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And UTCCollectionDateTime <= @CutoffDateTime'
				Else N''
				End + N';
			
			Delete D
			From dbo.DiskDriveStatistics D
			Inner Join @KeysToDelete K
				On K.SQLServerID = D.SQLServerID
					And K.UTCCollectionDateTime = D.UTCCollectionDateTime
					And K.DriveName = D.DriveName;';
	set @parms = N'@SQLServerIDIn int,@CutoffDateTimeIn datetime,@RecordsToDelete int'	
				
					
	if @Deleted = 0
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) SQLServerID, UTCCollectionDateTime, DriveName
			From dbo.DiskDriveStatistics with(nolock)
			Where UTCCollectionDateTime <= @CutoffDateTime;
			
			Delete D
			From dbo.DiskDriveStatistics D
			Inner Join @KeysToDelete K
				On K.SQLServerID = D.SQLServerID
					And K.UTCCollectionDateTime = D.UTCCollectionDateTime
					And K.DriveName = D.DriveName;
		end
		else
		begin
			exec sp_executesql @cmd, @parms, @SQLServerIDIn=@SQLServerID,@CutoffDateTimeIn= @CutoffDateTime,@RecordsToDelete = @RecordsToDelete;
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMESXCONFIGDATA.SQL
if (object_id('Grooming.p_GroomESXConfigData') is not null)
begin
drop procedure Grooming.p_GroomESXConfigData
end
go
create procedure [Grooming].[p_GroomESXConfigData]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (SQLServerID int not null,
							UTCCollectionDateTime datetime not null,
							primary key(SQLServerID, UTCCollectionDateTime))
select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'ESXConfigData'
	
if (@SQLServerID is not null)
begin
	Set @cmd = N'Declare @KeysToDelete Table (SQLServerID int not null,
							UTCCollectionDateTime datetime not null,
							primary key(SQLServerID, UTCCollectionDateTime))

				Insert Into @KeysToDelete
				Select Top(@RecordsToDelete) SQLServerID, UTCCollectionDateTime
				From dbo.ESXConfigData with(nolock)
				Where SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And UTCCollectionDateTime <= @CutoffDateTime'
				Else N''
				End + N';
			
				Delete CD
				From dbo.ESXConfigData CD
				Inner Join @KeysToDelete K
					On K.SQLServerID = CD.SQLServerID
						And K.UTCCollectionDateTime = CD.UTCCollectionDateTime;';
	set @parms = N'@SQLServerIDIn int,@CutoffDateTimeIn datetime,@RecordsToDelete int'	
				
					
	if @Deleted = 1
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) SQLServerID, UTCCollectionDateTime
			From dbo.ESXConfigData with(nolock)
			Where UTCCollectionDateTime <= @CutoffDateTime;
			
			Delete CD
			From dbo.ESXConfigData CD
			Inner Join @KeysToDelete K
				On K.SQLServerID = CD.SQLServerID
					And K.UTCCollectionDateTime = CD.UTCCollectionDateTime;		
		end
		else
		begin
			exec sp_executesql @cmd, @parms, @SQLServerIDIn=@SQLServerID,@CutoffDateTimeIn= @CutoffDateTime,@RecordsToDelete = @RecordsToDelete;
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMESXSTATISTICS.SQL
if (object_id('Grooming.p_GroomESXStatistics') is not null)
begin
drop procedure Grooming.p_GroomESXStatistics
end
go
create procedure [Grooming].[p_GroomESXStatistics]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (SQLServerID int not null,
							UTCCollectionDateTime datetime not null,
							primary key(SQLServerID, UTCCollectionDateTime))
select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'ESXStatistics'
	
if (@SQLServerID is not null)
begin
	Set @cmd = N'Declare @KeysToDelete Table (SQLServerID int not null,
							UTCCollectionDateTime datetime not null,
							primary key(SQLServerID, UTCCollectionDateTime))

				Insert Into @KeysToDelete
				Select Top(@RecordsToDelete) SQLServerID, UTCCollectionDateTime
				From dbo.ESXStatistics with(nolock)
				Where SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And UTCCollectionDateTime <= @CutoffDateTime'
				Else N''
				End + N';
			
				Delete ES
				From dbo.ESXStatistics ES
				Inner Join @KeysToDelete K
					On K.SQLServerID = ES.SQLServerID
						And K.UTCCollectionDateTime = ES.UTCCollectionDateTime;';
	set @parms = N'@SQLServerIDIn int,@CutoffDateTimeIn datetime,@RecordsToDelete int'	
				
					
	if @Deleted = 1
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) SQLServerID, UTCCollectionDateTime
			From dbo.ESXStatistics with(nolock)
			Where UTCCollectionDateTime <= @CutoffDateTime;
			
			Delete ES
			From dbo.ESXStatistics ES
			Inner Join @KeysToDelete K
				On K.SQLServerID = ES.SQLServerID
					And K.UTCCollectionDateTime = ES.UTCCollectionDateTime;
		end
		else
		begin
			exec sp_executesql @cmd, @parms, @SQLServerIDIn=@SQLServerID,@CutoffDateTimeIn= @CutoffDateTime,@RecordsToDelete = @RecordsToDelete;
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMEXPIREDFORECASTS.SQL

IF (OBJECT_ID('p_GroomExpiredForecasts') IS NOT NULL)
BEGIN
	DROP PROCEDURE [p_GroomExpiredForecasts]
END
GO

CREATE PROCEDURE [dbo].[p_GroomExpiredForecasts]	
AS
BEGIN

delete from PredictiveForecasts where Expiration < GETUTCDATE()

END
 
GO 

---------- P_GROOMGROOMINGLOG.SQL
if (object_id('Grooming.p_GroomGroomingLog') is not null)
begin
drop procedure Grooming.p_GroomGroomingLog
end
go
create procedure [Grooming].[p_GroomGroomingLog]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'GroomingLog'		

					
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	
		delete top (@RecordsToDelete)
		from GroomingLog
				where [RunID] not in
					(select top 10 RunID from GroomingLog (nolock)
						group by RunID
						order by max(UTCActionEndDateTime) desc
					) 

		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, null
		break;
	
	end catch
end	

set @RowsAffected = @@ROWCOUNT
set @RC = @RC + @RowsAffected	
				
exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, null

return @RC

end
 
GO 

---------- P_GROOMHOSTNAMES.SQL
if (object_id('Grooming.p_GroomHostNames') is not null)
begin
drop procedure Grooming.p_GroomHostNames
end
go
create procedure [Grooming].[p_GroomHostNames]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'HostNames'		
			


if (GetUTCDate() > @TimeoutTime)           
	raiserror (N'Timeout in %s', 11, 1,@BlockName);
	
 
begin try
	create table #AllList(HostNameID int primary key clustered)
	insert into #AllList
		select HostNameID 
		from HostNames
	
	create table #KeepList(HostNameID int primary key clustered)
	insert into	#KeepList(HostNameID)
		select HostNameID
		from ActiveWaitStatistics
		where HostNameID is not null
		union 
		select HostNameID
		from QueryMonitorStatistics
		where HostNameID is not null
		union 
		select HostNameID
		from DeadlockProcesses
		where HostNameID is not null
		union 
		select HostNameID
		from BlockingSessionStatistics	
		where HostNameID is not null
		
	create table #DeleteList(HostNameID int primary key clustered, deleteGroup int default(0))
	insert into	
		#DeleteList (HostNameID)
		select allList.HostNameID
		from #AllList allList
		left outer merge join #KeepList keepList
		on allList.HostNameID = keepList.HostNameID 
		where keepList.HostNameID is null 

	
	drop table #AllList	
	drop table #KeepList
	
	
end try
begin catch

	set @ErrorMessage = @BlockName + ERROR_MESSAGE()
	exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, null

end catch	
 
declare @deleteGroup int
declare @msg nvarchar(2048)
set @deleteGroup = 0
set @RowsAffected = @RecordsToDelete
	
if (select count(*) from #DeleteList) > 0
		begin		
	while @RowsAffected > 0
	begin

	begin try

		set @deleteGroup = @deleteGroup + 1

		update top (@RecordsToDelete) #DeleteList
		set deleteGroup = @deleteGroup
		where deleteGroup = 0
		
		if @@rowcount = 0
		begin
			select @deleteGroup = min(deleteGroup) from #DeleteList
			if @deleteGroup is not null
				begin
					set @msg = 'Retrying Group ' + cast(@deleteGroup as nvarchar(10)) 
					exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@msg, @RC, null
				end
		end
		
		delete top (@RecordsToDelete) hosts
		from	
			dbo.HostNames hosts 
			inner merge join #DeleteList d 
			on hosts.HostNameID = d.HostNameID
		where
			d.deleteGroup = @deleteGroup
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
			
		delete from #DeleteList 
			where deleteGroup = @deleteGroup
			
	end try
	begin catch

		if	error_number() = 547
		begin
			
			set @msg = error_message();
			
			if @msg like '%ActiveWait%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.ActiveWaitStatistics aws on
							d.HostNameID = aws.HostNameID;
			
			if @msg like '%QueryMonitor%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.QueryMonitorStatistics qms on
							d.HostNameID = qms.HostNameID;
			
			if @msg like '%DeadlockProcesses%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.DeadlockProcesses dp on
							d.HostNameID = dp.HostNameID;
			
			if @msg like '%BlockingSession%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.BlockingSessionStatistics bss on
							d.HostNameID = bss.HostNameID;
							
			set @msg = 'Conflict detected: ' + cast(@@rowcount as nvarchar(10)) + ' rows affected. Will Retry Group ' + cast(@deleteGroup as nvarchar(10)) + ' (' + @msg + ')'
			exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@msg, @RC, null
		end
		else
		begin
			set @ErrorMessage = @BlockName + ERROR_MESSAGE()
			exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, null
			return @RC;
		end
	end catch


	end
end	

drop table #DeleteList

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, null

return @RC

end
 
GO 

---------- P_GROOMINGDEFRAG.SQL
if (object_id('Grooming.p_GroomingDefrag') is not null)
begin
drop procedure Grooming.p_GroomingDefrag
end
go
create procedure [Grooming].[p_GroomingDefrag]
(
@id int,
@indexname nvarchar(256)
)
as
begin

declare @qualified_table_name nvarchar(500), @command nvarchar(max), @type int, @indexid bigint, @cmptlevel int, @isonline bit

set @isonline = 0


select 
	@qualified_table_name = quotename(schema_name(uid)) + '.' + quotename(name) 
from
	sysobjects
where 
	id = @id

select @cmptlevel = compatibility_level from master.sys.databases where database_id = db_id()


if (len(@qualified_table_name) > 0)
begin


    SELECT @command = 'ALTER INDEX '

	if @indexname <> 'ALL'
		begin

			select @type = type, @indexid = index_id from sys.indexes where object_id = @id and name = @indexname

			if @indexid is null
			begin		
				select @command = null
			end
			else
			begin
				select @command = @command + quotename(@indexname) + ' on ' + @qualified_table_name + ' REBUILD '
				-- Check for Enterprise Edition
				if lower(cast(serverproperty('edition') as nvarchar(50))) like '%enterprise edition%'
				   or lower(cast(serverproperty('edition') as nvarchar(50))) like '%developer edition%'
				begin
					-- Check for XML index
					if (@type <> 3)
						begin
							-- Check for long columns for clustered index
							if (@type = 1) 
								begin
									if not exists(select * from sys.columns where object_id = @id 
									and 
									(max_length < 0 
									or system_type_id in
									(select system_type_id from sys.types where name in ('image', 'text', 'ntext', 'xml'))
									))
									select @command = @command + 'WITH (ONLINE = ON) '
									set @isonline = 1
								end
							else
								begin
									-- Check for long columns for non-clustered index
									if not exists(select * from 
										sys.index_columns ic
										left join sys.columns c
										on ic.object_id = c.object_id
										left join sys.types t
										on c.system_type_id = t.system_type_id 
										where 
										ic.object_id = @id 
										and ic.index_id = @indexid
										and 
										(t.name in ('image', 'text', 'ntext', 'xml')
										or t.max_length < 0))
									select @command = @command + 'WITH (ONLINE = ON) '
									set @isonline = 1
								end
						end
				end
			end
		end
	else
		begin
			select @command = @command + 'ALL on ' + @qualified_table_name + ' REBUILD '
	
			-- Check for Enterprise Edition
			if lower(cast(serverproperty('edition') as nvarchar(50))) like '%enterprise edition%'
				or lower(cast(serverproperty('edition') as nvarchar(50))) like '%developer edition%'
			begin
				if not exists(select * from sys.xml_indexes where object_id = @id)
				begin
					if not exists(select * from sys.columns where object_id = @id 
						and 
						(max_length < 0 
						or system_type_id in
						(select system_type_id from sys.types where name in ('image', 'text', 'ntext', 'xml'))
						))
					select @command = @command + 'WITH (ONLINE = ON) '
					set @isonline = 1
				end
			end
		end
end		

if (@isonline = 0)
begin
	if (@indexname) = 'ALL'
	begin
		set @command = 'dbcc indexdefrag (0, ' + rtrim(cast(@id as nvarchar(50))) + ') WITH NO_INFOMSGS	'
	end
	else
	begin
		set @command = 'dbcc indexdefrag (0, ' + rtrim(cast(@id as nvarchar(50))) + ', ' + quotename(@indexname,'''') + ') WITH NO_INFOMSGS	'
	end
end

exec (@command)

end
 
GO 

---------- P_GROOMJOBMAINTENANCE.SQL
if (object_id('Grooming.p_GroomJobMaintenance') is not null)
begin
drop procedure Grooming.p_GroomJobMaintenance
end
go
create procedure [Grooming].[p_GroomJobMaintenance]
as
begin

set nocount on


begin try


declare @StartTime datetime
declare @TimeoutTime datetime
declare @TimeoutMinutes int
declare @run_id uniqueidentifier
declare @Sequence int
declare @RC int
declare @ErrorMessage nvarchar(2048)
declare @BlockName nvarchar(256)

select 
	@StartTime = isnull(UTCActionEndDateTime,getutcdate()),
	@run_id = isnull(RunID,newid())
from 
GroomingLog
where UTCActionEndDateTime = 
	(select 
		max (UTCActionEndDateTime) 
	from 
	GroomingLog (nolock)
	where Action = 'Started')
	
select @Sequence = max(Sequence) from GroomingLog where RunID = @run_id
	
select @TimeoutMinutes = isnull(Internal_Value,180) from RepositoryInfo where [Name] = 'GroomingMaxNumberMinutes'	

set @TimeoutTime = dateadd(mi,@TimeoutMinutes,@StartTime)

if (GetUTCDate() > @TimeoutTime)           
	raiserror (N'Timeout in %s', 11, 1,'Maintenance');

if (object_id('GroomingFragmentationMaintenance') is null)
begin
create table GroomingFragmentationMaintenance
(
rowid int identity primary key clustered,
objectid int,
tablename nvarchar(256),
indexname nvarchar(256),
indexid int,
lastdefrag datetime null,
reorgflag bit
)
end

;with DeleteList(objectid,tablename,indexname,indexid) as
(
select objectid,tablename,indexname,indexid
from GroomingFragmentationMaintenance
except
select
t.object_id,
t.name,
i.name,
i.index_id
from sys.indexes i
inner join sys.tables t
on i.object_id = t.object_id
where
i.type in (1,2)
and t.type = 'U')
delete GroomingFragmentationMaintenance
from
GroomingFragmentationMaintenance m 
inner join DeleteList d
on 
m.objectid = d.objectid
and m.tablename = d.tablename
and m.indexname = d.indexname
and m.indexid = d.indexid

set @RC = @@ROWCOUNT

exec Grooming.p_LogGroomingAction @run_id, @Sequence out,  'Grooming GroomingFragmentationMaintenance' , @RC, null


insert into GroomingFragmentationMaintenance(objectid,tablename,indexname,indexid)
select
t.object_id,
t.name,
i.name,
i.index_id
from sys.indexes i
inner join sys.tables t
on i.object_id = t.object_id
where
i.type in (1,2)
and t.type = 'U'
except
select objectid,tablename,indexname,indexid
from GroomingFragmentationMaintenance

set @RC = @@ROWCOUNT

exec Grooming.p_LogGroomingAction @run_id, @Sequence out,  'Building GroomingFragmentationMaintenance' , @RC, null

if not exists(select rowid from GroomingFragmentationMaintenance where reorgflag = 1)
begin
	update GroomingFragmentationMaintenance
	set reorgflag = 1
	where 
	rowid in(
	select top 10 f.rowid
	from 
	GroomingFragmentationMaintenance f
	inner join sys.partitions p
	on p.object_id = f.objectid
	inner join  sys.allocation_units au
	on (au.type = 2 and p.partition_id = au.container_id) OR (au.type IN (1,3) AND p.hobt_id = au.container_id) 
	cross apply Grooming.fn_GroomingFragmentation(db_id(),f.objectid,f.indexid) f2
	where
	(lastdefrag is null and f2.avg_fragmentation_in_percent > 30)
	or (datediff(d,lastdefrag,getutcdate()) > 1 and f2.avg_fragmentation_in_percent > 50)
	or (datediff(d,lastdefrag,getutcdate()) > 7 and f2.avg_fragmentation_in_percent > 30)
	group by 
	 f.rowid, f2.avg_fragmentation_in_percent
	having  
	sum(total_pages) > 100
	)
end


declare @id int, @indexname nvarchar(256)

while (1=1)
begin

	if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,'Maintenance');
	
	begin try
		
		select top 1
			@BlockName = 'Defrag ' + tablename,
			@id = objectid, 
			@indexname = case when indexid = 1 then 'ALL' else indexname end
		from 
			GroomingFragmentationMaintenance
		where reorgflag = 1
		order by indexid asc
		
		if @id is null break;

		exec [Grooming].[p_GroomingDefrag] @id, @indexname
		
		update GroomingFragmentationMaintenance
		set lastdefrag = getutcdate(), reorgflag = 0
		where objectid = @id
		and (indexname = @indexname or @indexname = 'ALL')
		
		set @id = null
		
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@BlockName, 0, null

	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, 0, null
		break;
	
	end catch		
	
end



end try --Global
begin catch
	set @ErrorMessage = ERROR_MESSAGE()
	exec Grooming.p_LogGroomingAction @run_id, @Sequence out,  @ErrorMessage, @RC, null
	
end catch

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, 'Finished Maintenance', null, null

end
 
GO 

---------- P_GROOMLEGACYQUERYMONITOR.SQL
if (object_id('p_GroomLegacyQueryMonitor') is not null)
begin
drop procedure p_GroomLegacyQueryMonitor
end
go
if (object_id('Grooming.p_GroomLegacyQueryMonitor') is not null)
begin
drop procedure Grooming.p_GroomLegacyQueryMonitor
end
go
create procedure [Grooming].[p_GroomLegacyQueryMonitor]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

if (object_id('QueryMonitor') is null)
	return;

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'LegacyQueryMonitor'
	
set @parms = N'@SQLServerIDIn int,@CutoffDateTimeIn datetime,@RecordsToDelete int'	
	
if (@SQLServerID is not null and @Deleted = 1)
begin
	Set @cmd = N'Declare @KeysToDelete Table (StatementUTCStartTime datetime not null primary key)

				Insert Into @KeysToDelete
				Select Top(@RecordsToDelete) StatementUTCStartTime
				From dbo.QueryMonitorStatistics with(nolock)
				Where SQLServerID = @SQLServerIDIn;
			
				Delete QMS
				From dbo.QueryMonitorStatistics QMS
				Inner Join @KeysToDelete K
					On K.StatementUTCStartTime = QMS.StatementUTCStartTime;';
end	
else
begin
	Set @cmd = N'Declare @KeysToDelete Table (StatementUTCStartTime datetime not null primary key)

				Insert Into @KeysToDelete
				Select Top(@RecordsToDelete) StatementUTCStartTime
				From dbo.QueryMonitorStatistics with(nolock)
				Where DeleteFlag = 1 
				Or StatementText is null 
				Or len(StatementText) = 0 
				Or UTCCollectionDateTime <= @CutoffDateTimeIn;
			
				Delete QMS
				From dbo.QueryMonitorStatistics QMS
				Inner Join @KeysToDelete K
					On K.StatementUTCStartTime = QMS.StatementUTCStartTime;';
end
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		exec sp_executesql @cmd, @parms, @SQLServerIDIn=@SQLServerID,@CutoffDateTimeIn= @CutoffDateTime,@RecordsToDelete = @RecordsToDelete;
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMLOGINNAMES.SQL
if (object_id('Grooming.p_GroomLoginNames') is not null)
begin
drop procedure Grooming.p_GroomLoginNames
end
go
create procedure [Grooming].[p_GroomLoginNames]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'LoginNames'		


if (GetUTCDate() > @TimeoutTime)           
	raiserror (N'Timeout in %s', 11, 1,@BlockName);

     
begin try
	create table #AllList(LoginNameID int primary key clustered)
	insert into #AllList
		select LoginNameID 
		from LoginNames
	
	create table #KeepList(LoginNameID int primary key clustered)
	insert into	#KeepList(LoginNameID)
		select LoginNameID
		from dbo.ActiveWaitStatistics
		where LoginNameID is not null
		union 
		select LoginNameID
		from dbo.QueryMonitorStatistics
		where LoginNameID is not null
		union 
		select LoginNameID
		from dbo.DeadlockProcesses
		where LoginNameID is not null
		union 
		select LoginNameID
		from dbo.BlockingSessionStatistics	
		where LoginNameID is not null
		
	create table #DeleteList(LoginNameID int primary key clustered, deleteGroup int default(0))
	insert into	
		#DeleteList (LoginNameID)
		select allList.LoginNameID
		from #AllList allList
		left outer merge join #KeepList keepList
		on allList.LoginNameID = keepList.LoginNameID 
		where keepList.LoginNameID is null 

	
	drop table #AllList	
	drop table #KeepList
	
end try
begin catch

	set @ErrorMessage = @BlockName + ERROR_MESSAGE()
	exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, null

end catch

 
declare @deleteGroup int
declare @msg nvarchar(2048)
set @deleteGroup = 0
set @RowsAffected = @RecordsToDelete
	
if (select count(*) from #DeleteList) > 0
		begin		
	while @RowsAffected > 0
	begin

	begin try

		set @deleteGroup = @deleteGroup + 1

		update top (@RecordsToDelete) #DeleteList
		set deleteGroup = @deleteGroup
		where deleteGroup = 0
		
		if @@rowcount = 0
		begin
			select @deleteGroup = min(deleteGroup) from #DeleteList
			if @deleteGroup is not null
				begin
					set @msg = 'Retrying Group ' + cast(@deleteGroup as nvarchar(10)) 
					exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@msg, @RC, null
				end
		end
		
		delete top (@RecordsToDelete) loginNames
		from	
			dbo.LoginNames loginNames 
			inner merge join #DeleteList d 
			on loginNames.LoginNameID = d.LoginNameID
		where
			d.deleteGroup = @deleteGroup
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
			
		delete from #DeleteList 
			where deleteGroup = @deleteGroup
			
	end try
	begin catch

		if	error_number() = 547
		begin
			
			set @msg = error_message();
			
			if @msg like '%ActiveWait%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.ActiveWaitStatistics aws on
							d.LoginNameID = aws.LoginNameID;
			
			if @msg like '%QueryMonitor%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.QueryMonitorStatistics qms on
							d.LoginNameID = qms.LoginNameID;
			
			if @msg like '%DeadlockProcesses%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.DeadlockProcesses dp on
							d.LoginNameID = dp.LoginNameID;
			
			if @msg like '%BlockingSession%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.BlockingSessionStatistics bss on
							d.LoginNameID = bss.LoginNameID;
		
						
			set @msg = 'Conflict detected: ' + cast(@@rowcount as nvarchar(10)) + ' rows affected. Will Retry Group ' + cast(@deleteGroup as nvarchar(10)) + ' (' + @msg + ')'
			exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@msg, @RC, null
		end
		else
		begin
			set @ErrorMessage = @BlockName + ERROR_MESSAGE()
			exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, null
			return @RC;
		end
	end catch


	end
end

drop table #DeleteList

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, null

return @RC

end
 
GO 

---------- P_GROOMMETRICMETADATA.SQL
if (object_id('Grooming.p_GroomMetricMetaData') is not null)
begin
drop procedure Grooming.p_GroomMetricMetaData
end
go
create procedure [Grooming].[p_GroomMetricMetaData]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000
)
as
begin

if (not exists(select Metric from MetricMetaData where [Deleted] = 1))
	return;

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)

Declare @KeysToDelete Table (SQLServerID int not null,
							UTCCollectionDateTime datetime not null,
							MetricID int not null,
							primary key(SQLServerID, UTCCollectionDateTime, MetricID))

select @RowsAffected = 0, 
	@RC = 0, 
	@BlockName = N'MetricMetaData';
	
Delete MI From MetricInfo MI
Where Exists (Select 1 from MetricMetaData
			Where [Deleted] = 1
			And Metric = MI.Metric);

set @RowsAffected = @@ROWCOUNT;
set @RC = @RC + @RowsAffected;
		
Delete CCD From CustomCounterDefinition CCD
Where Exists (Select 1 from MetricMetaData
			Where [Deleted] = 1
			And Metric = CCD.Metric);

set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
		Delete From @KeysToDelete;

		Insert Into @KeysToDelete
		Select Top(@RecordsToDelete) SQLServerID, UTCCollectionDateTime, MetricID
		From dbo.CustomCounterStatistics CCS with(nolock)
		Where Exists (Select 1 from MetricMetaData
					Where [Deleted] = 1
					And Metric = CCS.MetricID);
			
		Delete CCS
		From dbo.CustomCounterStatistics CCS
		Inner Join @KeysToDelete K
			On K.SQLServerID = CCS.SQLServerID
				And K.UTCCollectionDateTime = CCS.UTCCollectionDateTime
				And K.MetricID = CCS.MetricID;

		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, null
		break;
	
	end catch
end	

delete from MetricMetaData
	where [Deleted] = 1
	
set @RowsAffected = @@ROWCOUNT
set @RC = @RC + @RowsAffected	
				
exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, null

return @RC

end
 
GO 

---------- P_GROOMMIRRORINGSTATISTICS.SQL
if (object_id('Grooming.p_GroomMirroringStatistics') is not null)
begin
drop procedure Grooming.p_GroomMirroringStatistics
end
go
create procedure [Grooming].[p_GroomMirroringStatistics]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (DatabaseID int not null,
							UTCCollectionDateTime datetime not null,
							primary key(DatabaseID, UTCCollectionDateTime))
select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'MirroringStatistics'
	
if (@SQLServerID is not null)
begin
	Set @cmd = N'Declare @KeysToDelete Table (DatabaseID int not null,
							UTCCollectionDateTime datetime not null,
							primary key(DatabaseID, UTCCollectionDateTime))

				Insert Into @KeysToDelete
				Select Top(@RecordsToDelete) ms.DatabaseID, ms.UTCCollectionDateTime
				From dbo.MirroringStatistics ms with(nolock)
				Inner Join SQLServerDatabaseNames dn with(nolock) on ms.DatabaseID = dn.DatabaseID
				Where dn.SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And ms.UTCCollectionDateTime <= @CutoffDateTimeIn'
				Else N''
				End + N';
			
				Delete MS
				From dbo.MirroringStatistics MS
				Inner Join @KeysToDelete K
					On K.DatabaseID = MS.DatabaseID
						And K.UTCCollectionDateTime = MS.UTCCollectionDateTime;';
	set @parms = N'@SQLServerIDIn int, @CutoffDateTimeIn datetime, @RecordsToDelete int';
				
					
	if @Deleted = 1
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) DatabaseID, UTCCollectionDateTime
			From dbo.MirroringStatistics with(nolock)
			Where UTCCollectionDateTime <= @CutoffDateTime;
			
			Delete MS
			From dbo.MirroringStatistics MS
			Inner Join @KeysToDelete K
				On K.DatabaseID = MS.DatabaseID
					And K.UTCCollectionDateTime = MS.UTCCollectionDateTime;
		end
		else
		begin
			exec sp_executesql @cmd, @parms, @SQLServerIDIn = @SQLServerID, @CutoffDateTimeIn = @CutoffDateTime, @RecordsToDelete = @RecordsToDelete;
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMMONITOREDSQLSERVERS.SQL
if (object_id('Grooming.p_GroomMonitoredSQLServers') is not null)
begin
drop procedure Grooming.p_GroomMonitoredSQLServers
end
go
create procedure [Grooming].[p_GroomMonitoredSQLServers]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin


if (@Deleted = 0)
	return;
	
declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)


select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'MonitoredSQLServers (deleting)'

	
if (GetUTCDate() > @TimeoutTime)           
	raiserror (N'Timeout in %s', 11, 1,@BlockName);
       
begin try
           
	if (@SQLServerID is not null and @Deleted = 1)
	begin
		           
		delete from MonitoredSQLServers 
			where SQLServerID = @SQLServerID
	
	end
	
	set @RowsAffected = @@ROWCOUNT
	set @RC = @RC + @RowsAffected

end try
begin catch

	set @ErrorMessage = @BlockName + ERROR_MESSAGE()
	exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName

end catch


exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMOSSTATISTICS.SQL
if (object_id('Grooming.p_GroomOSStatistics') is not null)
begin
drop procedure Grooming.p_GroomOSStatistics
end
go
create procedure [Grooming].[p_GroomOSStatistics]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (SQLServerID int not null,
							UTCCollectionDateTime datetime not null,
							primary key(SQLServerID, UTCCollectionDateTime))
select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'OSStatistics'
	
if (@SQLServerID is not null)
begin
	Set @cmd = N'Declare @KeysToDelete Table (SQLServerID int not null,
							UTCCollectionDateTime datetime not null,
							primary key(SQLServerID, UTCCollectionDateTime))

				Insert Into @KeysToDelete
				Select Top(@RecordsToDelete) SQLServerID, UTCCollectionDateTime
				From dbo.OSStatistics with(nolock)
				Where SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And UTCCollectionDateTime <= @CutoffDateTime'
				Else N''
				End + N';
			
				Delete OS
				From dbo.OSStatistics OS
				Inner Join @KeysToDelete K
					On K.SQLServerID = OS.SQLServerID
						And K.UTCCollectionDateTime = OS.UTCCollectionDateTime;';
	set @parms = N'@SQLServerIDIn int,@CutoffDateTimeIn datetime,@RecordsToDelete int';	
				
					
	if @Deleted = 1
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) SQLServerID, UTCCollectionDateTime
			From dbo.OSStatistics with(nolock)
			Where UTCCollectionDateTime <= @CutoffDateTime;
			
			Delete OS
			From dbo.OSStatistics OS
			Inner Join @KeysToDelete K
				On K.SQLServerID = OS.SQLServerID
					And K.UTCCollectionDateTime = OS.UTCCollectionDateTime;
		end
		else
		begin
			exec sp_executesql @cmd, @parms, @SQLServerIDIn=@SQLServerID,@CutoffDateTimeIn= @CutoffDateTime,@RecordsToDelete = @RecordsToDelete;
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMPRESCRIPTIVEANALYSISDATA.SQL
if (object_id('Grooming.p_GroomPrescriptiveAnalysisData') is not null)
begin
drop procedure Grooming.p_GroomPrescriptiveAnalysisData
end
go
create procedure [Grooming].[p_GroomPrescriptiveAnalysisData]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 5000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (SQLServerID int not null,
							UTCAnalysisCompleteTime datetime not null,
							primary key(SQLServerID, UTCAnalysisCompleteTime))
select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'PrescriptiveAnalysis'
	
if (@SQLServerID is not null)
begin
	Set @cmd = N'Declare @KeysToDelete Table (SQLServerID int not null,
							UTCAnalysisCompleteTime datetime not null,
							primary key(SQLServerID, UTCAnalysisCompleteTime))
				Insert Into @KeysToDelete
				Select Top(@RecordsToDelete) SQLServerID, UTCAnalysisCompleteTime
				From dbo.PrescriptiveAnalysis with(nolock)
				Where SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And UTCAnalysisCompleteTime <= @CutoffDateTimeIn'
				Else N''
				End + N';
			
				Delete PA
				From dbo.PrescriptiveAnalysis PA
				Inner Join @KeysToDelete K
					On K.SQLServerID = PA.SQLServerID
						And K.UTCAnalysisCompleteTime = PA.UTCAnalysisCompleteTime;';
	set @parms = N'@SQLServerIDIn int,@CutoffDateTimeIn datetime,@RecordsToDelete int';	
				
					
	if @Deleted = 1
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) SQLServerID, UTCAnalysisCompleteTime
			From dbo.PrescriptiveAnalysis with(nolock)
			Where UTCAnalysisCompleteTime <= @CutoffDateTime;
			
			Delete PA
			From dbo.PrescriptiveAnalysis PA
			Inner Join @KeysToDelete K
				On K.SQLServerID = PA.SQLServerID
					And K.UTCAnalysisCompleteTime = PA.UTCAnalysisCompleteTime;
		end
		else
		begin
			exec sp_executesql @cmd, @parms, @SQLServerIDIn=@SQLServerID,@CutoffDateTimeIn= @CutoffDateTime,@RecordsToDelete = @RecordsToDelete;
			
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMQUERYMONITORSTATISTICS.SQL
if (object_id('Grooming.p_GroomQueryMonitorStatistics') is not null)
begin
drop procedure Grooming.p_GroomQueryMonitorStatistics
end
go
create procedure [Grooming].[p_GroomQueryMonitorStatistics]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (StatementUTCStartTime datetime not null)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'QueryMonitorStatistics'
	
if (@SQLServerID is not null)
begin
	Set @cmd = N'Declare @KeysToDelete Table (StatementUTCStartTime datetime not null)

				Insert Into @KeysToDelete
				Select Top(@RecordsToDelete) StatementUTCStartTime
				From dbo.QueryMonitorStatistics with(nolock)
				Where SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And StatementUTCStartTime <= @CutoffDateTimeIn'
				Else N''
				End + N';
			
				Delete QMS
				From dbo.QueryMonitorStatistics QMS
				Inner Join @KeysToDelete K
					On K.StatementUTCStartTime = QMS.StatementUTCStartTime;';
	set @parms = N'@SQLServerIDIn int,@CutoffDateTimeIn datetime,@RecordsToDelete int'	
				
					
	if @Deleted = 1
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) StatementUTCStartTime
			From dbo.QueryMonitorStatistics with(nolock)
			Where StatementUTCStartTime <= @CutoffDateTime;
			
			Delete QMS
			From dbo.QueryMonitorStatistics QMS
			Inner Join @KeysToDelete K
				On K.StatementUTCStartTime = QMS.StatementUTCStartTime;
		end
		else
		begin
			exec sp_executesql @cmd, @parms, @SQLServerIDIn=@SQLServerID,@CutoffDateTimeIn= @CutoffDateTime,@RecordsToDelete = @RecordsToDelete;
		end
		
		
		set @RowsAffected = isnull(@@ROWCOUNT,0)
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMQUERYSIGNATUREAGGREGATION.SQL
if (object_id('Grooming.p_GroomQuerySignatureAggregation') is not null)
begin
drop procedure Grooming.p_GroomQuerySignatureAggregation
end
go
create procedure [Grooming].[p_GroomQuerySignatureAggregation]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (QuerySignatureAggregationID int not null primary key)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'QuerySignatureAggregation'
	
if (@SQLServerID is not null)
begin
	Set @cmd = N'Declare @KeysToDelete Table (QuerySignatureAggregationID int not null primary key)

				Insert Into @KeysToDelete
				Select Top(@RecordsToDelete) QuerySignatureAggregationID
				From dbo.QuerySignatureAggregation with(nolock)
				Where SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And EventUTCStartTime <= @CutoffDateTime'
				Else N''
				End + N';
			
				Delete QSA
				From dbo.QuerySignatureAggregation QSA
				Inner Join @KeysToDelete K
					On K.QuerySignatureAggregationID = QSA.QuerySignatureAggregationID;';
	set @parms = N'@SQLServerIDIn int,@CutoffDateTimeIn datetime,@RecordsToDelete int'	
				
					
	if @Deleted = 1
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) QuerySignatureAggregationID
			From dbo.QuerySignatureAggregation with(nolock)
			Where EventUTCStartTime <= @CutoffDateTime;
			
			Delete QSA
			From dbo.QuerySignatureAggregation QSA
			Inner Join @KeysToDelete K
				On K.QuerySignatureAggregationID = QSA.QuerySignatureAggregationID;
		end
		else
		begin
			exec sp_executesql @cmd, @parms, @SQLServerIDIn=@SQLServerID,@CutoffDateTimeIn= @CutoffDateTime,@RecordsToDelete = @RecordsToDelete;
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMREPLICATIONTOPOLOGY.SQL
if (object_id('Grooming.p_GroomReplicationTopology') is not null)
begin
drop procedure Grooming.p_GroomReplicationTopology
end
go
create procedure [Grooming].[p_GroomReplicationTopology]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'ReplicationTopology'
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		Delete from ReplicationTopology with (tablockx)
		where ReplicationType = 0
		and isnull(LastPublisherSnapshotDateTime,'1/1/1900') <= @CutoffDateTime
		and isnull(LastDistributorSnapshotDateTime, '1/1/1900') <= @CutoffDateTime
		and isnull(LastSubscriberSnapshotDateTime, '1/1/1900') <= @CutoffDateTime

		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected

		Delete from ReplicationTopology with (tablockx)
		where ReplicationType <> 0
		and isnull(LastDistributorSnapshotDateTime, '1/1/1900') <= @CutoffDateTime
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMREPOSITORY.SQL
if (object_id('p_GroomRepository') is not null)
begin
drop procedure p_GroomRepository
end
go
 
GO 

---------- P_GROOMREPOSITORYDATA.SQL

if (object_id('Grooming.p_GroomRepositoryData') is not null)
begin
drop procedure Grooming.p_GroomRepositoryData
end
go
create procedure [Grooming].[p_GroomRepositoryData]
AS
begin

set nocount on

declare @ActivityCutoff datetime
declare @DeleteCount bigint
declare @RowsAffected int
declare @run_id uniqueidentifier	
declare @Sequence int	
declare @RC int
declare @InstanceName nvarchar(256)

declare @TimeoutMinutes int
declare @TimeoutTime DateTime	
declare @ErrorMessage nvarchar(2048)
declare @RecordsToDelete int

declare @SQLServerID int
declare @Active bit
declare @Deleted bit
declare @GroomActivity int
declare @GroomAlerts int
declare @GroomMetrics int
declare @GroomTasks int
declare @ActivityDays int
declare @AlertsDays int
declare @MetricsDays int 
declare @TasksDays int
declare @StartTime int
declare @SubDayType int
declare @AllowScheduleChange bit
declare @AgentIsRunning bit
declare @JobIsRunning bit
declare @RepositoryTime DateTime
declare @AlertCutoff DateTime
declare @MetricCutoff DateTime
declare @TaskCutoff DateTime
declare @Now DateTime
declare @LastReorg DateTime
declare @LastRunTime int
declare @LastRunDate int
declare @LastRunOutcome int
declare @QueriesOut int
declare @AggregationStartTime int
declare @AggregationSubDayType int
declare @AggregationAllowScheduleChange bit
declare @AggregationJobIsRunning bit
declare @AggregationLastRunDate int
declare @AggregationLastRunTime int
declare @AggregationLastRunOutcome int
declare @AuditDays int
declare @AuditCutoff DateTime
declare @GroomAudit int
-- START : SQLdm 10.0 (srishti) To support grooming
declare @PADays int
declare @PrescriptiveAnalysisCutoff DateTime
declare @GroomPrescriptiveAnalysis int
-- END : SQLdm 10.0 (srishti) To support grooming
--Start- SQLdm 9.0 - Grooming Time out- Declared the currdate variable and initialized with the current date time
declare @currDate datetime 
SET @currDate=getutcdate()
--End- SQLdm 9.0 - Grooming Time out- Declared the currdate variable and initialized with the current date time

set @run_id = newid()
set @DeleteCount = 0
set @Sequence = 0;

--Start- SQLdm 9.0 - Grooming Time out- Declared the table to collect already groomed Instance's ids and shifted the @groomingServers table declaration before TRY starts
declare @GroomedServerIds
	table( SQLServerID int)

declare @GroomingServers
	table(
	RowID int identity,
	SQLServerID int,
	InstanceName nvarchar(256), 
	Active bit,
	Deleted bit,
	GroomActivity int,
	GroomAlerts int,
	GroomMetrics int,
	GroomTasks int,
	GroomAudit int,
	GroomPrescriptiveAnalysis int)	
--End- SQLdm 9.0 - Grooming Time out- Declared the table to collect already groomed Instance's ids and shifted the @groomingServers table declaration before TRY starts

begin try --Global


-- Get the age in days at which alerts, metrics, and tasks should be deleted
-- and convert those ages to DateTimes relative to now.  These are defaults
-- that may be overridden on a per-server basis.
exec [p_GetGrooming] 
	@ActivityDays output, 
	@AlertsDays output, 
	@MetricsDays output, 
	@TasksDays output, 
	@StartTime output,
	@SubDayType output,
	@AllowScheduleChange output, 
	@AgentIsRunning output, 
	@JobIsRunning output, 
	@RepositoryTime output,
	@TimeoutMinutes output,
	@LastRunDate output,
	@LastRunTime output,
	@LastRunOutcome output,
	@QueriesOut output,
	@AggregationStartTime output,
	@AggregationSubDayType output,
	@AggregationAllowScheduleChange output,
	@AggregationJobIsRunning output,
	@AggregationLastRunDate output,
	@AggregationLastRunTime output,
	@AggregationLastRunOutcome output,
	@AuditDays output,
	@PADays output

	
select @Now = getutcdate()
set @TimeoutTime = dateadd(mi,@TimeoutMinutes,@Now)

exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,'Started', null, null

exec Grooming.p_GroomGroomingLog
	@run_id = @run_id,
	@Sequence = @Sequence out,
	@TimeoutTime = @TimeoutTime,
	@RecordsToDelete = 1000
	

insert into @GroomingServers (SQLServerID, InstanceName, Active, Deleted, GroomActivity, GroomAlerts, GroomMetrics, GroomTasks, GroomAudit, GroomPrescriptiveAnalysis )
select 
	SQLServerID, 
	InstanceName, 
	Active, 
	Deleted, 
	GroomActivity, 
	GroomAlerts, 
	GroomMetrics, 
	GroomTasks,
	GroomAudit,
	GroomPrescriptiveAnalysis
from MonitoredSQLServers 
	
		
if not exists(
	select SQLServerID from @GroomingServers 
	where GroomActivity > -1 or GroomAlerts > -1 or GroomMetrics > -1 or GroomTasks > -1 or GroomAudit > -1 or GroomPrescriptiveAnalysis > -1)
begin
	delete from @GroomingServers where Deleted = 0
	insert into @GroomingServers(SQLServerID, InstanceName, Active, Deleted, GroomActivity, GroomAlerts, GroomMetrics, GroomTasks,GroomAudit, GroomPrescriptiveAnalysis ) 
		select null,null,1,0,-1,-1,-1,-1,-1,-1
end

declare @LoopRowID int

select @LoopRowID = max(RowID) from @GroomingServers

while isnull(@LoopRowID,0) > 0
begin

	select @Deleted = Deleted from @GroomingServers where RowID = @LoopRowID
	
	

	-- Each active server can override the default age cutoff as follows.  
	-- If the server value = -1, use the global default determined above.  
	-- If the server value > -1, use the server value instead of the default.
	-- If the server value < -1, do not groom that server.  
	-- All tasks, alerts, and events are deleted for inactive servers.  
	-- Left joins are used in the DELETEs to groom rows that are somehow not 
	-- associated with any server.  

	select @ActivityCutoff = dateadd(day, -@ActivityDays, @Now)
	select @AlertCutoff = dateadd(day, -@AlertsDays, @Now)
	select @MetricCutoff = dateadd(day, -@MetricsDays, @Now)
	select @TaskCutoff = dateadd(day, -@TasksDays, @Now)
	select @AuditCutoff = dateadd(day, -@AuditDays, @Now)
	select @PrescriptiveAnalysisCutoff = dateadd(day, -@PADays, @Now)
	
	
	select 
		@SQLServerID = SQLServerID,
		@InstanceName = InstanceName,
		@GroomActivity = GroomActivity,
		@GroomAlerts = GroomAlerts,
		@GroomTasks = GroomTasks, 
		@GroomMetrics = GroomMetrics,
		@Active = Active,
		@GroomAudit = GroomAudit,
		@GroomPrescriptiveAnalysis = GroomPrescriptiveAnalysis
	from @GroomingServers where RowID = @LoopRowID		
	
	if (@Deleted = 0)
	begin
		if (@GroomActivity > -1)
			select @ActivityCutoff = dateadd(day, -@GroomActivity, @Now)
		if (@GroomAlerts > -1)
			select @AlertCutoff = dateadd(day, -@GroomAlerts, @Now)
		if (@GroomTasks > -1)
			select @TaskCutoff = dateadd(day, -@GroomTasks, @Now)
		if (@GroomMetrics > -1)
			select @MetricCutoff = dateadd(day, -@GroomMetrics, @Now)
		if (@GroomAudit > -1)
			select @AuditCutoff = dateadd(day, -@GroomAudit, @Now)
		if (@GroomPrescriptiveAnalysis > -1)
			select @PrescriptiveAnalysisCutoff = dateadd(day, -@GroomPrescriptiveAnalysis, @Now)
			
	end

	
	if (@GroomTasks >= -1 or @Deleted = 1)
	begin

	-- Tasks
	
		exec @RC = Grooming.p_GroomTasks
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @TaskCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Active -- Different for this table	
			
		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 

	end
	else -- Not grooming Tasks
	begin
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,'Skipping Tasks grooming', null, @InstanceName
	end
	
	if (@GroomAlerts >= -1 or @Deleted = 1)
	begin
	
	-- Alerts
	
		exec @RC = Grooming.p_GroomAlerts
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @AlertCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	
			
		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 
	
	end
	else -- Not grooming Alerts
	begin
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,'Skipping Alerts grooming', null, @InstanceName
	end

	if (@GroomAudit >= -1 or @Deleted = 1)
	begin 
		-- AuditedEvents

		exec @RC = Grooming.p_GroomAuditedEvents
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @AuditCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 
	end
	else -- Not grooming Alerts
	begin
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,'Skipping Audit grooming', null, @InstanceName
	end

	if (@GroomPrescriptiveAnalysis >= -1 or @Deleted = 1)
	begin 
		-- AuditedEvents

		exec @RC = Grooming.p_GroomPrescriptiveAnalysisData
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @PrescriptiveAnalysisCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 
	end
	else -- Not grooming Alerts
	begin
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,'Skipping Prescriptive Analysis grooming', null, @InstanceName
	end

	if (@GroomMetrics >= -1 or @Deleted = 1)
	begin
	-- OSStatistics
	
		exec @RC = Grooming.p_GroomOSStatistics
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @MetricCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 
		
	-- ServerStatistics

		exec @RC = Grooming.p_GroomServerStatistics
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @MetricCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 
		
	-- DiskDrives

		exec @RC = Grooming.p_GroomDiskDrives
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @MetricCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 

	--START SQLdm 9.1 (Ankit Srivastava) -- Filegroup and Mount Point Monitoring Improvements -- calling new procedure to groom disk drive stats
	exec @RC = Grooming.p_GroomDiskDriveStatistics
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @MetricCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 
	--END SQLdm 9.1 (Ankit Srivastava) -- Filegroup and Mount Point Monitoring Improvements -- calling new procedure to groom disk drive stats

	if (object_id('DatabaseStatistics_upgrade') is not null)
	begin
	
		exec @RC = Grooming.p_GroomDatabaseStatistics_upgrade
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @MetricCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 
	end
		
	-- DatabaseStatistics
	
		exec @RC = Grooming.p_GroomDatabaseStatistics
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @MetricCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 
		
	-- stageDatabaseStatistics
		declare @Yesterday datetime
		select @Yesterday = dateadd(d,-1,getdate())
		exec @RC = Grooming.p_GroomDatabaseStatisticsStaging
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 1000,
			@CutoffDateTime = @Yesterday,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 			
	
	-- DatabaseSize
	
		exec @RC = Grooming.p_GroomDatabaseSize
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @MetricCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 
		
	-- DatabaseFiles
	
		exec @RC = Grooming.p_GroomDatabaseFiles
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @MetricCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 
	
	
	-- MirroringStatistics
	
		exec @RC = Grooming.p_GroomMirroringStatistics
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @MetricCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 
	
	-- ReplicationTopology
	
		exec @RC = Grooming.p_GroomReplicationTopology
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @MetricCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 
		
	-- TableGrowth
	
		exec @RC = Grooming.p_GroomTableGrowth
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @MetricCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		
	-- TableReorganization
	
		exec @RC = Grooming.p_GroomTableReorganization
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @MetricCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 
		
	-- CustomCounterStatistics
	
		exec @RC = Grooming.p_GroomCustomCounterStatistics
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @MetricCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 

	
	-- Blocks (This will clear all parented blocking sessions too)
	
		exec @RC = Grooming.p_GroomBlocks
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @MetricCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted		
			
	-- BlockingSessionStatistics
	
		exec @RC = Grooming.p_GroomBlockingSessionStatistics
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @MetricCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 	
		
	-- VMConfigData
	
		exec @RC = Grooming.p_GroomVMConfigData
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @MetricCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 			
		
		
		
	-- ESXConfigData
	
		exec @RC = Grooming.p_GroomESXConfigData
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @MetricCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 	
	
	-- VMStatistics
	
		exec @RC = Grooming.p_GroomVMStatistics
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @MetricCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 			

	-- ESXStatistics
	
		exec @RC = Grooming.p_GroomESXStatistics
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @MetricCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 		
		
	-- BaselineStatistics
		
		exec @RC = Grooming.p_GroomBaselineStatistics	
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @MetricCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 	

	--AlwaysOnStatistics

		exec @RC = Grooming.p_GroomAlwaysOnStatistics
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,  --I made the limit 5000 because there are no foreign keys and this is only captured once per server and only for SQL Server 2012+
			@CutoffDateTime = @MetricCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC		
		select @RC = 0 
	end
	else -- Not grooming Metrics
	begin
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,'Skipping Metrics grooming', null, @InstanceName
	end
	
	
	if (@GroomActivity >= -1 or @Deleted = 1)
	begin
	
	
		-- TempdbFileData

		exec @RC = Grooming.p_GroomTempdbFileData
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @ActivityCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 
		
		
		-- ServerActivity	
		exec @RC = Grooming.p_GroomServerActivity 
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 1000,
			@CutoffDateTime = @ActivityCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 

		-- Legacy Query Monitor
		
		exec @RC = Grooming.p_GroomLegacyQueryMonitor 
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 1000,
			@CutoffDateTime = @ActivityCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 

		-- QueryMonitorStatistics
		exec @RC = Grooming.p_GroomQueryMonitorStatistics
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 3000,
			@CutoffDateTime = @ActivityCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	
			
		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 


	-- QuerySignatureAggregation

		exec @RC = Grooming.p_GroomQuerySignatureAggregation
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 3000,
			@CutoffDateTime = @ActivityCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	
			
		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 
		
	-- Deadlocks 

		exec @RC = Grooming.p_GroomDeadlocks
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 1000,
			@CutoffDateTime = @ActivityCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	
			
		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 
		
	-- WaitStatistics

		exec @RC = Grooming.p_GroomWaitStatistics
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 1000,
			@CutoffDateTime = @ActivityCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	
			
		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 
	
	--  ActiveWaitStatistics
	
		exec @RC = Grooming.p_GroomActiveWaitStatistics
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 1000,
			@CutoffDateTime = @ActivityCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	
			
		select @DeleteCount = @DeleteCount + @RC
		select @RC = 0 
		
		-- DatabaseFileActivity

		exec @RC = Grooming.p_GroomDatabaseFileActivity
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@RecordsToDelete = 5000,
			@CutoffDateTime = @ActivityCutoff,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	

		select @DeleteCount = @DeleteCount + @RC
	end
	else -- Not grooming Activity
	begin
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,'Skipping Activity grooming', null, @InstanceName
	end


	-- MonitoredSQLServers	
	if (@SQLServerID is not null and @Deleted = 1)
	begin
		exec @RC = Grooming.p_GroomMonitoredSQLServers
			@run_id = @run_id,
			@Sequence = @Sequence out,
			@TimeoutTime = @TimeoutTime,
			@SQLServerID = @SQLServerID,
			@InstanceName = @InstanceName,
			@Deleted = @Deleted	
	end
	
	select @Deleted = Deleted from @GroomingServers where RowID = @LoopRowID
	
	INSERT INTO @GroomedServerIds Select SQLServerID from @GroomingServers where RowID = @LoopRowID -- SQLdm 9.0 (Ankit Srivastava) collect the Server IDs which are groomed successfully
	delete from @GroomingServers where RowID = @LoopRowID
	select @LoopRowID = max(RowID) from @GroomingServers
end	

-- Global Tasks
	
	exec @RC = Grooming.p_GroomTasks
		@run_id = @run_id,
		@Sequence = @Sequence out,
		@TimeoutTime = @TimeoutTime,
		@RecordsToDelete = 5000,
		@CutoffDateTime = @TasksDays,
		@SQLServerID = -1
		
	select @DeleteCount = @DeleteCount + @RC
	select @RC = 0 
	
-- Global Alerts

	exec @RC = Grooming.p_GroomAlerts
		@run_id = @run_id,
		@Sequence = @Sequence out,
		@TimeoutTime = @TimeoutTime,
		@RecordsToDelete = 5000,
		@CutoffDateTime = @AlertsDays,
		@SQLServerID = -1
		
	select @DeleteCount = @DeleteCount + @RC
	select @RC = 0 

end try --Global
begin catch

	set @ErrorMessage = ERROR_MESSAGE()
	exec Grooming.p_LogGroomingAction @run_id, @Sequence out,  @ErrorMessage, @RC, @InstanceName	

-- Start - SQLdm 9.0 (Ankit Srivastava) - Grooming Time out -- Logging the status and message of failed Instances
	Declare @isPrimary bit
	Select @isPrimary=1

	WHILE EXISTS (Select * from @GroomingServers)
	BEGIN
	
		exec [dbo].[p_AddLatestGroomingStatus] @SQLServerID,@run_id,@currDate,0,@ErrorMessage,@isPrimary

		Delete from @GroomingServers where SQLServerID=@SQLServerID or SQLServerID is null

		Select @SQLServerID=max(SQLServerID) from @GroomingServers where SQLServerID is not null
		Select @isPrimary=0
	END
-- End - SQLdm 9.0 (Ankit Srivastava) - Grooming Time out -- Logging the status and message of failed Instances

end catch

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, 'Finished Metrics', @DeleteCount, @InstanceName

-- Start - SQLdm 9.0 (Ankit Srivastava) - Grooming Time out -- Logging the Grooming status of successfully groomed Instances

	WHILE EXISTS (Select * from @GroomedServerIds)
	BEGIN
		Select @SQLServerID=max(SQLServerID) from @GroomedServerIds where SQLServerID is not null

		if exists(Select * from MonitoredSQLServers where SQLServerID=@SQLServerID)
		begin
			exec [dbo].[p_AddLatestGroomingStatus] @SQLServerID,@run_id,@currDate,1,'Grooming Completed successfully',1
		end
		else
		begin
			DELETE FROM LatestGroomingStatus where SQLServerID=@SQLServerID or SQLServerID is null
		end

		Delete from @GroomedServerIds where SQLServerID=@SQLServerID or SQLServerID is null
	END
-- End - SQLdm 9.0 (Ankit Srivastava) - Grooming Time out -- Logging the Grooming status of successfully groomed Instances

end
 
GO 

---------- P_GROOMREPOSITORYORPHANDATA.SQL
if (object_id('Grooming.p_GroomRepositoryOrphanData') is not null)
begin
drop procedure Grooming.p_GroomRepositoryOrphanData
end
go
create procedure [Grooming].[p_GroomRepositoryOrphanData]
AS
begin

set nocount on

declare @StartTime datetime
declare @TimeoutTime datetime
declare @TimeoutMinutes int
declare @run_id uniqueidentifier
declare @Sequence int
declare @DeleteCount int
declare @RC int
declare @ErrorMessage nvarchar(2048)

set @DeleteCount = 0

begin try --Global

select 
	@StartTime = isnull(UTCActionEndDateTime,getutcdate()),
	@run_id = isnull(RunID,newid())
from 
GroomingLog
where UTCActionEndDateTime = 
	(select 
		max (UTCActionEndDateTime) 
	from 
	GroomingLog
	where Action = 'Started')
	
select @Sequence = max(Sequence) from GroomingLog where RunID = @run_id	

select @TimeoutMinutes = isnull(Internal_Value,180) from RepositoryInfo where [Name] = 'GroomingMaxNumberMinutes'	

set @TimeoutTime = dateadd(mi,@TimeoutMinutes,@StartTime)

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, 'Starting Orphans', null, null

-- HostNames
exec @RC = Grooming.p_GroomHostNames
	@run_id = @run_id,
	@Sequence = @Sequence out,
	@TimeoutTime = @TimeoutTime,
	@RecordsToDelete = 5000

select @DeleteCount = @DeleteCount + @RC
select @RC = 0 	
	
-- ApplicationNames
exec @RC = Grooming.p_GroomApplicationNames
	@run_id = @run_id,
	@Sequence = @Sequence out,
	@TimeoutTime = @TimeoutTime,
	@RecordsToDelete = 5000
	
-- LoginNames
exec @RC = Grooming.p_GroomLoginNames
	@run_id = @run_id,
	@Sequence = @Sequence out,
	@TimeoutTime = @TimeoutTime,
	@RecordsToDelete = 5000	

select @DeleteCount = @DeleteCount + @RC
select @RC = 0 

-- MetricMetaData
exec @RC = Grooming.p_GroomMetricMetaData
	@run_id = @run_id,
	@Sequence = @Sequence out,
	@TimeoutTime = @TimeoutTime,
	@RecordsToDelete = 1000	

select @DeleteCount = @DeleteCount + @RC
select @RC = 0 

-- SQLSignatures
exec @RC = Grooming.p_GroomSQLSignatures
	@run_id = @run_id,
	@Sequence = @Sequence out,
	@TimeoutTime = @TimeoutTime,
	@RecordsToDelete = 1000	

select @DeleteCount = @DeleteCount + @RC
select @RC = 0 

-- SQLStatements
exec @RC = Grooming.p_GroomSQLStatements
	@run_id = @run_id,
	@Sequence = @Sequence out,
	@TimeoutTime = @TimeoutTime,
	@RecordsToDelete = 1000	

select @DeleteCount = @DeleteCount + @RC
select @RC = 0 


-- DatabaseNames
exec @RC = Grooming.p_GroomDatabaseNames
	@run_id = @run_id,
	@Sequence = @Sequence out,
	@TimeoutTime = @TimeoutTime,
	@RecordsToDelete = 1000	

select @DeleteCount = @DeleteCount + @RC
select @RC = 0 

-- BaselineTemplates
exec @RC = Grooming.p_GroomBaselineTemplates
	@run_id = @run_id,
	@Sequence = @Sequence out,
	@TimeoutTime = @TimeoutTime,
	@RecordsToDelete = 1000	

select @DeleteCount = @DeleteCount + @RC
select @RC = 0 

-- Metric Threshold Instances
delete from MetricThresholdInstances 
	where InstanceID not in (select distinct ThresholdInstanceID from MetricThresholds)

set @RC = @@ROWCOUNT
select @DeleteCount = @DeleteCount + @RC
select @RC = 0		


end try --Global
begin catch
	set @ErrorMessage = ERROR_MESSAGE()
	exec Grooming.p_LogGroomingAction @run_id, @Sequence out,  @ErrorMessage, @RC, null
	
end catch

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, 'Finished Orphans', @DeleteCount, null


end
 
GO 

---------- P_GROOMSERVERACTIVITY.SQL
if (object_id('Grooming.p_GroomServerActivity') is not null)
begin
drop procedure Grooming.p_GroomServerActivity
end
go
create procedure [Grooming].[p_GroomServerActivity]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (SQLServerID int not null,
							UTCCollectionDateTime datetime not null,
							primary key(SQLServerID, UTCCollectionDateTime))

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'ServerActivity'
	
if (@SQLServerID is not null)
begin
	Set @cmd = N'Declare @KeysToDelete Table (SQLServerID int not null,
							UTCCollectionDateTime datetime not null,
							primary key(SQLServerID, UTCCollectionDateTime))

				Insert Into @KeysToDelete
				Select Top(@RecordsToDelete) SQLServerID, UTCCollectionDateTime
				From dbo.ServerActivity with(nolock)
				Where SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And UTCCollectionDateTime <= @CutoffDateTime'
				Else N''
				End + N';
			
				Delete SS
				From dbo.ServerActivity SS
				Inner Join @KeysToDelete K
					On K.SQLServerID = SS.SQLServerID
						And K.UTCCollectionDateTime = SS.UTCCollectionDateTime;';
	set @parms = N'@SQLServerIDIn int,@CutoffDateTimeIn datetime,@RecordsToDelete int'	
				
					
	if @Deleted = 1
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) SQLServerID, UTCCollectionDateTime
			From dbo.ServerActivity with(nolock)
			Where UTCCollectionDateTime <= @CutoffDateTime;
			
			Delete SA
			From dbo.ServerActivity SA
			Inner Join @KeysToDelete K
				On K.SQLServerID = SA.SQLServerID
					And K.UTCCollectionDateTime = SA.UTCCollectionDateTime;
		end
		else
		begin
			exec sp_executesql @cmd, @parms, @SQLServerIDIn=@SQLServerID,@CutoffDateTimeIn= @CutoffDateTime,@RecordsToDelete = @RecordsToDelete;
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMSERVERSTATISTICS.SQL
if (object_id('Grooming.p_GroomServerStatistics') is not null)
begin
drop procedure Grooming.p_GroomServerStatistics
end
go
create procedure [Grooming].[p_GroomServerStatistics]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (SQLServerID int not null,
							UTCCollectionDateTime datetime not null,
							primary key(SQLServerID, UTCCollectionDateTime))

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'ServerStatistics'
	
if (@SQLServerID is not null)
begin
	Set @cmd = N'Declare @KeysToDelete Table (SQLServerID int not null,
							UTCCollectionDateTime datetime not null,
							primary key(SQLServerID, UTCCollectionDateTime))

				Insert Into @KeysToDelete
				Select Top(@RecordsToDelete) SQLServerID, UTCCollectionDateTime
				From dbo.ServerStatistics with(nolock)
				Where SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And UTCCollectionDateTime <= @CutoffDateTime'
				Else N''
				End + N';
			
				Delete SS
				From dbo.ServerStatistics SS
				Inner Join @KeysToDelete K
					On K.SQLServerID = SS.SQLServerID
						And K.UTCCollectionDateTime = SS.UTCCollectionDateTime;';
	set @parms = N'@SQLServerIDIn int,@CutoffDateTimeIn datetime,@RecordsToDelete int'	
				
					
	if @Deleted = 1
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) SQLServerID, UTCCollectionDateTime
			From dbo.ServerStatistics with(nolock)
			Where UTCCollectionDateTime <= @CutoffDateTime;
			
			Delete SS
			From dbo.ServerStatistics SS
			Inner Join @KeysToDelete K
				On K.SQLServerID = SS.SQLServerID
					And K.UTCCollectionDateTime = SS.UTCCollectionDateTime;
		end
		else
		begin
			exec sp_executesql @cmd, @parms, @SQLServerIDIn=@SQLServerID,@CutoffDateTimeIn= @CutoffDateTime,@RecordsToDelete = @RecordsToDelete;
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMSQLSIGNATURES.SQL
if (object_id('Grooming.p_GroomSQLSignatures') is not null)
begin
drop procedure Grooming.p_GroomSQLSignatures
end
go
create procedure [Grooming].[p_GroomSQLSignatures]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'SQLSignatures'		
			

if (GetUTCDate() > @TimeoutTime)           
	raiserror (N'Timeout in %s', 11, 1,@BlockName);
       
begin try
	create table #AllList(SQLSignatureID int primary key clustered)
	insert into #AllList
		select SQLSignatureID 
		from SQLSignatures
	
	create table #KeepList(SQLSignatureID int primary key clustered)
	insert into	#KeepList(SQLSignatureID)
		select SQLSignatureID
		from dbo.ActiveWaitStatistics
		where SQLSignatureID is not null
		union 
		select SQLSignatureID
		from dbo.QueryMonitorStatistics
		where SQLSignatureID is not null
		union 
		select SQLSignatureID
		from dbo.DeadlockProcesses
		where SQLSignatureID is not null
		union 
		select SQLSignatureID
		from BlockingSessionStatistics
		where SQLSignatureID is not null
		union 
		select SQLSignatureID
		from dbo.QuerySignatureAggregation
		where SQLSignatureID is not null
		
	create table #DeleteList(SQLSignatureID int primary key clustered, deleteGroup int default(0))
	insert into	
		#DeleteList (SQLSignatureID)
		select allList.SQLSignatureID
		from #AllList allList
		left outer merge join #KeepList keepList
		on allList.SQLSignatureID = keepList.SQLSignatureID 
		where keepList.SQLSignatureID is null 

	
	drop table #AllList	
	drop table #KeepList
	
end try
begin catch

	set @ErrorMessage = @BlockName + ERROR_MESSAGE()
	exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, null

end catch


declare @deleteGroup int
declare @msg nvarchar(2048)
set @deleteGroup = 0
set @RowsAffected = @RecordsToDelete
	
if (select count(*) from #DeleteList) > 0
		begin		
	while @RowsAffected > 0
	begin

	begin try

		set @deleteGroup = @deleteGroup + 1

		update top (@RecordsToDelete) #DeleteList
		set deleteGroup = @deleteGroup
		where deleteGroup = 0
		
		if @@rowcount = 0
		begin
			select @deleteGroup = min(deleteGroup) from #DeleteList
			if @deleteGroup is not null
				begin
					set @msg = 'Retrying Group ' + cast(@deleteGroup as nvarchar(10)) 
					exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@msg, @RC, null
				end
		end
		
		delete top (@RecordsToDelete) sigs
		from	
			dbo.SQLSignatures sigs 
			inner merge join #DeleteList d 
			on sigs.SQLSignatureID = d.SQLSignatureID
		where
			d.deleteGroup = @deleteGroup
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
			
		delete from #DeleteList 
			where deleteGroup = @deleteGroup
			
	end try
	begin catch

		if	error_number() = 547
		begin
			
			set @msg = error_message();
			
			if @msg like '%ActiveWait%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.ActiveWaitStatistics aws on
							d.SQLSignatureID = aws.SQLSignatureID;
			
			if @msg like '%QueryMonitor%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.QueryMonitorStatistics qms on
							d.SQLSignatureID = qms.SQLSignatureID;
			
			if @msg like '%DeadlockProcesses%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.DeadlockProcesses dp on
							d.SQLSignatureID = dp.SQLSignatureID;
			
			if @msg like '%BlockingSession%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.BlockingSessionStatistics bss on
							d.SQLSignatureID = bss.SQLSignatureID;
		
			if @msg like '%QuerySignature%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.QuerySignatureAggregation qsa on
							d.SQLSignatureID = qsa.SQLSignatureID;		
							
			set @msg = 'Conflict detected: ' + cast(@@rowcount as nvarchar(10)) + ' rows affected. Will Retry Group ' + cast(@deleteGroup as nvarchar(10)) + ' (' + @msg + ')'
			exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@msg, @RC, null
		end
		else
		begin
			set @ErrorMessage = @BlockName + ERROR_MESSAGE()
			exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, null
			return @RC;
		end
	end catch


	end
end

drop table #DeleteList
	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, null

return @RC

end

 
GO 

---------- P_GROOMSQLSTATEMENTS.SQL
if (object_id('Grooming.p_GroomSQLStatements') is not null)
begin
drop procedure Grooming.p_GroomSQLStatements
end
go
create procedure [Grooming].[p_GroomSQLStatements]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'SQLStatements'		

	
if (GetUTCDate() > @TimeoutTime)           
	raiserror (N'Timeout in %s', 11, 1,@BlockName);
	
      
begin try
	create table #AllList(SQLStatementID int primary key clustered)
	insert into #AllList
		select SQLStatementID 
		from SQLStatements
	
	create table #KeepList(SQLStatementID int primary key clustered)
	insert into	#KeepList(SQLStatementID)
		select SQLStatementID
		from ActiveWaitStatistics
		where SQLStatementID is not null
		union 
		select SQLStatementID
		from QueryMonitorStatistics
		where SQLStatementID is not null
		union 
		select SQLStatementID
		from DeadlockProcesses
		where SQLStatementID is not null
		union 
		select SQLStatementID
		from BlockingSessionStatistics
		where SQLStatementID is not null
		
	create table #DeleteList(SQLStatementID int primary key clustered, deleteGroup int default(0))
	insert into	
		#DeleteList (SQLStatementID)
		select allList.SQLStatementID
		from #AllList allList
		left outer merge join #KeepList keepList
		on allList.SQLStatementID = keepList.SQLStatementID 
		where keepList.SQLStatementID is null 

	
	drop table #AllList	
	drop table #KeepList
	
end try
begin catch

	set @ErrorMessage = @BlockName + ERROR_MESSAGE()
	exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, null

end catch
	
 
declare @deleteGroup int
declare @msg nvarchar(2048)
set @deleteGroup = 0
set @RowsAffected = @RecordsToDelete
	
if (select count(*) from #DeleteList) > 0
		begin		
	while @RowsAffected > 0
	begin

	begin try

		set @deleteGroup = @deleteGroup + 1

		update top (@RecordsToDelete) #DeleteList
		set deleteGroup = @deleteGroup
		where deleteGroup = 0
		
		if @@rowcount = 0
		begin
			select @deleteGroup = min(deleteGroup) from #DeleteList
			if @deleteGroup is not null
				begin
					set @msg = 'Retrying Group ' + cast(@deleteGroup as nvarchar(10)) 
					exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@msg, @RC, null
				end
		end
		
		delete top (@RecordsToDelete) stmts
		from	
			dbo.SQLStatements stmts 
			inner merge join #DeleteList d 
			on stmts.SQLStatementID = d.SQLStatementID
		where
			d.deleteGroup = @deleteGroup

		--SQLdm 9.0 (Ankit Srivastava) -- Query Plan Collection -- Grooming of Query Plans - start
		delete top (@RecordsToDelete) plans
		from
			dbo.SQLQueryPlans plans
			inner merge join #DeleteList d 
			on plans.SQLStatementID = d.SQLStatementID
			
		where
			d.deleteGroup = @deleteGroup
		--SQLdm 9.0 (Ankit Srivastava) -- Query Plan Collection -- Grooming of Query Plans - end

		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
			
		delete from #DeleteList 
			where deleteGroup = @deleteGroup
			
	end try
	begin catch

		if	error_number() = 547
		begin
			
			set @msg = error_message();
			
			if @msg like '%ActiveWait%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.ActiveWaitStatistics aws on
							d.SQLStatementID = aws.SQLStatementID;
			
			if @msg like '%QueryMonitor%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.QueryMonitorStatistics qms on
							d.SQLStatementID = qms.SQLStatementID;
			
			if @msg like '%DeadlockProcesses%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.DeadlockProcesses dp on
							d.SQLStatementID = dp.SQLStatementID;
			
			if @msg like '%BlockingSession%'
					delete #DeleteList
					from #DeleteList d
					inner merge join
						dbo.BlockingSessionStatistics bss on
							d.SQLStatementID = bss.SQLStatementID;
		
							
			set @msg = 'Conflict detected: ' + cast(@@rowcount as nvarchar(10)) + ' rows affected. Will Retry Group ' + cast(@deleteGroup as nvarchar(10)) + ' (' + @msg + ')'
			exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@msg, @RC, null
		end
		else
		begin
			set @ErrorMessage = @BlockName + ERROR_MESSAGE()
			exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, null
			return @RC;
		end
	end catch


	end
end

drop table #DeleteList

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, null

return @RC

end



 
GO 

---------- P_GROOMTABLEGROWTH.SQL
if (object_id('Grooming.p_GroomTableGrowth') is not null)
begin
drop procedure Grooming.p_GroomTableGrowth
end
go
create procedure [Grooming].[p_GroomTableGrowth]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (TableID int not null,
							UTCCollectionDateTime datetime not null,
							primary key(TableID, UTCCollectionDateTime))
select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'TableGrowth'
	
if (@SQLServerID is not null)
begin
	Set @cmd = N'Declare @KeysToDelete Table (TableID int not null,
							UTCCollectionDateTime datetime not null,
							primary key(TableID, UTCCollectionDateTime))

				Insert Into @KeysToDelete
				Select Top(@RecordsToDelete) tgt.TableID, tgt.UTCCollectionDateTime
				From dbo.TableGrowth tgt with(nolock)
				Inner Join SQLServerTableNames tn (nolock) on tgt.TableID = tn.TableID
				Inner Join SQLServerDatabaseNames dn (nolock) on tn.DatabaseID = dn.DatabaseID
				Where dn.SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And tgt.UTCCollectionDateTime <= @CutoffDateTimeIn'
				Else N''
				End + N';
			
				Delete TG
				From dbo.TableGrowth TG
				Inner Join @KeysToDelete K
					On K.TableID = TG.TableID
						And K.UTCCollectionDateTime = TG.UTCCollectionDateTime;';
	set @parms = N'@SQLServerIDIn int, @CutoffDateTimeIn datetime, @RecordsToDelete int'	
				
					
	if @Deleted = 1
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) TableID, UTCCollectionDateTime
			From dbo.TableGrowth with(nolock)
			Where UTCCollectionDateTime <= @CutoffDateTime;
			
			Delete TG
			From dbo.TableGrowth TG
			Inner Join @KeysToDelete K
				On K.TableID = TG.TableID
					And K.UTCCollectionDateTime = TG.UTCCollectionDateTime;
		end
		else
		begin
			exec sp_executesql @cmd, @parms, @SQLServerIDIn = @SQLServerID, @CutoffDateTimeIn = @CutoffDateTime, @RecordsToDelete = @RecordsToDelete;
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMTABLEREORGANIZATION.SQL
if (object_id('Grooming.p_GroomTableReorganization') is not null)
begin
drop procedure Grooming.p_GroomTableReorganization
end
go
create procedure [Grooming].[p_GroomTableReorganization]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (TableID int not null,
							UTCCollectionDateTime datetime not null,
							primary key(TableID, UTCCollectionDateTime))

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'TableReorganization'
	
if (@SQLServerID is not null)
begin
	Set @cmd = N'Declare @KeysToDelete Table (TableID int not null,
							UTCCollectionDateTime datetime not null,
							primary key(TableID, UTCCollectionDateTime))
				Insert Into @KeysToDelete
				Select Top(@RecordsToDelete) tr.TableID, tr.UTCCollectionDateTime
				From dbo.TableReorganization tr with(nolock)
				Inner Join SQLServerTableNames tn (nolock) on tr.TableID = tn.TableID
				Inner Join SQLServerDatabaseNames dn (nolock) on tn.DatabaseID = dn.DatabaseID
				Where dn.SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And tr.UTCCollectionDateTime <= @CutoffDateTimeIn'
				Else N''
				End + N';
			
				Delete TR
				From dbo.TableReorganization TR
				Inner Join @KeysToDelete K
					On K.TableID = TR.TableID
						And K.UTCCollectionDateTime = TR.UTCCollectionDateTime;';
	set @parms = N'@SQLServerIDIn int, @CutoffDateTimeIn datetime, @RecordsToDelete int'	
				
					
	if @Deleted = 1
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) TableID, UTCCollectionDateTime
			From dbo.TableReorganization with(nolock)
			Where UTCCollectionDateTime <= @CutoffDateTime;
			
			Delete TR
			From dbo.TableReorganization TR
			Inner Join @KeysToDelete K
				On K.TableID = TR.TableID
					And K.UTCCollectionDateTime = TR.UTCCollectionDateTime;
		end
		else
		begin
			exec sp_executesql @cmd, @parms, @SQLServerIDIn = @SQLServerID, @CutoffDateTimeIn = @CutoffDateTime, @RecordsToDelete = @RecordsToDelete;
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMTASKS.SQL
if (object_id('Grooming.p_GroomTasks') is not null)
begin
drop procedure Grooming.p_GroomTasks
end
go
create procedure [Grooming].[p_GroomTasks]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (TaskID int not null primary key)

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'Tasks'
	
if (@SQLServerID is not null)
begin
	Set @cmd = N'Declare @KeysToDelete Table (TaskID int not null primary key)

				Insert Into @KeysToDelete
				Select Top(@RecordsToDelete) TaskID
				From dbo.Tasks with(nolock)
				Where Status = 16
				And ServerName = @SQLServerNameIn' +
				Case When @Deleted = 0 Then N'
				And CreatedOn <= @CutoffDateTimeIn'
				Else N''
				End + N';
			
				Delete QSA
				From dbo.Tasks QSA
				Inner Join @KeysToDelete K
					On K.TaskID = QSA.TaskID;';
	set @parms = N'@SQLServerNameIn nvarchar(256), @CutoffDateTimeIn datetime, @RecordsToDelete int'	
				
					
	if @Deleted = 1
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) TaskID
			From dbo.Tasks with(nolock)
			Where Status = 16
			And CreatedOn <= @CutoffDateTime;
			
			Delete QSA
			From dbo.Tasks QSA
			Inner Join @KeysToDelete K
				On K.TaskID = QSA.TaskID;
		end
		else
		begin
			if (@SQLServerID < 0)
			begin
				Delete From @KeysToDelete;

				Insert Into @KeysToDelete
				Select Top(@RecordsToDelete) TaskID
				From dbo.Tasks with(nolock)
				Where Status = 16
				And ServerName is null
				And CreatedOn <= @CutoffDateTime;
			
				Delete QSA
				From dbo.Tasks QSA
				Inner Join @KeysToDelete K
					On K.TaskID = QSA.TaskID;
			end
			else
			begin
				exec sp_executesql @cmd, @parms, @SQLServerNameIn = @InstanceName, @CutoffDateTimeIn = @CutoffDateTime, @RecordsToDelete = @RecordsToDelete; 
			end
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end




			
			
 
GO 

---------- P_GROOMTEMPDBFILEDATA.SQL
if (object_id('Grooming.p_GroomTempdbFileData') is not null)
begin
drop procedure Grooming.p_GroomTempdbFileData
end
go
create procedure [Grooming].[p_GroomTempdbFileData]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (FileID int not null,
							UTCCollectionDateTime datetime not null,
							primary key(UTCCollectionDateTime, FileID))

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'TempdbFileData'
	
if (@SQLServerID is not null)
begin
	Set @cmd = N'Declare @KeysToDelete Table (FileID int not null,
							UTCCollectionDateTime datetime not null,
							primary key(UTCCollectionDateTime, FileID))

				Insert Into @KeysToDelete
				Select Top(@RecordsToDelete) tfd.FileID, tfd.UTCCollectionDateTime
				From dbo.TempdbFileData tfd with(nolock)
				Inner Join DatabaseFiles df (nolock) on tfd.FileID = df.FileID
				Inner Join SQLServerDatabaseNames dn (nolock) on df.DatabaseID = dn.DatabaseID
				Where dn.SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And tfd.UTCCollectionDateTime <= @CutoffDateTimeIn'
				Else N''
				End + N';
			
				Delete TFD
				From dbo.TempdbFileData TFD
				Inner Join @KeysToDelete K
					On K.FileID = TFD.FileID
						And K.UTCCollectionDateTime = TFD.UTCCollectionDateTime;';
	set @parms = N'@SQLServerIDIn int, @CutoffDateTimeIn datetime, @RecordsToDelete int'	
				
					
	if @Deleted = 1
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) FileID, UTCCollectionDateTime
			From dbo.TempdbFileData with(nolock)
			Where UTCCollectionDateTime <= @CutoffDateTime;
			
			Delete TFD
			From dbo.TempdbFileData TFD
			Inner Join @KeysToDelete K
				On K.FileID = TFD.FileID
					And K.UTCCollectionDateTime = TFD.UTCCollectionDateTime;
		end
		else
		begin
		
			exec sp_executesql @cmd, @parms, @SQLServerIDIn = @SQLServerID, @CutoffDateTimeIn = @CutoffDateTime, @RecordsToDelete = @RecordsToDelete;
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMVMCONFIGDATA.SQL
if (object_id('Grooming.p_GroomVMConfigData') is not null)
begin
drop procedure Grooming.p_GroomVMConfigData
end
go
create procedure [Grooming].[p_GroomVMConfigData]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (SQLServerID int not null,
							UTCCollectionDateTime datetime not null,
							primary key(SQLServerID, UTCCollectionDateTime))

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'VMConfigData'
	
if (@SQLServerID is not null)
begin
	Set @cmd = N'Declare @KeysToDelete Table (SQLServerID int not null,
							UTCCollectionDateTime datetime not null,
							primary key(SQLServerID, UTCCollectionDateTime))

				Insert Into @KeysToDelete
				Select Top(@RecordsToDelete) SQLServerID, UTCCollectionDateTime
				From dbo.VMConfigData with(nolock)
				Where SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And UTCCollectionDateTime <= @CutoffDateTime'
				Else N''
				End + N';
			
				Delete VMCD
				From dbo.VMConfigData VMCD
				Inner Join @KeysToDelete K
					On K.SQLServerID = VMCD.SQLServerID
						And K.UTCCollectionDateTime = VMCD.UTCCollectionDateTime;';
	set @parms = N'@SQLServerIDIn int,@CutoffDateTimeIn datetime,@RecordsToDelete int';
					
	if @Deleted = 1
	begin
		set @BlockName = @BlockName + ' (deleting)'
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) SQLServerID, UTCCollectionDateTime
			From dbo.VMConfigData with(nolock)
			Where UTCCollectionDateTime <= @CutoffDateTime;
			
			Delete VMCD
			From dbo.VMConfigData VMCD
			Inner Join @KeysToDelete K
				On K.SQLServerID = VMCD.SQLServerID
					And K.UTCCollectionDateTime = VMCD.UTCCollectionDateTime;
		end
		else
		begin
			exec sp_executesql @cmd,
						@parms,
						@SQLServerIDIn = @SQLServerID,
						@CutoffDateTimeIn = @CutoffDateTime,
						@RecordsToDelete = @RecordsToDelete;
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMVMSTATISTICS.SQL
if (object_id('Grooming.p_GroomVMStatistics') is not null)
begin
drop procedure Grooming.p_GroomVMStatistics
end
go
create procedure [Grooming].[p_GroomVMStatistics]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (SQLServerID int not null,
							UTCCollectionDateTime datetime not null,
							primary key(SQLServerID, UTCCollectionDateTime))
select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'VMStatistics'
	
if (@SQLServerID is not null)
begin
	Set @cmd = N'Declare @KeysToDelete Table (SQLServerID int not null,
							UTCCollectionDateTime datetime not null,
							primary key(SQLServerID, UTCCollectionDateTime))

				Insert Into @KeysToDelete
				Select Top(@RecordsToDelete) SQLServerID, UTCCollectionDateTime
				From dbo.VMStatistics with(nolock)
				Where SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And UTCCollectionDateTime <= @CutoffDateTime'
				Else N''
				End + N';
			
				Delete VMS
				From dbo.VMStatistics VMS
				Inner Join @KeysToDelete K
					On K.SQLServerID = VMS.SQLServerID
					And K.UTCCollectionDateTime = VMS.UTCCollectionDateTime;';
	set @parms = N'@SQLServerIDIn int,@CutoffDateTimeIn datetime,@RecordsToDelete int';
	
	if @Deleted = 1
	begin
		set @BlockName = @BlockName + N' (deleting)';
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) SQLServerID, UTCCollectionDateTime
			From dbo.VMStatistics with(nolock)
			Where UTCCollectionDateTime <= @CutoffDateTime;
			
			Delete VMS
			From dbo.VMStatistics VMS
			Inner Join @KeysToDelete K
				On K.SQLServerID = VMS.SQLServerID
					And K.UTCCollectionDateTime = VMS.UTCCollectionDateTime;
		end
		else
		begin
			exec sp_executesql @cmd,
						@parms,
						@SQLServerIDIn = @SQLServerID,
						@CutoffDateTimeIn = @CutoffDateTime,
						@RecordsToDelete = @RecordsToDelete;
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end
 
GO 

---------- P_GROOMWAITSTATISTICS.SQL
if (object_id('Grooming.p_GroomWaitStatistics') is not null)
begin
drop procedure Grooming.p_GroomWaitStatistics
end
go
create procedure [Grooming].[p_GroomWaitStatistics]
(
@run_id uniqueidentifier,
@Sequence int out,
@TimeoutTime datetime,
@RecordsToDelete int = 1000,
@CutoffDateTime datetime,
@SQLServerID int = null,
@InstanceName sysname = null,
@Deleted bit = 0
)
as
begin

declare @RowsAffected int
declare @RC int
declare @BlockName nvarchar(256)
declare @ErrorMessage nvarchar(2048)
declare @cmd nvarchar(1000)
declare @parms nvarchar(1000)

Declare @KeysToDelete Table (SQLServerID int not null,
							UTCCollectionDateTime datetime not null,
							primary key(UTCCollectionDateTime, SQLServerID))

select 
	@RowsAffected = 0, 
	@RC = 0, 
	@BlockName = 'WaitStatistics'
	
if (@SQLServerID is not null)
begin
	Set @cmd = N'Declare @KeysToDelete Table (SQLServerID int not null,
							UTCCollectionDateTime datetime not null,
							primary key(UTCCollectionDateTime, SQLServerID))

				Insert Into @KeysToDelete
				Select Top(@RecordsToDelete) SQLServerID, UTCCollectionDateTime
				From dbo.WaitStatistics with(nolock)
				Where SQLServerID = @SQLServerIDIn' +
				Case When @Deleted = 0 Then N'
				And UTCCollectionDateTime <= @CutoffDateTime'
				Else N''
				End + N';
			
				Delete WS
				From dbo.WaitStatistics WS
				Inner Join @KeysToDelete K
					On K.SQLServerID = WS.SQLServerID
						And K.UTCCollectionDateTime = WS.UTCCollectionDateTime;';
	set @parms = N'@SQLServerIDIn int,@CutoffDateTimeIn datetime,@RecordsToDelete int';
	
	if @Deleted = 1
	begin
		set @BlockName = @BlockName + N' (deleting)';
	end
end	
			
while (1=1)
begin
	
    if (GetUTCDate() > @TimeoutTime)           
		raiserror (N'Timeout in %s', 11, 1,@BlockName);
           
	begin try
	           
		if (@SQLServerID is null)
		begin
			Delete From @KeysToDelete;

			Insert Into @KeysToDelete
			Select Top(@RecordsToDelete) SQLServerID, UTCCollectionDateTime
			From dbo.WaitStatistics with(nolock)
			Where UTCCollectionDateTime <= @CutoffDateTime;
			
			Delete WS
			From dbo.WaitStatistics WS
			Inner Join @KeysToDelete K
				On K.SQLServerID = WS.SQLServerID
					And K.UTCCollectionDateTime = WS.UTCCollectionDateTime;
		end
		else
		begin
			exec sp_executesql @cmd,
						@parms,
						@SQLServerIDIn = @SQLServerID,
						@CutoffDateTimeIn = @CutoffDateTime,
						@RecordsToDelete = @RecordsToDelete;
		end
		
		
		set @RowsAffected = @@ROWCOUNT
		set @RC = @RC + @RowsAffected
		if (@RowsAffected < @RecordsToDelete)
			break;
		
	end try
	begin catch

		set @ErrorMessage = @BlockName + ERROR_MESSAGE()
		exec Grooming.p_LogGroomingAction  @run_id, @Sequence out,@ErrorMessage, @RC, @InstanceName
		break;
	
	end catch
end	

exec Grooming.p_LogGroomingAction @run_id, @Sequence out, @BlockName, @RC, @InstanceName

return @RC

end


 
GO 

---------- P_HEARTBEATCOLLECTIONSERVICE.SQL
if (object_id('p_HeartbeatCollectionService') is not null)
begin
drop procedure p_HeartbeatCollectionService
end
go
create procedure [dbo].[p_HeartbeatCollectionService](
	@ServiceId uniqueidentifier,
	@LastHeartbeatUTC DateTime
)
as
begin
	declare @id uniqueidentifier
	declare @e int
	declare @rc int

	update [CollectionServices] set [LastHeartbeatUTC] = @LastHeartbeatUTC 
		where ([CollectionServiceID] = @ServiceId)

	select @e = @@error, @rc = @@rowcount

	if ((@e = 0) and (@rc = 0))
	begin
		select @e = -1
	end

	return @e
end
 
GO 

---------- P_IMPORTGETMONITOREDSQLSERVERS.SQL
if (object_id('p_ImportGetMonitoredSqlServers') is not null)
begin
drop procedure p_ImportGetMonitoredSqlServers
end
go
CREATE PROCEDURE [dbo].[p_ImportGetMonitoredSqlServers]
(
	@ActiveOnly BIT = 0
)
AS
BEGIN
	DECLARE @error int

	SELECT 
		[SQLServerID],
		[InstanceName],
		[ServerVersion],
		[Active],
		[RegisteredDate],
		[EarliestDateImportedFromLegacySQLdm]
	FROM [MonitoredSQLServers]
	WHERE
		((@ActiveOnly = 0) OR ([Active] = 1))

	SELECT @error = @@error

	IF @error != 0 GOTO HANDLE_ERROR

	RETURN(0)

	HANDLE_ERROR:
		RAISERROR('An error occurred while getting the monitored SQL Server instances.', 10, 1)
        RETURN(@error)			
END
 
GO 

---------- P_IMPORTUPDATEEARLIESTDATEIMPORTED.SQL
if (object_id('p_ImportUpdateEarliestDateImported') is not null)
begin
drop procedure p_ImportUpdateEarliestDateImported
end
go
CREATE PROCEDURE [dbo].[p_ImportUpdateEarliestDateImported]
(
	@SQLServerID int,
	@EarliestDateImportedFromLegacySQLdm datetime
)
AS
BEGIN
	DECLARE @error int

	UPDATE 	[dbo].[MonitoredSQLServers]
	SET
	       	[EarliestDateImportedFromLegacySQLdm] = @EarliestDateImportedFromLegacySQLdm
	WHERE
		[SQLServerID] = @SQLServerID

	SELECT @error = @@error

	IF @error != 0 GOTO HANDLE_ERROR

	RETURN(0)

	HANDLE_ERROR:
		RAISERROR('An error occurred while updating monitored SQL Server import date.', 10, 1)
        RETURN(@error)			
END
 
GO 

---------- P_INSERTACTIVEWAIT.SQL
if (object_id('p_InsertActiveWait') is not null)
begin
drop procedure p_InsertActiveWait
end
go

create procedure [dbo].p_InsertActiveWait(
@SQLServerID int,
@UTCCollectionDateTime datetime,
@ApplicationName nvarchar(256),
@ApplicationNameID int output,
@DatabaseName nvarchar(255),
@DatabaseID int,
@HostName nvarchar(256),
@HostNameID int output,
@LoginName nvarchar(256),                                           
@LoginNameID int output,
@SessionID smallint,
@SQLStatement nvarchar(max),
@SQLStatementHash nvarchar(30),
@SQLStatementID int output,
@SQLSignature nvarchar(max),
@SQLSignatureHash nvarchar(30),
@SQLSignatureID int output,
@StatementUTCStartTime datetime,
@StatementLocalStartTime datetime,
@WaitDuration bigint,
@WaitType varchar(120),
@WaitTypeID int output,
@MSTicks bigint
)
AS
begin
	declare @ReturnMessage nvarchar(128)
	

	if (nullif(@ApplicationNameID,0) is null)
	begin
		exec p_InsertApplicationName @ApplicationName, @ApplicationNameID output
	end

	if (nullif(@DatabaseID,0) is null)
	begin
		exec p_InsertDatabaseName @SQLServerID, @DatabaseName, 0, null, @DatabaseID output, @ReturnMessage output
	end

	if (nullif(@HostNameID,0) is null)
	begin
		exec p_InsertHostName @HostName, @HostNameID output
	end

	if (nullif(@LoginNameID,0) is null)
	begin
		exec p_InsertLoginName @LoginName, @LoginNameID output
	end

	if (nullif(@SQLStatementID,0) is null)
	begin
		exec p_InsertSQLStatement @SQLStatementHash, @SQLStatement, @SQLStatementID output
	end

	if (nullif(@WaitTypeID,0) is null)
	begin
		exec p_InsertWaitTypes @WaitType, @WaitTypeID output, @ReturnMessage output
	end

	if (nullif(@SQLSignatureID,0) is null)
	begin
		exec p_InsertSQLSignature @SQLSignatureHash, @SQLSignature, @SQLStatementID, @SQLSignatureID output
	end


	if (exists(select [MSTicks] from [ActiveWaitStatistics] where [MSTicks] = @MSTicks and [SQLServerID] = @SQLServerID))
	begin
		delete
		from [ActiveWaitStatistics]
		where 
			[MSTicks] = @MSTicks
			and [SQLServerID] = @SQLServerID            
			and [WaitDuration] < @WaitDuration
			and [SessionID] = @SessionID
			and [WaitTypeID] = @WaitTypeID           
			and [HostNameID] = @HostNameID           
			and [ApplicationNameID] = @ApplicationNameID    
			and [LoginNameID] = @LoginNameID          
			and [DatabaseID] = @DatabaseID           
			and [SQLStatementID] = @SQLStatementID 
	end


	insert into [ActiveWaitStatistics]
	([SQLServerID]            
	,[UTCCollectionDateTime]
	,[StatementUTCStartTime]
	,[WaitDuration]         
	,[SessionID]            
	,[WaitTypeID]           
	,[HostNameID]           
	,[ApplicationNameID]    
	,[LoginNameID]          
	,[DatabaseID]           
	,[SQLStatementID]
	,[SQLSignatureID]
	,[MSTicks]
	,[StatementLocalStartTime])
	values
	(@SQLServerID            
	,@UTCCollectionDateTime
	,@StatementUTCStartTime
	,@WaitDuration         
	,@SessionID            
	,@WaitTypeID           
	,@HostNameID           
	,@ApplicationNameID    
	,@LoginNameID          
	,@DatabaseID           
	,@SQLStatementID
	,@SQLSignatureID
	,@MSTicks
	,@StatementLocalStartTime)

END

go
 
GO 

---------- P_INSERTALWAYSONSTATISTICS.SQL

------------------------------------------------------------------------------
-- <copyright file="p_InsertAlwaysOnStatistics.sql" company="Idera, Inc.">
--     Copyright (c) Idera, Inc. All rights reserved.
-- </copyright>
------------------------------------------------------------------------------
if (object_id('p_InsertAlwaysOnStatistics') is not null)
begin
drop procedure p_InsertAlwaysOnStatistics
end
go
create procedure [dbo].p_InsertAlwaysOnStatistics(
    @UTCCollectionDateTime datetime,
    @ReplicaId uniqueidentifier,
    @GroupId uniqueidentifier,
    @GroupDatabaseId uniqueidentifier,
    @DatabaseId int,
    @IsFailoverReady bit,
    @SynchronizationState tinyint,
    @SynchronizationHealth tinyint,
    @DatabaseState tinyint,
    @IsSuspended bit,
    @LastHardenedTime datetime,
    @LogSedQueueSize bigint,
    @LogSendRate bigint,
    @RedoQueueSize bigint,
    @RedoRate bigint,
    @ReplicaRole int,
    @OperationalState tinyint,
    @ConnectedState tinyint,
    @SynchronizationHealthAvailabilityReplica tinyint,
    @LastConnectErrorNumber int,
    @LastConnectErrorDescription nvarchar(1024),
    @LastConnectErrorTimestamp datetime,
    @EstimatedDataLossTime bigint,
    @SynchronizationPerformance int,
    @FilestreamSendRate bigint,
    @TimeDeltaInSeconds float,
    @EstimatedRecoveryTime int
)
as
begin
    -- Nolock transactions.
    set transaction isolation level read uncommitted

    DECLARE @SQLServerID int
    select @SQLServerID = isnull((select top 1 SQLServerID from AlwaysOnReplicas AOR where AOR.ReplicaId = @ReplicaId), -1)

    insert into [dbo].[AlwaysOnStatistics] (
        UTCCollectionDateTime,
        ReplicaId,
        GroupId,
        DatabaseId,
        SQLServerID,
        IsFailoverReady,
        SynchronizationState,
        SynchronizationHealth,
        DatabaseState,
        IsSuspended,
        LastHardenedTime,
        LogSedQueueSize,
        LogSendRate,
        RedoQueueSize,
        RedoRate,
        ReplicaRole,
        OperationalState,
        ConnectedState,
        SynchronizationHealthAvailabilityReplica,
        LastConnectErrorNumber,
        LastConnectErrorDescription,
        LastConnectErrorTimestamp,
        EstimatedDataLossTime,
        SynchronizationPerformance,
        FilestreamSendRate,
        TimeDeltaInSeconds,
        EstimatedRecoveryTime,
        GroupDatabaseId
    )
    values
    (
        @UTCCollectionDateTime,
        @ReplicaId,
        @GroupId,
        @DatabaseId,
        @SQLServerID,
        @IsFailoverReady,
        @SynchronizationState,
        @SynchronizationHealth,
        @DatabaseState,
        @IsSuspended,
        @LastHardenedTime,
        @LogSedQueueSize,
        @LogSendRate,
        @RedoQueueSize,
        @RedoRate,
        @ReplicaRole,
        @OperationalState,
        @ConnectedState,
        @SynchronizationHealthAvailabilityReplica,
        @LastConnectErrorNumber,
        @LastConnectErrorDescription,
        @LastConnectErrorTimestamp,
        @EstimatedDataLossTime,
        @SynchronizationPerformance,
        @FilestreamSendRate,
        @TimeDeltaInSeconds,
        @EstimatedRecoveryTime,
        @GroupDatabaseId
    )
end
 
GO 

---------- P_INSERTAPPLICATIONNAME.SQL
if (object_id('p_InsertApplicationName') is not null)
begin
drop procedure p_InsertApplicationName
end
go
create procedure p_InsertApplicationName
	@ApplicationName nvarchar(256),
	@ApplicationNameID int output
as
begin

	select @ApplicationNameID = ApplicationNameID
	from ApplicationNames
	where ApplicationName = @ApplicationName
	or (ApplicationName is null and @ApplicationName is null)

	if (nullif(@ApplicationNameID,0) is null)
	begin
		insert into ApplicationNames([ApplicationName]) values (@ApplicationName)
		select @ApplicationNameID = scope_identity()
	end

	
end
 
GO 

---------- P_INSERTBLOCK.SQL
if (object_id('[p_InsertBlock]') is not null)
begin
drop procedure [p_InsertBlock]
end
go

create procedure [dbo].[p_InsertBlock]
	@BlockID uniqueidentifier,
	@SQLServerID int,
	@UTCCollectionDateTime datetime,
	@XActID bigint,
	@XDLData nvarchar(max),   
	@ReturnMessage nvarchar(128) output
as
begin

insert into [Blocks]
   ([BlockID]
    ,[XActID]
	,[SQLServerID]
	,[UTCCollectionDateTime]
	,[XDLData])
values
	(@BlockID,
	@XActID,
	@SQLServerID,
	@UTCCollectionDateTime,
	@XDLData)

end

GO

 
GO 

---------- P_INSERTBLOCKINGSESSION.SQL
if (object_id('[p_InsertBlockingSession]') is not null)
begin
drop procedure [p_InsertBlockingSession]
end
go

create  procedure [dbo].[p_InsertBlockingSession](
@SQLServerID int,
@UTCCollectionDateTime datetime,
@BlockID uniqueidentifier,
@ApplicationName nvarchar(256),
@ApplicationNameID int output,
@DatabaseName nvarchar(255),
@DatabaseID int,
@HostName nvarchar(256),
@HostNameID int output,
@LoginName nvarchar(256),                                           
@LoginNameID int output,
@SessionID smallint,
@SQLStatement nvarchar(max),
@SQLStatementHash nvarchar(30),
@SQLStatementID int output,
@SQLSignature nvarchar(max),
@SQLSignatureHash nvarchar(30),
@SQLSignatureID int output,
@BlockingUTCStartTime datetime,
@BlockingLocalStartTime datetime,
@BlockingDurationMilliseconds bigint
)
AS
begin
	declare @ReturnMessage nvarchar(128)
	
	set @BlockingUTCStartTime = dateadd(ms,datepart(ms,@BlockingUTCStartTime)*-1,@BlockingUTCStartTime)

	if (nullif(@ApplicationNameID,0) is null)
	begin
		exec p_InsertApplicationName @ApplicationName, @ApplicationNameID output
	end

	if (nullif(@DatabaseID,0) is null)
	begin
		exec p_InsertDatabaseName @SQLServerID, @DatabaseName, 0, null, @DatabaseID output, @ReturnMessage output
	end

	if (nullif(@HostNameID,0) is null)
	begin
		exec p_InsertHostName @HostName, @HostNameID output
	end

	if (nullif(@LoginNameID,0) is null)
	begin
		exec p_InsertLoginName @LoginName, @LoginNameID output
	end

	if (nullif(@SQLStatementID,0) is null)
	begin
		exec p_InsertSQLStatement @SQLStatementHash, @SQLStatement, @SQLStatementID output
	end

	if (nullif(@SQLSignatureID,0) is null)
	begin
		exec p_InsertSQLSignature @SQLSignatureHash, @SQLSignature, @SQLStatementID, @SQLSignatureID output
	end

	-- The utc start time drifts, so treat any identical blockers starting within the same 2-second window as the same blocker
	if (exists(select [BlockingUTCStartTime] from [BlockingSessionStatistics] where ([BlockingUTCStartTime] = @BlockingUTCStartTime or dateadd(s,-1,[BlockingUTCStartTime]) = @BlockingUTCStartTime or dateadd(s,1,[BlockingUTCStartTime]) = @BlockingUTCStartTime) and [SQLServerID] = @SQLServerID))
	begin
		delete
		from [BlockingSessionStatistics]
		where 
			([BlockingUTCStartTime] = @BlockingUTCStartTime or dateadd(s,-1,[BlockingUTCStartTime]) = @BlockingUTCStartTime or dateadd(s,1,[BlockingUTCStartTime]) = @BlockingUTCStartTime)
			and [SQLServerID] = @SQLServerID            
			and [BlockingDurationMilliseconds] <= @BlockingDurationMilliseconds
			and [SessionID] = @SessionID
			and [HostNameID] = @HostNameID           
			and [ApplicationNameID] = @ApplicationNameID    
			and [LoginNameID] = @LoginNameID          
			and [DatabaseID] = @DatabaseID           
			and [SQLStatementID] = @SQLStatementID 
	end


	insert into [BlockingSessionStatistics]
	([SQLServerID]            
	,[UTCCollectionDateTime]
	,[BlockingUTCStartTime]
	,[BlockingDurationMilliseconds]
	,[SessionID]            
	,[HostNameID]           
	,[ApplicationNameID]    
	,[LoginNameID]          
	,[DatabaseID]           
	,[SQLStatementID]
	,[SQLSignatureID]
	,[BlockingLocalStartTime]
	,[BlockID]
	)
	values
	(@SQLServerID            
	,@UTCCollectionDateTime
	,@BlockingUTCStartTime
	,@BlockingDurationMilliseconds         
	,@SessionID            
	,@HostNameID           
	,@ApplicationNameID    
	,@LoginNameID          
	,@DatabaseID           
	,@SQLStatementID
	,@SQLSignatureID
	,@BlockingLocalStartTime
	,@BlockID)

END

 
GO 

---------- P_INSERTCUSTOMCOUNTERSTATISTICS.SQL
if (object_id('p_InsertCustomCounterStatistics') is not null)
begin
drop procedure p_InsertCustomCounterStatistics
end
go
create procedure p_InsertCustomCounterStatistics
	@SQLServerID int,
	@UTCCollectionDateTime datetime,
	@MetricID int,
	@TimeDeltaInSeconds float,
	@RawValue decimal(38,9),
	@DeltaValue decimal(38,9),
	@ErrorMessage nvarchar(255),
	@RunTimeInMilliseconds float,
	@ReturnMessage nvarchar(128) output
as
begin

INSERT INTO [CustomCounterStatistics]
			([SQLServerID]
			,[UTCCollectionDateTime]
			,[MetricID]
			,[TimeDeltaInSeconds]
			,[RawValue]
			,[DeltaValue]
			,[ErrorMessage]
			,[RunTimeInMilliseconds])
     VALUES
			(@SQLServerID
			,@UTCCollectionDateTime
			,@MetricID
			,@TimeDeltaInSeconds
			,@RawValue
			,@DeltaValue
			,@ErrorMessage
			,@RunTimeInMilliseconds)
end
 
GO 

---------- P_INSERTCUSTOMREPORTSCOUNTERS.SQL
if (object_id('[p_InsertCustomReportsCounters]') is not null)
begin
drop procedure [p_InsertCustomReportsCounters]
end
go

create proc p_InsertCustomReportsCounters (
@ReportName nvarchar(255),
@GraphNumber int,
@CounterShortDescription nvarchar(255),
@CounterName nvarchar(255),
@Aggregation int,
@Source int
)
as
begin
declare @ID int

select @ID = ID from CustomReports where reportName = @ReportName

if (select count(*) from CustomReportsCounters where ID = @ID and GraphNumber = @GraphNumber) > 0
	begin
		select @GraphNumber
		Update CustomReportsCounters 
		set CounterShortDescription = @CounterShortDescription, 
		CounterName = @CounterName, 
		Aggregation = @Aggregation,
		Source = @Source
		where ID = @ID and GraphNumber = @GraphNumber
	end
else
	begin
		insert into CustomReportsCounters values (@ID, 
		@GraphNumber, 
		@CounterShortDescription, 
		replace(@CounterName,' ','_'), 
		@Aggregation,
		@Source)
	end
end
 
GO 

---------- P_INSERTDATABASEFILE.SQL
if (object_id('p_InsertDatabaseFile') is not null)
begin
drop procedure p_InsertDatabaseFile
end
go
create procedure p_InsertDatabaseFile
	@DatabaseID int,
	@FileName nvarchar(255),
	@FileType bit,
	@FilePath nvarchar(1000),
	@DriveName nvarchar(256),
	@FileID int output
as
begin

declare @LookupFileID int, @TempDriveName nvarchar(256)


-- Do not match on drive letter because this may change with config changes
select 
	@LookupFileID = FileID,
	@TempDriveName = DriveName
from 
	DatabaseFiles (nolock)
where 
	DatabaseID = @DatabaseID
	and FileName = @FileName
	and FilePath = @FilePath

if (@LookupFileID is null)
begin
	insert into [DatabaseFiles]
	   (
		[DatabaseID]
	   ,[FileName]
  	   ,[FileType]
	   ,[FilePath]
	   ,[DriveName])
	Values
	   (@DatabaseID
	   ,@FileName
	   ,@FileType
	   ,@FilePath
	   ,@DriveName)

	select @LookupFileID = SCOPE_IDENTITY()
end
else
begin
	if (@TempDriveName <> @DriveName)
		update [DatabaseFiles] set DriveName = @DriveName where FileID = @LookupFileID
end

set @FileID = @LookupFileID

end
 
GO 

---------- P_INSERTDATABASENAME.SQL
if (object_id('p_InsertDatabaseName') is not null)
begin
drop procedure p_InsertDatabaseName
end
go
create procedure p_InsertDatabaseName
	@SQLServerID int,
	@DatabaseName nvarchar(255),
	@SystemDatabase bit,
	@DatabaseCreateDate datetime = null,
	@DatabaseID int output,
	@ReturnMessage nvarchar(128) output
as
begin

declare @LookupDatabaseID int,
		@LookupDatabaseCreateDate datetime

select 
	@LookupDatabaseID = DatabaseID,
	@LookupDatabaseCreateDate = CreationDateTime 
from 
	SQLServerDatabaseNames (nolock)
where 
	SQLServerID = @SQLServerID
	and DatabaseName = @DatabaseName

if (@LookupDatabaseID is null)
begin
	--Checking the existence of parameter SQLServerId. Fix for rally defect DE20479. Aditya Shukla SQLdm 8.6
	if exists(select 1 from MonitoredSQLServers (nolock) where SQLServerID = @SQLServerID)
	begin
		insert into [SQLServerDatabaseNames]
		   ([SQLServerID]
		   ,[DatabaseName]
		   ,[SystemDatabase]
		   ,[CreationDateTime])
		Values
		   (@SQLServerID
		   ,@DatabaseName
		   ,@SystemDatabase
		   ,@DatabaseCreateDate)

		select @LookupDatabaseID = SCOPE_IDENTITY()
	end
	else
	begin
		set @LookupDatabaseID = NULL
	end
end

if (@DatabaseCreateDate is not null) and (@LookupDatabaseID is not null) and (isnull(@LookupDatabaseCreateDate,'1900-01-01 00:00:00 AM') <> @DatabaseCreateDate)
begin
	update [SQLServerDatabaseNames]
		set [CreationDateTime] = @DatabaseCreateDate
	where 
		SQLServerID = @SQLServerID
		and DatabaseName = @DatabaseName
end

set @DatabaseID = @LookupDatabaseID

end
 
GO 

---------- P_INSERTDATABASESIZE.SQL
if (object_id('p_InsertDatabaseSize') is not null)
begin
drop procedure p_InsertDatabaseSize
end
go
create procedure p_InsertDatabaseSize
	@SQLServerID int,
	@DatabaseName nvarchar(255),
	@SystemDatabase bit,
	@UTCCollectionDateTime datetime,
	@DatabaseStatus int,
	@DataFileSizeInKilobytes decimal,        
	@LogFileSizeInKilobytes decimal, 
	@LogSizeInKilobytes decimal,         
	@DataSizeInKilobytes decimal,            
	@TextSizeInKilobytes decimal,            
	@IndexSizeInKilobytes decimal,           
	@LogExpansionInKilobytes decimal,        
	@DataExpansionInKilobytes decimal,       
	@PercentLogSpace float,                  
	@PercentDataSize float,        
	@TimeDeltaInSeconds float,
	@ReturnDatabaseID int output,
	@DatabaseCreateDate datetime,
	@ReturnMessage nvarchar(128) output
as
begin

declare @DatabaseID int,
		@InnerReturnMessage nvarchar(128),
		@DatabaseStatisticsTime datetime

execute [p_InsertDatabaseName] 
   @SQLServerID
  ,@DatabaseName
  ,@SystemDatabase
  ,@DatabaseCreateDate
  ,@DatabaseID output
  ,@InnerReturnMessage output

-- Fix for rally defect DE20479. Aditya Shukla SQLdm 8.6
-- Checking if the databaseid parameter returned from p_InsertDatabaseName has valid value or not
if(@DatabaseID is null)
begin
	--Returning prematurely if databaseid parameter is invalid
	set @ReturnDatabaseID = -1
	return
end

select @DatabaseStatisticsTime = max(UTCCollectionDateTime)
from DatabaseStatistics (nolock)
where DatabaseID = @DatabaseID

insert into [DatabaseSize]
	([DatabaseID]
	,[UTCCollectionDateTime]
	,[DatabaseStatus]
	,[DataFileSizeInKilobytes]
	,[LogFileSizeInKilobytes]
	,[LogSizeInKilobytes]
	,[DataSizeInKilobytes]
	,[TextSizeInKilobytes]
	,[IndexSizeInKilobytes] 
	,[LogExpansionInKilobytes] 
	,[DataExpansionInKilobytes] 
	,[PercentLogSpace] 
	,[PercentDataSize]
	,[TimeDeltaInSeconds]
	,[DatabaseStatisticsTime])
 values
	(@DatabaseID
	,@UTCCollectionDateTime
	,@DatabaseStatus
	,@DataFileSizeInKilobytes                
	,@LogFileSizeInKilobytes  
	,@LogSizeInKilobytes               
	,@DataSizeInKilobytes                    
	,@TextSizeInKilobytes                    
	,@IndexSizeInKilobytes                   
	,@LogExpansionInKilobytes                
	,@DataExpansionInKilobytes               
	,@PercentLogSpace                        
	,@PercentDataSize
	,@TimeDeltaInSeconds
	,@DatabaseStatisticsTime
	)

	if exists (select 1 from DatabaseSizeDateTime where DatabaseID = @DatabaseID)
	begin
		-- If the Database entry is present in the DatabaseSizeDateTime table then update other wise insert the row
		update DatabaseSizeDateTime set DatabaseID = @DatabaseID, UTCCollectionDateTime = @UTCCollectionDateTime where DatabaseID = @DatabaseID
	end
	else
	begin
		insert into DatabaseSizeDateTime (DatabaseID, UTCCollectionDateTime) values (@DatabaseID, @UTCCollectionDateTime)
	end
	
set @ReturnDatabaseID = @DatabaseID

end
 
GO 

---------- P_INSERTDATABASESTATISTICS.SQL
if (object_id('p_InsertDatabaseStatistics') is not null)
begin
drop procedure p_InsertDatabaseStatistics
end
go
create procedure p_InsertDatabaseStatistics
	@SQLServerID int,
	@DatabaseName nvarchar(255),
	@SystemDatabase bit,
	@UTCCollectionDateTime datetime,
	@DatabaseStatus int,
	@Transactions bigint,
	@LogFlushWaits bigint,
	@LogFlushes bigint,
	@LogKilobytesFlushed bigint,
	@LogCacheReads bigint,
	@LogCacheHitRatio float,
	@TimeDeltaInSeconds float,
	@ReturnDatabaseID int output,
	@NumberReads decimal,
	@NumberWrites decimal,
	@BytesRead decimal,
	@BytesWritten decimal,
	@IoStallMS decimal,  
	@DatabaseCreateDate datetime,
	@LastBackupDate datetime, -- SQLdm 10.0 (Gaurav Karwal) - Database backup alerts
	@ReturnMessage nvarchar(128) output
as
begin

declare @DatabaseID int,
		@InnerReturnMessage nvarchar(128),
		@DatabaseSizeTime datetime

execute [p_InsertDatabaseName] 
   @SQLServerID
  ,@DatabaseName
  ,@SystemDatabase
  ,@DatabaseCreateDate
  ,@DatabaseID output
  ,@InnerReturnMessage output

select @DatabaseSizeTime = max(UTCCollectionDateTime)
from DatabaseSize (nolock)
where DatabaseID = @DatabaseID

insert into [DatabaseStatistics]
	([DatabaseID]
	,[UTCCollectionDateTime]
	,[DatabaseStatus]
	,[Transactions]
	,[LogFlushWaits]
	,[LogFlushes]
	,[LogKilobytesFlushed]
	,[LogCacheReads]
	,[LogCacheHitRatio]
	,[TimeDeltaInSeconds]
	,[NumberReads]
	,[NumberWrites]
	,[BytesRead]
	,[BytesWritten]
	,[IoStallMS]
	,[DatabaseSizeTime]
	,[LastBackupDateTime]) -- SQLdm 10.0 (Vandana Gogna) - Database backup alerts
 values
	(@DatabaseID
	,@UTCCollectionDateTime
	,@DatabaseStatus
	,@Transactions
	,@LogFlushWaits
	,@LogFlushes
	,@LogKilobytesFlushed
	,@LogCacheReads
	,@LogCacheHitRatio
	,@TimeDeltaInSeconds
	,@NumberReads 
	,@NumberWrites 
	,@BytesRead 
	,@BytesWritten 
	,@IoStallMS
	,@DatabaseSizeTime
	,@LastBackupDate) -- SQLdm 10.0 (Vandana Gogna) - Database backup alerts

set @ReturnDatabaseID = @DatabaseID

end
 
GO 

---------- P_INSERTDEADLOCK.SQL
if (object_id('p_InsertDeadlock') is not null)
begin
drop procedure p_InsertDeadlock
end
go
create procedure p_InsertDeadlock
	@SQLServerID int,
	@UTCCollectionDateTime datetime,
	@DeadlockID uniqueidentifier,         
	@XDLData nvarchar(max),   
	@ReturnMessage nvarchar(128) output
as
begin

insert into [Deadlocks]
   ([DeadlockID]
	,[SQLServerID]
	,[UTCCollectionDateTime]
	,[XDLData])
values
	(@DeadlockID,
	@SQLServerID,
	@UTCCollectionDateTime,
	@XDLData)

end
go
 
GO 

---------- P_INSERTDEADLOCKPROCESS.SQL
if (object_id('p_InsertDeadlockProcess') is not null)
begin
drop procedure p_InsertDeadlockProcess
end
go
create procedure p_InsertDeadlockProcess
	@SQLServerID int,
	@UTCCollectionDateTime datetime,
	@UTCOccurrenceDateTime datetime,
	@LocalOccurrenceDateTime datetime,
	@DeadlockID uniqueidentifier,         
	@ApplicationName nvarchar(256),
	@ApplicationNameID int output,
	@DatabaseName nvarchar(255),
	@DatabaseID int,
	@HostName nvarchar(256),
	@HostNameID int output,
	@LoginName nvarchar(256),                                           
	@LoginNameID int output,
	@SessionID smallint,
	@SQLStatement nvarchar(max),
	@SQLStatementHash nvarchar(30),
	@SQLStatementID int output,
	@SQLSignature nvarchar(max),
	@SQLSignatureHash nvarchar(30),
	@SQLSignatureID int output
as
begin

	declare @ReturnMessage nvarchar(128)

	if (nullif(@ApplicationNameID,0) is null)
	begin
		exec p_InsertApplicationName @ApplicationName, @ApplicationNameID output
	end

	if (nullif(@DatabaseID,0) is null)
	begin
		exec p_InsertDatabaseName @SQLServerID, @DatabaseName, 0, null, @DatabaseID output, @ReturnMessage output
	end

	if (nullif(@HostNameID,0) is null)
	begin
		exec p_InsertHostName @HostName, @HostNameID output
	end

	if (nullif(@LoginNameID,0) is null)
	begin
		exec p_InsertLoginName @LoginName, @LoginNameID output
	end

	if (nullif(@SQLStatementID,0) is null)
	begin
		exec p_InsertSQLStatement @SQLStatementHash, @SQLStatement, @SQLStatementID output
	end

	if (nullif(@SQLSignatureID,0) is null)
	begin
		exec p_InsertSQLSignature @SQLSignatureHash, @SQLSignature, @SQLStatementID, @SQLSignatureID output
	end

insert into [DeadlockProcesses]
   ([DeadlockID]
	,[SQLServerID]
	,[UTCCollectionDateTime]
	,[UTCOccurrenceDateTime]
	,[HostNameID]
	,[ApplicationNameID]
	,[LoginNameID]
	,[DatabaseID]
	,[SQLStatementID]
	,[SQLSignatureID] 
	,[SessionID]
	,[LocalOccurrenceDateTime]
)
values
	(@DeadlockID,
	@SQLServerID,
	@UTCCollectionDateTime,
	@UTCOccurrenceDateTime,
	@HostNameID,
	@ApplicationNameID,
	@LoginNameID,
	@DatabaseID,
	@SQLStatementID,
	@SQLSignatureID,
	@SessionID,
	@LocalOccurrenceDateTime)

end
go
 
GO 

---------- P_INSERTDISKDRIVE.SQL
if (object_id('p_InsertDiskDrive') is not null)
begin
drop procedure p_InsertDiskDrive
end
go
create procedure p_InsertDiskDrive
	@SQLServerID int,
	@DriveName nvarchar(256),
	@UTCCollectionDateTime datetime,
	@UnusedSizeKB dec(18,0),
	@TotalSizeKB dec(18,0),
	@DiskIdlePercent bigint,
	@AverageDiskQueueLength bigint,
	@AverageDiskMillisecondsPerRead bigint,
	@AverageDiskMillisecondsPerTransfer bigint,
	@AverageDiskMillisecondsPerWrite bigint,
	@DiskReadsPerSecond bigint,
	@DiskTransfersPerSecond bigint,
	@DiskWritesPerSecond bigint,
	@ReturnMessage nvarchar(128) output
as
begin

	declare @DatabaseSizeTime datetime
	
	select 	@DatabaseSizeTime = LastDatabaseCollectionTime
	from MonitoredSQLServers
	where SQLServerID = @SQLServerID
	
	insert into [dbo].[DiskDrives]
	(
		[SQLServerID],
		[UTCCollectionDateTime],
		[DriveName],
		[UnusedSizeKB],
		[TotalSizeKB],
		[DiskIdlePercent],
		[AverageDiskQueueLength],
		[AverageDiskMillisecondsPerRead],
		[AverageDiskMillisecondsPerTransfer],
		[AverageDiskMillisecondsPerWrite],
		[DiskReadsPerSecond],
		[DiskTransfersPerSecond],
		[DiskWritesPerSecond],
		[DatabaseSizeTime]
	)
	values
	(	
		@SQLServerID,
		@UTCCollectionDateTime,
		@DriveName,
		@UnusedSizeKB,
		@TotalSizeKB,
		@DiskIdlePercent,
		@AverageDiskQueueLength,
		@AverageDiskMillisecondsPerRead,
		@AverageDiskMillisecondsPerTransfer,
		@AverageDiskMillisecondsPerWrite,
		@DiskReadsPerSecond,
		@DiskTransfersPerSecond,
		@DiskWritesPerSecond,
		@DatabaseSizeTime
	)

end
 
GO 

---------- P_INSERTESXCONFIGDATA.SQL
if (object_id('p_InsertESXConfigData') is not null)
begin
drop procedure p_InsertESXConfigData
end
go
create procedure p_InsertESXConfigData 
	@SQLServerID int,
	@UTCCollectionDateTime datetime,
	@UUID nvarchar(128),
	@HostName nvarchar(256),
	@DomainName nvarchar(256),
	@ESXStatus int,
	@ESXBootTime datetime,
	@ESXCPUMhz int,
	@ESXNumCPUCores smallint,
	@ESXNumCPUPkgs smallint,
	@ESXNumCPUThreads smallint, 
	@ESXNumNics int,
	@ESXMemSize bigint,
	@ReturnMessage nvarchar(128) output
as
begin

	insert into [ESXConfigData] (
		[SQLServerID],
		[UTCCollectionDateTime],
		[UUID] , 
		[HostName] ,
		[DomainName] , 
		[Status] , 
		[BootTime] , 
		[CPUMHz] ,
		[NumCPUCores] ,
		[NumCPUPkgs] ,
		[NumCPUThreads] ,
		[NumNICs] ,
		[MemorySize] )
	values (
		@SQLServerID,
		@UTCCollectionDateTime ,
		@UUID , 
		@HostName ,
		@DomainName ,
		@ESXStatus ,
		@ESXBootTime ,
		@ESXCPUMhz ,
		@ESXNumCPUCores ,
		@ESXNumCPUPkgs ,
		@ESXNumCPUThreads ,
		@ESXNumNics ,
		@ESXMemSize )

end
 
GO 

---------- P_INSERTESXSTATISTICS.SQL
if (object_id('p_InsertESXStatistics') is not null)
begin
drop procedure p_InsertESXStatistics
end
go
create procedure p_InsertESXStatistics 
	@SQLServerID int,
	@UTCCollectionDateTime datetime,
	@ESXCPUUsage float,
	@ESXCPUUsageMHz int,
	@ESXMemSwapInRate bigint,
	@ESXMemSwapOutRate bigint,
	@ESXMemActive bigint,
	@ESXMemConsumed bigint,
	@ESXMemGranted bigint,
	@ESXMemBallooned bigint,
	@ESXMemUsage float,
	@ESXDiskRead bigint,
	@ESXDiskWrite bigint,
	@ESXDiskDeviceLatency bigint,
	@ESXKernelLatency bigint,
	@ESXQueueLatency bigint,
	@ESXTotalLatency bigint,
	@ESXDiskUsage bigint,
	@ESXNetUsage bigint,
	@ESXNetReceived bigint,
	@ESXNetTransmitted bigint,
	@ESXMemPagePerSec bigint,
	@ESXAvailableMemBytes bigint,
	@ReturnMessage nvarchar(128) output
as
begin

	insert into [ESXStatistics]  (
		[SQLServerID],
		[UTCCollectionDateTime],
		[CPUUsage] ,
		[CPUUsageMHz] ,
		[MemSwapInRate] ,
		[MemSwapOutRate] ,
		[MemActive] ,
		[MemConsumed] ,
		[MemGranted] ,
		[MemBalooned] ,
		[MemUsage] ,
		[DiskRead] ,
		[DiskWrite] ,
		[DiskDeviceLatency] ,
		[DiskKernelLatency] ,
		[DiskQueueLatency] ,
		[DiskTotalLatency] ,
		[DiskUsage] ,
		[NetUsage] ,
		[NetReceived] ,
		[NetTransmitted],
		[MemPagePerSec],
		[AvailableMemBytes]
		)
	values (
		@SQLServerID,
		@UTCCollectionDateTime ,
		@ESXCPUUsage ,
		@ESXCPUUsageMHz ,
		@ESXMemSwapInRate ,
		@ESXMemSwapOutRate ,
		@ESXMemActive ,
		@ESXMemConsumed , 
		@ESXMemGranted ,
		@ESXMemBallooned ,
		@ESXMemUsage ,
		@ESXDiskRead ,
		@ESXDiskWrite ,
		@ESXDiskDeviceLatency ,
		@ESXKernelLatency ,
		@ESXQueueLatency ,
		@ESXTotalLatency ,
		@ESXDiskUsage ,
		@ESXNetUsage ,
		@ESXNetReceived ,
		@ESXNetTransmitted,
		@ESXMemPagePerSec,
		@ESXAvailableMemBytes	)

end
 
GO 

---------- P_INSERTFILEACTIVITY.SQL
if (object_id('p_InsertFileActivity') is not null)
begin
drop procedure p_InsertFileActivity
end
go
create procedure p_InsertFileActivity
	@DatabaseID int,
	@FileName nvarchar(255),
	@FileType bit,
	@FilePath nvarchar(1000),
	@FileID int,
	@UTCCollectionDateTime datetime,
	@TimeDeltaInSeconds float,
	@NumberReads decimal,
	@NumberWrites decimal,
	@DriveName nvarchar(256)
as
begin

if (@FileID is null)
begin
	execute [p_InsertDatabaseFile]
		@DatabaseID,
		@FileName,
		@FileType,
		@FilePath,
		@DriveName,
		@FileID output
end

if (@FileID is null)
	return


insert into
	[DatabaseFileActivity] 
	(
	[FileID],
	[UTCCollectionDateTime],
	[Reads],
	[Writes],
	[TimeDeltaInSeconds]
	)
values
	(
	@FileID,
	@UTCCollectionDateTime,
	@NumberReads,
	@NumberWrites,
	@TimeDeltaInSeconds
	)

end
 
GO 

---------- P_INSERTHOSTNAME.SQL
if (object_id('p_InsertHostName') is not null)
begin
drop procedure p_InsertHostName
end
go
create procedure p_InsertHostName
	@HostName nvarchar(256),
	@HostNameID int output
as
begin

	select @HostNameID = HostNameID
	from HostNames
	where HostName = @HostName
	or (HostName is null and @HostName is null)

	if (nullif(@HostNameID,0) is null)
	begin
		insert into HostNames([HostName]) values (@HostName)
		select @HostNameID = scope_identity()
	end

	
end
 
GO 

---------- P_INSERTLOGINNAME.SQL
if (object_id('p_InsertLoginName') is not null)
begin
drop procedure p_InsertLoginName
end
go
create procedure p_InsertLoginName
	@LoginName nvarchar(256),
	@LoginNameID int output
as
begin

	select @LoginNameID = LoginNameID
	from LoginNames
	where LoginName = @LoginName
	or (LoginName is null and @LoginName is null)

	if (nullif(@LoginNameID,0) is null)
	begin
		insert into LoginNames([LoginName]) values (@LoginName)
		select @LoginNameID = scope_identity()
	end

	
end
 
GO 

---------- P_INSERTMIRRORMONITORINGSTATISTICS.SQL
if (object_id('p_InsertMirroringStatistics') is not null)
begin
drop procedure [p_InsertMirroringStatistics]
end
go

CREATE PROCEDURE [dbo].[p_InsertMirroringStatistics]
	-- Add the parameters for the stored procedure here
    @SQLServerID int,
	@dbname nvarchar(128),
	@instance_name nvarchar(128),
	@partner_name nvarchar(128), 
	@mirroring_guid uniqueidentifier,
	@role tinyint,
	@mirroring_state tinyint,
	@witness_status tinyint,
	@log_generation_rate int,
	@unsent_log int,
	@send_rate int,
	@unrestored_log int,
	@recovery_rate int,
	@transaction_delay int,
	@transactions_per_sec int,
	@average_delay int,
	@time_recorded datetime,
	@time_behind datetime,
	@local_time datetime,
	@partner_address nvarchar(128),
	@witness_address nvarchar(128),
	@safety_level int,
	@utc_collection_datetime datetime,
	@ReturnDatabaseID int output,  
	@ReturnMessage nvarchar(128) output
	
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

declare @DatabaseID int,
		@InnerReturnMessage nvarchar(128)

execute [p_InsertDatabaseName] 
   @SQLServerID
  ,@dbname
  ,0
  ,null
  ,@DatabaseID output
  ,@InnerReturnMessage output
	

-- Insert statements for procedure here
INSERT INTO [MirroringStatistics]
           ([DatabaseID]
           ,[mirroring_guid]
           ,[UTCCollectionDateTime]
           ,[role]
           ,[mirroring_state]
           ,[witness_status]
           ,[log_generation_rate]
           ,[unsent_log]
           ,[send_rate]
           ,[unrestored_log]
           ,[recovery_rate]
           ,[transaction_delay]
           ,[transactions_per_sec]
           ,[average_delay]
           ,[time_recorded]
           ,[time_behind]
           ,[local_time])
     VALUES
           (@DatabaseID
           ,@mirroring_guid
           ,@utc_collection_datetime
           ,@role
           ,@mirroring_state
           ,@witness_status
           ,@log_generation_rate
           ,@unsent_log
           ,@send_rate
           ,@unrestored_log
           ,@recovery_rate
           ,@transaction_delay
           ,@transactions_per_sec
           ,@average_delay
           ,@time_recorded 
           ,@time_behind
           ,@local_time)

if not exists (select * from [MirroringParticipants]
where [DatabaseID] = @DatabaseID)
INSERT INTO [MirroringParticipants]
           ([DatabaseID]
           ,[mirroring_guid]
           ,[role]
           ,[principal_address]
           ,[Mirror_address]
           ,[witness_address]
           ,[safety_level]
           ,[is_suspended]
           ,[mirroring_state]
           ,[witness_status]
           ,[mirror_instanceID]
           ,[principal_instanceID]
		   ,[partner_instance]
           ,[last_updated])
     VALUES
           (@DatabaseID
           ,@mirroring_guid
           ,@role
           ,case @role when 2 then @partner_address else null end
           ,case @role when 1 then @partner_address else null end 
           ,@witness_address
           ,@safety_level
           ,0
           ,@mirroring_state
           ,@witness_status
           ,case @role when 2 then @SQLServerID else null end
           ,case @role when 1 then @SQLServerID else null end
		   ,@partner_name
           ,GETDATE())
else
update [MirroringParticipants]
           set [mirroring_guid]  = @mirroring_guid
           ,[role] = @role
           ,[principal_address] = case @role when 2 then @partner_address else null end
           ,[Mirror_address] = case @role when 1 then @partner_address else null end
           ,[witness_address] = @witness_address
           ,[safety_level] = @safety_level
           ,[mirroring_state] = @mirroring_state
           ,[witness_status] = @witness_status
           ,[mirror_instanceID] = case @role when 2 then @SQLServerID else null end
           ,[principal_instanceID] = case @role when 1 then @SQLServerID else null end
		   ,[partner_instance] = @partner_name
           ,[last_updated] = GETDATE()
where [DatabaseID] = @DatabaseID
           
          set @ReturnDatabaseID = @DatabaseID
           
END
 
GO 

---------- P_INSERTOSSTATISTICS.SQL
if (object_id('p_InsertOSStatistics') is not null)
begin
drop procedure p_InsertOSStatistics
end
go
create procedure p_InsertOSStatistics
	@SQLServerID int,
	@UTCCollectionDateTime datetime,
	@OSTotalPhysicalMemoryInKilobytes bigint,
	@OSAvailableMemoryInKilobytes bigint,
	@PagesPerSecond float,
	@ProcessorTimePercent float,
	@PrivilegedTimePercent float,
	@UserTimePercent float,
	@ProcessorQueueLength float,
	@DiskTimePercent float,
	@DiskQueueLength float,
	@ReturnMessage nvarchar(128) output
as
begin

insert into [OSStatistics]
	([SQLServerID]
	,[UTCCollectionDateTime]
	,[OSTotalPhysicalMemoryInKilobytes]
	,[OSAvailableMemoryInKilobytes]
	,[PagesPerSecond]
	,[ProcessorTimePercent]
	,[PrivilegedTimePercent]
	,[UserTimePercent]
	,[ProcessorQueueLength]
	,[DiskTimePercent]
	,[DiskQueueLength])
values
	(@SQLServerID,
	@UTCCollectionDateTime,
	@OSTotalPhysicalMemoryInKilobytes,
	@OSAvailableMemoryInKilobytes,
	@PagesPerSecond,
	@ProcessorTimePercent,
	@PrivilegedTimePercent,
	@UserTimePercent,
	@ProcessorQueueLength,
	@DiskTimePercent,
	@DiskQueueLength
	)

end

 
GO 

---------- P_INSERTQUERYMONITORSTATEMENT.SQL
IF (object_id('[p_InsertQueryMonitorStatement]') IS NOT NULL)
BEGIN
DROP PROCEDURE [p_InsertQueryMonitorStatement]
END
GO

CREATE procedure [dbo].[p_InsertQueryMonitorStatement]
	@SQLServerID int,
	@UTCCollectionDateTime datetime,
	@ApplicationName nvarchar(256),
	@ApplicationNameID int output,
	@DatabaseName nvarchar(255),
	@DatabaseID int output,
	@HostName nvarchar(256),
	@HostNameID int output,
	@LoginName nvarchar(256),                                           
	@LoginNameID int output,
	@SessionID smallint,
	@StatementType int,
	@SQLStatement nvarchar(max),
	@SQLStatementHash nvarchar(30),
	@SQLStatementID int output,
	@SQLSignature nvarchar(max),
	@SQLSignatureHash nvarchar(30),
	@SQLSignatureID int output,
	@StatementUTCStartTime datetime,
	@StatementLocalStartTime datetime,
	@DurationMilliseconds bigint,
	@CPUMilliseconds bigint,
	@Reads bigint,
	@Writes bigint,
	@QueryPlan nvarchar(max)= null, -- --SQLdm 9.0 (Ankit Srivastava): Query Monitoring with Extended Event Session  -- Added optional QueryPlan paramater
	@IsActualPlan bit = null --SQLdm 10.0 (Tarun Sapra): Estimated Query Plan - If this flag is set to false, the query plan is estimated not actual
as
begin

	declare @ReturnMessage nvarchar(128)
	declare @SQLPlanID int

	if (nullif(@ApplicationNameID,0) is null)
	begin
		exec p_InsertApplicationName @ApplicationName, @ApplicationNameID output
	end

	if (nullif(@DatabaseID,0) is null)
	begin
		exec p_InsertDatabaseName @SQLServerID, @DatabaseName, 0, null, @DatabaseID output, @ReturnMessage output
	end

	if (nullif(@HostNameID,0) is null)
	begin
		exec p_InsertHostName @HostName, @HostNameID output
	end

	if (nullif(@LoginNameID,0) is null)
	begin
		exec p_InsertLoginName @LoginName, @LoginNameID output
	end

	if (nullif(@SQLStatementID,0) is null)
	begin
		exec p_InsertSQLStatement @SQLStatementHash, @SQLStatement, @SQLStatementID output
	end

	-- If we get this far and don't have a SQLStatementID then the record is not worth inserting
	-- We'll keep all the lookup values inserted above since they may be of value
	if (nullif(@SQLStatementID,0) is null)
		return

	if (nullif(@SQLSignatureID,0) is null)
	begin
		exec p_InsertSQLSignature @SQLSignatureHash, @SQLSignature, @SQLStatementID, @SQLSignatureID output
	end

	--SQLdm 9.0 (Ankit Srivastava): Query Monitoring with Extended Event Session -- calling the Insert method fro query plans
	if (@SQLStatementID is not null)
	begin
		exec p_InsertSQLQueryPlan @QueryPlan, @SQLStatementID, @SQLPlanID output, @IsActualPlan
	end

insert into [QueryMonitorStatistics]
	([SQLServerID]
	,[UTCCollectionDateTime]
	,[StatementUTCStartTime] 
	,[DurationMilliseconds] 
	,[CPUMilliseconds]
	,[Reads]
	,[Writes]
	,[HostNameID]
	,[ApplicationNameID]
	,[LoginNameID]
	,[DatabaseID]
	,[StatementType]
	,[SQLStatementID]
	,[SQLSignatureID]
	,[SessionID]
	,[StatementLocalStartTime]
	,[PlanID]) --SQLdm 9.0 (Ankit Srivastava) - SQL Query Plan View - inserting new column
values
	(@SQLServerID
	,@UTCCollectionDateTime
	,@StatementUTCStartTime 
	,@DurationMilliseconds 
	,@CPUMilliseconds
	,@Reads
	,@Writes
	,@HostNameID
	,@ApplicationNameID
	,@LoginNameID
	,@DatabaseID
	,@StatementType
	,@SQLStatementID
	,@SQLSignatureID
	,@SessionID
	,@StatementLocalStartTime
	,@SQLPlanID)--SQLdm 9.0 (Ankit Srivastava) - SQL Query Plan View - inserting new column
end


GO

 
GO 

---------- P_INSERTRUNQUERYSCRIPT.SQL
if (object_id('p_InsertRunQueryScript') is not null)
begin
drop procedure [p_InsertRunQueryScript]
end
go

create procedure [p_InsertRunQueryScript]
	@Name NVARCHAR(100),
	@ScriptText nvarchar(max)
as
begin
	DECLARE @ReturnValue INT;
	
	INSERT INTO RunQueryScripts 
		(Type, Name, ScriptText)
	VALUES
		(1, @Name, @ScriptText)
		
	SELECT @ReturnValue = SCOPE_IDENTITY();
	SELECT @ReturnValue;
end
 
GO 

---------- P_INSERTSERVERACTIVITY.SQL
if (object_id('p_InsertServerActivity') is not null)
begin
drop procedure p_InsertServerActivity
end
go
create procedure p_InsertServerActivity
	@SQLServerID int,
	@UTCCollectionDateTime datetime,
	@StateOverview nvarchar(max) = null,
	@SystemProcesses image = null,
	@SessionList image = null,
	@LockStatistics image = null,
	@LockList image = null,
	@RefreshType int = 0
as
begin

declare @err int

if (exists(select SQLServerID from [ServerActivity] 
			where [SQLServerID] = @SQLServerID
			and [UTCCollectionDateTime] = @UTCCollectionDateTime
			--and isnull([RefreshType],0) = @RefreshType -- VH - Removing to prevent collision
		   )
	)
begin
	update [ServerActivity] set
		[StateOverview] = coalesce(@StateOverview,[StateOverview])
	   ,[SystemProcesses] = coalesce(@SystemProcesses, [SystemProcesses])
	   ,[SessionList] = coalesce(@SessionList, [SessionList])
	   ,[LockStatistics] = coalesce(@LockStatistics, [LockStatistics])
	   ,[LockList] = coalesce(@LockList, [LockList])
	   ,[RefreshType] = case when isnull([RefreshType],0) = 0 then 0 else @RefreshType end  -- VH - If we're combining up more than one type we want the scheduled refresh type to take precedence
	where [SQLServerID] = @SQLServerID 
		and [UTCCollectionDateTime] = @UTCCollectionDateTime 
		-- and isnull([RefreshType],0) = @RefreshType
end
else
begin
	insert into [ServerActivity]
		([SQLServerID]
		,[UTCCollectionDateTime]
		,[StateOverview]
		,[SystemProcesses]
		,[SessionList]
		,[LockStatistics]
		,[LockList]
		,[RefreshType])
	values
		(@SQLServerID
		,@UTCCollectionDateTime
		,@StateOverview
		,@SystemProcesses
		,@SessionList
		,@LockStatistics
		,@LockList
		,@RefreshType)
end

SELECT @err = @@error
	
RETURN @err

end
 
GO 

---------- P_INSERTSERVERSTATISTICS.SQL
if (object_id('p_InsertServerStatistics') is not null)
begin
drop procedure p_InsertServerStatistics
end
go
create procedure p_InsertServerStatistics
	@SQLServerID int,
	@UTCCollectionDateTime datetime,
	@TimeDeltaInSeconds float,
	@AgentServiceStatus int,
	@SqlServerServiceStatus int,
	@DTCServiceStatus int,
	@FullTextSearchStatus int,
	@BufferCacheHitRatioPercentage float,
	@CheckpointWrites bigint,
	@ClientComputers int,
	@CPUActivityPercentage float,
	@CPUTimeDelta bigint,
	@CPUTimeRaw bigint,
	@DistributionLatencyInSeconds float,
	@FullScans bigint,
	@IdleTimeDelta bigint,
	@IdleTimePercentage float,
	@IdleTimeRaw bigint,
	@IOActivityPercentage float,
	@IOTimeDelta bigint,
	@IOTimeRaw bigint,
	@LazyWriterWrites bigint,
	@LockWaits bigint,
	@Logins bigint,
	@LogFlushes bigint,
	@SqlMemoryAllocatedInKilobytes bigint,
	@SqlMemoryUsedInKilobytes bigint,
	@OldestOpenTransactionsInMinutes bigint,
	@PacketErrors bigint,
	@PacketsReceived bigint,
	@PacketsSent bigint,
	@PageErrors bigint,
	@PageLifeExpectancy bigint,
	@PageLookups bigint,
	@PageReads bigint,
	@PageSplits bigint,
	@PageWrites bigint,
	@ProcedureCacheHitRatioPercentage float,
	@ProcedureCacheSizeInKilobytes bigint,
	@ProcedureCacheSizePercent float,
	@ReadAheadPages bigint,
	@ReplicationLatencyInSeconds float,
	@ReplicationSubscribed bigint,
	@ReplicationUndistributed bigint,
	@ReplicationUnsubscribed bigint,
	@ResponseTimeInMilliseconds int,
	@ServerVersion nvarchar(30),
	@ServerEdition nvarchar(30),
	@SqlCompilations bigint,
	@SqlRecompilations bigint,
	@TableLockEscalations bigint,
	@TempDBSizeInKilobytes bigint,
	@TempDBSizePercent float,
	@Batches bigint,
	@UserProcesses int,
	@WorkFilesCreated bigint,
	@WorkTablesCreated bigint,
	@SystemProcesses int,
	@UserProcessesConsumingCPU int, 
	@SystemProcessesConsumingCPU int, 
	@BlockedProcesses int, 
	@OpenTransactions int, 
	@DatabaseCount int,
	@DataFileCount int,
	@LogFileCount int,
	@DataFileSpaceAllocatedInKilobytes decimal,
	@DataFileSpaceUsedInKilobytes decimal,
	@LogFileSpaceAllocatedInKilobytes decimal,
	@LogFileSpaceUsedInKilobytes decimal,
	@TotalLocks decimal,
	@BufferCacheSizeInKilobytes bigint,
	@ActiveProcesses int,
	@LeadBlockers int,
	@CommittedInKilobytes bigint,
	@ConnectionMemoryInKilobytes bigint,
	@FreePagesInKilobytes bigint,
	@GrantedWorkspaceMemoryInKilobytes bigint,
	@LockMemoryInKilobytes bigint,
	@OptimizerMemoryInKilobytes bigint,
	@TotalServerMemoryInKilobytes bigint,
	@FreeCachePagesInKilobytes bigint,
	@CachePagesInKilobytes bigint,
	@MaxConnections bigint,
	@PhysicalMemoryInKilobytes bigint,
	@ProcessorCount int,
	@ProcessorsUsed int,
	@ProcessorType nvarchar(20),
	@ServerHostName nvarchar(50),
	@RealServerName nvarchar(100),
	@WindowsVersion nvarchar(30),
	@SqlServerEdition nvarchar(30),  
	@RunningSince datetime,
	@IsClustered bit,
	@OsStatisticAvailability nvarchar(50),
	@ClusterNodeName nvarchar(256),
	@VersionStoreGenerationKilobytes bigint,
	@VersionStoreCleanupKilobytes bigint,
	@TempdbPFSWaitTimeMilliseconds bigint,
	@TempdbGAMWaitTimeMilliseconds bigint,
	@TempdbSGAMWaitTimeMilliseconds bigint,
	@Transactions bigint,
	@SQLBrowserServiceStatus int,   --SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --update the SQL Browser service column
	@SQLActiveDirectoryHelperServiceStatus int,   --SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --update the SQL Active Directory Helper service column
	@ReturnMessage nvarchar(128) output
as
begin
	insert into [ServerStatistics]
			([SQLServerID]
			,[UTCCollectionDateTime]
			,[TimeDeltaInSeconds]
			,[AgentServiceStatus]
			,[SqlServerServiceStatus]
			,[DTCServiceStatus]
			,[FullTextSearchStatus]
			,[BufferCacheHitRatioPercentage]
			,[CheckpointWrites]
			,[ClientComputers]
			,[CPUActivityPercentage]
			,[CPUTimeDelta]
			,[CPUTimeRaw]
			,[DistributionLatencyInSeconds]
			,[FullScans]
			,[IdleTimeDelta]
			,[IdleTimePercentage]
			,[IdleTimeRaw]
			,[IOActivityPercentage]
			,[IOTimeDelta]
			,[IOTimeRaw]
			,[LazyWriterWrites]
			,[LockWaits]
			,[Logins]
			,[LogFlushes]
			,[SqlMemoryAllocatedInKilobytes]
			,[SqlMemoryUsedInKilobytes]
			,[OldestOpenTransactionsInMinutes]
			,[PacketErrors]
			,[PacketsReceived]
			,[PacketsSent]
			,[PageErrors]
			,[PageLifeExpectancy]
			,[PageLookups]
			,[PageReads]
			,[PageSplits]
			,[PageWrites]
			,[ProcedureCacheHitRatioPercentage]
			,[ProcedureCacheSizeInKilobytes]
			,[ProcedureCacheSizePercent]
			,[ReadAheadPages]
			,[ReplicationLatencyInSeconds]
			,[ReplicationSubscribed]
			,[ReplicationUndistributed]
			,[ReplicationUnsubscribed]
			,[ResponseTimeInMilliseconds]
			,[ServerVersion]
			,[SqlCompilations]
			,[SqlRecompilations]
			,[TableLockEscalations]
			,[TempDBSizeInKilobytes]
			,[TempDBSizePercent]
			,[Batches]
			,[UserProcesses]
			,[WorkFilesCreated]
			,[WorkTablesCreated]
			,[SystemProcesses]
			,[UserProcessesConsumingCPU]
			,[SystemProcessesConsumingCPU]
			,[BlockedProcesses]
			,[OpenTransactions]
			,[DatabaseCount]
			,[DataFileCount]
			,[LogFileCount]
			,[DataFileSpaceAllocatedInKilobytes]
			,[DataFileSpaceUsedInKilobytes]
			,[LogFileSpaceAllocatedInKilobytes]
			,[LogFileSpaceUsedInKilobytes]
			,[TotalLocks]
			,[BufferCacheSizeInKilobytes]
			,[ActiveProcesses]
			,[LeadBlockers]
			,[CommittedInKilobytes]
			,[ConnectionMemoryInKilobytes]
			,[FreePagesInKilobytes]
			,[GrantedWorkspaceMemoryInKilobytes]
			,[LockMemoryInKilobytes]
			,[OptimizerMemoryInKilobytes]
			,[TotalServerMemoryInKilobytes]
			,[FreeCachePagesInKilobytes]
			,[CachePagesInKilobytes]
			,[MaxConnections]
			,[PhysicalMemoryInKilobytes]
			,[ProcessorCount]
			,[ProcessorsUsed]
			,[ProcessorType]
			,[ServerHostName]
			,[RealServerName]
			,[WindowsVersion]
			,[SqlServerEdition]
			,[RunningSince]
			,[IsClustered]
			,[OsStatisticAvailability]
			,[ClusterNodeName]
			,[VersionStoreGenerationKilobytes]
			,[VersionStoreCleanupKilobytes]
			,[TempdbPFSWaitTimeMilliseconds]
			,[TempdbGAMWaitTimeMilliseconds]
			,[TempdbSGAMWaitTimeMilliseconds]
			,[Transactions]
			,[SQLBrowserServiceStatus]      --SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --update the SQL Browser service column
			,[SQLActiveDirectoryHelperServiceStatus]   --SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --update the SQL Active Directory Helper service column
			)
     values
           (@SQLServerID
			,@UTCCollectionDateTime
			,@TimeDeltaInSeconds
			,@AgentServiceStatus
			,@SqlServerServiceStatus
			,@DTCServiceStatus
			,@FullTextSearchStatus
			,@BufferCacheHitRatioPercentage
			,@CheckpointWrites
			,@ClientComputers
			,@CPUActivityPercentage
			,@CPUTimeDelta
			,@CPUTimeRaw
			,@DistributionLatencyInSeconds
			,@FullScans
			,@IdleTimeDelta
			,@IdleTimePercentage
			,@IdleTimeRaw
			,@IOActivityPercentage
			,@IOTimeDelta
			,@IOTimeRaw
			,@LazyWriterWrites
			,@LockWaits
			,@Logins
			,@LogFlushes
			,@SqlMemoryAllocatedInKilobytes
			,@SqlMemoryUsedInKilobytes
			,@OldestOpenTransactionsInMinutes
			,@PacketErrors
			,@PacketsReceived
			,@PacketsSent
			,@PageErrors
			,@PageLifeExpectancy
			,@PageLookups
			,@PageReads
			,@PageSplits
			,@PageWrites
			,@ProcedureCacheHitRatioPercentage
			,@ProcedureCacheSizeInKilobytes
			,@ProcedureCacheSizePercent
			,@ReadAheadPages
			,@ReplicationLatencyInSeconds
			,@ReplicationSubscribed
			,@ReplicationUndistributed
			,@ReplicationUnsubscribed
			,@ResponseTimeInMilliseconds
			,@ServerVersion
			,@SqlCompilations
			,@SqlRecompilations
			,@TableLockEscalations
			,@TempDBSizeInKilobytes
			,@TempDBSizePercent
			,@Batches
			,@UserProcesses
			,@WorkFilesCreated
			,@WorkTablesCreated
			,@SystemProcesses
			,@UserProcessesConsumingCPU  
			,@SystemProcessesConsumingCPU  
			,@BlockedProcesses 
			,@OpenTransactions			
			,@DatabaseCount
			,@DataFileCount
			,@LogFileCount
			,@DataFileSpaceAllocatedInKilobytes
			,@DataFileSpaceUsedInKilobytes
			,@LogFileSpaceAllocatedInKilobytes
			,@LogFileSpaceUsedInKilobytes
			,@TotalLocks
			,@BufferCacheSizeInKilobytes
			,@ActiveProcesses
			,@LeadBlockers
			,@CommittedInKilobytes
			,@ConnectionMemoryInKilobytes
			,@FreePagesInKilobytes
			,@GrantedWorkspaceMemoryInKilobytes
			,@LockMemoryInKilobytes
			,@OptimizerMemoryInKilobytes
			,@TotalServerMemoryInKilobytes
			,@FreeCachePagesInKilobytes
			,@CachePagesInKilobytes
			,@MaxConnections
			,@PhysicalMemoryInKilobytes
			,@ProcessorCount
			,@ProcessorsUsed
			,@ProcessorType
			,@ServerHostName
			,@RealServerName
			,@WindowsVersion
			,@SqlServerEdition
			,@RunningSince
			,@IsClustered
			,@OsStatisticAvailability
			,@ClusterNodeName
			,@VersionStoreGenerationKilobytes
			,@VersionStoreCleanupKilobytes
			,@TempdbPFSWaitTimeMilliseconds 
			,@TempdbGAMWaitTimeMilliseconds
			,@TempdbSGAMWaitTimeMilliseconds
			,@Transactions
			,@SQLBrowserServiceStatus        --SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --update the SQL Browser service column
			,@SQLActiveDirectoryHelperServiceStatus   --SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --update the SQL Active Directory Helper service column
)
exec p_UpdateServerVersion @SQLServerID, @ServerVersion, @ServerEdition

update [MonitoredSQLServers] 
	set [ActiveClusterNode] = @ClusterNodeName,
		[RealServerName] = @RealServerName
	where [SQLServerID] = @SQLServerID

-- exec p_UpdateLastRefreshTime @SQLServerID

select @ReturnMessage = @@error

end
 
GO 

---------- P_INSERTSQLQUERYPLAN.SQL
--Added new procedure in SQLdm 9.0 by Ankit Srivastava -- inserting query plan 
--declare @planId int
--EXEC p_InsertSQLQueryPlan 'QRWTWT23142425wtwtee,234,@planId
 
if (object_id('p_InsertSQLQueryPlan') is not null)
begin
drop procedure p_InsertSQLQueryPlan
end
go
create procedure [dbo].[p_InsertSQLQueryPlan]
	@QueryPlan nvarchar(max),
	@SQLStatementID int,
	@PlanID int output, 
	@IsActualPlan bit = 1 --SQLdm 10.0 (Tarun Sapra) - Display Estimated Query Plan - Flag to tell if the query plan is actual or estimated
as
begin

	if @QueryPlan is null or len(@QueryPlan) = 0 
		return

	
	if (@QueryPlan is not null or @QueryPlan <> 'NULL')
	begin
		if (select case when @QueryPlan = cast(@QueryPlan as varchar(4000)) then 1 else 0 end) = 1
		begin
			if not exists(Select * from SQLQueryPlans where [PlanXML]=@QueryPlan and [SQLStatementID]=@SQLStatementID) --SQLdm 9.0 (Ankit Srivastava) - SQL Query Plan View -validating against the combination of both the columns
			BEGIN
			insert into SQLQueryPlans([PlanXML],[SQLStatementID],[Overflow],[IsActualPlan]) values (@QueryPlan,@SQLStatementID,0,@IsActualPlan) --SQLdm 10.0 (Tarun Sapra) - Display Estimated Query Plan - Flag to tell if the query plan is actual or estimated
			select @PlanID = scope_identity()
			END
			ELSE
			Select @PlanID=PlanID from SQLQueryPlans where [PlanXML]=@QueryPlan and [SQLStatementID]=@SQLStatementID --SQLdm 9.0 (Ankit Srivastava) - SQL Query Plan View - Selection on based of both the columns
		end
		else
		begin
		if not exists(Select * from SQLQueryPlansOverflow,SQLQueryPlans where [PlanXMLOverflow]=@QueryPlan and [SQLStatementID]=@SQLStatementID) --SQLdm 9.0 (Ankit Srivastava) - SQL Query Plan View -validating against the combination of both the columns
			BEGIN
			insert into SQLQueryPlans([SQLStatementID],[Overflow],[IsActualPlan]) values (@SQLStatementID,1,@IsActualPlan) --SQLdm 10.0 (Tarun Sapra) - Display Estimated Query Plan - Flag to tell if the query plan is actual or estimated
			select @PlanID = scope_identity()
			insert into SQLQueryPlansOverflow([PlanXMLOverflow],[PlanID]) values (@QueryPlan,@PlanID)
			END
		else
		Select @PlanID=SQP.[PlanID]  from SQLQueryPlansOverflow,SQLQueryPlans SQP where [PlanXMLOverflow]=@QueryPlan and SQP.[SQLStatementID]=@SQLStatementID --SQLdm 9.0 (Ankit Srivastava) - SQL Query Plan View - Selection on based of both the columns
		end
	end

	
end

GO

 
GO 

---------- P_INSERTSQLSIGNATURE.SQL
if (object_id('p_InsertSQLSignature') is not null)
begin
drop procedure p_InsertSQLSignature
end
go
create procedure p_InsertSQLSignature
	@SQLSignatureHash varchar(30),
	@SQLSignature nvarchar(max),
	@SQLStatementExampleID int,
	@SQLSignatureID int output
as
begin

	if len(@SQLSignature) = 0
		return

	select @SQLSignatureID = SQLSignatureID
	from SQLSignatures
	where 
		SQLSignatureHash = @SQLSignatureHash
	
	if (@@rowcount > 1)
	begin
		select @SQLSignatureID = SQLSignatureID
		from AllSQLSignatures
		where SQLSignatureHash = @SQLSignatureHash
	end

	if (nullif(@SQLSignatureID,0) is null)
	begin
		if (select case when @SQLSignature = cast(@SQLSignature as varchar(4000)) then 1 else 0 end) = 1
		begin
			insert into SQLSignatures([SQLSignatureHash],[SQLSignature],[Overflow],[SQLStatementExampleID]) values (@SQLSignatureHash,@SQLSignature,0,@SQLStatementExampleID)
			select @SQLSignatureID = scope_identity()
		end
		else
		begin
			insert into SQLSignatures([SQLSignatureHash],[Overflow],[SQLStatementExampleID]) values (@SQLSignatureHash,1,@SQLStatementExampleID)
			select @SQLSignatureID = scope_identity()
			insert into SQLSignaturesOverflow([SQLSignatureID],[SQLSignatureOverflow]) values (@SQLSignatureID,@SQLSignature)
			
		end
	end

	
end
go
 
GO 

---------- P_INSERTSQLSTATEMENT.SQL
if (object_id('p_InsertSQLStatement') is not null)
begin
drop procedure p_InsertSQLStatement
end
go
create procedure p_InsertSQLStatement
	@SQLStatementHash varchar(30),
	@SQLStatement nvarchar(max),
	@SQLStatementID int output
as
begin

	if @SQLStatement is null or len(@SQLStatement) = 0 
		return

	select @SQLStatementID = SQLStatementID
	from SQLStatements
	where 
		SQLStatementHash = @SQLStatementHash

	if (@@rowcount > 1)
	begin
		select @SQLStatementID = SQLStatementID
		from AllSQLStatements
		where SQLStatementHash = @SQLStatementHash
	end

	if (nullif(@SQLStatementID,0) is null)
	begin
		if (select case when @SQLStatement = cast(@SQLStatement as varchar(4000)) then 1 else 0 end) = 1
		begin
			insert into SQLStatements([SQLStatementHash],[SQLStatement],[Overflow]) values (@SQLStatementHash,@SQLStatement,0)
			select @SQLStatementID = scope_identity()
		end
		else
		begin
			insert into SQLStatements([SQLStatementHash],[Overflow]) values (@SQLStatementHash,1)
			select @SQLStatementID = scope_identity()
			insert into SQLStatementsOverflow([SQLStatementID],[SQLStatementOverflow]) values (@SQLStatementID,@SQLStatement)
		end
	end

	
end
go
 
GO 

---------- P_INSERTTABLEGROWTH.SQL
if (object_id('p_InsertTableGrowth') is not null)
begin
drop procedure p_InsertTableGrowth
end
go
create procedure p_InsertTableGrowth
	@SQLServerID int,
	@UTCCollectionDateTime datetime,
	@DatabaseName nvarchar(128) = null,
	@SystemDatabase bit,
	@DatabaseID int = -1,
	@TableName nvarchar(255),
	@SchemaName nvarchar(255),
	@SystemTable bit,
	@NumberOfRows bigint,
	@DataSize float,
	@TextSize float,
	@IndexSize float,
	@TimeDeltaInSeconds float,
	@ReturnMessage nvarchar(128) output
as
begin

declare @InnerReturnMessage nvarchar(128), @TableID int

exec [p_InsertTableName] 
   @SQLServerID
  ,@DatabaseName
  ,@SystemDatabase
  ,@TableName
  ,@SchemaName
  ,@SystemTable
  ,@DatabaseID output
  ,@TableID output
  ,@InnerReturnMessage output


insert into [TableGrowth]
	([TableID]
	,[UTCCollectionDateTime]
	,[NumberOfRows]
	,[DataSize]
	,[TextSize]
	,[IndexSize]
	,[TimeDeltaInSeconds])
 values
	(@TableID
	,@UTCCollectionDateTime
	,@NumberOfRows
	,@DataSize
	,@TextSize
	,@IndexSize
	,isnull(@TimeDeltaInSeconds,86400))

end
 
GO 

---------- P_INSERTTABLENAME.SQL
if (object_id('p_InsertTableName') is not null)
begin
drop procedure p_InsertTableName
end
go
create procedure p_InsertTableName
	@SQLServerID int,
	@DatabaseName nvarchar(128) = null,
	@SystemDatabase bit,
	@TableName nvarchar(255),
	@SchemaName nvarchar(255),
    @SystemTable bit,
	@DatabaseID int output,
	@TableID int output,
	@ReturnMessage nvarchar(128) output
as
begin

declare @InnerReturnMessage nvarchar(128)

if isnull(@DatabaseID,0) < 1
	execute [p_InsertDatabaseName] 
	   @SQLServerID
	  ,@DatabaseName
	  ,@SystemDatabase
	  ,null
	  ,@DatabaseID output
	  ,@InnerReturnMessage output

declare @LookupTableID int

select 
	@LookupTableID = TableID 
from 
	SQLServerTableNames (nolock)
where 
	DatabaseID = @DatabaseID
	and TableName = @TableName
	and SchemaName = @SchemaName

if (@LookupTableID is null)
begin
	insert into [SQLServerTableNames]
	   ([DatabaseID]
	   ,[TableName]
	   ,[SchemaName]
	   ,[SystemTable])
	Values
	   (@DatabaseID
	   ,@TableName
	   ,@SchemaName
	   ,@SystemTable)

	select @LookupTableID = SCOPE_IDENTITY()
end

set @TableID = @LookupTableID
set @ReturnMessage = @InnerReturnMessage

end
 
GO 

---------- P_INSERTTABLEREORGANIZATION.SQL
if (object_id('p_InsertTableReorganization') is not null)
begin
drop procedure p_InsertTableReorganization
end
go
create procedure p_InsertTableReorganization
	@SQLServerID int,
	@UTCCollectionDateTime datetime,
	@DatabaseName nvarchar(128) = null,
	@SystemDatabase bit,
	@DatabaseID int = -1,
	@TableName nvarchar(255),
	@SchemaName nvarchar(255),
	@SystemTable bit,
	@ScanDensity float,
	@LogicalFragmentation float,
	@TimeDeltaInSeconds float,
	@ReturnMessage nvarchar(128) output
as
begin

declare @InnerReturnMessage nvarchar(128), @TableID int

exec [p_InsertTableName] 
   @SQLServerID
  ,@DatabaseName
  ,@SystemDatabase
  ,@TableName
  ,@SchemaName
  ,@SystemTable
  ,@DatabaseID output
  ,@TableID output
  ,@InnerReturnMessage output

insert into [TableReorganization]
	([TableID]
	,[UTCCollectionDateTime]
	,[ScanDensity]
	,[LogicalFragmentation]
	,[TimeDeltaInSeconds])
 values
	(@TableID
	,@UTCCollectionDateTime
	,@ScanDensity
	,@LogicalFragmentation
	,isnull(@TimeDeltaInSeconds,86400))

-- was this, but error_message is only valid on SQL Server 2005
-- set @ReturnMessage = isnull(error_message(),'')
set @ReturnMessage = ''

return @@error


end
 
GO 

---------- P_INSERTTEMPDBFILEDATA.SQL
if (object_id('p_InsertTempdbFileData') is not null)
begin
drop procedure p_InsertTempdbFileData
end
go
create procedure p_InsertTempdbFileData
	@DatabaseID int,
	@FileName nvarchar(255),
	@FileType bit,
	@FilePath nvarchar(1000),
	@FileID int,
	@UTCCollectionDateTime datetime,
	@TimeDeltaInSeconds float,
	@DriveName nvarchar(256),
	@FileSizeInKilobytes bigint,
	@UserObjectsInKilobytes bigint,
	@InternalObjectsInKilobytes bigint,
	@VersionStoreInKilobytes bigint,
	@MixedExtentsInKilobytes bigint,
	@UnallocatedSpaceInKilobytes bigint
	
as
begin

if (@FileID is null)
begin
	execute [p_InsertDatabaseFile]
		@DatabaseID,
		@FileName,
		@FileType,
		@FilePath,
		@DriveName,
		@FileID output
end

if (@FileID is null)
	return


insert into
	[TempdbFileData]
	(
		[FileID],
		[UTCCollectionDateTime],
		[FileSizeInKilobytes],
		[UserObjectsInKilobytes],	
		[InternalObjectsInKilobytes],
		[VersionStoreInKilobytes],
		[MixedExtentsInKilobytes],
		[UnallocatedSpaceInKilobytes],
		[TimeDeltaInSeconds]
	)
values
	(
	@FileID,
	@UTCCollectionDateTime,
	@FileSizeInKilobytes,
	@UserObjectsInKilobytes,
	@InternalObjectsInKilobytes,
	@VersionStoreInKilobytes,
	@MixedExtentsInKilobytes,
	@UnallocatedSpaceInKilobytes,
	@TimeDeltaInSeconds
	)

end
 
GO 

---------- P_INSERTVMCONFIGDATA.SQL
if (object_id('p_InsertVMConfigData') is not null)
begin
drop procedure p_InsertVMConfigData
end
go
create procedure p_InsertVMConfigData
	@SQLServerID int,
	@UTCCollectionDateTime datetime,
	@UUID nvarchar(128),
	@Name nvarchar(256),
	@HeartBeat int,
	@DomainName nvarchar(256),
	@BootTime datetime,
	@NumCPUs int,
	@CPULimit bigint,
	@CPUReserve bigint,
	@MemSize bigint,
	@MemLimit bigint,
	@MemReserve bigint,
	@ReturnMessage nvarchar(128) output
as
begin

	insert into [VMConfigData] (
		[SQLServerID],
		[UTCCollectionDateTime],
		[UUID] ,
		[VMName] ,
		[VMHeartBeat] ,
		[DomainName] ,
		[BootTime] ,
		[NumCPUs] ,
		[CPULimit] ,
		[CPUReserve] ,
		[MemSize] ,
		[MemLimit] ,
		[MemReserve] )
	values (
		@SQLServerID ,
		@UTCCollectionDateTime , 
		@UUID ,
		@Name ,
		@HeartBeat ,
		@DomainName ,
		@BootTime ,
		@NumCPUs ,
		@CPULimit ,
		@CPUReserve ,
		@MemSize ,
		@MemLimit ,
		@MemReserve )
	
end
	
 
GO 

---------- P_INSERTVMSTATISTICS.SQL
if (object_id('p_InsertVMStatistics') is not null)
begin
drop procedure p_InsertVMStatistics
end
go
create procedure p_InsertVMStatistics 
	@SQLServerID int,
	@UTCCollectionDateTime datetime,
	@CPUUsage float,
	@CPUUsageMHz int,
	@CPUReady bigint,
	@CPUSwapWait bigint,
	@MemSwapInRate bigint,
	@MemSwapOutRate bigint,
	@MemSwapped bigint,
	@MemActive bigint,
	@MemConsumed bigint,
	@MemGranted bigint,
	@MemBallooned bigint,
	@MemUsage float,
	@DiskRead bigint,
	@DiskWrite bigint,
	@DiskUsage bigint,
	@NetUsage bigint,
	@NetReceived bigint,
	@NetTransmitted bigint,
	@PagePerSecVM bigint,
	@AvailableByteVm bigint,
	@ReturnMessage nvarchar(128) output
as
begin

	insert into [VMStatistics]  (
		[SQLServerID],
		[UTCCollectionDateTime],
		[CPUUsage] ,
		[CPUUsageMHz] ,
		[CPUReady] ,
		[CPUSwapWait] ,
		[MemSwapInRate] ,
		[MemSwapOutRate] ,
		[MemSwapped] ,
		[MemActive] ,
		[MemConsumed] ,
		[MemGranted] ,
		[MemBalooned] ,
		[MemUsage] ,
		[DiskRead] ,
		[DiskWrite] ,
		[DiskUsage] ,
		[NetUsage] ,
		[NetReceived] ,
		[NetTransmitted],
		[PagePerSecVM],
		[AvailableByteVm]	)
	values (
		@SQLServerID,
		@UTCCollectionDateTime ,
		@CPUUsage ,
		@CPUUsageMHz ,
		@CPUReady ,
		@CPUSwapWait ,
		@MemSwapInRate ,
		@MemSwapOutRate ,
		@MemSwapped , 
		@MemActive ,
		@MemConsumed , 
		@MemGranted ,
		@MemBallooned ,
		@MemUsage ,
		@DiskRead ,
		@DiskWrite ,
		@DiskUsage ,
		@NetUsage ,
		@NetReceived ,
		@NetTransmitted,
		@PagePerSecVM,
		@AvailableByteVm	)

end
 
GO 

---------- P_INSERTWAITSTATISTICS.SQL
if (object_id('p_InsertWaitStatistics') is not null)
begin
drop procedure p_InsertWaitStatistics
end
go
create procedure p_InsertWaitStatistics
	@SQLServerID int,
	@UTCCollectionDateTime datetime,
	@TimeDeltaInSeconds float,
	@ReturnID bigint output,
	@ReturnMessage nvarchar(128) output
as
begin

	insert into WaitStatistics
			([SQLServerID]
			,[UTCCollectionDateTime]
			,[TimeDeltaInSeconds]
			)
	values
			(
			@SQLServerID
			,@UTCCollectionDateTime
			,@TimeDeltaInSeconds 
			)

	select @ReturnID = scope_identity()

select @ReturnMessage = @@error

end
 
GO 

---------- P_INSERTWAITSTATISTICSDETAILS.SQL
if (object_id('p_InsertWaitStatisticsDetails') is not null)
begin
drop procedure p_InsertWaitStatisticsDetails
end
go
create procedure p_InsertWaitStatisticsDetails
	@WaitStatisticsId bigint,
	@WaitTypeId int,
	@WaitingTasks bigint,	
	@WaitTimeInMilliseconds bigint,
	@MaxWaitTimeInMilliseconds bigint,
	@ResourceWaitTimeInMilliseconds bigint,
	@ReturnMessage nvarchar(128) output
as
begin
	insert into [WaitStatisticsDetails]
			([WaitStatisticsID]
			,[WaitTypeID]
			,[WaitingTasks]
			,[WaitTimeInMilliseconds]
			,[MaxWaitTimeInMilliseconds]
			,[ResourceWaitTimeInMilliseconds])
	values
			(
			@WaitStatisticsId
			,@WaitTypeId
			,@WaitingTasks	
			,@WaitTimeInMilliseconds 
			,@MaxWaitTimeInMilliseconds
			,@ResourceWaitTimeInMilliseconds 
			)

select @ReturnMessage = @@error

end

	
 
GO 

---------- P_INSERTWAITTYPES.SQL
if (object_id('p_InsertWaitTypes') is not null)
begin
drop procedure p_InsertWaitTypes
end
go
create procedure p_InsertWaitTypes
	@WaitType varchar(120),
	@ReturnID int output,
	@ReturnMessage nvarchar(128) output
as
begin

	declare @WaitTypeReturn int

	select @WaitTypeReturn = [WaitTypeID] 
	from [WaitTypes]
	where [WaitType] = @WaitType
	
	if (@WaitTypeReturn is null)
	begin

		declare @WaitCategoryID int

		exec p_GetWaitCategory @WaitType, @WaitCategoryID output
		
		insert into [WaitTypes]
			(
			[WaitType]
			,[CategoryID]
			)
		values
			(
			@WaitType
			,@WaitCategoryID
			)

		select @WaitTypeReturn = [WaitTypeID] 
		from [WaitTypes]
		where [WaitType] = @WaitType
	end


	select @ReturnID = @WaitTypeReturn
	select @ReturnMessage = @@error

end

	
 
GO 

---------- P_ISAPPSECENABLED.SQL
--p_IsAppSecEnabled
IF (OBJECT_ID('p_IsAppSecEnabled') IS NOT NULL)
BEGIN
DROP PROCEDURE p_IsAppSecEnabled
END
GO    
CREATE PROC p_IsAppSecEnabled
AS
BEGIN
	SELECT ISNULL(Internal_Value,0) AppSecurityEnabled FROM RepositoryInfo (nolock) WHERE Name COLLATE database_default = 'ApplicationSecurityEnabled';
END
 
GO 

---------- P_ISUSERADMINISTRATOR.SQL
IF (object_id('p_IsUserAdministrator') is not null)
BEGIN
drop procedure p_IsUserAdministrator
END
GO

CREATE PROCEDURE [dbo].[p_IsUserAdministrator]
	@IsSQLLogin bit,
	@SQLLoginName nvarchar(128),
	@WindowsSID varbinary(85),
	@PermissionID int
AS
BEGIN
	declare @e int
	declare @securityEnabled bit
	declare @sysadmin bit
	declare @sqldmAdministrator bit
	declare @repositoryVersion int
	
	----------------------------------------------------------------------------------------------------
	-- create temp table to hold the list of matching logins
	----------------------------------------------------------------------------------------------------
	create table #temp_MatchingLogins
	(
		MatchLoginSID varbinary(85) not null
	)
	
	----------------------------------------------------------------------------------------------------
	-- initialize flags
	----------------------------------------------------------------------------------------------------
	set @securityEnabled = 0
	set @sysadmin = 0
	set @sqldmAdministrator = 0

	----------------------------------------------------------------------------------------------------
	-- check if security is enabled
	-- if ApplicationSecurityEnabled flag is there, check if its set, else create the flag and clear it
	----------------------------------------------------------------------------------------------------
	if ((select count([Internal_Value]) 
		from dbo.[RepositoryInfo] 
			where [Name] = 'ApplicationSecurityEnabled') = 1)
	begin
		if ((select count([Internal_Value]) 
			from dbo.[RepositoryInfo] 
				where [Name] = 'ApplicationSecurityEnabled' and [Internal_Value] != 0) = 1)
			set @securityEnabled = 1
		else
			set @securityEnabled = 0
	end
	else
	begin
		-- insert row for application security enabled flag and clear it
		insert into dbo.[RepositoryInfo]
		values ('ApplicationSecurityEnabled',0,'')
		
		set @securityEnabled = 0
	end

	----------------------------------------------------------------------------------------------------
	-- check if user is sysadmin
	----------------------------------------------------------------------------------------------------
	if IS_SRVROLEMEMBER ('sysadmin') = 1
		set @sysadmin = 1
	else
		set @sysadmin = 0

	----------------------------------------------------------------------------------------------------
	-- if security is not enabled set administrator flag because everyone is an administrator
	-- else get the permissions assigned to the user.
	----------------------------------------------------------------------------------------------------
	if @securityEnabled = 0
		set @sqldmAdministrator = 1
	else
	begin
		-- if user is sysadmin they are administrator 
		-- else check the Permisssion table for administrator powers.
		if @sysadmin = 1
		begin
			-- set SQLdm admin flag
			set @sqldmAdministrator = 1
		end
		else
		begin
			-- determine matching logins
			if @IsSQLLogin = 1
			begin
				-- insert the matching login from syslogins table
				insert into #temp_MatchingLogins
				select sid from master..syslogins where name = @SQLLoginName and isntname = 0
			end
			else
			begin
				-- determine the version of SQLdm repository.
				select @repositoryVersion = CAST(SUBSTRING(CONVERT(char(20), SERVERPROPERTY('ProductVersion')),1,1) as int)
				
				-- if SQL Server 2000, just insert the input windows user sid into temp table because
				-- SQL Server 2000 does not have support for getting the user token.
				-- if SQL Server 2005 or higher get the sids from the login token.
				if @repositoryVersion = 8
					insert into #temp_MatchingLogins values(@WindowsSID)
				else				
					insert into #temp_MatchingLogins
					exec ('select sid from sys.login_token where type = ''WINDOWS LOGIN'' or type = ''WINDOWS GROUP''')				
			end
			
			-- if matching logins are available get token information
			if (select count(MatchLoginSID) from #temp_MatchingLogins) > 0
			begin

				-- check if user has administrator power with specified permisison ID.
				if (select count(Permission) 
					from [dbo].[Permission]
						where Permission = 2 -- admin power
							and LoginSID in (select MatchLoginSID from #temp_MatchingLogins)
								and Enabled = 1
									and PermissionID != @PermissionID) > 0
					set @sqldmAdministrator = 1
				else
					set @sqldmAdministrator = 0
			end
		end
	end

	----------------------------------------------------------------------------------------------------
	-- select flags & assigned servers
	----------------------------------------------------------------------------------------------------
	select @sqldmAdministrator as SQLdmAdministrator
	
	select @e = @@error
	return @e
END
GO
 
GO 

---------- P_LOGGROOMINGACTION.SQL
if (object_id('Grooming.p_LogGroomingAction') is not null)
begin
drop procedure Grooming.p_LogGroomingAction
end
go
CREATE PROCEDURE [Grooming].[p_LogGroomingAction]
(
@RunID uniqueidentifier,
@Sequence int output,
@Action nvarchar(256),
@AffectedRecords int,
@InstanceName nvarchar(256) = null
)
AS
BEGIN

	set @Sequence = @Sequence + 1
	insert into [GroomingLog] (RunID,Sequence,UTCActionEndDateTime,[Action],AffectedRecords,InstanceName)
	values (@RunID, @Sequence, getutcdate(), @Action, @AffectedRecords, @InstanceName)

END


 
GO 

---------- P_MOVEQUERYMONITORSTATEMENT.SQL
if (object_id('p_MoveQueryMonitorStatement') is not null)
begin
drop procedure p_MoveQueryMonitorStatement
end
go
create procedure p_MoveQueryMonitorStatement
	@SQLServerID int,
	@UTCCollectionDateTime datetime,
	@ApplicationName nvarchar(256),
	@ApplicationNameID int output,
	@DatabaseName nvarchar(255),
	@DatabaseID int output,
	@HostName nvarchar(256),
	@HostNameID int output,
	@LoginName nvarchar(256),                                           
	@LoginNameID int output,
	@SessionID smallint,
	@StatementType int,
	@SQLStatement nvarchar(max),
	@SQLStatementHash nvarchar(30),
	@SQLStatementID int output,
	@SQLSignature nvarchar(max),
	@SQLSignatureHash nvarchar(30),
	@SQLSignatureID int output,
	@StatementUTCStartTime datetime,
	@StatementLocalStartTime datetime,
	@DurationMilliseconds bigint,
	@CPUMilliseconds bigint,
	@Reads bigint,
	@Writes bigint,
	@CompletionTime datetime
as
begin
	exec p_InsertQueryMonitorStatement 
		@SQLServerID,
		@UTCCollectionDateTime,
		@ApplicationName,
		@ApplicationNameID ,
		@DatabaseName,
		@DatabaseID,
		@HostName,
		@HostNameID,
		@LoginName,                                       
		@LoginNameID,
		@SessionID,
		@StatementType,
		@SQLStatement,
		@SQLStatementHash,
		@SQLStatementID,
		@SQLSignature,
		@SQLSignatureHash,
		@SQLSignatureID,
		@StatementUTCStartTime,
		@StatementLocalStartTime,
		@DurationMilliseconds,
		@CPUMilliseconds,
		@Reads,
		@Writes

	update QueryMonitor
		set DeleteFlag = 1
	where 
		SQLServerID=@SQLServerID and
		UTCCollectionDateTime =@UTCCollectionDateTime and
		isnull(DatabaseID ,0) =isnull(@DatabaseID ,0) and
		isnull(ClientComputerName ,'') =isnull(@HostName ,0) and
		isnull(SqlUserName ,'') =isnull(@LoginName ,0) and
		isnull(Spid ,0) =isnull(@SessionID ,0) and
		isnull(StatementType ,0) =isnull(@StatementType ,0) and
		isnull(StatementText ,'') =isnull(@SQLStatement ,0) and
		isnull(DurationMilliseconds ,0) =isnull(@DurationMilliseconds ,0) and
		isnull(CPUMilliseconds ,0) =isnull(@CPUMilliseconds ,0) and
		isnull(Reads ,0) =isnull(@Reads ,0) and
		isnull(Writes ,0) =isnull(@Writes ,0) and
		(CompletionTime is null or isnull(CompletionTime,getdate()) =isnull(@CompletionTime ,getdate()))

end

go
 
GO 

---------- P_POPULATEMETRICTHRESHOLDS.SQL
--p_PopulateMetricThresholds 92
IF (OBJECT_ID('p_PopulateMetricThresholds') IS NOT NULL)
BEGIN
DROP PROCEDURE p_PopulateMetricThresholds
END
GO
CREATE PROCEDURE [dbo].p_PopulateMetricThresholds
	  @MetricID BIGINT
AS
BEGIN
	--DECLARE @retVal INT
	--		,@WarningThresholdXML NVARCHAR(MAX)
	--		,@WarningThresholdXMLRef INT
	--		,@CriticalThresholdXML NVARCHAR(MAX)
	--		,@CriticalThresholdXMLRef INT
	--		,@InfoThresholdXML NVARCHAR(MAX)
	--		,@InfoThresholdXMLRef INT
	--		;
			
	SELECT SQLServerID, Metric, CONVERT(XML,WarningThreshold).value('(/Threshold/Value)[1]','numeric') WarningThreshold,CONVERT(XML,CriticalThreshold).value('(/Threshold/Value)[1]','numeric') CriticalThreshold,CONVERT(XML,InfoThreshold).value('(/Threshold/Value)[1]','numeric') InfoThreshold   FROM MetricThresholds WHERE Metric = @MetricID;
	--IF(@WarningThresholdXML !='' AND @CriticalThresholdXML !='' AND @InfoThresholdXML !='') BEGIN
	--	--Putting xml in sql cache
	--	EXEC sp_xml_preparedocument @WarningThresholdXMLRef OUTPUT, @WarningThresholdXML;
	--	EXEC sp_xml_preparedocument @CriticalThresholdXMLRef OUTPUT, @CriticalThresholdXML;
	--	EXEC sp_xml_preparedocument @InfoThresholdXMLRef OUTPUT, @InfoThresholdXML;
		
	--	SELECT W.MetricID,W.WarningThreshold,C.CriticalThreshold, I.InfoThreshold, W.StateNum WarningState, C.StateNum CriticalState,I.StateNum InfoState
	--	FROM
	--	(SELECT @MetricID MetricID, Value WarningThreshold,@WarningState StateNum FROM OPENXML(@WarningThresholdXMLRef,'/Threshold',2) WITH(Value NUMERIC)) W
	--	 JOIN 
	--	(SELECT @MetricID MetricID, Value CriticalThreshold, @CriticalState StateNum FROM OPENXML(@CriticalThresholdXMLRef,'/Threshold',2) WITH(Value NUMERIC)) C
	--	ON (W.MetricID = C.MetricID)
	--	 JOIN 
	--	(SELECT  @MetricID MetricID, Value InfoThreshold, @InfoState StateNum FROM OPENXML(@InfoThresholdXMLRef,'/Threshold',2) WITH(Value NUMERIC)) I
	--	ON (C.MetricID = I.MetricID)
	--	--Removing xml from sql cache
	--	EXEC sp_xml_removedocument @WarningThresholdXMLRef;
	--	EXEC sp_xml_removedocument @CriticalThresholdXMLRef;
	--	EXEC sp_xml_removedocument @InfoThresholdXMLRef;
	--END
	
END
 
GO 

---------- P_POPULATEMETRICTHRESHOLDSNEW.SQL
--p_PopulateMetricThresholdsNew 92
IF (OBJECT_ID('p_PopulateMetricThresholdsNew') IS NOT NULL)
BEGIN
DROP PROCEDURE [p_PopulateMetricThresholdsNew]
END
GO
CREATE PROCEDURE [dbo].[p_PopulateMetricThresholdsNew]
	  @MetricID BIGINT
AS
BEGIN
	 SELECT me.SQLServerID, me.Metric, CONVERT(XML,WarningThreshold).value('(/Threshold/Value)[1]','numeric') WarningThreshold,CONVERT(XML,CriticalThreshold).value('(/Threshold/Value)[1]','numeric') CriticalThreshold,CONVERT(XML,InfoThreshold).value('(/Threshold/Value)[1]','numeric') InfoThreshold ,m.InstanceName
   FROM MonitoredSQLServers m (NOLOCK)
		JOIN MetricThresholds me (NOLOCK) ON m.SQLServerID = me.SQLServerID 
   WHERE m.Active =1 and  me.Metric = @MetricID;	
END
 
GO 

---------- P_POSTINSTALLUPGRADE.SQL
IF (object_id('p_PostInstallUpgrade') IS NOT NULL)
BEGIN
DROP PROCEDURE p_PostInstallUpgrade
END
GO

CREATE PROCEDURE [dbo].[p_PostInstallUpgrade]
AS
BEGIN
	set ansi_warnings on
	if (select isnull(count([Internal_Value]),0) from [dbo].[RepositoryInfo] where [Name] = 'PostInstallUpgradeTo7.2') = 0
	begin
		declare @SQLVersion int
		select @SQLVersion = Internal_Value from RepositoryInfo where Name = 'SQLVersionAtUpgrade'

		if @SQLVersion < 10
		begin
			update DefaultMetricThresholds set Data = null where Data = ''
			update MetricThresholds set Data = null where Data = ''
			update MonitoredSQLServers set QueryMonitorAdvancedConfiguration = null where QueryMonitorAdvancedConfiguration = ''
			update CustomCounterDefinition set Batch = null where Batch = ''
			update MonitoredSQLServers set DiskCollectionSettings = null where DiskCollectionSettings = ''
			update MonitoredSQLServers set ActiveWaitAdvancedConfiguration = null where ActiveWaitAdvancedConfiguration = ''
			update MonitoredSQLServers set TableStatisticsExcludedDatabases = null where TableStatisticsExcludedDatabases = ''
			update MetricInfo set Comments = null where Comments = ''
			
			insert into [dbo].[RepositoryInfo] ([Name], [Internal_Value],[Character_Value]) values ('PostInstallUpgradeTo7.2', 1, Convert(nvarchar(30), GetDate(), 121))
		end
	end
	
	set ansi_warnings on
	--if (select isnull(count([Internal_Value]),0) from [dbo].[RepositoryInfo] where [Name] = 'PostInstallUpgradeTo7.5') = 0
	--begin
	--		update DiskDrives set DatabaseSizeTime = UTCCollectionDateTime where DatabaseSizeTime is null
			
	--		insert into [dbo].[RepositoryInfo] ([Name], [Internal_Value],[Character_Value]) values ('PostInstallUpgradeTo7.5', 1, Convert(nvarchar(30), GetDate(), 121))
	--end
	if not exists (select name from sysindexes where name = 'IXAlerts2')
	begin
		print 'Creating IXAlerts2'
		create nonclustered index [IXAlerts2] ON [Alerts]([ServerName],[UTCOccurrenceDateTime] DESC,[Active])
	end
	
	if not exists (select name from sysindexes where name = 'IXAlerts4')
	begin
		-- IXAlerts4 added to improve selection of active alerts and alert summary
		print 'Creating IXAlerts4'
		create nonclustered index [IXAlerts4] ON [Alerts]([UTCOccurrenceDateTime] DESC,[ServerName],[Severity])
	end
	
	if not exists (select name from sysindexes where name = 'IXAlerts5')
	begin
		print 'Creating IXAlerts5'
		create nonclustered index [IXAlerts5] ON [Alerts] ([ServerName], [UTCOccurrenceDateTime]) INCLUDE ([AlertID]) ON [PRIMARY]
	end

	if exists (select name from sysindexes where name = 'IXAlerts3')
	begin
		-- 6.0.1 - get rid of useless index
		print 'Dropping IXAlerts3'
		drop index [Alerts].[IXAlerts3]
	end


	if not exists (select name from sys.indexes where name = 'IX_Alerts_ViewSupport')
	begin
		create index IX_Alerts_ViewSupport on Alerts(ServerName, Metric, UTCOccurrenceDateTime, AlertID) include (DatabaseName,TableName,Severity, Active, StateEvent,Value,Heading,Message) 
	end

	--if not exists (select name from sys.indexes where name = 'IX_Alerts_ViewSupport_Operational')
	--begin
	--	create index IX_Alerts_ViewSupport_Operational on Alerts([ServerName], [UTCOccurrenceDateTime])  include (Metric,DatabaseName,TableName,Severity, Active, StateEvent,Value,Heading,Message) 
	--end

	
	if not exists (select name from sys.indexes where name = 'IX_Alerts_PredictiveTrainingIndex')
	begin
		create index IX_Alerts_PredictiveTrainingIndex on Alerts([ServerName],[Metric],[Severity],[UTCOccurrenceDateTime]) include ([StateEvent])
	end
	


	if not exists (select name from sysindexes where name = 'IXTasks')
	begin
		print 'Creating IXTasks'
		create nonclustered index [IXTasks] ON [Tasks]([ServerName],[CreatedOn],[Status],[Severity])
	end

	-- create index IXServerStatistics if it doesn't already exist
	IF (not exists(select id from sysindexes where name = 'IXServerStatistics' collate database_default)) 
	begin
		-- 6.0 new index - adding here rather than in the install script
		print 'Creating IXServerStatistics'
		create nonclustered index [IXServerStatistics] on [ServerStatistics]([SQLServerID],[UTCCollectionDateTime]) 
	end
	
--	-- drop index IXQueryMonitorSQLServerID (clustered) 
--	if (exists(select id from sysindexes where name = 'IXQueryMonitorSQLServerID' collate database_default)) 
--	begin
--		print 'Dropping IXQueryMonitorSQLServerID'
--		drop index QueryMonitor.IXQueryMonitorSQLServerID
--	end
--	
--	-- drop index IXQueryMonitorCompletionTime
--	IF (exists(select id from sysindexes where name = 'IXQueryMonitorCompletionTime' collate database_default)) 
--	begin
--		print 'Dropping IXQueryMonitorCompletionTime'
--		drop index QueryMonitor.IXQueryMonitorCompletionTime
--	end
--	
--	-- add clustered index IXQueryMonitorCompletionTime2
--	if (not exists(select id from sysindexes where name = 'IXQueryMonitorCompletionTime2' collate database_default)) 
--	begin
--		-- 6.0 replace index - adding here rather than in the install script
--		print 'Creating IXQueryMonitorCompletionTime2'
--		create clustered index [IXQueryMonitorCompletionTime2] ON [QueryMonitor]([SQLServerID],[CompletionTime]) 
--	end
--
--	if (not exists(select id from sysindexes where name = 'IXQueryMonitorSnapshot' collate database_default)) 
--	begin
--		-- 6.0 new index - adding here rather than in the install script
--		print 'Creating IXQueryMonitorSnapshot'
--		create nonclustered index [IXQueryMonitorSnapshot] on [QueryMonitor]([SQLServerID],[UTCCollectionDateTime]) 
--	end

	if (not exists(select id from sysindexes where name = 'IXTableGrowth' collate database_default)) 
	begin
		-- 6.0 new index - adding here rather than in the install script
		print 'Creating IXTableGrowth'
		create nonclustered index [IXTableGrowth] on [TableGrowth]([TableID],[UTCCollectionDateTime]) 
	end

	if (not exists(select id from sysindexes where name = 'IXTableReorganization' collate database_default)) 
	begin
		-- 6.0 new index - adding here rather than in the install script
		print 'Creating IXTableReorganization'
		create nonclustered index [IXTableReorganization] on [TableReorganization]([TableID],[UTCCollectionDateTime]) 
	end

	if (not exists(select id from sysindexes where name = 'IXSQLServerDatabaseNames2' collate database_default)) 
	begin
		-- 6.0 new index - adding here rather than in the install script
		print 'Creating IXSQLServerDatabaseNames2'
		create nonclustered index [IXSQLServerDatabaseNames2] on [SQLServerDatabaseNames]([SQLServerID],[DatabaseID]) 
	end

	if (not exists(select id from sysindexes where name = 'IXSQLServerTableNames2' collate database_default)) 
	begin
		-- 6.0 new index - adding here rather than in the install script
		print 'Creating IXSQLServerTableNames2'
		create nonclustered index [IXSQLServerTableNames2] on [SQLServerTableNames]([DatabaseID],[TableID]) 
	end

	if (not exists(select id from sysindexes where name = 'IXSQLServerTableNames1' collate database_default)) 
	begin
		-- 6.1 new index 
		print 'Creating IXSQLServerTableNames1'
		CREATE INDEX [IXSQLServerTableNames1] ON [SQLServerTableNames]([DatabaseID],[TableName])
	end

	if (exists(select id from sysindexes where name = 'IXSQLServerTableNames' collate database_default)) 
	begin
		-- 6.1 drop index IXSQLServerTableNames 
		print 'Dropping IXSQLServerTableNames'
		drop index SQLServerTableNames.IXSQLServerTableNames
	end


	if (not exists(select id from sysindexes where name = 'IXQueryMonitorStatisticsSQLServerID' collate database_default)) 
	begin
		CREATE INDEX [IXQueryMonitorStatisticsSQLServerID] ON [QueryMonitorStatistics] ([SQLServerID],[DurationMilliseconds], [StatementType]) 
		INCLUDE ([StatementUTCStartTime], [CPUMilliseconds], [Reads], [Writes], [HostNameID], [ApplicationNameID], [LoginNameID], [DatabaseID], [SQLStatementID], [SQLSignatureID], [SessionID])
	end
		
	if (not exists(select id from sysindexes where name = 'IXDatabaseStatisticsDatabaseID' collate database_default)) 
	begin
		CREATE NONCLUSTERED INDEX IXDatabaseStatisticsDatabaseID ON [dbo].[DatabaseStatistics] ([DatabaseID],[UTCCollectionDateTime])
			INCLUDE ([Transactions],[TimeDeltaInSeconds],[BytesRead],[BytesWritten])
	end
	
	-- Upgrade process for Informational Alerting in 7.0
	if (select count([Internal_Value]) from [dbo].[RepositoryInfo] where [Name] = 'UpgradedTo7.0') <> 0
	begin
		if (select count([Internal_Value]) from [dbo].[RepositoryInfo] where [Name] = 'PostInstallUpgradeTo7.0') = 0
		begin
		
			declare @BatchUpgradeDate datetime
			
			set @BatchUpgradeDate = DATEADD(dd, datediff(dd, 0, GETDATE()-1),0)
			
			-- Alerts
			update [dbo].[Alerts] set [Severity] = [Severity]*2 where [UTCOccurrenceDateTime] >= @BatchUpgradeDate  and [Severity] in (2,4)
			
			-- ServerActivity
			select SQLServerID, UTCCollectionDateTime, cast(StateOverview as XML) as [StateOverview] into #SATempData from ServerActivity where UTCCollectionDateTime >= @BatchUpgradeDate

			while exists (select * from #SATempData where StateOverview.exist('/Servers/Server//State/@Severity[.="4"]') = 1)
				update #SATempData 
					set StateOverview.modify('replace value of (/Servers/Server//State/@Severity[.="4"])[1] with "8"')

			while exists (select * from #SATempData where StateOverview.exist('/Servers/Server//State/@Severity[.="2"]') = 1)
				update #SATempData 
					set StateOverview.modify('replace value of (/Servers/Server//State/@Severity[.="2"])[1] with "4"')

			update [dbo].[ServerActivity] set [ServerActivity].[StateOverview] = convert(nvarchar(max), b.StateOverview) from #SATempData b where ServerActivity.SQLServerID = b.SQLServerID and ServerActivity.UTCCollectionDateTime = b.UTCCollectionDateTime

			-- Tasks
			update [dbo].[Tasks] set [Severity] = [Severity]*2 where [CreatedOn] = @BatchUpgradeDate and [Severity] in (2,4) 

			insert into [dbo].[RepositoryInfo] ([Name], [Internal_Value],[Character_Value]) values ('PostInstallUpgradeTo7.0', 1, Convert(nvarchar(30), @BatchUpgradeDate, 121))
		end
	end				
	if (not exists(select Internal_Value from RepositoryInfo where Name = 'Installed6.6GroomingHotfix'))
	begin

		create index [ActiveWaitStatisticsHostNameID] on [ActiveWaitStatistics]([HostNameID])
		create index [QueryMonitorStatisticsHostNameID] on [QueryMonitorStatistics]([HostNameID]) 
		create index [DeadlockProcessesHostNameID] on [DeadlockProcesses]([HostNameID])
		create index [BlockingSessionStatisticsHostNameID] on [BlockingSessionStatistics]([HostNameID])

		create index [ActiveWaitStatisticsApplicationNameID] on [ActiveWaitStatistics]([ApplicationNameID])
		create index [QueryMonitorStatisticsApplicationNameID] on [QueryMonitorStatistics]([ApplicationNameID]) 
		create index [DeadlockProcessesApplicationNameID] on [DeadlockProcesses]([ApplicationNameID])
		create index [BlockingSessionStatisticsApplicationNameID] on [BlockingSessionStatistics]([ApplicationNameID])
		create index [QuerySignatureAggregationApplicationNameID] on [QuerySignatureAggregation]([ApplicationNameID])
							
		create index [ActiveWaitStatisticsLoginNameID] on [ActiveWaitStatistics]([LoginNameID])
		create index [QueryMonitorStatisticsLoginNameID] on [QueryMonitorStatistics]([LoginNameID]) 
		create index [DeadlockProcessesLoginNameID] on [DeadlockProcesses]([LoginNameID])
		create index [BlockingSessionStatisticsLoginNameID] on [BlockingSessionStatistics]([LoginNameID])

		create index [ActiveWaitStatisticsSQLSignatureID] on [ActiveWaitStatistics]([SQLSignatureID])
		create index [QueryMonitorStatisticsSQLSignatureID] on [QueryMonitorStatistics]([SQLSignatureID]) 
		create index [DeadlockProcessesSQLSignatureID] on [DeadlockProcesses]([SQLSignatureID])
		create index [BlockingSessionStatisticsSQLSignatureID] on [BlockingSessionStatistics]([SQLSignatureID])
		create index [QuerySignatureAggregationSQLSignatureID] on [QuerySignatureAggregation]([SQLSignatureID])

		create index [ActiveWaitStatisticsSQLStatementID] on [ActiveWaitStatistics]([SQLStatementID])
		create index [QueryMonitorStatisticsSQLStatementID] on [QueryMonitorStatistics]([SQLStatementID]) 
		create index [DeadlockProcessesSQLStatementID] on [DeadlockProcesses]([SQLStatementID])
		create index [BlockingSessionStatisticsSQLStatementID] on [BlockingSessionStatistics]([SQLStatementID])

		create index [DatabaseFileActivityFileID] on [DatabaseFileActivity]([FileID],[UTCCollectionDateTime])
		create index [DatabaseFilesDatabaseID] on [DatabaseFiles]([DatabaseID])
		
		CREATE NONCLUSTERED INDEX [QueryMonitorStatisticsAggregationSupport]
			ON [dbo].[QueryMonitorStatistics] ([SQLServerID],[StatementUTCStartTime])
			INCLUDE ([StatementLocalStartTime],[DurationMilliseconds],[CPUMilliseconds],[Reads],[Writes],[ApplicationNameID],[DatabaseID],[StatementType],[SQLSignatureID])
			
		CREATE NONCLUSTERED INDEX [DeadlockProcessesAggregationSupport]
			ON [dbo].[DeadlockProcesses] ([SQLServerID],[UTCOccurrenceDateTime])
			INCLUDE ([LocalOccurrenceDateTime],[ApplicationNameID],[DatabaseID],[SQLSignatureID])

		CREATE NONCLUSTERED INDEX [QuerySignatureAggregationAggregationSupport]
			ON [dbo].[QuerySignatureAggregation] ([SQLServerID])
			INCLUDE ([QuerySignatureAggregationID],[EventUTCStartTime],[QueryMonitorOccurrences],[WaitOcurrences],[BlockingOcurrences],[DeadlockOcurrences],[TotalDurationMilliseconds],[MaxDurationMilliseconds],[TotalCPUMilliseconds],[MaxCPUMilliseconds],[TotalReads],[MaxReads],[TotalWrites],[MaxWrites],[StatementType],[TotalBlockingDurationMilliseconds],[MaxBlockingDurationMilliseconds],[TotalWaitDuration],[MaxWaitDuration],[ApplicationNameID],[DatabaseID],[SQLSignatureID])
	
		insert into RepositoryInfo(Name,Internal_Value)
		select 'Installed6.6GroomingHotfix',1
	end
	
	if (not exists(select index_id from sys.indexes where name = 'IXQueryMonitorStatisticsQMViewSupport' collate database_default)) 
	begin
		create index IXQueryMonitorStatisticsQMViewSupport on [QueryMonitorStatistics](SQLServerID,StatementType,DurationMilliseconds)
		include (UTCCollectionDateTime,CPUMilliseconds,Reads,Writes,HostNameID,ApplicationNameID,LoginNameID,DatabaseID,SQLStatementID,SQLSignatureID,SessionID)
	end

	if (not exists(select index_id from sys.indexes where name = 'IXActiveWaitStatisticsQMViewSupport' collate database_default)) 
	begin
		create index IXActiveWaitStatisticsQMViewSupport on [ActiveWaitStatistics](SQLServerID, WaitDuration, StatementUTCStartTime, SQLSignatureID)
		include (SessionID, HostNameID, ApplicationNameID, LoginNameID, DatabaseID, SQLStatementID)
	end


	if (not exists(select index_id from sys.indexes where name = 'IXDeadlockProcessesQMViewSupport' collate database_default)) 
	begin
		create index IXDeadlockProcessesQMViewSupport ON [dbo].[DeadlockProcesses] ([SQLServerID],[UTCOccurrenceDateTime],[SQLStatementID])
		INCLUDE ([HostNameID],[ApplicationNameID],[LoginNameID],[DatabaseID],[SQLSignatureID],[SessionID])
	end

	if (not exists(select index_id from sys.indexes where name = 'IXServerActivityGroomingSupport' collate database_default)) 
	begin
		create index IXServerActivityGroomingSupport ON [dbo].[ServerActivity] (UTCCollectionDateTime)
	end


	if (not exists(select index_id from sys.indexes where name = 'IXTableGrowthGroomingSupport' collate database_default)) 
	begin
		create index IXTableGrowthGroomingSupport ON [dbo].[TableGrowth] (UTCCollectionDateTime)
	end
	
	if (not exists(select index_id from sys.indexes where name = 'IXDeadlocksGroomingSupport' collate database_default)) 
	begin
		create index IXDeadlocksGroomingSupport ON [dbo].[Deadlocks] (UTCCollectionDateTime)
	end


	IF  EXISTS (SELECT object_id FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[p_DropDefaultConstraint]') AND type in (N'P', N'PC'))
		DROP PROCEDURE [dbo].[p_DropDefaultConstraint]

	if not exists(select name from sys.indexes where name = 'DeadlockProcessDeadlockID')
	begin
		create index DeadlockProcessDeadlockID on DeadlockProcesses([DeadlockID])
	end

	----------------------------------------------------------------------
	-- upgrade to 8.0
	If Not Exists (Select 1 from sys.indexes
		Where name = N'ix_ServerActivity_UTCCollectionDateTime_SQLServerID_Includes_StateOverview' collate database_default
		And object_id = OBJECT_ID('dbo.ServerActivity'))
	  Begin
		print 'Creating ix_ServerActivity_UTCCollectionDateTime_SQLServerID_Includes_StateOverview'
		Create Index ix_ServerActivity_UTCCollectionDateTime_SQLServerID_Includes_StateOverview
			On dbo.ServerActivity (UTCCollectionDateTime, SQLServerID)
			Include (StateOverview);
	  End
	----------------------------------------------------------------------
	-- upgrade to 8.0
	If Not Exists (Select 1 from sys.indexes
			Where name = N'ix__DatabaseSize__DatabaseId_UTCCollectionDateTime_Includes' collate database_default
			And object_id = OBJECT_ID('dbo.DatabaseSize') )
	  Begin
		print 'Creating ix__DatabaseSize__DatabaseId_UTCCollectionDateTime_Includes'
		Create Index ix__DatabaseSize__DatabaseId_UTCCollectionDateTime_Includes
			On dbo.DatabaseSize
		(
			[DatabaseID] ASC,
			[UTCCollectionDateTime] ASC
		)
		Include (DataFileSizeInKilobytes,
			DataSizeInKilobytes,
			TextSizeInKilobytes,
			IndexSizeInKilobytes,
			DataExpansionInKilobytes,
			TimeDeltaInSeconds);
	  End
	----------------------------------------------------------------------
	-- upgrade to 8.0
	If Not Exists (Select 1 from sys.indexes
			Where name = N'ix_DatabaseStatistics_UTCCollectionDateTime_Includes' collate database_default
			And object_id = OBJECT_ID('dbo.DatabaseStatistics') )
	  Begin
		print 'Creating ix_DatabaseStatistics_UTCCollectionDateTime_Includes'
		Create Index ix_DatabaseStatistics_UTCCollectionDateTime_Includes
			On dbo.DatabaseStatistics (UTCCollectionDateTime)
			Include (DatabaseID, DatabaseStatus, Transactions, LogFlushWaits, LogFlushes,
				LogKilobytesFlushed, LogCacheReads, LogCacheHitRatio, TimeDeltaInSeconds,
				NumberReads, NumberWrites, BytesRead, BytesWritten, IoStallMS);
	  End
	
	----------------------------------------------------------------------
	-- upgrade to 8.0

	-- if lower(cast(serverproperty('edition') as nvarchar(50))) like '%enterprise edition%'
	-- or lower(cast(serverproperty('edition') as nvarchar(50))) like '%developer edition%'
	-- begin

	-- If Exists (Select 1 From sys.indexes
		-- Where object_id = object_id('dbo.TableGrowth')
		-- And name = 'PKTableGrowth'
		-- And fill_factor <> 60)
	  -- Begin
	  -- print 'Changing fillfactor of PKTableGowth to 60'
		-- -- Change FillFactor
		-- Alter Index PKTableGrowth On dbo.TableGrowth Rebuild
			-- With (Online = On, FillFactor = 60);
	  -- End
	-- End  

	----------------------------------------------------------------------
	-- upgrade to 8.0
	If Not Exists (Select 1 from sys.indexes
			Where name = N'ix_TempdbFileData_FileID_Includes_UTCCollectionDateTime'
			And object_id = OBJECT_ID('dbo.TempdbFileData'))
	  Begin
		print 'Creating ix_TempdbFileData_FileID_Includes_UTCCollectionDateTime'
		Create Index ix_TempdbFileData_FileID_Includes_UTCCollectionDateTime
			On dbo.TempdbFileData (FileID)
			Include (UTCCollectionDateTime);
	  End
	  
	----------------------------------------------------------------------
	-- upgrade to 8.0
	If Not Exists (Select 1 from sys.indexes
			Where name = N'ix__DiskDrives__SQLServerID_DriveName__Includes'
			And object_id = OBJECT_ID('dbo.DiskDrives'))
	  Begin
		print 'Creating ix__DiskDrives__SQLServerID_DriveName__Includes'
		CREATE INDEX ix__DiskDrives__SQLServerID_DriveName__Includes
			ON dbo.DiskDrives (SQLServerID, DriveName)
			INCLUDE (UTCCollectionDateTime,
				AverageDiskMillisecondsPerRead,
				AverageDiskMillisecondsPerTransfer,
				AverageDiskMillisecondsPerWrite,
				DiskReadsPerSecond,
				DiskTransfersPerSecond,
				DiskWritesPerSecond);
	  End
	  
	----------------------------------------------------------------------	
	----------------------------------------------------------------------
	-- upgrade to 8.0
	If Not Exists (Select 1 from sys.indexes
			Where name = N'ix_BlockingSessionStatistics_UTCCollectionDateTime_Includes_BlockingUTCStartTime'
			And object_id = OBJECT_ID('dbo.BlockingSessionStatistics'))
	  Begin
		print 'Creating ix_BlockingSessionStatistics_UTCCollectionDateTime_Includes_BlockingUTCStartTime'
		Create Index ix_BlockingSessionStatistics_UTCCollectionDateTime_Includes_BlockingUTCStartTime
			On dbo.BlockingSessionStatistics (UTCCollectionDateTime)
			Include (BlockingUTCStartTime);
	  End

	----------------------------------------------------------------------
	-- upgrade to 8.0
	If Not Exists (Select 1 from sys.indexes
			Where name = N'ix_BlockingSessionStatistics_SQLServerID_Includes_BlockingUTCStartTime'
			And object_id = OBJECT_ID('dbo.BlockingSessionStatistics'))
	  Begin
		print 'Creating ix_BlockingSessionStatistics_SQLServerID_Includes_BlockingUTCStartTime'
		Create Index ix_BlockingSessionStatistics_SQLServerID_Includes_BlockingUTCStartTime
			On dbo.BlockingSessionStatistics (SQLServerID)
			Include (BlockingUTCStartTime);
	  End

	----------------------------------------------------------------------
	-- upgrade to 8.0
	If Not Exists (Select 1 from sys.indexes
			Where name = N'ix_BlockingSessionStatistics__Includes_SQLSignatureID'
			And object_id = OBJECT_ID('dbo.BlockingSessionStatistics'))
	  Begin
		print 'Creating ix_BlockingSessionStatistics__Includes_SQLSignatureID'
		Create Index ix_BlockingSessionStatistics__Includes_SQLSignatureID
			On dbo.BlockingSessionStatistics (SQLServerID, BlockingUTCStartTime, BlockingLocalStartTime, BlockingDurationMilliseconds, ApplicationNameID,  DatabaseID)
			Include (SQLSignatureID);
	  End

	----------------------------------------------------------------------------	
	----------------------------------------------------------------------
	-- upgrade to 8.0
	If Not Exists (Select 1 from sys.indexes
			Where name = N'ix_QuerySignatureAggregation_EventUTCStartTime_Includes_QuerySignatureAggregationID'
			And object_id = OBJECT_ID('dbo.QuerySignatureAggregation'))
	  Begin
		print 'Creating ix_QuerySignatureAggregation_EventUTCStartTime_Includes_QuerySignatureAggregationID'
		Create Index ix_QuerySignatureAggregation_EventUTCStartTime_Includes_QuerySignatureAggregationID
			On dbo.QuerySignatureAggregation (EventUTCStartTime)
			Include (QuerySignatureAggregationID);
	  End
	  
	--------------------------------------------------------------
	----------------------------------------------------------------------
	-- upgrade to 8.0
	If Not Exists (Select 1 from sys.indexes
			Where name = N'ix__BaselineStatistics__SQLServerID_MetricID__Includes'
			And object_id = OBJECT_ID('dbo.BaselineStatistics'))
	  Begin
		print 'Creating ix__BaselineStatistics__SQLServerID_MetricID__Includes'
		CREATE INDEX ix__BaselineStatistics__SQLServerID_MetricID__Includes
			ON dbo.BaselineStatistics (SQLServerID, MetricID)
			INCLUDE (UTCCalculation, Mean);
	  End
	-------------------------------------------------------------------------------------	
	----------------------------------------------------------------------
	-- upgrade to 8.0
	If Not Exists (Select 1 from sys.indexes
			Where name = N'ix_MetricThresholds_Enabled_Includes'
			And object_id = OBJECT_ID('dbo.MetricThresholds'))
	  Begin
		print 'Creating ix_MetricThresholds_Enabled_Includes'
		Create Index ix_MetricThresholds_Enabled_Includes
			On dbo.MetricThresholds (Enabled)
			Include (SQLServerID, Metric);
	  End

	----------------------------------------------------------------------
	-- upgrade to 8.0
	If Not Exists (Select 1 from sys.indexes
			Where name = N'ix__MetricThresholds__ThresholdInstanceID'
			And object_id = OBJECT_ID('dbo.MetricThresholds'))
	  Begin
		print 'Creating ix__MetricThresholds__ThresholdInstanceID'
		Create Index ix__MetricThresholds__ThresholdInstanceID
			On dbo.MetricThresholds (ThresholdInstanceID);
	  End
	  
	----------------------------------------------------------------------	

	--upgrade to 9.1
	-----------------------------------------------------------------------------------------------------
	--START SQLdm 9.1 (Ankit Srivastava ) --Rally Defect DE43572 -- Adding index to improve the query performance
	if (not exists (SELECT object_id  FROM sys.indexes WHERE object_id = OBJECT_ID('BlockingSessionStatistics') and name = 'IXBlockingSessionStatistics_DurationMilliSeconds'collate database_default)) 
	begin
		CREATE NONCLUSTERED INDEX [IXBlockingSessionStatistics_DurationMilliSeconds] on [BlockingSessionStatistics]([BlockingDurationMilliseconds])
	END
	--END SQLdm 9.1 (Ankit Srivastava ) --Rally Defect DE43572 -- Adding index to improve the query performance

    --START SQLdm 9.1 (Ankit Srivastava ) --Rally Defect DE43572 -- Adding index to improve the query performance
	if not exists(select name from sys.indexes where object_id=object_id('DeadlockProcesses') and name = 'DeadlockProcess_NonClustered')
	begin
		create index [DeadlockProcess_NonClustered] on DeadlockProcesses([SQLServerID],[UTCOccurrenceDateTime],[SQLSignatureID])
	end
	--END SQLdm 9.1 (Ankit Srivastava ) --Rally Defect DE43572 -- Adding index to improve the query performance
	if not exists(select name from sys.indexes where object_id=object_id('QuerySignatureAggregation') and name = 'QuerySignatureAggregation_SQLServerID')
	begin
		create index [QuerySignatureAggregation_SQLServerID] on QuerySignatureAggregation([SQLServerID])
	end

	--START SQLdm 9.1 (Ankit Srivastava ) --Rally Defect DE43423 -- Adding index to improve the query performance
	IF not exists(select name from sys.indexes where object_id=object_id('DatabaseStatistics') and name = 'IX_DatabaseStatisticsComposite')
	begin
		CREATE NONCLUSTERED INDEX IX_DatabaseStatisticsComposite ON [dbo].[DatabaseStatistics] ([DatabaseID],[UTCCollectionDateTime])
		INCLUDE ([Transactions],[LogFlushWaits],[LogFlushes],[LogKilobytesFlushed],[LogCacheReads],[LogCacheHitRatio],[TimeDeltaInSeconds],[BytesRead],[BytesWritten],[DatabaseSizeTime])
	end
	--END SQLdm 9.1 (Ankit Srivastava ) --Rally Defect DE43423 -- Adding index to improve the query performance

	--START: SQLdm 9.1 (Abhishek Joshi) -Filegroup improvements -add a non-clustered index
	IF NOT EXISTS(SELECT * FROM sys.indexes WHERE name = 'IXDatabaseFilesFileGroupName' )
	Begin
		CREATE NONCLUSTERED INDEX [IXDatabaseFilesFileGroupName] ON [dbo].[DatabaseFiles]
		(
			[FileGroupName] ASC
		)
	End
	
	IF NOT EXISTS(SELECT * FROM sys.indexes WHERE name = 'IXDiskDriveStatisticsUTCCollectionDateTime' )
	Begin
		CREATE NONCLUSTERED INDEX [IXDiskDriveStatisticsUTCCollectionDateTime] ON [dbo].[DiskDriveStatistics]
		(
			[UTCCollectionDateTime] ASC
		)
	End

	IF NOT EXISTS(SELECT * FROM sys.indexes WHERE name = 'IXDiskDriveStatisticsDriveName' )
	Begin
		CREATE NONCLUSTERED INDEX [IXDiskDriveStatisticsDriveName] ON [dbo].[DiskDriveStatistics]
		(
			[DriveName] ASC
		)
	End

	IF NOT EXISTS(SELECT * FROM sys.indexes WHERE name = 'IXDiskDriveStatisticsSQLServerID' )
	Begin
		CREATE NONCLUSTERED INDEX [IXDiskDriveStatisticsSQLServerID] ON [dbo].[DiskDriveStatistics]
		(
			[SQLServerID] ASC
		)
	End
--END: SQLdm 9.1 (Abhishek Joshi) -Filegroup improvements -add a non-clustered index
	-----------------------------------------------------------------------------------------------------
END
 
GO 

---------- P_REMOVEFROMMETRICTHRESHOLD.SQL
if (object_id('p_RemoveFromMetricThreshold') is not null)
begin
drop procedure p_RemoveFromMetricThreshold
end
go

CREATE PROCEDURE dbo.p_RemoveFromMetricThreshold
	@XmlText nvarchar(max),
	@Value nvarchar(256),
	@ValueType nvarchar(256),
	@Result nvarchar(4000) output
AS
BEGIN
declare @xmlDoc int,
		@OP nvarchar(256),
		@Enabled nvarchar(256),
		@valueArray nvarchar(4000),
		@serviceState nvarchar(256)

		SET @OP = 'EQ'
		SET @Enabled = 'true'
		SET @valueArray = ''

		if (@XmlText is not null)
		begin
			exec sp_xml_preparedocument @xmlDoc output, @XmlText
	
			select @OP = [Op], @Enabled = [Enabled] from openxml(@xmlDoc, '/Threshold', 3) with (Op nvarchar(256), Enabled nvarchar(256))

			declare read_threshold_entry cursor
			for
				select servicestate from openxml(@xmlDoc, '//anyType', 2) with (servicestate nvarchar(256) 'text()')

			open read_threshold_entry
			fetch read_threshold_entry into @serviceState
			while @@fetch_status = 0
			begin
				if @serviceState <> @Value
				begin
					set @valueArray = @valueArray + '<anyType xsi:type="' + @ValueType + '">'
					set @valueArray = @valueArray + @serviceState
					set @valueArray = @valueArray + '</anyType>'
				end

				fetch read_threshold_entry into @serviceState
			end
	
			Close read_threshold_entry
			deallocate read_threshold_entry
	
			exec sp_xml_removedocument @xmlDoc
		end

		set @Result = '<?xml version="1.0" encoding="utf-16"?><Threshold xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XmlSchema" Op="'
		set @Result = @Result + @OP
		set @Result = @Result + '" Enabled="'
		set @Result = @Result + @Enabled
		set @Result = @Result + '"><Value xsi:type="ArrayOfAnyType">'
		set @Result = @Result + @valueArray
		set @Result = @Result + '</Value></Threshold>'
END
 
GO 

---------- P_REMOVEMANAGEMENTSERVICE.SQL
if (object_id('p_RemoveManagementService') is not null)
begin
drop procedure p_RemoveManagementService
end
go
CREATE PROCEDURE [dbo].[p_RemoveManagementService](
	@ServiceId UNIQUEIDENTIFIER
)
AS
BEGIN
	DECLARE @e INT

	DELETE FROM [ManagementServices] WHERE ([ManagementServiceID] = @ServiceId)

	SELECT @e = @@error
	if (@e = 0)
	begin
		-- remove the default management service record (if this was the default)
		DELETE FROM [RepositoryInfo] WHERE (LOWER([Character_Value]) = LOWER(@ServiceId))
	end

	RETURN @e
END
 
GO 

---------- P_REPOSITORYINFO.SQL
if (object_id('[p_RepositoryInfo]') is not null)
begin
drop procedure [p_RepositoryInfo]
end
go
create procedure [dbo].[p_RepositoryInfo]
as
begin
	select 
		'Instance Name' as 'Name',
		NULL as 'Internal_Value',
		CONVERT(nvarchar(128), serverproperty('servername')) as 'Character_Value'
	union
	select 
		'Repository Version' as 'Name',
		NULL as 'Internal_Value',
		dbo.fn_GetDatabaseVersion() as 'Character_Value'
	union
	select 
		'Active Servers' as 'Name',
		count(SQLServerID) as 'Internal_Value',
		cast(count(SQLServerID) as nvarchar(256)) as 'Character_Value'
	from MonitoredSQLServers (NOLOCK)
	where Active=1
	union
	select
		Name,
		Internal_Value,
		Character_Value
	from
		[RepositoryInfo] (NOLOCK)
end
 
GO 

---------- P_SAVEANALYSISCONFIGURATION.SQL
if (object_id('p_SaveAnalysisConfiguration') is not null)
begin
drop procedure [p_SaveAnalysisConfiguration]
end
go


create procedure [p_SaveAnalysisConfiguration] 
@sqlServerID INT,
@productionServer bit,
@OLTP bit,
@analysisStartTime DateTime,
@duration INT,
@scheduledDays smallint,
@isActive bit,
@includeDatabase int,
@filterApplication nvarchar(max),
@categoryID xml,
@databaseID xml,
@recommendationID xml,
@schedulingStatus bit --SQLDM10.0 (praveen suhalka) : scheduling status
AS
begin

DECLARE  @analysisConfigID INT
DECLARE @checkXML INT 
BEGIN TRY
   -- Start A Transaction
   --srishti Purohit -- parent transaction will commit this change also
--BEGIN TRANSACTION

--BEGIN

--update records having IsActive true for this server id
UPDATE [dbo].[AnalysisConfiguration]
SET IsActive = 0
WHERE MonitoredServerID = @sqlServerID


			-- insert analysis record in table
			-- insert new record in [PrescriptiveAnalysis] table
			INSERT INTO [dbo].[AnalysisConfiguration] WITH(TABLOCK)
				   ([MonitoredServerID]
           ,[ProductionServer]
           ,[OLTP]
           ,[StartTime]
		   ,[Duration]
           ,[ScheduledDays]
           ,[IncludeDatabase]
           ,[IsActive]
           ,[FilterApplication]
		   ,[SchedulingStatus])   --SQLDM10.0 (praveen suhalka) : scheduling status
			 VALUES ( 
				 @sqlServerID,
				 @productionServer,
				@OLTP ,
				@analysisStartTime ,
				@duration,
				@scheduledDays ,
				@includeDatabase ,
				@isActive ,
				@filterApplication,
				@schedulingStatus   --SQLDM10.0 (praveen suhalka) : scheduling status
			 )
	
			
			--SET @analysisID = SCOPE_IDENTITY()
	SET @analysisConfigID = (CASE WHEN @@ROWCOUNT > 0 THEN SCOPE_IDENTITY() ELSE -1 END)
		if(@analysisConfigID > 0)
		BEGIN
		SET @checkXML = @categoryID.exist('(//CategoryID)')
			if( @checkXML != 0)
			BEGIN
			
				INSERT INTO [dbo].[AnalysisConfigCategories]
			   ([AnalysisConfigurationID]
			   ,[CategoryID])			
				--(SELECT @analysisConfigID, A.B.value('(CategoryID)[1]', 'int' ) ID
				--		FROM    @categoryID.nodes('/Category') A(B))
						(select @analysisConfigID, x.record.query('ID').value('.', 'int')
						from @categoryID.nodes('Category/CategoryID') as x(record))

			END
			SET @checkXML = @databaseID.exist('(//DatabaseID)')
			if( @checkXML != 0)
			BEGIN
			
					  INSERT INTO [dbo].[AnalysisConfigBlockedDatabases]
			  ([AnalysisConfigurationID]
			   ,[DatabaseID])
				--(SELECT @analysisConfigID,T.Item.value('DatabaseID[1]', 'int')
				--FROM   @databaseID.nodes('/Database') AS T(Item))
				(select @analysisConfigID, x.record.query('ID').value('.', 'int')
						from @databaseID.nodes('Database/DatabaseID') as x(record))
			END
			SET @checkXML = @recommendationID.exist('(//RecommendationID)')
			if( @checkXML != 0)
			BEGIN
			
				INSERT INTO [dbo].[AnalysisConfigBlockedRecommendation]
			   ([AnalysisConfigurationID]
			   ,[RecommendationID])
				--(SELECT @analysisConfigID,T.Item.value('RecommendationID[1]', 'nvarchar(10)')
				--FROM   @recommendationID.nodes('/Recommendation') AS T(Item))
				(select @analysisConfigID, x.record.query('ID').value('.', 'nvarchar(10)')
						from @recommendationID.nodes('Recommendation/RecommendationID') as x(record))
			END
	--END

	--COMMIT
	END

END TRY
BEGIN CATCH
 Print 'Transaction Failed - Will Rollback'
  -- Any Error Occurred during Transaction. Rollback
  --ROLLBACK  -- Roll back
  		  
		  SET @analysisConfigID = -1
  RAISERROR ('Error while saving configuration changes.',
             16,
             1)
END CATCH

end
 
GO 
 
GO 

---------- P_SAVEANALYSISRECOMMENDATIONANDPROPERTIES.SQL
if (object_id('p_SaveAnalysisRecommendationAndProperties') is not null)
begin
drop procedure [p_SaveAnalysisRecommendationAndProperties]
end
go

create procedure [p_SaveAnalysisRecommendationAndProperties] 
@prescriptiveAnalysisDetailsID INT,
@listOfRecommendations xml
AS
begin
--For excepttion handling
DECLARE
  @ErrorMessage   varchar(2000)
 ,@ErrorSeverity  tinyint
 ,@ErrorState     tinyint
 -- handling while loop for each recomm
 
DECLARE @countRecomm int
DECLARE @incrementCounter int
DECLARE @prescriptiveAnalysisRecommendationID INT
SET @countRecomm = 0
SET @incrementCounter = 1
SET @prescriptiveAnalysisRecommendationID = 0
 --START save recommendations
		-- Insert recommendations details one by one 

SELECT @countRecomm = @listOfRecommendations.value('count(/ListOfRecommendation/Recomm)', 'int')
if(@countRecomm > 0)
BEGIN

WHILE(@incrementCounter <= @countRecomm)
BEGIN
IF EXISTS(select RecommendationID from PrescriptiveRecommendation where RecommendationID in( SELECT 
			N.Item.value('@RecommID[1]',  'nvarchar(10)') FROM 
			@listOfRecommendations.nodes('/ListOfRecommendation/Recomm[sql:variable("@incrementCounter")]') AS N(Item)
				) AND IsActive = 1)
				BEGIN
				   INSERT INTO [dbo].[PrescriptiveAnalysisRecommendation] 
           ([RecommendationID]
           ,[ComputedRankFactor]
           ,[PrescriptiveAnalysisDetailsID]
           ,[IsFlagged]
		   ,[OptimizationStatusID]
		   ,[OptimizationErrorMessage])
		-- (SELECT B.Item.value('@RecommID[1]',  'nvarchar(10)')
		-- ,B.Item.value('@ComputedRankFactor[1]',      'float')
		-- ,@prescriptiveAnalysisDetailsID
		-- ,B.Item.value('@isFlagged[1]',  'bit')
		--FROM   @listOfRecommendations.nodes('/ListOfAnlysis/Analysis') AS A(Item)
		--CROSS  APPLY A.Item.nodes('Recomm') AS B (Item))

		(
		SELECT 
			N.Item.value('@RecommID[1]',  'nvarchar(10)'),
			N.Item.value('@ComputedRankFactor[1]', 'float'),
			@prescriptiveAnalysisDetailsID,
			N.Item.value('@isFlagged[1]', 'bit'),
			N.Item.value('@OptimizationStatus[1]', 'int'),
			N.Item.value('@OptimizationError[1]', 'nvarchar(max)')
		FROM 
			@listOfRecommendations.nodes('/ListOfRecommendation/Recomm[sql:variable("@incrementCounter")]') AS N(Item)
				)

		SET @prescriptiveAnalysisRecommendationID = (CASE WHEN @@ROWCOUNT > 0 THEN SCOPE_IDENTITY() ELSE -1 END)
		
		if(@prescriptiveAnalysisRecommendationID > 0)
		BEGIN

				   INSERT INTO [dbo].PrescriptiveRecommendationProperty
				   ([RecommendationID],
				   [PropertyName]
				   )
				   (
		SELECT DISTINCT(
			N.Item.value('@RecommID[1]',  'nvarchar(10)')),
			Tab1.Col1.value('@Name[1]', '[nvarchar](200)') AS PROPERTY
		FROM 
			@listOfRecommendations.nodes('/ListOfRecommendation/Recomm[sql:variable("@incrementCounter")]') AS N(Item)
	cross apply N.Item.nodes('Properties/Property') as Tab1(Col1)
				WHERE Tab1.Col1.value('@Name[1]', '[nvarchar](200)') NOT IN(SELECT [PropertyName] FROM PrescriptiveRecommendationProperty
		WHERE N.Item.value('@RecommID[1]',  'nvarchar(10)') =[RecommendationID])
		)

		if(@@ERROR <> 0 )
		BEGIN
			Print 'Error while saving anaysis in [PrescriptiveAnalysis].'
		  -- Any Error Occurred during Transaction. Rollback
		  ROLLBACK  -- Roll back
  		  
			SET @ErrorMessage  = ERROR_MESSAGE()
			SET @ErrorSeverity = ERROR_SEVERITY()
			SET @ErrorState    = ERROR_STATE()
			RAISERROR('Unable to save analysis in PrescriptiveAnalysis.', @ErrorSeverity, @ErrorState)
			RETURN 0
		END
		ELSE
		BEGIN 
		
					INSERT INTO [dbo].[PrescriptiveAnalysisRecommendationProperty]
				   ( [AnalysisRecommendationID] ,
					 [PropertyID]  ,
					 [Value] 
				   )
					  (SELECT @prescriptiveAnalysisRecommendationID
					 ,(SELECT ID FROM PrescriptiveRecommendationProperty 
					 WHERE [PropertyName] = Tab1.Col1.value('@Name[1]', '[nvarchar](200)') AND [RecommendationID] = A.Item.value('@RecommID[1]',  'nvarchar(10)')) AS [PropertyID]
					,VALUE =CASE CAST(Tab1.Col1.query('./value/child::*') as nvarchar(max)) WHEN '' 
					THEN Tab1.Col1.value('.', '[nvarchar](max)')
					ELSE CAST(Tab1.Col1.query('./value/child::*') as nvarchar(max)) END
					--, Tab1.Col1.value('.', '[nvarchar](max)') AS VALUE
					FROM   @listOfRecommendations.nodes('/ListOfRecommendation/Recomm[sql:variable("@incrementCounter")]') AS A(Item)
					cross apply A.Item.nodes('Properties/Property') as Tab1(Col1)
					
					)

					if(@@ERROR <> 0 )
					BEGIN
						Print 'Error while saving anaysis in [PrescriptiveAnalysis].'
					  -- Any Error Occurred during Transaction. Rollback
					  ROLLBACK  -- Roll back
  		  
						SET @ErrorMessage  = ERROR_MESSAGE()
						SET @ErrorSeverity = ERROR_SEVERITY()
						SET @ErrorState    = ERROR_STATE()
						RAISERROR('Unable to save analysis in PrescriptiveAnalysis.', @ErrorSeverity, @ErrorState)
						RETURN 0
					END
			END
		END
END
SET @incrementCounter = @incrementCounter + 1
END

END

--END save recommendations
		if(@@ERROR <> 0)
		BEGIN
			Print 'Error while saving anaysis in [PrescriptiveAnalysis].'
		  -- Any Error Occurred during Transaction. Rollback
		  ROLLBACK  -- Roll back
  		  
			SET @ErrorMessage  = ERROR_MESSAGE()
			SET @ErrorSeverity = ERROR_SEVERITY()
			SET @ErrorState    = ERROR_STATE()
			RAISERROR('Unable to save analysis in PrescriptiveAnalysis.', @ErrorSeverity, @ErrorState)
			RETURN 0
		END
		ELSE 
		BEGIN
			RETURN 1
		END

end
 
GO 
 
GO 

---------- P_SAVEANALYSISRECORDS.SQL
if (object_id('p_SaveAnalysisRecords') is not null)
begin
drop procedure [p_SaveAnalysisRecords]
end
go

create procedure [p_SaveAnalysisRecords] 
@sqlServerID INT,
@analysisStartTime DATETIME,
@analysisCompleteTime DATETIME ,
@recommendationCount INT,
@listOfRecommendations xml,
@analysisID INT OUT,
@prescriptiveAnalysisDetailsID INT OUT,
@prescriptiveAnalysisRecommendationID INT OUT
AS
begin

BEGIN TRY
   -- Start A Transaction
BEGIN TRANSACTION


BEGIN

			-- insert analysis record in table
			-- insert new record in [PrescriptiveAnalysis] table
			INSERT INTO [dbo].[PrescriptiveAnalysis] WITH(TABLOCK)
				   ([SQLServerID]
           ,[UTCAnalysisStartTime]
           ,[UTCAnalysisCompleteTime]
           ,[RecommendationCount]
           ,[RecordCreatedTimestamp]
           ,[RecordUpdateDateTimestamp])
			 VALUES ( @sqlServerID
			 ,@analysisStartTime
			 ,@analysisCompleteTime
			 ,@recommendationCount
			  
			  ,CURRENT_TIMESTAMP
			  ,CURRENT_TIMESTAMP)
	
			
			SET @analysisID = (CASE WHEN @@ROWCOUNT > 0 THEN SCOPE_IDENTITY() ELSE -1 END)
		if(@analysisID > 0)
		BEGIN
			INSERT INTO [dbo].[PrescriptiveAnalysisDetails]
           ([AnalysisID]
           ,[AnalyzerID]
           ,[Status]
           ,[RecommendationCount]
           ,[RecordCreatedTimestamp]
           ,[RecordUpdateDateTimestamp])
			
			(SELECT @analysisID,T.Item.value('@AnalyzerID[1]', 'int'),
			T.Item.value('@status[1]',  'int'),
			T.Item.value('@recommCount[1]', 'int')
			,CURRENT_TIMESTAMP
			,CURRENT_TIMESTAMP
FROM   @listOfRecommendations.nodes('/ListOfAnlysis/Analysis') AS T(Item))

		SET @prescriptiveAnalysisDetailsID = (CASE WHEN @@ROWCOUNT > 0 THEN SCOPE_IDENTITY() ELSE -1 END)
		if(@prescriptiveAnalysisDetailsID > 0)
		BEGIN

				   INSERT INTO [dbo].[PrescriptiveAnalysisRecommendation]
           ([RecommendationID]
           ,[ComputedRankFactor]
           --,[Relevance]
           ,[PrescriptiveAnalysisDetailsID]
     --      ,[Description]
     --      ,[Finding]
     --      ,[ImpactExplanation]
		   --,[ProblemExplanation] 
		   --,[Recommendation]
           ,[IsFlagged])
     (SELECT B.Item.value('@RecommID[1]',  'nvarchar(10)')
	 ,B.Item.value('@ComputedRankFactor[1]',      'float')
	 --,B.Item.value('@Relevance[1]',        'decimal(18,0)')
	 ,PAD.PrescriptiveAnalysisDetailsID
	 --,B.Item.value('@Description[1]',  'nvarchar(4000)')
	 --,B.Item.value('@Finding[1]',  'nvarchar(500)')
	 --,B.Item.value('@Impact[1]',  'nvarchar(4000)')
	 --,B.Item.value('@ProblemExplanation[1]',  'nvarchar(4000)')
	 --,B.Item.value('@Recommendation[1]',  'nvarchar(max)')
	 ,B.Item.value('@isFlagged[1]',  'bit')
	FROM   @listOfRecommendations.nodes('/ListOfAnlysis/Analysis') AS A(Item)
	CROSS  APPLY A.Item.nodes('Recomm') AS B (Item), [PrescriptiveAnalysisDetails] AS PAD
	WHERE [AnalysisID] = @analysisID AND [AnalyzerID] = A.Item.value('@AnalyzerID[1]', 'int'))

		  
		   --START saving proeprties of recommedations for each analysis

		   SET @prescriptiveAnalysisRecommendationID = (CASE WHEN @@ROWCOUNT > 0 THEN SCOPE_IDENTITY() ELSE -1 END)
		if(@prescriptiveAnalysisRecommendationID > 0)
		BEGIN

				   INSERT INTO [dbo].PrescriptiveRecommendationProperty
				   ([RecommendationID],
				   [PropertyName]
				   )
     (SELECT DISTINCT B.Item.value('@RecommID[1]',  'nvarchar(10)') AS RECOMM
	 , Tab1.Col1.value('@Name[1]', '[nvarchar](200)') AS PROPERTY
	FROM   @listOfRecommendations.nodes('/ListOfAnlysis/Analysis') AS A(Item)
	CROSS  APPLY A.Item.nodes('Recomm') AS B (Item)
	cross apply B.Item.nodes('Properties/Property') as Tab1(Col1)
	WHERE Tab1.Col1.value('@Name[1]', '[nvarchar](200)') NOT IN(SELECT [PropertyName] FROM PrescriptiveRecommendationProperty
		WHERE B.Item.value('@RecommID[1]',  'nvarchar(10)') =[RecommendationID])
 ) 

		if(@@ERROR <> 0 )
		BEGIN
			Print 'no record insrted . Transaction Failed - Will Rollback'
		  -- Any Error Occurred during Transaction. Rollback
		  ROLLBACK  -- Roll back
		  
		  SET @analysisID = -1
		  SET @prescriptiveAnalysisDetailsID = -1
		  SET @prescriptiveAnalysisRecommendationID = -1
		  RAISERROR ('Error while saving anaysis.',
             16,
             1)
		END
		ELSE
		BEGIN 
		
					INSERT INTO [dbo].[PrescriptiveAnalysisRecommendationProperty]
				   ( [AnalysisRecommendationID] ,
					 [PropertyID]  ,
					 [Value] 
				   )
					  (SELECT DISTINCT( PAR.ID) AS [AnalysisRecommendationID]
					 ,(SELECT MIN(ID) FROM PrescriptiveRecommendationProperty 
					 WHERE [PropertyName] = Tab1.Col1.value('@Name[1]', '[nvarchar](200)') AND [RecommendationID] = B.Item.value('@RecommID[1]',  'nvarchar(10)')) AS [PropertyID]
					,VALUE =CASE CAST(Tab1.Col1.query('./value/child::*') as nvarchar(max)) WHEN '' 
					THEN Tab1.Col1.value('.', '[nvarchar](max)')
					ELSE CAST(Tab1.Col1.query('./value/child::*') as nvarchar(max)) END
					--, Tab1.Col1.value('.', '[nvarchar](max)') AS VALUE
					FROM   @listOfRecommendations.nodes('/ListOfAnlysis/Analysis') AS A(Item)
					CROSS  APPLY A.Item.nodes('Recomm') AS B (Item)
					cross apply B.Item.nodes('Properties/Property') as Tab1(Col1)
					JOIN PrescriptiveAnalysisRecommendation AS PAR ON PAR.RecommendationID = B.Item.value('@RecommID[1]',  'nvarchar(10)')
					JOIN PrescriptiveAnalysisDetails PAD ON PAD.PrescriptiveAnalysisDetailsID = PAR.PrescriptiveAnalysisDetailsID 
					JOIN PrescriptiveAnalysis PA ON PA.AnalysisID = PAD.AnalysisID
					WHERE PA.[AnalysisID] = @analysisID  AND PAD.[AnalyzerID] = A.Item.value('@AnalyzerID[1]', 'int')
					)

					if(@@ERROR <> 0 )
					BEGIN
						Print 'no record insrted . Transaction Failed - Will Rollback'
					  -- Any Error Occurred during Transaction. Rollback
					  ROLLBACK  -- Roll back
		  
					  SET @analysisID = -1
					  SET @prescriptiveAnalysisDetailsID = -1
					  SET @prescriptiveAnalysisRecommendationID = -1
					  RAISERROR ('Error while saving anaysis.',
						 16,
						 1)
					END
		END


		END
		ELSE
		BEGIN
			Print 'no record insrted . Transaction Failed - Will Rollback'
		  -- Any Error Occurred during Transaction. Rollback
		  ROLLBACK  -- Roll back
		  
		  SET @analysisID = -1
		  SET @prescriptiveAnalysisDetailsID = -1
		  SET @prescriptiveAnalysisRecommendationID = -1
		  RAISERROR ('Error while saving anaysis.',
             16,
             1)
		END
		
		   --END saving proeprties of recommedations for each analysis

		END
		ELSE
		BEGIN
			SET @analysisID = NULL
			SET @prescriptiveAnalysisDetailsID = NULL
			Print 'no record insrted . Transaction Failed - Will Rollback'
		  -- Any Error Occurred during Transaction. Rollback
		  ROLLBACK  -- Roll back
		  
		  SET @analysisID = -1
		  SET @prescriptiveAnalysisDetailsID = -1
		  SET @prescriptiveAnalysisRecommendationID = -1
		  RAISERROR ('Error while saving anaysis.',
             16,
             1)
		END
	END
	ELSE
	BEGIN
			Print 'no record insrted . Transaction Failed - Will Rollback'
		  -- Any Error Occurred during Transaction. Rollback
		  ROLLBACK  -- Roll back
		  		  
		  SET @analysisID = -1
		  SET @prescriptiveAnalysisDetailsID = -1
		  SET @prescriptiveAnalysisRecommendationID = -1
		  RAISERROR ('Error while saving anaysis.',
             16,
             1)
	END
		
	END

	COMMIT

END TRY
BEGIN CATCH
 Print 'Error while saving anaysis.'
  -- Any Error Occurred during Transaction. Rollback
  ROLLBACK  -- Roll back
  		  
		  SET @analysisID = -1
		  SET @prescriptiveAnalysisDetailsID = -1
		  SET @prescriptiveAnalysisRecommendationID = -1
  RAISERROR ('Error while saving anaysis.',
             16,
             1)
END CATCH

end
 
GO 
 
GO 

---------- P_SAVEPRESCRIPTIVEANALYSIS.SQL
if (object_id('p_SavePrescriptiveAnalysis') is not null)
begin
drop procedure [p_SavePrescriptiveAnalysis]
end
go

create procedure [p_SavePrescriptiveAnalysis] 
@sqlServerID INT,
@analysisStartTime DATETIME,
@analysisCompleteTime DATETIME ,
@recommendationCount INT,
@analysisTypeId INT,
@analysisID INT = 0 OUT
AS
begin
--For excepttion handling
DECLARE
  @ErrorMessage   varchar(2000)
 ,@ErrorSeverity  tinyint
 ,@ErrorState     tinyint


-- Save analysis
-- insert analysis record in table
			-- insert new record in [PrescriptiveAnalysis] table
			INSERT INTO [dbo].[PrescriptiveAnalysis] WITH(TABLOCK)
				   ([SQLServerID]
           ,[UTCAnalysisStartTime]
           ,[UTCAnalysisCompleteTime]
           ,[RecommendationCount]
		   ,[AnalysisTypeID]
           ,[RecordCreatedTimestamp]
           ,[RecordUpdateDateTimestamp])
			 VALUES ( @sqlServerID
			 ,@analysisStartTime
			 ,@analysisCompleteTime
			 ,@recommendationCount	
			 ,@analysisTypeId
			  ,CURRENT_TIMESTAMP
			  ,CURRENT_TIMESTAMP)
	
			
			SET @analysisID = (CASE WHEN @@ROWCOUNT > 0 THEN SCOPE_IDENTITY() ELSE -1 END)
			PRINT @analysisID
		if(@analysisID <= 0)
		BEGIN
			Print 'Error while saving anaysis in [PrescriptiveAnalysis].'
		  -- Any Error Occurred during Transaction. Rollback
		  ROLLBACK  -- Roll back
  		  
			SET @ErrorMessage  = ERROR_MESSAGE()
			SET @ErrorSeverity = ERROR_SEVERITY()
			SET @ErrorState    = ERROR_STATE()
			RAISERROR('Unable to save analysis in PrescriptiveAnalysis.', @ErrorSeverity, @ErrorState)
			RETURN 0
		END
		ELSE 
		BEGIN
		-- return analysis id 
		RETURN @analysisID
		END

end
 
GO 
 
GO 

---------- P_SAVEPRESCRIPTIVEANALYSISDETAILS.SQL
if (object_id('p_SavePrescriptiveAnalysisDetails') is not null)
begin
drop procedure [p_SavePrescriptiveAnalysisDetails]
end
go

create procedure [p_SavePrescriptiveAnalysisDetails] 
@analysisID INT,
@analyzerID INT,
@status INT ,
@recommendationCount INT,
@prescriptiveAnalysisDetailsID INT = 0 OUT
AS
begin
--For excepttion handling
DECLARE
  @ErrorMessage   varchar(2000)
 ,@ErrorSeverity  tinyint
 ,@ErrorState     tinyint


-- Save analysis details
-- insert analysis record in table
			-- insert new record in [PrescriptiveAnalysisDetails] table
			if(@analysisID > 0)
		BEGIN
			INSERT INTO [dbo].[PrescriptiveAnalysisDetails]
           ([AnalysisID]
           ,[AnalyzerID]
           ,[Status]
           ,[RecommendationCount]
           ,[RecordCreatedTimestamp]
           ,[RecordUpdateDateTimestamp])
			
			(SELECT @analysisID,
			@analyzerID,
			@status[1],
			@recommendationCount
			,CURRENT_TIMESTAMP
			,CURRENT_TIMESTAMP)

		SET @prescriptiveAnalysisDetailsID = (CASE WHEN @@ROWCOUNT > 0 THEN SCOPE_IDENTITY() ELSE -1 END)
		if(@prescriptiveAnalysisDetailsID <= 0)
		BEGIN
			Print 'Error while saving anaysis in [PrescriptiveAnalysis].'
		  -- Any Error Occurred during Transaction. Rollback
		  ROLLBACK  -- Roll back
  		  
			SET @ErrorMessage  = ERROR_MESSAGE()
			SET @ErrorSeverity = ERROR_SEVERITY()
			SET @ErrorState    = ERROR_STATE()
			RAISERROR('Unable to save analysis in PrescriptiveAnalysis.', @ErrorSeverity, @ErrorState)
			RETURN 0
		END
		ELSE 
		BEGIN
		-- return analysis id 
		RETURN @analysisID
		END
	END

end
 
GO 
 
GO 

---------- P_SETAGGREGATIONFLAG.SQL
if (object_id('p_SetAggregationFlag') is not null)
begin
drop procedure p_SetAggregationFlag
end
go
CREATE PROCEDURE [dbo].p_SetAggregationFlag(
	@SQLSignatureID bigint,
	@DoNotAggregate bit = 0
)
as 
begin
	update SQLSignatures
	set DoNotAggregate = @DoNotAggregate
	where SQLSignatureID = @SQLSignatureID

end
 
GO 

---------- P_SETBASELINEPARAMETERS.SQL
if (object_id('p_SetBaselineParameters') is not null)
begin
drop procedure p_SetBaselineParameters
end
go
CREATE PROCEDURE [dbo].[p_SetBaselineParameters](
	@SQLServerID int,
	@UseDefaults bit,
	@StartDate datetime,
	@EndDate datetime,
	@Days tinyint
)
AS
BEGIN
	declare @err int

	update [MonitoredSQLServers] Set
		   [RefRangeUseDefaults] = @UseDefaults,
  		   [RefRangeStartTimeUTC] = @StartDate,
		   [RefRangeEndTimeUTC] = @EndDate,
		   [RefRangeDays] = @Days
	where [SQLServerID] = @SQLServerID

	select @err = @@error

	return @err
END
		
 
GO 

---------- P_SETDEFAULTALERTTEMPLATE.SQL
if (object_id('p_SetDefaultAlertTemplate') is not null)
begin
drop procedure p_SetDefaultAlertTemplate
end
go

CREATE PROCEDURE [dbo].p_SetDefaultAlertTemplate(
	@templateID int
)
AS
begin
	declare @currentDefault int
	declare @error int
	
	select @currentDefault = TemplateID from dbo.AlertTemplateLookup where [Default] = 1
	set @error = @@ERROR
	
	if (@error = 0)
	BEGIN
		update dbo.AlertTemplateLookup set [Default] = 0 where TemplateID = @currentDefault
		set @error = @@ERROR
	END
	
	if (@error = 0)
	BEGIN
		update dbo.AlertTemplateLookup set [Default] = 1 where TemplateID = @templateID
		set @error = @@ERROR
	END
	
	RETURN @error
END
 
GO 

---------- P_SETDEFAULTCOLLECTIONSERVICE.SQL
if (object_id('[p_SetDefaultCollectionService]') is not null)
begin
drop procedure [p_SetDefaultCollectionService]
end
go
create procedure [dbo].[p_SetDefaultCollectionService]
(@ManagementServiceID [uniqueidentifier],
 @CollectionServiceID [uniqueidentifier] output)
as
begin
	declare @CollectionServiceIDTemp uniqueidentifier

	select @CollectionServiceIDTemp = @CollectionServiceID

	if @CollectionServiceIDTemp is null
	begin
		--- see if a default is already set
		select 
			@CollectionServiceIDTemp = [DefaultCollectionServiceID]		
		from
			[ManagementServices]
		where @ManagementServiceID = @ManagementServiceID
		
		if (@CollectionServiceIDTemp is not null)
		begin -- return the current default
			select @CollectionServiceID = @CollectionServiceIDTemp		
			return 0
		end
		--- no default, select the first existing 
		select top 1
			@CollectionServiceIDTemp = CollectionServiceID
		from
			[CollectionServices]
		where [ManagementServiceID] = @ManagementServiceID
		order by [MachineName],[InstanceName] asc		
		--- none found, exit
		if @CollectionServiceIDTemp is null
			return 1
	end

	update [ManagementServices]
		set [DefaultCollectionServiceID] = @CollectionServiceIDTemp
		where [ManagementServiceID] = @ManagementServiceID
	
	update [MonitoredSQLServers]
		set [CollectionServiceID] = @CollectionServiceIDTemp
--		where [CollectionServiceID] is null 

	select @CollectionServiceID = @CollectionServiceIDTemp

	return 0
end
 
GO 

---------- P_SETDEFAULTDASHBOARDLAYOUT.SQL
if (object_id('p_SetDefaultDashboardLayout') is not null)
begin
drop procedure [p_SetDefaultDashboardLayout]
end
go

create procedure [p_SetDefaultDashboardLayout] 
	@LoginName nvarchar(256),
	@SQLServerID int,
	@DashboardLayoutID int
as
begin

	if exists (select 1 from DashboardDefaults
					where LoginName = @LoginName
						and (SQLServerID = @SQLServerID
							 or (SQLServerID is null and @SQLServerID is null)))
		update DashboardDefaults
			set DashboardLayoutID = @DashboardLayoutID
			where LoginName = @LoginName
				and (SQLServerID = @SQLServerID
						or (SQLServerID is null and @SQLServerID is null))
	else
		insert into DashboardDefaults
				(LoginName,
				 SQLServerID,
				 DashboardLayoutID
				)
			values (@LoginName,
					@SQLServerID,
					@DashboardLayoutID
				)

end	
 
GO 

---------- P_SETDEFAULTMANAGEMENTSERVICE.SQL
if (object_id('[p_SetDefaultManagementService]') is not null)
begin
drop procedure [p_SetDefaultManagementService]
end
go
create procedure [dbo].[p_SetDefaultManagementService]
(@ManagementServiceID [uniqueidentifier] output)
as
begin
	declare @ManagementServiceIDTemp uniqueidentifier

	if @ManagementServiceID is null
	begin
		select top 1
			@ManagementServiceIDTemp = ManagementServiceID
		from
			[ManagementServices]
		order by [MachineName] asc
	end
	else
	begin
		select @ManagementServiceIDTemp = @ManagementServiceID
	end

	if @ManagementServiceIDTemp is null
		return 1

	if exists(select [Name] from [RepositoryInfo] where [Name] = 'Default Management Service')
	begin
		update [RepositoryInfo]
		set [Character_Value] = @ManagementServiceIDTemp, [Internal_Value] = NULL
		where [Name] = 'Default Management Service'
	end
	else
		insert into [RepositoryInfo]
			   ([Name]
			   ,[Character_Value])
		 values
			   ('Default Management Service'
			   ,@ManagementServiceIDTemp)

	set @ManagementServiceID = @ManagementServiceIDTemp

	return 0
end
 
GO 

---------- P_SETMIRRORINGPREFERREDCONFIG.SQL
if (object_id('p_SetMirroringPreferredConfig') is not null)
begin
drop procedure [p_SetMirroringPreferredConfig]
end
go

create procedure [dbo].[p_SetMirroringPreferredConfig](
@Guid uniqueidentifier,
@mirror int = null, 
@principal int = null, 
@witnessName nvarchar(128) = null, 
@databaseName nvarchar(128) = null,
@Normal int
) as
--------------------------------------------------------------------------------
--  Batch: MirroringSetPreferredConfig
--  Variables: 
--		[0] - Session GUID
--		[1] - Action integer 0 = Failed Over, 1 = Normal, -1 = Agnostic
--------------------------------------------------------------------------------

if @Normal = -1
delete from MirroringPreferredConfig where MirroringGuid = @Guid
else
begin

if exists(select * from MirroringPreferredConfig where MirroringGuid = @Guid)
begin
update MirroringPreferredConfig 
set MirrorInstanceID = @mirror, 
PrincipalInstanceID = @principal,
NormalConfiguration = @Normal,
DatabaseName = @databaseName,
WitnessAddress = @witnessName
where MirroringGuid = @Guid
end
else
begin
insert into MirroringPreferredConfig (
MirroringGuid, 
MirrorInstanceID, 
PrincipalInstanceID, 
NormalConfiguration, 
DatabaseName, 
WitnessAddress)
values (@Guid, @mirror, @principal, @Normal, @databaseName, @witnessName)
end
end
GO
 
GO 

---------- P_SETNEXTPREDICTIVEFORECAST.SQL
if (object_id('p_SetNextPredictiveForecast') is not null)
begin
drop procedure p_SetNextPredictiveForecast 
end
go
create procedure p_SetNextPredictiveForecast
	@NextForecast datetime
as
begin
	if exists(select Name from [RepositoryInfo] where Name = 'PredictiveAnalyticsForecast')
	begin
		update RepositoryInfo set Character_Value = convert(nvarchar(100), @NextForecast, 121) where Name = 'PredictiveAnalyticsForecast'		
	end
	else
	begin
		insert into RepositoryInfo (Name, Character_Value) values ( 'PredictiveAnalyticsForecast', convert(nvarchar(100), @NextForecast, 121))
	end
end
 
GO 

---------- P_SETNEXTPREDICTIVEMODELREBUILD.SQL
if (object_id('p_SetNextPredictiveModelRebuild') is not null)
begin
drop procedure p_SetNextPredictiveModelRebuild 
end
go
create procedure p_SetNextPredictiveModelRebuild
	@NextRebuild datetime
as
begin
	if exists(select Name from [RepositoryInfo] where Name = 'PredictiveAnalyticsRebuild')
	begin
		update RepositoryInfo set Character_Value = convert(nvarchar(100), @NextRebuild, 121) where Name = 'PredictiveAnalyticsRebuild'		
	end
	else
	begin
		insert into RepositoryInfo (Name, Character_Value) values ( 'PredictiveAnalyticsRebuild', convert(nvarchar(100), @NextRebuild, 121) )
	end
end
 
GO 

---------- P_SETPREDICTIVEANALYTICSENABLED.SQL
if (object_id('p_SetPredictiveAnalyticsEnabled') is not null)
begin
drop procedure p_SetPredictiveAnalyticsEnabled 
end
go
create procedure p_SetPredictiveAnalyticsEnabled
	@PredictiveAnalyticsEnabled int
as
begin
	if exists(select Name from [RepositoryInfo] where Name = 'PredictiveAnalyticsEnabled')
	begin
		update RepositoryInfo set Internal_Value = @PredictiveAnalyticsEnabled where Name = 'PredictiveAnalyticsEnabled'
		
	end
	else
	begin
		insert into RepositoryInfo (Name,Internal_Value) values ( 'PredictiveAnalyticsEnabled',@PredictiveAnalyticsEnabled)
	end
end
 
GO 

---------- P_SNOOZEALERTS.SQL
if (object_id('p_SnoozeAlerts') is not null)
begin
drop procedure [p_SnoozeAlerts]
end
go

create procedure [p_SnoozeAlerts]
	@SQLServerID int,
	@Metric int,
	@SnoozeMinutes int,
	@SnoozeStart datetime output,
	@SnoozeEnd datetime output,
	@SnoozeStartUser nvarchar(255) output,
	@SnoozeEndUser nvarchar(255) output
as
begin
	DECLARE @err int
	DECLARE @Now datetime
	DECLARE @NotNow datetime
	DECLARE @End datetime
	DECLARE @Start datetime
	DECLARE @StartUser nvarchar(255)
	DECLARE @EndUser nvarchar(255)
	DECLARE @InstanceName nvarchar(256)
	DECLARE @LastAlertRefreshTime datetime

	set @Now = GetUTCDate()
	set @End = DateAdd(minute, @SnoozeMinutes, @Now)	
	set @NotNow = DateAdd(d,-5,@Now)

	select	@InstanceName = [InstanceName], 
			@LastAlertRefreshTime = [LastAlertRefreshTime]
		from MonitoredSQLServers
		where SQLServerID = @SQLServerID

	set @StartUser = @SnoozeStartUser

	set @EndUser = @SnoozeEndUser
	if (@EndUser is null)
		set @EndUser = @SnoozeStartUser

	if (@Start is null)
		set @Start = @Now

	UPDATE MetricThresholds SET
			[UTCSnoozeStart] = 
				case when coalesce([UTCSnoozeEnd],@NotNow) < @Now then @Now else [UTCSnoozeStart] end,
			[SnoozeStartUser] = 
				case when coalesce([UTCSnoozeEnd],@NotNow) < @Now then @StartUser else [SnoozeStartUser] end,
			[UTCSnoozeEnd] = @End,
			[SnoozeEndUser] = @EndUser
		WHERE [SQLServerID] = @SQLServerID 
			and (@Metric is null or [Metric] = @Metric) 
			and ([Metric] not in (48,56))
	-- kill the active flag for existing alerts
	update Alerts set [Active] = 0 
	where [ServerName] = @InstanceName and 
	  	  [UTCOccurrenceDateTime] = @LastAlertRefreshTime and
		  [Active] = 1 and 
		  (@Metric is null or [Metric] = @Metric) and
		  ([Metric] not in (48,56))


	SELECT @err = @@error
	
	SELECT @SnoozeEnd = @End	
	SELECT @SnoozeEndUser = @EndUser	
	SELECT @SnoozeStart = @Now
	SELECT @SnoozeStartUser = @StartUser	

	RETURN @err
end
 
GO 

---------- P_STARTAGGREGATIONJOB.SQL
if (object_id('p_StartAggregationJob') is not null)
begin
drop procedure [p_StartAggregationJob]
end
go

create procedure [p_StartAggregationJob]
as
begin
	DECLARE @jobname nvarchar(256)
	SELECT @jobname = 'Aggregate Data ' + DB_NAME()

	EXEC msdb.dbo.sp_start_job @job_name=@jobname
end
 
GO 

---------- P_STARTGROOMJOB.SQL
if (object_id('p_StartGroomJob') is not null)
begin
drop procedure [p_StartGroomJob]
end
go

create procedure [p_StartGroomJob]
as
begin
	DECLARE @jobname nvarchar(256)
	SELECT @jobname = 'Groom ' + DB_NAME()

	EXEC msdb.dbo.sp_start_job @job_name=@jobname
end
 
GO 

---------- P_SYNCCUSTOMCOUNTERTHRESHOLDS.SQL
IF (object_id('p_SyncCustomCounterThresholds') IS NOT NULL)
BEGIN
DROP PROCEDURE p_SyncCustomCounterThresholds
END
GO

CREATE PROCEDURE [dbo].[p_SyncCustomCounterThresholds]
AS
BEGIN
	declare @MissingMetrics table(SQLServerID int not null, Metric int not null)

	-- thresholds that need creating
	insert into @MissingMetrics
	select distinct ST.SQLServerId, CCT.Metric
		from ServerTags ST
			left outer join CustomCounterTags CCT on ST.TagId = CCT.TagId
			left outer join MetricThresholds MT on ST.SQLServerId = MT.SQLServerID and CCT.Metric = MT.Metric
		where
			MT.Metric is null and CCT.Metric is not null

	--lookup the default alert template
	DECLARE @defaultID int
	SELECT @defaultID = [TemplateID] FROM [AlertTemplateLookup] where [Default] = 1

	insert into MetricThresholds
		select MM.SQLServerID, MM.Metric, DMT.Enabled, DMT.WarningThreshold, DMT.CriticalThreshold, DMT.Data, NULL, NULL, NULL, NULL, DMT.InfoThreshold, DMT.ThresholdInstanceID,DMT.ThresholdEnabled, DMT.IsBaselineEnabled, DMT.[BaselineWarningThreshold],
		DMT.[BaselineCriticalThreshold], DMT.[BaselineInfoThreshold]
			from @MissingMetrics MM 
				left join DefaultMetricThresholds DMT on DMT.UserViewID = @defaultID and MM.Metric = DMT.Metric
			where DMT.Metric is not null

	-- remove custom counter thresholds that are 
	-- no longer linked or associated by tag
    delete MT
        from MetricThresholds MT
            join CustomCounterDefinition CCD on MT.Metric = CCD.Metric
            left join CustomCounterTags CCT on MT.Metric = CCT.Metric
            left join ServerTags ST on MT.SQLServerID = ST.SQLServerId and CCT.TagId = ST.TagId 
        where 
            CCT.TagId is null and ST.SQLServerId is null

END
 
GO 

---------- P_TABLEGROWTHFORECAST.SQL
if (object_id('p_TableGrowthForecast') is not null)
begin
drop procedure p_TableGrowthForecast
end
go
CREATE PROCEDURE [dbo].[p_TableGrowthForecast]
			@TableXML nvarchar(4000),
			@Database nvarchar(256),
			@ServerId int,
			@UTCStart DateTime,
			@UTCEnd DateTime,
			@UTCOffset int,
			@Interval tinyint
AS
BEGIN
declare @xmlDoc int
set ansi_warnings off

declare @Tables table(
		TableName nvarchar(255)
) 

-- Prepare XML document
exec sp_xml_preparedocument @xmlDoc output, @TableXML

-- Extract the server IDs from the SML doc.
insert into @Tables	
select
	TableName 
from openxml(@xmlDoc, '//Table', 1)
	with (TableName nvarchar(255))

exec sp_xml_removedocument @xmlDoc

select 
	[SchemaName] + '.' + [TableName] as TableName,
	dbo.fn_RoundDateTime(@Interval, max(dateadd(mi, @UTCOffset, growth.[UTCCollectionDateTime]))) as [LastCollectioninInterval],
	sum((DataSize + [TextSize] + IndexSize) * TimeDeltaInSeconds) / nullif(sum(TimeDeltaInSeconds),0) as TotalSize
from
	[SQLServerDatabaseNames] dbnames (nolock)
	join [SQLServerTableNames] tnames (nolock)
	on dbnames.[DatabaseID] = tnames.[DatabaseID]
	join [TableGrowth] growth (nolock)
	on tnames.[TableID] = growth.[TableID]
where 
	-- Filter for SQL Server		
	dbnames.[SQLServerID] = @ServerId
	and
	-- Filter for database		
	dbnames.[DatabaseName] = @Database
	and
	-- Filter tables		
	tnames.[SchemaName] + '.' + tnames.[TableName] collate database_default in (select TableName collate database_default from @Tables)
	and
    growth.[UTCCollectionDateTime] BETWEEN @UTCStart and @UTCEnd
group by
	[TableName], [SchemaName]
	-- Always group by year at the least
	,datepart(yy, dateadd(mi, @UTCOffset, growth.[UTCCollectionDateTime]))
	-- Group by all intervals greater than or equal to the selected interval
	,case when @Interval <= 3 then datepart(mm,dateadd(mi, @UTCOffset, growth.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, growth.[UTCCollectionDateTime])) end
	,case when @Interval <= 2 then datepart(dd,dateadd(mi, @UTCOffset, growth.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, growth.[UTCCollectionDateTime])) end
	,case when @Interval <= 1 then datepart(hh,dateadd(mi, @UTCOffset, growth.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, growth.[UTCCollectionDateTime])) end
	,case when @Interval =  0 then datepart(mi,dateadd(mi, @UTCOffset, growth.[UTCCollectionDateTime])) else datepart(yy,dateadd(mi, @UTCOffset, growth.[UTCCollectionDateTime])) end
order by
	[TableName]
	,[LastCollectioninInterval] 
END
 
 
GO 

---------- P_TOPSERVERSALERTS.SQL
if (object_id('p_TopServersAlerts') is not null)
begin
drop procedure p_TopServersAlerts
end
go
CREATE PROCEDURE [dbo].[p_TopServersAlerts]
	@NumServers int,
	@UTCStart DateTime,
	@UTCEnd DateTime,
	@SQLServerIDs nvarchar(max) = null
AS
begin

declare @now datetime

declare @SQLServers table(
		SQLServerID int,
		InstanceName nvarchar(256),
		LastScheduledCollectionTime datetime)
		
create table #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

insert into #SecureMonitoredSQLServers
exec [p_GetReportServers]
		

if @SQLServerIDs is not null 
begin
	declare @xmlDoc int
	exec sp_xml_preparedocument @xmlDoc output, @SQLServerIDs

	insert into @SQLServers
		select ID, smss.InstanceName, LastScheduledCollectionTime
		from openxml(@xmlDoc, '//Srvr', 1) with (ID int)
			join #SecureMonitoredSQLServers smss on smss.SQLServerID = ID
			inner join MonitoredSQLServers mss (nolock) on mss.SQLServerID = smss.SQLServerID
		where mss.Active = 1
	exec sp_xml_removedocument @xmlDoc
end
else
begin
	insert into @SQLServers
		select smss.SQLServerID, smss.InstanceName, LastScheduledCollectionTime
		from #SecureMonitoredSQLServers smss 
			inner join MonitoredSQLServers mss (nolock) on mss.SQLServerID = smss.SQLServerID
		where Active = 1
end

set @now = DateAdd(second,10,GetUTCDate())

set rowcount @NumServers
select 
	ms.[SQLServerID]
	,[InstanceName]
	,count([AlertID]) as AlertCount
	,sum(case [Severity] when 1 then 1 else 0 end) as OkCount
	,sum(case [Severity] when 2 then 1 else 0 end) as InfoCount
	,sum(case [Severity] when 4 then 1 else 0 end) as WarningCount
	,sum(case [Severity] when 8 then 1 else 0 end) as CriticalCount
from
	@SQLServers ms
	left outer join [Alerts] a (nolock)
		on [InstanceName] collate database_default = [ServerName] collate database_default
			and ms.LastScheduledCollectionTime = a.[UTCOccurrenceDateTime] 
			and	a.Active = 1
	join MetricThresholds t (nolock) on
		ms.[SQLServerID] = t.[SQLServerID] and
		a.[Metric] = t.[Metric] 	
where (t.[UTCSnoozeEnd] is null or t.[UTCSnoozeEnd] < @now)	
group by 
	ms.[SQLServerID]
	,ms.[InstanceName]
order by 
	[AlertCount] DESC

set rowcount 0
end
 
 
GO 

---------- P_TOPSERVERSCPU.SQL
if (object_id('p_TopServersCpu') is not null)
begin
drop procedure p_TopServersCpu
end
go
CREATE PROCEDURE [dbo].[p_TopServersCpu]
	@NumServers int,
	@UTCStart DateTime,
	@UTCEnd DateTime,
	@SQLServerIDs nvarchar(max) = null
AS
begin
declare @SQLServers table(
		SQLServerID int,
		InstanceName nvarchar(256))

create table #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

insert into #SecureMonitoredSQLServers
exec [p_GetReportServers]

if @SQLServerIDs is not null 
begin
	declare @xmlDoc int
	exec sp_xml_preparedocument @xmlDoc output, @SQLServerIDs

	insert into @SQLServers
		select ID, smss.InstanceName
		from openxml(@xmlDoc, '//Srvr', 1) with (ID int)
			join MonitoredSQLServers mss (nolock) on mss.SQLServerID = ID
			inner join #SecureMonitoredSQLServers smss on mss.SQLServerID = smss.SQLServerID

	exec sp_xml_removedocument @xmlDoc
end
else
begin
	insert into @SQLServers
		select smss.SQLServerID, smss.InstanceName
		from #SecureMonitoredSQLServers smss 
			inner join MonitoredSQLServers mss (nolock) on mss.SQLServerID = smss.SQLServerID
		where Active = 1
end

set rowcount @NumServers

select
	ms.[SQLServerID]
	,[InstanceName]
	,avg([ResponseTimeInMilliseconds]) as [ResponseTimeInMilliseconds]
	,avg([CPUActivityPercentage]) as [CPUActivityPercentage]
	,avg([DiskTimePercent]) as [DiskTimePercent]
	,avg([OSAvailableMemoryInKilobytes]) as [OSAvailableMemoryInKilobytes]
	,avg([OSTotalPhysicalMemoryInKilobytes]) as [OSTotalPhysicalMemoryInKilobytes]
from
	@SQLServers ms
	left outer join [ServerStatistics] s1 (nolock)
	on ms.[SQLServerID] = s1.[SQLServerID]
	left join [OSStatistics] o (nolock)
	on o.[SQLServerID] = ms.[SQLServerID] and o.[UTCCollectionDateTime] = s1.[UTCCollectionDateTime]
where
	s1.[UTCCollectionDateTime] between @UTCStart and @UTCEnd
	and
	o.[UTCCollectionDateTime] between @UTCStart and @UTCEnd
group by
	ms.[SQLServerID], [InstanceName]
order by
	[CPUActivityPercentage] DESC

set rowcount 0

end 
 
GO 

---------- P_TOPSERVERSDATABASEALERTS.SQL
-- SQLDM 8.5:Mahesh : Added for Rest service consumption

if (object_id('p_TopServersDatabaseAlerts') is not null)
begin
drop procedure p_TopServersDatabaseAlerts
end
go
CREATE PROCEDURE [dbo].[p_TopServersDatabaseAlerts]
	@NumServers int,
	@UTCStart DateTime,
	@UTCEnd DateTime,
	@SQLServerIDs nvarchar(max) = null
AS
begin

declare @now datetime

declare @SQLServers table(
		SQLServerID int,
		InstanceName nvarchar(256),
		LastScheduledCollectionTime datetime)
		
create table #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

insert into #SecureMonitoredSQLServers
exec [p_GetReportServers]
		

if @SQLServerIDs is not null 
begin
	declare @xmlDoc int
	exec sp_xml_preparedocument @xmlDoc output, @SQLServerIDs

	insert into @SQLServers
		select ID, smss.InstanceName, LastScheduledCollectionTime
		from openxml(@xmlDoc, '//Srvr', 1) with (ID int)
			join #SecureMonitoredSQLServers smss on smss.SQLServerID = ID
			inner join MonitoredSQLServers mss (nolock) on mss.SQLServerID = smss.SQLServerID
		where mss.Active = 1
	exec sp_xml_removedocument @xmlDoc
end
else
begin
	insert into @SQLServers
		select smss.SQLServerID, smss.InstanceName, LastScheduledCollectionTime
		from #SecureMonitoredSQLServers smss 
			inner join MonitoredSQLServers mss (nolock) on mss.SQLServerID = smss.SQLServerID
		where Active = 1
end

set @now = DateAdd(second,10,GetUTCDate())

set rowcount @NumServers
select 
	ms.[SQLServerID]
	,[InstanceName]
	,a.[DatabaseName]
	,count([AlertID]) as AlertCount
	,sum(case [Severity] when 1 then 1 else 0 end) as OkCount
	,sum(case [Severity] when 2 then 1 else 0 end) as InfoCount
	,sum(case [Severity] when 4 then 1 else 0 end) as WarningCount
	,sum(case [Severity] when 8 then 1 else 0 end) as CriticalCount
from
	@SQLServers ms
	left outer join [Alerts] a (nolock)
		on [InstanceName] collate database_default = [ServerName] collate database_default
			and ms.LastScheduledCollectionTime = a.[UTCOccurrenceDateTime] 
			and	a.Active = 1
	join MetricThresholds t (nolock) on
		ms.[SQLServerID] = t.[SQLServerID] and
		a.[Metric] = t.[Metric] 	
where (t.[UTCSnoozeEnd] is null or t.[UTCSnoozeEnd] < @now)	
group by 
	ms.[SQLServerID]
	,ms.[InstanceName]
	,a.[DatabaseName]
Having a.DatabaseName is not null
order by 
	[AlertCount] DESC

set rowcount 0
end
 
 
GO 

---------- P_TOPSERVERSDISK.SQL
if (object_id('p_TopServersDisk') is not null)
begin
drop procedure p_TopServersDisk
end
go
CREATE PROCEDURE [dbo].[p_TopServersDisk]
	@NumServers int,
	@UTCStart DateTime,
	@UTCEnd DateTime,
	@SQLServerIDs nvarchar(max) = null
AS
begin
declare @SQLServers table(
		SQLServerID int,
		InstanceName nvarchar(256))

create table #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

insert into #SecureMonitoredSQLServers
exec [p_GetReportServers]

if @SQLServerIDs is not null 
begin
	declare @xmlDoc int
	exec sp_xml_preparedocument @xmlDoc output, @SQLServerIDs

	insert into @SQLServers
		select ID, smss.InstanceName
		from openxml(@xmlDoc, '//Srvr', 1) with (ID int)
			join MonitoredSQLServers mss (nolock) on mss.SQLServerID = ID
			inner join #SecureMonitoredSQLServers smss on mss.SQLServerID = smss.SQLServerID

	exec sp_xml_removedocument @xmlDoc
end
else
begin
	insert into @SQLServers
		select smss.SQLServerID, smss.InstanceName
		from MonitoredSQLServers mss (nolock)
			inner join #SecureMonitoredSQLServers smss on mss.SQLServerID = smss.SQLServerID
		where Active = 1
end


set rowcount @NumServers

select
	ms.[SQLServerID]
	,[InstanceName]
	,avg([ResponseTimeInMilliseconds]) as [ResponseTimeInMilliseconds]
	,avg([CPUActivityPercentage]) as [CPUActivityPercentage]
	,avg([DiskTimePercent]) as [DiskTimePercent]
	,avg([OSAvailableMemoryInKilobytes]) as [OSAvailableMemoryInKilobytes]
	,avg([OSTotalPhysicalMemoryInKilobytes]) as [OSTotalPhysicalMemoryInKilobytes]
from
	@SQLServers ms
	left outer join [ServerStatistics] s1 (nolock)
	on ms.[SQLServerID] = s1.[SQLServerID]
	left join [OSStatistics] o (nolock)
	on o.[SQLServerID] = ms.[SQLServerID] and o.[UTCCollectionDateTime] = s1.[UTCCollectionDateTime]
where
	s1.[UTCCollectionDateTime] between @UTCStart and @UTCEnd
	and
	o.[UTCCollectionDateTime] between @UTCStart and @UTCEnd
group by
	ms.[SQLServerID], [InstanceName]
order by
	[DiskTimePercent] DESC

set rowcount 0

end 
 
 
GO 

---------- P_TOPSERVERSMEMORY.SQL
if (object_id('p_TopServersMemory') is not null)
begin
drop procedure p_TopServersMemory
end
go
CREATE PROCEDURE [dbo].[p_TopServersMemory]
	@NumServers int,
	@UTCStart DateTime,
	@UTCEnd DateTime,
	@SQLServerIDs nvarchar(max) = null
AS
begin
declare @SQLServers table(
		SQLServerID int,
		InstanceName nvarchar(256))

create table #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

insert into #SecureMonitoredSQLServers
exec [p_GetReportServers]

if @SQLServerIDs is not null 
begin
	declare @xmlDoc int
	exec sp_xml_preparedocument @xmlDoc output, @SQLServerIDs

	insert into @SQLServers
		select ID, smss.InstanceName
		from openxml(@xmlDoc, '//Srvr', 1) with (ID int)
			join MonitoredSQLServers mss (nolock) on mss.SQLServerID = ID
			inner join #SecureMonitoredSQLServers smss on mss.SQLServerID = smss.SQLServerID

	exec sp_xml_removedocument @xmlDoc
end
else
begin
	insert into @SQLServers
		select smss.SQLServerID, smss.InstanceName
		from MonitoredSQLServers mss (nolock)
			inner join #SecureMonitoredSQLServers smss on mss.SQLServerID = smss.SQLServerID
		where Active = 1
end


set rowcount @NumServers

select
	ms.[SQLServerID]
	,[InstanceName]
	,avg([ResponseTimeInMilliseconds]) as [ResponseTimeInMilliseconds]
	,avg([CPUActivityPercentage]) as [CPUActivityPercentage]
	,avg([DiskTimePercent]) as [DiskTimePercent]
	,avg(cast([OSTotalPhysicalMemoryInKilobytes] - [OSAvailableMemoryInKilobytes] as float)/[OSTotalPhysicalMemoryInKilobytes] * 100) as [OSMemoryUsagePercent]
from
	@SQLServers ms
	left outer join [ServerStatistics] s1 (nolock)
	on ms.[SQLServerID] = s1.[SQLServerID]
	left join [OSStatistics] o (nolock)
	on o.[SQLServerID] = ms.[SQLServerID] and o.[UTCCollectionDateTime] = s1.[UTCCollectionDateTime]
where
	s1.[UTCCollectionDateTime] between @UTCStart and @UTCEnd
	and
	o.[UTCCollectionDateTime] between @UTCStart and @UTCEnd
group by
	ms.[SQLServerID], [InstanceName]
order by
	[OSMemoryUsagePercent] DESC

set rowcount 0

end
 
 
GO 

---------- P_TOPSERVERSQUERYWAITS.SQL
-- Created by Aditya Shukla for SQLdm 8.6
-- This procedure is used to fetch data for the Query Waits section in Top servers report

--exec p_TopServersQueryWaits 5, '2013-7-24 00:00:00', '2014-7-24 10:00:00', 
--'<Srvrs><Srvr ID="1"/><Srvr ID="2"/><Srvr ID="3"/><Srvr ID="4"/><Srvr ID="5"/><Srvr ID="6"/><Srvr ID="7"/><Srvr ID="8"/><Srvr ID="9"/><Srvr ID="10"/><Srvr ID="11"/><Srvr ID="12"/><Srvr ID="13"/></Srvrs>',
--2000

if (object_id('p_TopServersQueryWaits') is not null)
begin
drop procedure [p_TopServersQueryWaits]
end
go

create procedure [dbo].[p_TopServersQueryWaits]
	@NumServers int,
	@UTCStart DateTime,
	@UTCEnd DateTime,
	@SQLServerIDs nvarchar(max) = null,
	@threshold bigint = 0 -- a value in milliseconds
as
begin

declare @SQLServers table(
		SQLServerID int,
		InstanceName nvarchar(256))

create table #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

insert into #SecureMonitoredSQLServers
exec [p_GetReportServers]

--Figuring out the SQL servers that are required as per the front end filter
if @SQLServerIDs is not null 
begin
	declare @xmlDoc int
	-- Parsing the xml for servers
	exec sp_xml_preparedocument @xmlDoc output, @SQLServerIDs

	insert into @SQLServers
		select ID, smss.InstanceName
		from openxml(@xmlDoc, '//Srvr', 1) with (ID int)
			join MonitoredSQLServers mss (nolock) on mss.SQLServerID = ID
			inner join #SecureMonitoredSQLServers smss on mss.SQLServerID = smss.SQLServerID

	exec sp_xml_removedocument @xmlDoc
end
else
begin
	insert into @SQLServers
		select smss.SQLServerID, smss.InstanceName
		from #SecureMonitoredSQLServers smss 
			inner join MonitoredSQLServers mss (nolock) on mss.SQLServerID = smss.SQLServerID
		where Active = 1
end

--Assigning row numbers to rows of sets partitioned by sql server and ordered by wait desc 
select aws.SQLServerID,
	ms.InstanceName, 
	aws.WaitTypeID, 
	aws.LoginNameID, 
	aws.WaitDuration, 
	aws.WaitDuration - @threshold as [difference], 
	aws.StatementUTCStartTime,
	row_number() over (partition by aws.[SQLServerID] order by aws.WaitDuration desc) as rankNumber 
into #RankedData
from @SQLServers ms inner join ActiveWaitStatistics aws (nolock)
	on ms.SQLServerID = aws.SQLServerID
where aws.[UTCCollectionDateTime] between @UTCStart and @UTCEnd
and aws.WaitDuration > @threshold

--This ensures that only @TopN rows are selected
set rowcount @NumServers

--Selecting the top row from each of the partitioned sets while the row count is less than @TopN
select 
	rd.SQLServerID [SQLServerID],
	rd.InstanceName [InstanceName], 
	wt.WaitType [WaitType],
	rd.StatementUTCStartTime [StatementUTCStartTime],
	rd.WaitDuration [WaitDuration],
	rd.[difference] [ExceededThresholdBy],
	ln.LoginName [LoginName]
from #RankedData rd left join LoginNames ln (nolock) 
on rd.LoginNameID = ln.LoginNameID
left join WaitTypes wt (nolock)
on wt.WaitTypeID = rd.WaitTypeID
where rankNumber = 1
order by rd.WaitDuration

set rowcount 0

end
GO

 
GO 

---------- P_TOPSERVERSRESPONSETIME.SQL
if (object_id('p_TopServersResponseTime') is not null)
begin
drop procedure p_TopServersResponseTime
end
go
CREATE PROCEDURE [dbo].[p_TopServersResponseTime]
	@NumServers int,
	@UTCStart DateTime,
	@UTCEnd DateTime,
	@SQLServerIDs nvarchar(max) = null
AS
BEGIN

declare @SQLServers table(
			SQLServerID int,
			InstanceName nvarchar(256))

create table #SecureMonitoredSQLServers(InstanceName nvarchar(256),SQLServerID int)

insert into #SecureMonitoredSQLServers
exec [p_GetReportServers]

if @SQLServerIDs is not null 
begin
	declare @xmlDoc int
	exec sp_xml_preparedocument @xmlDoc output, @SQLServerIDs

	insert into @SQLServers
		select ID, smss.InstanceName
		from openxml(@xmlDoc, '//Srvr', 1) with (ID int)
			join #SecureMonitoredSQLServers smss (nolock) on SQLServerID = ID

	exec sp_xml_removedocument @xmlDoc
end
else
begin
	insert into @SQLServers
		select smss.SQLServerID, smss.InstanceName
		from #SecureMonitoredSQLServers smss 
			inner join MonitoredSQLServers mss (nolock) on mss.SQLServerID = smss.SQLServerID
		where Active = 1
end


set rowcount @NumServers

select
	ms.[SQLServerID]
	,[InstanceName]
	,avg([ResponseTimeInMilliseconds]) as [ResponseTimeInMilliseconds]
	,avg([CPUActivityPercentage]) as [CPUActivityPercentage]
	,avg([DiskTimePercent]) as [DiskTimePercent]
	,avg([OSAvailableMemoryInKilobytes]) as [OSAvailableMemoryInKilobytes]
	,avg([OSTotalPhysicalMemoryInKilobytes]) as [OSTotalPhysicalMemoryInKilobytes]
from
	@SQLServers ms
	left outer join [ServerStatistics] s1 (nolock)
	on ms.[SQLServerID] = s1.[SQLServerID]
	left join [OSStatistics] o (nolock)
	on o.[SQLServerID] = ms.[SQLServerID] and o.[UTCCollectionDateTime] = s1.[UTCCollectionDateTime]
where
	s1.[UTCCollectionDateTime] between @UTCStart and @UTCEnd
	and
	o.[UTCCollectionDateTime] between @UTCStart and @UTCEnd
group by
	ms.[SQLServerID], [InstanceName]
order by
	[ResponseTimeInMilliseconds] DESC

set rowcount 0

end
 
 
GO 

---------- P_UNSNOOZEALERTS.SQL
if (object_id('p_UnsnoozeAlerts') is not null)
begin
drop procedure [p_UnsnoozeAlerts]
end
go

create procedure [p_UnsnoozeAlerts]
	@SQLServerID int,
	@MetricXML nvarchar(max),
	@SnoozeStart datetime output,
	@SnoozeEnd datetime output,
	@SnoozeStartUser nvarchar(255) output,
	@SnoozeEndUser nvarchar(255) output
as
begin
	DECLARE @err int
	DECLARE @xmlDoc int
	DECLARE @Now datetime
	DECLARE @Start datetime
	DECLARE @StartUser nvarchar(255)
	DECLARE @EndUser nvarchar(255)
	
	DECLARE @Metrics table(Metric int) 

	if (@MetricXML is not null)
	begin
		exec sp_xml_preparedocument @xmlDoc output, @MetricXML

		insert into @Metrics	
		select MetricID
			from openxml(@xmlDoc, '//Metric', 1) with (MetricID int) 

		exec sp_xml_removedocument @xmlDoc
	end

	set @Now = GetUTCDate()

	if (@MetricXML is not null)
	begin
		select @Start = [UTCSnoozeStart], @StartUser = [SnoozeStartUser] 
		from MetricThresholds 
			where SQLServerID = @SQLServerID and Metric = (select min(Metric) from @Metrics)
	end

	if (@StartUser is null) 
	begin
		set @StartUser = SYSTEM_USER
	end

	set @EndUser = @SnoozeEndUser
	if (@EndUser is null)
		set @EndUser = SYSTEM_USER

	if (@Start is null)
		set @Start = @Now

	UPDATE MetricThresholds SET
			[UTCSnoozeEnd] = @Now,
			[SnoozeEndUser] = @EndUser
		WHERE [SQLServerID] = @SQLServerID 
			and (@MetricXML is null or [Metric] in (select [Metric] from @Metrics))

	SELECT @err = @@error
	
	SELECT @SnoozeEnd = @Now	
	SELECT @SnoozeEndUser = @EndUser	
	SELECT @SnoozeStart = @Start
	SELECT @SnoozeStartUser = @StartUser	

	RETURN @err
end
 
GO 

---------- P_UPDATEALERTTEMPLATE.SQL
if (object_id('p_UpdateAlertTemplate') is not null)
begin
drop procedure p_UpdateAlertTemplate
end
go

CREATE PROCEDURE [dbo].p_UpdateAlertTemplate(
	@templateID int,
	@Name nvarchar(256), 
	@Description nvarchar(1024)
)
AS
begin
	declare @error int


	if (exists(select [TemplateID] from [dbo].[AlertTemplateLookup] where [TemplateID] = @templateID))
	begin
		UPDATE [dbo].[AlertTemplateLookup]
			SET [Name] = @Name,
				[Description] = @Description
			WHERE [TemplateID] = @templateID
		set @error = @@error
		
		if (@error > 0)
		begin
			raiserror('There was an error updating the AlertTemplateLookup table', @error, 0)
		end
	end
end
				
 
GO 

---------- P_UPDATEALWAYSONAVAILABILITYGROUPTOPOLOGYXML.SQL

------------------------------------------------------------------------------
-- <copyright file="p_UpdateAlwaysOnAvailabilityGroupTopologyXml.sql" company="Idera, Inc.">
--     Copyright (c) Idera, Inc. All rights reserved.
-- </copyright>
------------------------------------------------------------------------------
if (object_id('p_UpdateAlwaysOnAvailabilityGroupTopologyXml') is not null)
begin
drop procedure p_UpdateAlwaysOnAvailabilityGroupTopologyXml
end
go
create procedure [dbo].[p_UpdateAlwaysOnAvailabilityGroupTopologyXml](
    @AvailabilityGroupsXml xml
)
as
begin
    -- Nolock transactions.
    set transaction isolation level read uncommitted

    -- Declare dummy table.
    declare @temporalTopologyTable table (
        GroupId uniqueidentifier,
        GroupName sysname,
        ServerSourceName sysname,
        ListenerDnsName nvarchar(63),
        ListenerPort int,
        ListenerIpAddress nvarchar(48)
        )

    -- Get the XML in its data model representation.
    declare @status int
    declare @docpointer int
    exec @status = sp_xml_preparedocument @docpointer output, @AvailabilityGroupsXml

    -- @status 0 (success) or >0 (failure)
    if @status = 0
    begin
        -- If the XML could be converted in its data model representation.
        insert into @temporalTopologyTable
        -- TODO REview use explicit columns declarations.
        select * from openxml (@docpointer, '//AvailabilityGroup', 0)
            with(
                GroupId uniqueidentifier 'GroupId',
                GroupName sysname 'GroupName',
                ServerSourceName sysname 'ServerSourceName',
                ListenerDnsName nvarchar(63) 'ListenerDnsName',
                ListenerPort int 'ListenerPort',
                ListenerIpAddress nvarchar(48) 'ListenerIPAddress'
                )

        -- Get all nodes on which is perfomr the grooming.
        declare @nodesSubSet table (
            ServerSourceName sysname
        )

        insert into @nodesSubSet
        select distinct [@temporalTopologyTable].[ServerSourceName] from @temporalTopologyTable

        -- Get registers to set inactive.
        declare @inactiveRegisters table (
            GroupTopologyId bigint,
            GroupName sysname,
            GroupId uniqueidentifier,
            ServerSourceName sysname
            )

        insert into @inactiveRegisters
        select [Groups].[GroupTopologyId], [Groups].[GroupName], [Groups].[GroupId], [Groups].[ServerSourceName]
            from [dbo].[AlwaysOnAvailabilityGroups] as [Groups]
            left outer join @temporalTopologyTable on [Groups].[GroupId] = [@temporalTopologyTable].[GroupId]
                and [@temporalTopologyTable].[ServerSourceName] = [Groups].[ServerSourceName]
            left join @nodesSubSet on [@nodesSubSet].[ServerSourceName] = [Groups].[ServerSourceName]
        where ([Groups].[GroupId] <> [@temporalTopologyTable].[GroupId]
            or [@temporalTopologyTable].[GroupId] is null
            or [Groups].[GroupId] is null)
            and ([@nodesSubSet].[ServerSourceName] = [Groups].[ServerSourceName])
            and [Groups].[Active] = 1

        -- Goes through Groups to insert / update these.
        declare @inactiveGroupIdCursor bigint
        set rowcount 0
        select 1 from @inactiveRegisters
        set rowcount 1

        -- Get the cursor
        select @inactiveGroupIdCursor = [@inactiveRegisters].[GroupTopologyId] from @inactiveRegisters

        while @@rowcount <> 0
        begin
            set rowcount 0

            if exists(select 1 from [dbo].[AlwaysOnAvailabilityGroups] as [Groups]
                        where [Groups].[GroupTopologyId] = @inactiveGroupIdCursor)
            begin
                -- Set [Active] column to false.
                update [dbo].[AlwaysOnAvailabilityGroups]
                    set
                        [Active] = 0
                where [GroupTopologyId] = @inactiveGroupIdCursor
            end

            delete @inactiveRegisters where [GroupTopologyId] = @inactiveGroupIdCursor

            set rowcount 1
            select @inactiveGroupIdCursor = [@inactiveRegisters].[GroupTopologyId] from @inactiveRegisters
        end

        set rowcount 0

         -- Goes through Replicas and insert / update these.
        declare @groupId uniqueidentifier
        set rowcount 0
        select 1 from @temporalTopologyTable
        set rowcount 1

        -- Get the cursor
        select @groupId = GroupId from @temporalTopologyTable

        while @@rowcount <> 0
        begin
            set rowcount 0

            -- Procede to update / insert the registers in the 'AlwaysOnReplicas'.
            declare @groupName sysname
            declare @serverSourceName sysname
            declare @listenerDnsName nvarchar(63)
            declare @listenerPort int
            declare @listenerIpAddress nvarchar(48)
            declare @active bit
            declare @delete bit

            -- Get scalar values
            select @groupName = GroupName from @temporalTopologyTable where GroupId = @groupId
            -- In a single topology, just have one to match for ServerSourceName
            select @serverSourceName = ServerSourceName from @temporalTopologyTable where GroupId = @groupId
            select @listenerDnsName = ListenerDnsName from @temporalTopologyTable where GroupId = @groupId
            select @listenerPort = ListenerPort from @temporalTopologyTable where GroupId = @groupId
            select @listenerIpAddress = ListenerIpAddress from @temporalTopologyTable where GroupId = @groupId
            select @active = 1
            select @delete = 0

            if exists(select 1 from [dbo].[AlwaysOnAvailabilityGroups]
                        where GroupId = @groupId and ServerSourceName = @serverSourceName)
            begin
                -- Update Availability Replicas
                update [dbo].[AlwaysOnAvailabilityGroups]
                    set
                        [GroupName] = @groupName,
                        [ServerSourceName] = @serverSourceName,
                        [ListenerDnsName] = @listenerDnsName,
                        [ListenerPort] = @listenerPort,
                        [ListenerIpAddress] = @listenerIpAddress,
                        [Active] = @active,
                        [Delete] = @delete
                where GroupId = @groupId and ServerSourceName = @serverSourceName
            end
            else
            begin
                -- Insert Availability Replicas
                insert into [dbo].[AlwaysOnAvailabilityGroups](
                    [GroupId],
                    [GroupName],
                    [ServerSourceName],
                    [ListenerDnsName],
                    [ListenerPort],
                    [ListenerIpAddress],
                    [Active],
                    [Delete]
                    )
                values(
                    @groupId,
                    @groupName,
                    @serverSourceName,
                    @listenerDnsName,
                    @listenerPort,
                    @listenerIpAddress,
                    @active,
                    @delete
                    )
            end

            delete @temporalTopologyTable where GroupId = @groupId

            set rowcount 1
            select @groupId = GroupId from @temporalTopologyTable
        end
        
        set rowcount 0

        -- Call SP in order to update the Replicas topology.
        exec dbo.p_UpdateAlwaysOnAvailabilityReplicaTopologyXml @AvailabilityReplicaXml = @AvailabilityGroupsXml
    end
    else
    begin
        -- An error occurred, the XML cannot be processed.
        select @AvailabilityGroupsXml
    end

    return @status
end
 
GO 

---------- P_UPDATEALWAYSONAVAILABILITYREPLICATOPOLOGYXML.SQL

------------------------------------------------------------------------------
-- <copyright file="p_UpdateAlwaysOnAvailabilityReplicaTopologyXml.sql" company="Idera, Inc.">
--     Copyright (c) Idera, Inc. All rights reserved.
-- </copyright>
------------------------------------------------------------------------------
if (object_id('p_UpdateAlwaysOnAvailabilityReplicaTopologyXml') is not null)
begin
drop procedure p_UpdateAlwaysOnAvailabilityReplicaTopologyXml
end
go
create procedure [dbo].p_UpdateAlwaysOnAvailabilityReplicaTopologyXml(
    @AvailabilityReplicaXml xml
)
as
begin
    -- Nolock transactions.
    set transaction isolation level read uncommitted

    -- Declare dummy table.
    declare @temporalTopologyTable table (
        ReplicaId uniqueidentifier,
        GroupId uniqueidentifier,
        ServerSourceName sysname,
        SQLServerID int,
        ReplicaName nvarchar(256),
        ReplicaRole int,
        FailoverMode int,
        AvailabilityMode int,
        PrimaryConnectionMode tinyint,
        SecondaryConnectionMode tinyint
        )

    -- Get the XML in its data model representation.
    declare @status int
    declare @docpointer int
    exec @status = sp_xml_preparedocument @docpointer output, @AvailabilityReplicaXml

    -- @status 0 (success) or >0 (failure)
    if @status = 0
    begin
        -- If the XML could be converted in its data model representation.
        insert into @temporalTopologyTable
        select
                ReplicaId,
                GroupId,
                ServerSourceName,
                isnull([SQLServers].[SQLServerID], -1) as [SQLServerID],
                ReplicaName,
                ReplicaRole,
                FailoverMode,
                AvailabilityMode,
                PrimaryConnectionMode,
                SecondaryConnectionMode
            from openxml (@docpointer, '//ReplicaItems/AvailabilityReplica', 0)
            with(
                ReplicaId uniqueidentifier 'ReplicaId',
                GroupId uniqueidentifier 'GroupId',
                ServerSourceName sysname 'ServerSourceName',
                SQLServerID int 'SqlServerId',
                ReplicaName nvarchar(256) 'ReplicaName',
                ReplicaRole int 'ReplicaRoleIntValue',
                FailoverMode int 'FailoverModeIntValue',
                AvailabilityMode int 'AvailabilityModeIntValue',
                PrimaryConnectionMode tinyint 'PrimaryConnectionModeIntValue',
                SecondaryConnectionMode tinyint 'SecondaryConnectionModeIntValue'
                )
            left outer join [dbo].[MonitoredSQLServers] as [SQLServers] on [SQLServers].[RealServerName] = ReplicaName
                and [SQLServers].[Deleted] = 0

        -- For all register to set as inactive.
        declare @nodesSubSet table (
            ServerSourceName sysname
        )

        insert into @nodesSubSet
        select distinct [@temporalTopologyTable].[ServerSourceName] from @temporalTopologyTable

        -- Process XML
        declare @registersToRemove table (
            ReplicaTopologyId bigint,
            GroupId uniqueidentifier,
            ReplicaId uniqueidentifier,
            ReplicaName nvarchar(256)
            )

        -- Get the registers to set inactive.
        insert into @registersToRemove
        select [Replicas].[ReplicaTopologyId], [Replicas].[GroupId], [Replicas].[ReplicaId], [Replicas].[ReplicaName]
            from [dbo].[AlwaysOnReplicas] as [Replicas]
            left outer join @temporalTopologyTable on [Replicas].[ReplicaId] = [@temporalTopologyTable].[ReplicaId] 
                and [Replicas].[ServerSourceName] = [@temporalTopologyTable].[ServerSourceName]
            left join @nodesSubSet on [Replicas].[ServerSourceName] = [@nodesSubSet].[ServerSourceName]
        where ([Replicas].[ReplicaId] <> [@temporalTopologyTable].[ReplicaId]
            or [@temporalTopologyTable].[ReplicaId] is null
            or [Replicas].[ReplicaId] is null)
            and ([Replicas].[ServerSourceName] = [@nodesSubSet].[ServerSourceName])
            and [Replicas].[Active] = 1

        -- Goes through Replicas and insert / update these.
        declare @replicaIdKey bigint
        set rowcount 0
        select 1 from @registersToRemove
        set rowcount 1

        -- Get the cursor
        select @replicaIdKey = [@registersToRemove].[ReplicaTopologyId] from @registersToRemove

        while @@rowcount <> 0
        begin
            set rowcount 0

            if exists(select 1 from [dbo].[AlwaysOnReplicas] as [Replicas]
                        where [Replicas].[ReplicaTopologyId] = @replicaIdKey)
            begin
                -- Set Active to false.
                update [dbo].[AlwaysOnReplicas]
                    set
                        [Active] = 0
                where 
                    ReplicaTopologyId = @replicaIdKey
            end

            delete @registersToRemove where ReplicaTopologyId = @replicaIdKey

            set rowcount 1
            select @replicaIdKey = [@registersToRemove].[ReplicaTopologyId] from @registersToRemove
        end

        set rowcount 0

        -- Goes through Replicas and insert / update these.
        declare @replicaIdCursor uniqueidentifier
        set rowcount 0
        select 1 from @temporalTopologyTable
        set rowcount 1

        -- Get the cursor
        select @replicaIdCursor = ReplicaId from @temporalTopologyTable

        while @@rowcount <> 0
        begin
            set rowcount 0
            -- Get the database id for a row.
            declare @replicaId uniqueidentifier
            select @replicaId = ReplicaId from @temporalTopologyTable
            
            -- Procede to update / insert the registers in the 'AlwaysOnReplicas'.
            -- Define scalar values
            declare @groupId uniqueidentifier
            declare @sqlServerId int
            declare @serverSourceName sysname
            declare @replicaName nvarchar(256)
            declare @replicaRole int
            declare @failoverMode int
            declare @availabilityMode int
            declare @primaryConnectionMode tinyint
            declare @secondaryConnectionMode tinyint
            declare @active bit
            declare @delete bit

            -- Get scalar values
            select @groupId = GroupId from @temporalTopologyTable where ReplicaId = @replicaId
            select @serverSourceName = ServerSourceName from @temporalTopologyTable where ReplicaId = @replicaId
            select @sqlServerId = SQLServerID from @temporalTopologyTable where ReplicaId = @replicaId
            select @replicaName = ReplicaName from @temporalTopologyTable where ReplicaId = @replicaId
            select @replicaRole = ReplicaRole from @temporalTopologyTable where ReplicaId = @replicaId
            select @failoverMode = FailoverMode from @temporalTopologyTable where ReplicaId = @replicaId
            select @availabilityMode = AvailabilityMode from @temporalTopologyTable where ReplicaId = @replicaId
            select @primaryConnectionMode = PrimaryConnectionMode from @temporalTopologyTable where ReplicaId = @replicaId
            select @secondaryConnectionMode = SecondaryConnectionMode from @temporalTopologyTable where ReplicaId = @replicaId
            select @active = 1
            select @delete = 0

             if exists(select 1 from [dbo].[AlwaysOnReplicas]
                        where ReplicaId = @replicaId and ServerSourceName = @serverSourceName)
             begin
                -- Update Availability Replicas
                update [dbo].[AlwaysOnReplicas]
                    set
                        [ReplicaId] = @replicaId,
                        [GroupId] = @groupId,
                        [ServerSourceName] = @serverSourceName,
                        [SQLServerID] = @sqlServerId,
                        [ReplicaName] = @replicaName,
                        [ReplicaRole] = @replicaRole,
                        [FailoverMode] = @failoverMode,
                        [AvailabilityMode] = @availabilityMode,
                        [PrimaryConnectionMode] = @primaryConnectionMode,
                        [SecondaryConnectionMode] = @secondaryConnectionMode,
                        [Active] = @active,
                        [Delete] = @delete
                where ReplicaId = @replicaId and ServerSourceName = @serverSourceName
             end
             else
             begin
                -- Insert Availability Replicas
                insert into [dbo].[AlwaysOnReplicas](
                    [ReplicaId],
                    [GroupId],
                    [ServerSourceName],
                    [SQLServerID],
                    [ReplicaName],
                    [ReplicaRole],
                    [FailoverMode],
                    [AvailabilityMode],
                    [PrimaryConnectionMode],
                    [SecondaryConnectionMode],
                    [Active],
                    [Delete]
                    )
                values(
                    @replicaId,
                    @groupId,
                    @serverSourceName,
                    @sqlServerId,
                    @replicaName,
                    @replicaRole,
                    @failoverMode,
                    @availabilityMode,
                    @primaryConnectionMode,
                    @secondaryConnectionMode,
                    @active,
                    @delete
                )
             end

            delete @temporalTopologyTable where ReplicaId = @replicaId

            set rowcount 1
            select @replicaId = ReplicaId from @temporalTopologyTable
        end
        
        set rowcount 0

        -- Call SP in order to update the Databases topology.
        exec dbo.p_UpdateAlwaysOnDatabaseTopologyXml @DatabaseItemsXml = @AvailabilityReplicaXml
    end
    
    else
    begin
        -- An error occurred, the XML cannot be processed.
        select @AvailabilityReplicaXml
    end

    return @status
end
 
GO 

---------- P_UPDATEALWAYSONDATABASETOPOLOGYXML.SQL

------------------------------------------------------------------------------
-- <copyright file="p_UpdateAlwaysOnDatabaseTopologyXml.sql" company="Idera, Inc.">
--     Copyright (c) Idera, Inc. All rights reserved.
-- </copyright>
------------------------------------------------------------------------------
if (object_id('p_UpdateAlwaysOnDatabaseTopologyXml') is not null)
begin
drop procedure p_UpdateAlwaysOnDatabaseTopologyXml
end
go
create procedure [dbo].p_UpdateAlwaysOnDatabaseTopologyXml(
    @DatabaseItemsXml xml
)
as
begin
    -- Nolock transactions.
    set transaction isolation level read uncommitted

    -- Declare the table to wrap the XML.
    declare @temporalTopologyTable table (
        AlwaysOnDatabaseId int,
        ReplicaId uniqueidentifier,
        GroupId uniqueidentifier,
        GroupDatabaseId uniqueidentifier,
        DatabaseId int,
        DatabaseName nvarchar(128),
        ServerSourceName sysname
    )

    -- Get the XML in a data model representation.
    declare @status int
    declare @docpointer int
    exec @status = sp_xml_preparedocument @docpointer output, @DatabaseItemsXml

    -- @status 0 (success) or >0 (failure)
    if @status = 0
    begin
        -- If the XML could be converted in its data model representation.
        insert into @temporalTopologyTable
        select
            AlwaysOnDatabaseId,
            ReplicaId,
            GroupId,
            GroupDatabaseId,
            DatabaseId,
            DatabaseName,
            ServerSourceName
        from openxml (@docpointer, '//DatabaseItems/AlwaysOnDatabase', 0)
        with(
            AlwaysOnDatabaseId int 'NULL',
            ReplicaId uniqueidentifier 'ReplicaId',
            GroupId uniqueidentifier 'GroupId',
            GroupDatabaseId uniqueidentifier 'GroupDatabaseId',
            DatabaseId int 'DatabaseId',
            DatabaseName nvarchar(128) 'DatabaseName',
            ServerSourceName sysname 'ServerSourceName'
            )

        -- Goes through each row our temporary table.
        declare @alwaysOnDatabaseCursor int
        set rowcount 0
        select 1 from @temporalTopologyTable
        set rowcount 1
        --update #mytemp set mykey = 1
        update @temporalTopologyTable set AlwaysOnDatabaseId=1

        -- Get the cursor
        select @alwaysOnDatabaseCursor = AlwaysOnDatabaseId from @temporalTopologyTable

        while @@rowcount <> 0
        begin
            set rowcount 0
            -- Get the database id for a row.
            declare @alwaysOnDatabaseId int
            select @alwaysOnDatabaseId = 1

            -- Define scalar values
            declare @replicaId uniqueidentifier
            declare @groupId uniqueidentifier
            declare @groupDatabaseId uniqueidentifier
            declare @databaseId int
            declare @databaseName sysname
            declare @serverSourceName sysname
            declare @delete bit

            -- Get scalar values
            select @replicaId = ReplicaId from @temporalTopologyTable where AlwaysOnDatabaseId = @alwaysOnDatabaseId
            select @groupId = GroupId from @temporalTopologyTable where AlwaysOnDatabaseId = @alwaysOnDatabaseId
            select @groupDatabaseId = GroupDatabaseId from @temporalTopologyTable where AlwaysOnDatabaseId = @alwaysOnDatabaseId
            select @databaseId = DatabaseId from @temporalTopologyTable where AlwaysOnDatabaseId = @alwaysOnDatabaseId
            select @databaseName = DatabaseName from @temporalTopologyTable where AlwaysOnDatabaseId = @alwaysOnDatabaseId
            select @serverSourceName = ServerSourceName from @temporalTopologyTable where AlwaysOnDatabaseId = @alwaysOnDatabaseId
            select @delete = 0

            if exists(select 1 from [dbo].[AlwaysOnDatabases]
                        where GroupId = @groupId and ReplicaId = @replicaId and DatabaseID = @databaseId and ServerSourceName = @serverSourceName)
            begin
                -- Update the row
                update [dbo].[AlwaysOnDatabases]
                    set
                    [ReplicaId] = @replicaId,
                    [GroupId] = @groupId,
                    [GroupDatabaseId] = @groupDatabaseId,
                    [DatabaseID] = @databaseId,
                    [DatabaseName] = @databaseName,
                    [Delete] = @delete
                where GroupId = @groupId and ReplicaId = @replicaId and DatabaseID = @databaseId and ServerSourceName = @serverSourceName
            end
            else
            begin
                -- Insert the row
                insert into [dbo].[AlwaysOnDatabases] (
                    [ReplicaId],
                    [GroupId],
                    [GroupDatabaseId],
                    [DatabaseID],
                    [DatabaseName],
                    [ServerSourceName],
                    [Delete]
                    )
                values (
                    @replicaId,
                    @groupId,
                    @groupDatabaseId,
                    @databaseId,
                    @databaseName,
                    @serverSourceName,
                    @delete
                    )
            end

            delete @temporalTopologyTable where AlwaysOnDatabaseId = @alwaysOnDatabaseId

            set rowcount 1
            update @temporalTopologyTable set AlwaysOnDatabaseId=1
        end

        set rowcount 0

        -- Call SP in order to update the Databases topology.
        exec dbo.p_GroomAlwaysOnDatabaseTopologyXml @DatabaseItemsXml = @DatabaseItemsXml
    end
    else
    begin
        -- Error occurs the xml cannot be retrieved
        select @DatabaseItemsXml
    end

    return @status
end
 
GO 

---------- P_UPDATEBLOCKEDRECOMMENDATIONDATABASEANALYSISCONFIGURATION.SQL

if (object_id('p_UpdateBlockedRecommendationDatabaseAnalysisConfiguration') is not null)
begin
drop procedure [p_UpdateBlockedRecommendationDatabaseAnalysisConfiguration]
end
go


create procedure [p_UpdateBlockedRecommendationDatabaseAnalysisConfiguration] 
@sqlServerID INT,
@databaseID xml,
@recommendationID xml
AS
begin

DECLARE @checkXML INT 
DECLARE @analysisConfigID INT 
BEGIN TRY
   -- Start A Transaction
BEGIN TRANSACTION

BEGIN
--get record having IsActive true for this server id
SELECT @analysisConfigID = ID FROM [dbo].[AnalysisConfiguration]
WHERE MonitoredServerID = @sqlServerID AND IsActive = 1

if(@analysisConfigID > 0)
BEGIN

	-- delete all existting records for that config
	delete from AnalysisConfigBlockedDatabases WHERE AnalysisConfigurationID =@analysisConfigID
	delete from AnalysisConfigBlockedRecommendation WHERE AnalysisConfigurationID =@analysisConfigID

			SET @checkXML = @databaseID.exist('(//DatabaseID)')
			if( @checkXML != 0)
			BEGIN
				INSERT INTO [dbo].[AnalysisConfigBlockedDatabases]
			  ([AnalysisConfigurationID]
			   ,[DatabaseID])
				(select @analysisConfigID, x.record.query('ID').value('.', 'int')
						from @databaseID.nodes('Database/DatabaseID') as x(record))
			END
			
			SET @checkXML = @recommendationID.exist('(//RecommendationID)')
			if( @checkXML != 0)
			BEGIN
			
				INSERT INTO [dbo].[AnalysisConfigBlockedRecommendation]
			   ([AnalysisConfigurationID]
			   ,[RecommendationID])
				(select @analysisConfigID, x.record.query('ID').value('.', 'nvarchar(10)')
						from @recommendationID.nodes('Recommendation/RecommendationID') as x(record))

			END

END
ELSE
	BEGIN
	Print 'Analysis Id not found - Will Rollback'
	  -- Any Error Occurred during Transaction. Rollback
	  ROLLBACK  -- Roll back
  		  
	  RAISERROR ('Analysis Id not found - Will Rollback',
             16,
             1)
	END 

COMMIT
END
END TRY
BEGIN CATCH
 Print 'Error while updating configurations.'
  -- Any Error Occurred during Transaction. Rollback
  ROLLBACK  -- Roll back
  		  
  RAISERROR ('Error while updating configurations.',
             16,
             1)
END CATCH

end
 
GO 
 
GO 

---------- P_UPDATECOUNTER.SQL
if (object_id('p_UpdateCounter') is not null)
begin
drop procedure p_UpdateCounter
end
go

CREATE PROCEDURE [dbo].p_UpdateCounter(
	@Metric int,
	@Name nvarchar(128),
	@Category nvarchar(64),	
	@Description nvarchar(512),
	@Class int, 
	@Flags int,
	@Scale float,
	@MinValue int,
	@MaxValue bigint,
	@DefaultInfoValue bigint,
	@DefaultWarningValue bigint,
	@DefaultCriticalValue bigint,
	@DoNotifications bit,
	@EventCategory int,
	@DefaultMessageID int,
	@AlertEnabledDefault bit, 
	@ValueComparison int,	
	@ValueType nvarchar(128),
	@Rank int,
	@MetricType int,
	@CalculationType int,
	@CounterEnabled bit,
	@ObjectName	nvarchar(256),
	@CounterName nvarchar(256),
	@InstanceName nvarchar(256),
	@Batch	nvarchar(max)
)
AS
begin
	declare @e int
	declare @result int
	declare @DisableInfoThreshold bit
	declare @infoThresholdXML xml

	set @DisableInfoThreshold = 0
	
	if (@DefaultInfoValue < @MinValue) 
	begin
		set @DisableInfoThreshold = 1
	end

	UPDATE [CustomCounterDefinition] SET
		[MetricType] = @MetricType,
		[CalculationType] = @CalculationType,
		[Scale] = @Scale,
		[Object] = @ObjectName,
		[Counter] = @CounterName,
		[Instance] = @InstanceName,
		[Batch] = @Batch
	WHERE [Metric] = @Metric

	SET @result = @@error

	UPDATE [MetricMetaData] SET
		[Class] = @Class,
		[Flags] = @Flags,
		[MinValue] = @MinValue,
		[MaxValue] = @MaxValue,
		[DefaultWarningValue] = @DefaultWarningValue,
		[DefaultCriticalValue] = @DefaultCriticalValue,
		[DefaultInfoValue] = case when @DefaultInfoValue < @MinValue then [DefaultInfoValue] else @DefaultInfoValue end,
		[DoNotifications] = @DoNotifications,
		[EventCategory] = @EventCategory,
		[DefaultMessageID] = @DefaultMessageID,
		[AlertEnabledDefault] = @AlertEnabledDefault,
		[ValueComparison] = @ValueComparison,
		[ValueType] = @ValueType,
		[Rank] = @Rank
	WHERE [Metric] = @Metric
	
	SET @e = @@error
	IF (@e <> 0 and @result = 0)
		SET @result = @e

	UPDATE [MetricInfo] SET
		[Rank] = @Rank,
		[Category] = @Category,
		[Name] = @Name,
		[Description] = @Description
	WHERE [Metric] = @Metric
	SET @e = @@error
	IF (@e <> 0 and @result = 0)
		SET @result = @e

	SELECT @infoThresholdXML = CAST(b.InfoThreshold as XML) from AlertTemplateLookup a left join DefaultMetricThresholds b on a.TemplateID = b.UserViewID where a.[Default] = 1 and b.Metric = @Metric
	
	if (@@ROWCOUNT > 0)
	BEGIN
		if (@DisableInfoThreshold = 1)
		begin
			set @infoThresholdXML.modify('replace value of (/Threshold/@Enabled)[1] with "false"')
		end
		else begin
			set @infoThresholdXML.modify('replace value of (/Threshold/@Enabled)[1] with "true"')
		end
		
		update DefaultMetricThresholds set InfoThreshold = CONVERT(nvarchar(1024), @infoThresholdXML) from AlertTemplateLookup a left join DefaultMetricThresholds b on a.TemplateID = b.UserViewID where a.[Default] = 1 and b.Metric = @Metric
	END
	RETURN @result
END	
 
GO 

---------- P_UPDATECOUNTERSTATUS.SQL
if (object_id('p_UpdateCounterStatus') is not null)
begin
drop procedure p_UpdateCounterStatus
end
go

CREATE PROCEDURE [dbo].p_UpdateCounterStatus(
	@Metric int,
	@Enabled bit
)
AS
begin
	declare @e int

	BEGIN TRANSACTION

	-- mark the custom counter disabled
	UPDATE [CustomCounterDefinition] 
		SET [Enabled] = @Enabled
		WHERE Metric = @Metric
	SET @e = @@error

	IF (@e = 0)
	BEGIN
		-- deactivate alerts
		UPDATE Alerts SET [Active] = 0
			WHERE [Metric] = @Metric	
		SET @e = @@error		
	END

	IF (@e = 0)
		COMMIT
	ELSE
		ROLLBACK		

	return @e
END	
 
GO 

---------- P_UPDATECUSTOMCOUNTERTAGS.SQL
IF (object_id('p_UpdateCustomCounterTags') IS NOT NULL)
BEGIN
DROP PROCEDURE p_UpdateCustomCounterTags
END
GO

CREATE PROCEDURE [dbo].[p_UpdateCustomCounterTags]
(
	@Metric INT,
	@Tags nvarchar(max),
	@Synchronize BIT = 1
)
AS
BEGIN
	DECLARE @error INT
	DECLARE @xmlDoc INT

	IF (@Tags IS NOT NULL)
	BEGIN
		DECLARE @TagIds TABLE(TagId INT)

		EXEC sp_xml_preparedocument @xmlDoc OUTPUT, @Tags
		INSERT INTO @TagIds	
			SELECT TagId
				FROM OPENXML(@xmlDoc, '//Tag', 1) WITH (TagId INT)
		EXEC sp_xml_removedocument @xmlDoc

		IF (@Synchronize = 1)
		BEGIN
			DELETE FROM CustomCounterTags 
			WHERE 
				Metric = @Metric AND
				TagId NOT IN (SELECT TagId FROM @TagIds)
		END

		DELETE FROM @TagIds
		WHERE TagId IN (SELECT TagId FROM CustomCounterTags WHERE Metric = @Metric)

		INSERT INTO CustomCounterTags
			SELECT @Metric, TagId FROM @TagIds
	END
	ELSE
	BEGIN
		DELETE FROM CustomCounterTags WHERE Metric = @Metric	
	END

	SELECT TagId FROM CustomCounterTags WHERE Metric = @Metric

	SELECT @error = @@error
	RETURN @error
END
 
GO 

---------- P_UPDATECUSTOMREPORT.SQL
if (object_id('[p_UpdateCustomReport]') is not null)
begin
drop procedure [p_UpdateCustomReport]
end
go

CREATE proc [dbo].[p_UpdateCustomReport](
@reportID int = null OUT, 
@operation int,
@reportName nvarchar(255) = null,
@reportShortDescription nvarchar(255) = null,
@reportText nvarchar(4000) = null,
@showTopServers bit
) as
begin
declare @ptr varbinary(16), @len int

if @reportID is null and @operation <> 5
	select @reportID = ID 
	from CustomReports 
	where reportName = @reportName

if @operation = 1
	delete from CustomReports where ID = @reportID
if @operation = 2 
	begin
		select @ptr = TEXTPTR(reportText), @len = datalength(reportText)/2 
		from CustomReports 
		where ID = @reportID

		WriteText CustomReports.reportText @ptr null
		update CustomReports set reportText = @reportText, ShowTopServers = @showTopServers where ID = @reportID
	end
if @operation = 3
	begin
		select @ptr = TEXTPTR(reportText), @len = datalength(reportText)/2 
		from CustomReports 
		where ID = @reportID

		UpdateText CustomReports.reportText @ptr @len 0 @reportText
	end
if @operation = 4
	begin
		update CustomReports 
		set reportName = @reportName, reportShortDescription = @reportShortDescription, ShowTopServers = @showTopServers
		where ID = @reportID
	end
if @operation = 5
	begin
		insert into CustomReports (reportName, reportShortDescription, reportText, ShowTopServers)values (@reportName, @reportShortDescription, @reportText, @showTopServers)
		SELECT @reportID = SCOPE_IDENTITY()
	end
end
 
GO 

---------- P_UPDATEDASHBOARDLAYOUT.SQL
if (object_id('p_UpdateDashboardLayout') is not null)
begin
drop procedure [p_UpdateDashboardLayout]
end
go

create procedure [p_UpdateDashboardLayout] 
	@DashboardLayoutID int,
	@Name nvarchar(128),
	@Configuration nvarchar(max),
	@Image image,
	@UseAsDefault bit
as
begin

	declare @LastUpdated datetime
	declare @LoginName nvarchar(256)
	
	select @LastUpdated = GETUTCDATE()

	update [DashboardLayouts]
		set Name = @Name,
			LastUpdated = @LastUpdated,
			LastViewed = @LastUpdated,
			Configuration = isnull(@Configuration, Configuration),
			LayoutImage = isnull(@Image, LayoutImage)
		where
			DashboardLayoutID = @DashboardLayoutID

	if (@UseAsDefault = 1)
	begin
		select @LoginName = LoginName from [DashboardLayouts] where DashboardLayoutID = @DashboardLayoutID
		exec p_SetDefaultDashboardLayout @LoginName, null, @DashboardLayoutID
	end

end
 
GO 

---------- P_UPDATEDASHBOARDLAYOUTVIEWED.SQL
if (object_id('p_UpdateDashboardLayoutViewed') is not null)
begin
drop procedure [p_UpdateDashboardLayoutViewed]
end
go

create procedure [p_UpdateDashboardLayoutViewed] 
	@DashboardLayoutID int
as
begin

	update [DashboardLayouts]
		set LastViewed = GETUTCDATE()
		where
			DashboardLayoutID = @DashboardLayoutID

end
 
GO 

---------- P_UPDATEGROOMING.SQL
if (object_id('p_UpdateGrooming') is not null)
begin
drop procedure [p_UpdateGrooming]
end
go

create procedure [p_UpdateGrooming]
	@AlertsDays int ,
	@MetricsDays int ,
	@TasksDays int ,
	@ActivityDays int,
	@AuditDays int,
	--10.0 SQLdm srishti purohit
    --Prescriptive analysis old data grooming implementation
	@PADays int,
	@StartTime int,
	@SubDayType int ,
	@QueriesDays int,
	@AggregationStartTime int,
	@AggregationSubDayType int
as
begin
	declare @rc int

	DELETE FROM RepositoryInfo WHERE Name in ('GroomAlerts', 'GroomMetrics', 'GroomTasks', 'GroomActivity','GroomQueryAggregation','GroomAudit', 'GroomPrescriptiveAnalysis') 
	
	INSERT RepositoryInfo ([Name], Internal_Value)
	VALUES ('GroomAlerts', @AlertsDays);
	
	INSERT RepositoryInfo ([Name], Internal_Value)
	VALUES ('GroomMetrics', @MetricsDays);
	
	INSERT RepositoryInfo ([Name], Internal_Value)
	VALUES ('GroomTasks', @TasksDays);

	INSERT RepositoryInfo ([Name], Internal_Value)
	VALUES ('GroomActivity', @ActivityDays);

	INSERT RepositoryInfo ([Name], Internal_Value)
	VALUES ('GroomQueryAggregation', @QueriesDays);
	
	INSERT RepositoryInfo ([Name], Internal_Value)
	VALUES ('GroomAudit', @AuditDays);

	INSERT RepositoryInfo ([Name], Internal_Value)
	VALUES ('GroomPrescriptiveAnalysis', @PADays);

	-- Now reconfigure the grooming job.
	DECLARE @schedname nvarchar(256)

	set @schedname = 'Groom ' + DB_NAME()
	-- sp_update_jobschedule is used for compatibility with SQL Server 2000
	
	if (@SubDayType is not null and @StartTime is not null)	
	begin
		if (@SubDayType = 1)
			EXEC @rc = msdb.dbo.sp_update_jobschedule 
				@job_name = @schedname, 
				@name = @schedname, 
				@enabled=1, 
				@freq_type=4, 
				@freq_interval=1, 
				@freq_subday_type=1, 
				@freq_subday_interval=0, 
				@freq_relative_interval=0, 
				@freq_recurrence_factor=0, 
				@active_start_time=@StartTime,
				@active_end_time=0,
				@active_start_date=20070511, 
				@active_end_date=99991231
		else
			EXEC @rc = msdb.dbo.sp_update_jobschedule 
				@job_name = @schedname, 
				@name = @schedname, 
				@enabled=1, 
				@freq_type=4, 
				@freq_interval=1, 
				@freq_subday_type=@SubDayType, 
				@freq_subday_interval=@StartTime, 
				@freq_relative_interval=0, 
				@freq_recurrence_factor=0, 
				@active_start_time=0,
				@active_end_time=0,
				@active_start_date=20070511, 
				@active_end_date=99991231
	end

	set @schedname = 'Aggregate Data ' + DB_NAME()
	-- sp_update_jobschedule is used for compatibility with SQL Server 2000
	
	if (@AggregationSubDayType is not null and @AggregationStartTime is not null)	
	begin
		if (@AggregationSubDayType = 1)
			EXEC @rc = msdb.dbo.sp_update_jobschedule 
				@job_name = @schedname, 
				@name = @schedname, 
				@enabled=1, 
				@freq_type=4, 
				@freq_interval=1, 
				@freq_subday_type=1, 
				@freq_subday_interval=0, 
				@freq_relative_interval=0, 
				@freq_recurrence_factor=0, 
				@active_start_time=@AggregationStartTime,
				@active_end_time=0,
				@active_start_date=20070511, 
				@active_end_date=99991231
		else
			EXEC @rc = msdb.dbo.sp_update_jobschedule 
				@job_name = @schedname, 
				@name = @schedname, 
				@enabled=1, 
				@freq_type=4, 
				@freq_interval=1, 
				@freq_subday_type=@AggregationSubDayType, 
				@freq_subday_interval=@AggregationStartTime, 
				@freq_relative_interval=0, 
				@freq_recurrence_factor=0, 
				@active_start_time=0,
				@active_end_time=0,
				@active_start_date=20070511, 
				@active_end_date=99991231
	end

	return @rc
end
 
GO 

---------- P_UPDATELASTDATABASEREFRESHTIME.SQL
if (object_id('p_UpdateLastDatabaseRefreshTime') is not null)
begin
drop procedure [p_UpdateLastDatabaseRefreshTime]
end
go

create procedure [p_UpdateLastDatabaseRefreshTime] (
	@SqlServerID int,
    @UTCLastDatabaseCollectionTime datetime = null
)
as
begin
	DECLARE @err int

	if @UTCLastDatabaseCollectionTime is null
		SET @UTCLastDatabaseCollectionTime = GetUTCDate()

	UPDATE MonitoredSQLServers SET
			[LastDatabaseCollectionTime] = @UTCLastDatabaseCollectionTime,
			[LastAlertRefreshTime] = @UTCLastDatabaseCollectionTime
			
		WHERE [SQLServerID] = @SqlServerID

	SELECT @err = @@error
	
	RETURN @err
end
 
GO 

---------- P_UPDATELASTREFRESHTIME.SQL
if (object_id('p_UpdateLastRefreshTime') is not null)
begin
drop procedure [p_UpdateLastRefreshTime]
end
go

create procedure [p_UpdateLastRefreshTime] (
	@SqlServerID int,
    @UTCLastScheduledCollectionTime datetime = null
)
as
begin
	DECLARE @err int

	if @UTCLastScheduledCollectionTime is null
		SET @UTCLastScheduledCollectionTime = GetUTCDate()

	UPDATE MonitoredSQLServers SET
			[LastScheduledCollectionTime] = @UTCLastScheduledCollectionTime,
			[LastAlertRefreshTime] = @UTCLastScheduledCollectionTime
		WHERE [SQLServerID] = @SqlServerID

	SELECT @err = @@error
	
	RETURN @err
end
 
GO 

---------- P_UPDATEMETRICINFO.SQL

if (object_id('p_UpdateMetricInfo') is not null)
begin
drop procedure [p_UpdateMetricInfo]
end
go
CREATE PROCEDURE [dbo].[p_UpdateMetricInfo](
	@Metric int,
	@Comments nvarchar(4000)
)
AS
begin

declare @e int

UPDATE	[MetricInfo] 
	SET [Comments] = @Comments
WHERE ([Metric] = @Metric)

SELECT @e = @@error

return @e

end
 
GO 

---------- P_UPDATEMETRICTHRESHOLD.SQL
if (object_id('p_UpdateMetricThreshold') is not null)
begin
drop procedure [p_UpdateMetricThreshold]
end
go

create procedure [p_UpdateMetricThreshold] (
	@UserViewID int,
	@SQLServerID int,
	@Metric int,
	@Enabled bit,
	@WarningThreshold nvarchar(1024),
	@CriticalThreshold nvarchar(1024),
	@Data nvarchar(max),
	@UTCSnoozeStart datetime,
	@UTCSnoozeEnd datetime,
	@SnoozeStartUser nvarchar(255),
	@SnoozeEndUser nvarchar(255),
	@InfoThreshold nvarchar(1024),
	@ThresholdInstance nvarchar(256),
	@ThresholdInstanceType int,
	@ThresholdEnabled bit,
	@IsBaselineEnabled bit,
	@BaselineWarningThresholdXML nvarchar(256),
	@BaselineCriticalThresholdXML nvarchar(256),
	@BaselineInfoThresholdXML nvarchar(256)
)
as
begin
	DECLARE @err int 
	DECLARE @InstanceName nvarchar(256)
	DECLARE @ActiveSnapshotDateTime datetime
	DECLARE @OldWarningThreshold nvarchar(1024)
	DECLARE @OldOp nvarchar(32)
	DECLARE @NewOp nvarchar(32)
	DECLARE @ThresholdInstanceID int
	set @err = 0
	set @ThresholdInstanceID = -2
	
	-- Get/Create the Threshold Instance ID for this Threshold Instance
	EXEC p_AddThresholdInstance @ThresholdInstanceType, @ThresholdInstance, @ThresholdInstanceID output
	if (@ThresholdInstanceID = -2)
	BEGIN
		RAISERROR('Using invalid Threshold Instance ID', 10, 1, -1)
		return -1
	END
		
	if (@SQLServerID IS NULL) 
	BEGIN
		IF (@UserViewID IS NULL)
		BEGIN
			RAISERROR('@SQLServerID or @UserViewID is required.', 10, 1, -1)
			RETURN -1
		END    
		ELSE
		BEGIN
			SELECT @OldWarningThreshold = [WarningThreshold]
				FROM [DefaultMetricThresholds]
				WHERE ([UserViewID] = @UserViewID) AND 
					  ([Metric] = @Metric) and
					  ([ThresholdInstanceID] = @ThresholdInstanceID)

			IF (@@ROWCOUNT > 0)
			BEGIN
				UPDATE[DefaultMetricThresholds] 
					SET [Enabled] = @Enabled,
						[InfoThreshold] = @InfoThreshold,
						[WarningThreshold] = @WarningThreshold, 
						[CriticalThreshold] = @CriticalThreshold,
						[Data] = @Data,
						[ThresholdEnabled] = @ThresholdEnabled,
						[IsBaselineEnabled] = @IsBaselineEnabled,
						[BaselineWarningThreshold] = @BaselineWarningThresholdXML,
						[BaselineCriticalThreshold] = @BaselineCriticalThresholdXML,
						[BaselineInfoThreshold] = @BaselineInfoThresholdXML
				WHERE ([UserViewID] = @UserViewID) AND ([Metric] = @Metric) AND ([ThresholdInstanceID] = @ThresholdInstanceID)

				-- determine if the default comparison operation changed and update existing thresholds
				SET @NewOp = SUBSTRING(@WarningThreshold, PATINDEX('% Op="__" %', @WarningThreshold), 9)
				SET @OldOp = SUBSTRING(@OldWarningThreshold, PATINDEX('% Op="__" %', @OldWarningThreshold), 9)
				IF (@OldOp <> @NewOp)
				BEGIN
					UPDATE MetricThresholds SET
						[InfoThreshold] = @InfoThreshold,
						[WarningThreshold] = @WarningThreshold,
						[CriticalThreshold] = @CriticalThreshold,
						[IsBaselineEnabled] = @IsBaselineEnabled,
						[BaselineWarningThreshold] = @BaselineWarningThresholdXML,
						[BaselineCriticalThreshold] = @BaselineCriticalThresholdXML,
						[BaselineInfoThreshold] = @BaselineInfoThresholdXML
					WHERE Metric = @Metric
				END
			END
		END
	END
	ELSE
	BEGIN
		IF (@UserViewID IS NOT NULL)
		BEGIN
			RAISERROR('@SQLServerID and @UserViewID are mutually exclusive.', 10, 1, -1)
			RETURN -1
		END
		ELSE
		BEGIN
			IF (EXISTS (select 
							[WarningThreshold] 
						from 
							[MetricThresholds] 
						where 
							[SQLServerID] = @SQLServerID AND 
							[Metric] = @Metric AND 
							[ThresholdInstanceID] = @ThresholdInstanceID)
				)
			BEGIN
				UPDATE[MetricThresholds] 
					SET [Enabled] = @Enabled,
						[InfoThreshold] = @InfoThreshold,
						[WarningThreshold] = @WarningThreshold, 
						[CriticalThreshold] = @CriticalThreshold,
						[Data] = @Data,
						[UTCSnoozeStart] = COALESCE(@UTCSnoozeStart,[UTCSnoozeStart]),
						[UTCSnoozeEnd] = COALESCE(@UTCSnoozeEnd,[UTCSnoozeEnd]),
						[SnoozeStartUser] = COALESCE(@SnoozeStartUser,[SnoozeStartUser]),
						[SnoozeEndUser] = COALESCE(@SnoozeEndUser,[SnoozeEndUser]),
						[ThresholdEnabled] = @ThresholdEnabled,
						[IsBaselineEnabled] = @IsBaselineEnabled,
						[BaselineWarningThreshold] = @BaselineWarningThresholdXML,
						[BaselineCriticalThreshold] = @BaselineCriticalThresholdXML,
						[BaselineInfoThreshold] = @BaselineInfoThresholdXML
				WHERE ([SQLServerID] = @SQLServerID) AND ([Metric] = @Metric) AND ([ThresholdInstanceID] = @ThresholdInstanceID)

				IF (@Enabled = 0 AND @ThresholdInstanceID = -1)
				BEGIN
					SELECT @InstanceName = [InstanceName],
						@ActiveSnapshotDateTime = [LastAlertRefreshTime]
						from MonitoredSQLServers (nolock) 
						where [SQLServerID] = @SQLServerID

					-- clear the active flag from any alerts outstanding for this metric
					UPDATE [Alerts] SET [Active] = 0
						WHERE 
							[ServerName] = @InstanceName and
							[UTCOccurrenceDateTime] = @ActiveSnapshotDateTime and
							[Active] = 1 and
							[Metric] = @Metric
				END
			END
		END
	END

	SELECT @err = @@error

	RETURN @err
end
 
GO 

---------- P_UPDATEMONITOREDSQLSERVER.SQL
IF (object_id('p_UpdateMonitoredSqlServer') IS NOT NULL)
BEGIN
DROP PROCEDURE [p_UpdateMonitoredSqlServer]
END
GO


CREATE PROCEDURE [dbo].[p_UpdateMonitoredSqlServer]
(
	@SqlServerId int,
	@Active bit,
	@CollectionServiceId uniqueidentifier,
	@UseIntegratedSecurity bit,
	@Username nvarchar(128),
	@Password nvarchar(128),
	@ScheduledCollectionIntervalInSeconds int,
	@MaintenanceModeEnabled bit,
	@QueryMonitorEnabled bit,
	@QueryMonitorSqlBatchEventsEnabled bit,
	@QueryMonitorSqlStatementEventsEnabled bit,
	@QueryMonitorStoredProcedureEventsEnabled bit,
	@ActivityMonitorDeadlockEventsEnabled bit,
	@QueryMonitorDurationFilterInMilliseconds int,
	@QueryMonitorCpuUsageFilterInMilliseconds int,
	@QueryMonitorLogicalDiskReadsFilter int,
	@QueryMonitorPhysicalDiskWritesFilter int,
	@QueryMonitorTraceFileSizeKB int,
	@QueryMonitorTraceFileRollovers int,
	@QueryMonitorTraceRecordsPerRefresh int,
	@GrowthStatisticsStartTime datetime = '1900-01-01 3:00:00 AM',
	@ReorgStatisticsStartTime datetime = '1900-01-01 3:00:00 AM',
	@GrowthStatisticsDays tinyint = 253,
	@ReorgStatisticsDays tinyint = 253,
	@TableStatisticsExcludedDatabases nvarchar(max) = null,
	@EncryptData bit = 0,
	@TrustServerCert bit = 0,
	@ReorgMinTableSizeKB int = 200,
	@DisableReplicationMonitoring bit = 0,
	@MaintenanceModeType int = 0,
	@MaintenanceModeStart datetime = null,
	@MaintenanceModeStop datetime = null,
	@MaintenanceModeDurationSeconds int = null,
	@MaintenanceModeDays smallint = 0,
	@QueryMonitorAdvancedConfiguration nvarchar(max) = null,
	@DisableExtendedHistoryCollection bit = 0,
	@MaintenanceModeRecurringStart datetime = null,
	@DisableOleAutomation bit = 0,
	@DiskCollectionSettings nvarchar(max) = null,
	@QueryMonitorStopTimeUTC datetime = null,
	@InputBufferLimiter int = 500,
	@InputBufferLimited bit = 0,
	@PreferredClusterNode nvarchar(256) = null,
	@ActiveWaitCollectorStartTimeRelative datetime = null,
	@ActiveWaitCollectorRunTimeSeconds int = 0, 
	@ActiveWaitCollectorCollectionTimeSeconds int = 30,
	@ActiveWaitCollectorEnabled bit = 0,
	@ActiveWaitLoopTimeMilliseconds int = 500,
	@ActiveWaitAdvancedConfiguration nvarchar(max) = null,
	@ServerPingInterval int = 30,
	@VHostID int = -1,
	@VmUID nvarchar(256) = null,
	@VmName nvarchar(256) = null,
	@VmDomainName nvarchar(256) = null,
	@AlertRefreshInMinutes bit = true,
	@BaselineTemplate nvarchar(1024) = null,
	@DatabaseStatisticsRefreshIntervalInSeconds int,
	@ActiveWaitXEEnable bit = 1,
	@ActiveWaitXEFileSizeMB int = 1,
	@ActiveWaitXEFilesRollover int = 3,
	@ActiveWaitXERecordsPerRefresh int = 1000,
	@ActiveWaitXEMaxMemoryMB int = 1,
	@ActiveWaitXEEventRetentionMode tinyint = 1,
	@ActiveWaitXEMaxDispatchLatencySecs int = 300,
	@ActiveWaitXEMaxEventSizeMB int = 1,
	@ActiveWaitXEMemoryPartitionMode int = 0,
	@ActiveWaitXETrackCausality bit = 0,
	@ActiveWaitXEStartupState bit = 0,
	@ActiveWaitsXEFileName nvarchar(1024) = 'dm7XESessionOut.xel',
	@WmiCollectionEnabled bit = 0,
	@WmiConnectAsService bit = 0,
	@WmiUserName nvarchar(256) = null,
	@WmiPassword nvarchar(256) = null,
	@ActivityMonitorEnabled bit,
	@ActivityMonitorBlockingEventsEnabled bit,
	@ActivityMonitorAutogrowEventsEnabled bit,

	@ActivityMonitorBlockedProcessThreshold int,

	@MaintenanceModeMonth int,

	@MaintenanceModeSpecificDay int,

	@MaintenanceModeWeekOrdinal int,

	@MaintenanceModeWeekDay int,

	@MaintenanceModeMonthDuration int,

	@MaintenanceModeMonthRecurringStart datetime = null,
	--SQLdm 9.0 (Ankit Srivastava): Query Monitoring with Extended Event Session  -- Added two new parameters for updating the MonitoredSqlServer
	@QueryMonitorTraceMonitoringEnabled bit,
	@QueryMonitorCollectQueryPlan bit,

	--START SQLdm 9.1 (Ankit Srivastava): Activity Monitor with Extended Events  -- Added new parameters
	@ActivityMonitorTraceMonitoringEnabled bit,
	@ActivityMonitorXEFileSizeMB int =1,
	@ActivityMonitorXEFilesRollover int =3,
	@ActivityMonitorXERecordsPerRefresh int =1000,
	@ActivityMonitorXEMaxMemoryMB int =1,
	@ActivityMonitorXEEventRetentionMode int =1,
	@ActivityMonitorXEMaxDispatchLatencySecs int =300,
	@ActivityMonitorXEMaxEventSizeMB int =1,
	@ActivityMonitorXEMemoryPartitionMode int =0,
	@ActivityMonitorXETrackCausality bit =0,
	@ActivityMonitorXEStartupState bit =0,
	@ActivityMonitorXEFileName nvarchar(1024)= 'AMExtendedEventLog.xel',
	 --END SQLdm 9.1 (Ankit Srivastava): Activity Monitor with Extended Events  -- Added new parameters
	--START SQLdm 9.1 (Ankit Srivastava): Query Monitor 9.0 Improvement feedback -adding new parameters for uery monitoring extended event session configuration
	@QueryMonitorXEFileSizeMB int=20,
	@QueryMonitorXEFilesRollover int=5,
	--END SQLdm 9.1 (Ankit Srivastava): Query Monitor 9.0 Improvement feedback - adding new parameters for uery monitoring extended event session configuration
	@friendlyServerName nvarchar(256) = null,
	@baselineConfigList xml
	-- START 10.0 (srishti purohit) : To handle analysis configuration
	
	,@productionServer bit,
	@OLTP bit,
	@analysisStartTime DATETIME,
	@duration INT,
	@scheduledDays smallint,
	@isActive bit,
	@includeDatabase int,
	@filterApplication nvarchar(max),
	@categoryID xml,
	@databaseID xml,
	@recommendationID xml
	
	-- END 10.0 (srishti purohit) : To handle analysis configuration
	,@QueryMonitorCollectEstimatedQueryPlan bit--SQLdm 10.0 (Tarun Sapra)- Flag for displaying estimated query plan only
	,@schedulingStatus bit --SQLDM10.0 (praveen suhalka) : scheduling status
)
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @error int
	DECLARE @rowcount int

	UPDATE [dbo].[MonitoredSQLServers]
	SET 
		[Active] = @Active,
		[FriendlyServerName] = @friendlyServerName,
		[CollectionServiceID] = @CollectionServiceId,
		[UseIntegratedSecurity] = @UseIntegratedSecurity,
		[Username] = @Username,
		[Password] = @Password,
		[ScheduledCollectionIntervalInSeconds] = @ScheduledCollectionIntervalInSeconds,
		[MaintenanceModeEnabled] = @MaintenanceModeEnabled,
		[QueryMonitorEnabled] = @QueryMonitorEnabled,
		[QueryMonitorSqlBatchEventsEnabled] = @QueryMonitorSqlBatchEventsEnabled,
		[QueryMonitorSqlStatementEventsEnabled] = @QueryMonitorSqlStatementEventsEnabled,
		[QueryMonitorStoredProcedureEventsEnabled] = @QueryMonitorStoredProcedureEventsEnabled,
		[QueryMonitorDurationFilterInMilliseconds] = @QueryMonitorDurationFilterInMilliseconds,
		[QueryMonitorCpuUsageFilterInMilliseconds] = @QueryMonitorCpuUsageFilterInMilliseconds,
		[QueryMonitorLogicalDiskReadsFilter] = @QueryMonitorLogicalDiskReadsFilter,
		[QueryMonitorPhysicalDiskWritesFilter] = @QueryMonitorPhysicalDiskWritesFilter,
		[QueryMonitorTraceFileSizeKB] = @QueryMonitorTraceFileSizeKB,
		[QueryMonitorTraceFileRollovers] = @QueryMonitorTraceFileRollovers,
		[QueryMonitorTraceRecordsPerRefresh] = @QueryMonitorTraceRecordsPerRefresh,
		[ActivityMonitorEnabled] = @ActivityMonitorEnabled,
		[ActivityMonitorDeadlockEventsEnabled] = @ActivityMonitorDeadlockEventsEnabled,
		[ActivityMonitorBlockingEventsEnabled] = @ActivityMonitorBlockingEventsEnabled,		
		[ActivityMonitorAutoGrowEventsEnabled] = @ActivityMonitorAutogrowEventsEnabled,		
		[ActivityMonitorBlockedProcessThreshold] = @ActivityMonitorBlockedProcessThreshold,
		[GrowthStatisticsStartTime] = @GrowthStatisticsStartTime,
		[ReorgStatisticsStartTime] = @ReorgStatisticsStartTime,
		[GrowthStatisticsDays] = @GrowthStatisticsDays,
		[ReorgStatisticsDays] = @ReorgStatisticsDays,
		[TableStatisticsExcludedDatabases] = @TableStatisticsExcludedDatabases,
		[EncryptData] = @EncryptData,
		[TrustServerCert] = @TrustServerCert,
		[ReorgMinTableSizeKB] = @ReorgMinTableSizeKB,
		[DisableReplicationMonitoring] = @DisableReplicationMonitoring,
		[MaintenanceModeType] = @MaintenanceModeType,
		[MaintenanceModeStart] = @MaintenanceModeStart,
		[MaintenanceModeStop] = @MaintenanceModeStop,
		[MaintenanceModeDurationSeconds] = @MaintenanceModeDurationSeconds,
		[MaintenanceModeDays] = @MaintenanceModeDays,
		[QueryMonitorAdvancedConfiguration] = @QueryMonitorAdvancedConfiguration,
		[DisableExtendedHistoryCollection] = @DisableExtendedHistoryCollection,
		[MaintenanceModeRecurringStart] = @MaintenanceModeRecurringStart,
		[DisableOleAutomation] = @DisableOleAutomation,
		[DiskCollectionSettings] = @DiskCollectionSettings,
		[QueryMonitorStopTimeUTC] = @QueryMonitorStopTimeUTC,
		[InputBufferLimiter] = @InputBufferLimiter,
		[InputBufferLimited] = @InputBufferLimited,
		[PreferredClusterNode] = @PreferredClusterNode,
		[ActiveWaitCollectorStartTimeRelative] = @ActiveWaitCollectorStartTimeRelative,
		[ActiveWaitCollectorRunTimeSeconds] = @ActiveWaitCollectorRunTimeSeconds,
		[ActiveWaitCollectorCollectionTimeSeconds] = @ActiveWaitCollectorCollectionTimeSeconds,
		[ActiveWaitCollectorEnabled] = @ActiveWaitCollectorEnabled,
		[ActiveWaitLoopTimeMilliseconds] = @ActiveWaitLoopTimeMilliseconds,
		[ActiveWaitAdvancedConfiguration] = @ActiveWaitAdvancedConfiguration,
		[ServerPingInterval] = @ServerPingInterval,
		[VHostID] = @VHostID,
		[VmUID] = @VmUID,
		[VmName] = @VmName,
		[VmDomainName] = @VmDomainName,
		[AlertRefreshInMinutes]  = @AlertRefreshInMinutes,
		[DatabaseStatisticsRefreshIntervalInSeconds] = @DatabaseStatisticsRefreshIntervalInSeconds,
		[ActiveWaitXEEnable] = @ActiveWaitXEEnable,
		[ActiveWaitXEFileSizeMB] = @ActiveWaitXEFileSizeMB,
		[ActiveWaitXEFilesRollover] = @ActiveWaitXEFilesRollover,
		[ActiveWaitXERecordsPerRefresh] = @ActiveWaitXERecordsPerRefresh,
		[ActiveWaitXEMaxMemoryMB] = @ActiveWaitXEMaxMemoryMB,
		[ActiveWaitXEEventRetentionMode] = @ActiveWaitXEEventRetentionMode,
		[ActiveWaitXEMaxDispatchLatencySecs] = @ActiveWaitXEMaxDispatchLatencySecs,
		[ActiveWaitXEMaxEventSizeMB] = @ActiveWaitXEMaxEventSizeMB,
		[ActiveWaitXEMemoryPartitionMode] = @ActiveWaitXEMemoryPartitionMode,
		[ActiveWaitXETrackCausality] = @ActiveWaitXETrackCausality,
		[ActiveWaitXEStartupState] = @ActiveWaitXEStartupState,
		[ActiveWaitsXEFileName] = @ActiveWaitsXEFileName,
		[WmiCollectionEnabled] = @WmiCollectionEnabled,
		[WmiConnectAsService] = @WmiConnectAsService,
		[WmiUserName] = @WmiUserName,

		[WmiPassword] = @WmiPassword,
		
		[MaintenanceModeMonth] = @MaintenanceModeMonth,

		[MaintenanceModeSpecificDay] = @MaintenanceModeSpecificDay,

		[MaintenanceModeWeekOrdinal] = @MaintenanceModeWeekOrdinal,

		[MaintenanceModeWeekDay] = @MaintenanceModeWeekDay,

		[MaintenanceModeMonthDuration] = @MaintenanceModeMonthDuration,

		[MaintenanceModeMonthRecurringStart] = @MaintenanceModeMonthRecurringStart,
		--SQLdm 9.0 (Ankit Srivastava): Query Monitoring with Extended Event Session -- Setting the values of newly addded Query Monitor columns
		[QueryMonitorTraceMonitoringEnabled] =@QueryMonitorTraceMonitoringEnabled, 
		[QueryMonitorCollectQueryPlan] =@QueryMonitorCollectQueryPlan,
		--START SQLdm 9.1 (Ankit Srivastava): Activity Monitor with Extended Events  -- Added new columns and values 
		[QueryMonitorCollectEstimatedQueryPlan] = @QueryMonitorCollectEstimatedQueryPlan,--SQLdm 10.0 (Tarun Sapra) - Sets the flag for getting estimated query plan
			[ActivityMonitorTraceMonitoringEnabled]=@ActivityMonitorTraceMonitoringEnabled,
			[ActivityMonitorXEFileSizeMB]=@ActivityMonitorXEFileSizeMB,
			[ActivityMonitorXEFilesRollover]=@ActivityMonitorXEFilesRollover,
			[ActivityMonitorXERecordsPerRefresh]=@ActivityMonitorXERecordsPerRefresh,
			[ActivityMonitorXEMaxMemoryMB]=@ActivityMonitorXEMaxMemoryMB,
			[ActivityMonitorXEEventRetentionMode]=@ActivityMonitorXEEventRetentionMode,
			[ActivityMonitorXEMaxDispatchLatencySecs]=@ActivityMonitorXEEventRetentionMode,
			[ActivityMonitorXEMaxEventSizeMB]=@ActivityMonitorXEMaxEventSizeMB,
			[ActivityMonitorXEMemoryPartitionMode]=@ActivityMonitorXEMemoryPartitionMode,
			[ActivityMonitorXETrackCausality]=@ActivityMonitorXETrackCausality,
			[ActivityMonitorXEStartupState]=@ActivityMonitorXEStartupState,
			[ActivityMonitorXEFileName]=@ActivityMonitorXEFileName,
	--END SQLdm 9.1 (Ankit Srivastava): Activity Monitor with Extended Events  -- Added new columns and values 
	--START SQLdm 9.1 (Ankit Srivastava): Query Monitor 9.0 Improvement feedback - adding new column values for uery monitoring extended event session configuration
			[QueryMonitorXEFileSizeMB] =@QueryMonitorXEFileSizeMB,
			[QueryMonitorXEFilesRollover]=@QueryMonitorXEFilesRollover
	--END SQLdm 9.1 (Ankit Srivastava): Query Monitor 9.0 Improvement feedback - adding new column values for uery monitoring extended event session configuration

	WHERE [SQLServerID] = @SqlServerId 		

	SELECT @error = @@error, @rowcount = @@rowcount
	
	-- insert latest template for this server	
	exec p_AddBaselineTemplate @SqlServerId,@BaselineTemplate
	exec p_UpsertBaselineTemplate @SqlServerId,@baselineConfigList
	IF @error != 0 GOTO HANDLE_ERROR

	-- START 10.0 (srishti purohit) : To handle analysis configuration
	exec p_SaveAnalysisConfiguration @SqlServerId,@productionServer,@OLTP,
	@analysisStartTime ,
	@duration ,@scheduledDays ,@isActive ,
	@includeDatabase ,
	@filterApplication ,
	@categoryID ,
	@databaseID ,
	@recommendationID,
	@schedulingStatus --SQLDM10.0 (praveen suhalka) : scheduling status

	IF @error != 0 --GOTO HANDLE_ERROR
	BEGIN
	RAISERROR('An error occurred while updating instance ANALYSIS %d.', 10, 1, @SqlServerId)
        RETURN(@error)
		END

	-- END 10.0 (srishti purohit) : To handle analysis configuration

	IF @rowcount = 1 BEGIN
		SELECT 
			[SQLServerID], 
			[RegisteredDate],
			[OutOfProcOleAutomation]
		FROM [dbo].[MonitoredSQLServers]
		WHERE [SQLServerID] = @SqlServerId
	END
        
	RETURN(0)

	HANDLE_ERROR:
		RAISERROR('An error occurred while updating instance %d.', 10, 1, @SqlServerId)
        RETURN(@error)
END
 

GO

 
GO 

---------- P_UPDATENOTIFICATIONPROVIDER.SQL
if (object_id('p_UpdateNotificationProvider') is not null)
begin
drop procedure [p_UpdateNotificationProvider]
end
go

create procedure [p_UpdateNotificationProvider] 
	@ProviderID uniqueidentifier,
	@SerializedType nvarchar(64),
	@SerializedObject nvarchar(max)
as
begin
	DECLARE @err int
	
	UPDATE [NotificationProviders] 
		SET [SerializedType] = @SerializedType,
			[SerializedObject] = @SerializedObject
		WHERE [ProviderId] = @ProviderID 

	SELECT @err = @@error
	RETURN @err
end
 
GO 

---------- P_UPDATENOTIFICATIONRULE.SQL
if (object_id('p_UpdateNotificationRule') is not null)
begin
drop procedure [p_UpdateNotificationRule]
end
go

create procedure [p_UpdateNotificationRule] 
	@RuleID uniqueidentifier,
	@SerializedObject nvarchar(max)
as
begin
	DECLARE @err int
	DECLARE @id uniqueidentifier
	
	UPDATE [NotificationRules] SET [SerializedObject] = @SerializedObject
		WHERE [RuleID] = @RuleID 

	SELECT @err = @@error

	RETURN @err
end
 
GO 

---------- P_UPDATEPERMISSION.SQL
if (object_id('p_UpdatePermission') is not null)
begin
drop procedure [p_UpdatePermission]
end
go

create procedure [p_UpdatePermission]
	@PermissionID int,
	@Permission int,
	@Enabled bit,
	@TagsXML nvarchar(max),
	@ServerXML nvarchar(max),
	@Comment nvarchar(1024),
	@WebAppPermission bit-- SQLdm 8.5 <Ankit Srivastava> added new columns
as
begin
	DECLARE @err int
	DECLARE @permissionExists int
	declare @xmlDoc int
	
	-- check if permission exists
	select @permissionExists = count(PermissionID) 
	from [dbo].[Permission] 
	where PermissionID = @PermissionID
	
	-- update if permission exists.
	if (@permissionExists != 0)
	begin
		-- update Permission table
		update [dbo].[Permission]
		set Permission = @Permission, Enabled = @Enabled, Comment = @Comment , WebAppPermission=@WebAppPermission
		where PermissionID = @PermissionID

		-- Add tags to permission
		exec p_UpdatePermissionTags @PermissionID, @TagsXML

		-- delete servers from PermissionServers table for input PermissionID.
		delete from [dbo].[PermissionServers] where PermissionID = @PermissionID

		-- re-add servers to PermissionServers table
		exec sp_xml_preparedocument @xmlDoc output, @ServerXML

		insert into [dbo].[PermissionServers] (PermissionID, SQLServerID)
		select @PermissionID, SQLServerID
			from openxml(@xmlDoc, '//Server', 1) with (SQLServerID int) 

		exec sp_xml_removedocument @xmlDoc
	end
	
	SELECT @err = @@error
	RETURN @err
end
 
GO 

---------- P_UPDATEPERMISSIONSTATUS.SQL
if (object_id('p_UpdatePermissionStatus') is not null)
begin
drop procedure [p_UpdatePermissionStatus]
end
go

create procedure [p_UpdatePermissionStatus]
	@PermissionID int,
	@Enabled bit
as
begin
	DECLARE @err int
	
	-- update Permission table
	update [dbo].[Permission]
	set Enabled = @Enabled
	where PermissionID = @PermissionID
	
	SELECT @err = @@error
	RETURN @err
end
 
GO 

---------- P_UPDATEPERMISSIONTAGS.SQL
IF (object_id('p_UpdatePermissionTags') IS NOT NULL)
BEGIN
DROP PROCEDURE p_UpdatePermissionTags
END
GO

CREATE PROCEDURE [dbo].[p_UpdatePermissionTags]
(
	@PermissionId INT,
	@Tags nvarchar(max),
	@Synchronize BIT = 1
)
AS
BEGIN
	DECLARE @error INT
	DECLARE @xmlDoc INT

	IF (@Tags IS NOT NULL)
	BEGIN
		DECLARE @TagIds TABLE(TagId INT)

		EXEC sp_xml_preparedocument @xmlDoc OUTPUT, @Tags
		INSERT INTO @TagIds	
			SELECT TagId
				FROM OPENXML(@xmlDoc, '//Tag', 1) WITH (TagId INT)
		EXEC sp_xml_removedocument @xmlDoc

		IF (@Synchronize = 1)
		BEGIN
			DELETE FROM PermissionTags 
			WHERE 
				PermissionId = @PermissionId AND
				TagId NOT IN (SELECT TagId FROM @TagIds)
		END

		DELETE FROM @TagIds
		WHERE TagId IN (SELECT TagId FROM PermissionTags WHERE PermissionId = @PermissionId)

		INSERT INTO PermissionTags
			SELECT @PermissionId, TagId FROM @TagIds
	END
	ELSE
	BEGIN
		DELETE FROM PermissionTags WHERE PermissionId = @PermissionId	
	END

	SELECT TagId FROM PermissionTags WHERE PermissionId = @PermissionId

	SELECT @error = @@error
	RETURN @error
END
 
GO 

---------- P_UPDATERECOMMENDATIONFLAGSTATUS.SQL
if (object_id('p_UpdateRecommendationFlagStatus') is not null)
begin
drop procedure [p_UpdateRecommendationFlagStatus]
end
go

create procedure [p_UpdateRecommendationFlagStatus] 
@analysisRecommendationID INT,
@flag BIT,
@isFlagChanged BIT OUT
AS
begin

--For excepttion handling
DECLARE
  @ErrorMessage   varchar(2000)
 ,@ErrorSeverity  tinyint
 ,@ErrorState     tinyint

SET @isFlagChanged =0

UPDATE [dbo].[PrescriptiveAnalysisRecommendation]
   SET [IsFlagged] = @flag
 WHERE [ID] = @analysisRecommendationID

SET @isFlagChanged = 1

IF(@@ERROR <> 0)
BEGIN
SET @isFlagChanged = 0
 Print 'Transaction Failed .'
			SET @ErrorMessage  = ERROR_MESSAGE()
			SET @ErrorSeverity = ERROR_SEVERITY()
			SET @ErrorState    = ERROR_STATE()
			RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState)
			
END

end
 
GO 
 
GO 

---------- P_UPDATERECOMMENDATIONOPTIMIZATIONSTATUS.SQL
if (object_id('p_UpdateRecommendationOptimizationStatus') is not null)
begin
drop procedure [p_UpdateRecommendationOptimizationStatus]
end
go

create procedure [p_UpdateRecommendationOptimizationStatus] 
@analysisRecommendationID INT,
@status int,
@errorMessageText nvarchar(max),
@isStatusChanged BIT OUT
AS
begin

--For excepttion handling
DECLARE
  @ErrorMessage   varchar(2000)
 ,@ErrorSeverity  tinyint
 ,@ErrorState     tinyint


SET @isStatusChanged =0

UPDATE [dbo].[PrescriptiveAnalysisRecommendation]
   SET [OptimizationStatusID] = @status,
	[OptimizationErrorMessage] = @errorMessageText
 WHERE [ID] = @analysisRecommendationID

SET @isStatusChanged = 1
IF(@@ERROR <> 0)
BEGIN
SET @isStatusChanged = 0
 Print 'Transaction Failed .'
  SET @ErrorMessage  = ERROR_MESSAGE()
			SET @ErrorSeverity = ERROR_SEVERITY()
			SET @ErrorState    = ERROR_STATE()
			RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState)
			
END

end
 
GO 
 
GO 

---------- P_UPDATEREPLICATIONTOPOLOGY.SQL
if (object_id('p_UpdateReplicationTopologySubscriber') is not null)
begin
drop procedure p_UpdateReplicationTopologySubscriber
end
go

create PROCEDURE [dbo].[p_UpdateReplicationTopologySubscriber]
	-- Add the parameters for the stored procedure here
	@PublisherInstance nvarchar(128),
	@PublisherDB nvarchar(128),
	@SubscriberInstance nvarchar(128) = null,
	@SubscriberDB nvarchar(128) = null,
	@LastSnapshotDateTime datetime = null,
	@ReplicationType int = null,
	@SubscriptionType int = null,
	@LastSubscriberUpdate datetime = null,
	@LastSyncStatus tinyint = null,
	@LastSyncSummary nvarchar(128) = null,
	@LastSyncTime datetime = null,
	@Publication nvarchar(128) = null
	as
BEGIN
	exec p_UpdateReplicationTopology 
	1,--subscriber
	@PublisherInstance, 
	@PublisherDB,
	null,
	null,
	@SubscriberInstance, 
	@SubscriberDB,
	@LastSnapshotDateTime,
	null,
	null,
	null,
	null,
	null,
	@ReplicationType,
	@SubscriptionType,
	@LastSubscriberUpdate,
	@LastSyncStatus,
	@LastSyncSummary,
	@LastSyncTime,
	null,
	@Publication,
	null,
	null
END
go

if (object_id('p_UpdateReplicationTopologyDistributor') is not null)
begin
drop procedure p_UpdateReplicationTopologyDistributor
end
go

create PROCEDURE [dbo].[p_UpdateReplicationTopologyDistributor]
	-- Add the parameters for the stored procedure here
	@PublisherInstance nvarchar(128),
	@PublisherDB nvarchar(128),
	@DistributorInstance nvarchar(128) = null,
	@DistributorDB nvarchar(128) = null,
	@SubscriberInstance nvarchar(128) = null,
	@SubscriberDB nvarchar(128) = null,
	@LastSnapshotDateTime datetime = null,
	@SubscribedTransactions int = null,
	@NonSubscribedTransactions int = null,
	@MaxSubscriptionLatency int = null,
	@Publication nvarchar(128) = null,
	@PublicationDescription nvarchar(155) = null,
	@Articles int = 0,
	@ReplicationType tinyint = 0
	as
BEGIN
	exec p_UpdateReplicationTopology 
	2,--distributor
	@PublisherInstance, 
	@PublisherDB,
	@DistributorInstance,
	@DistributorDB,
	@SubscriberInstance, 
	@SubscriberDB,
	@LastSnapshotDateTime,
	@SubscribedTransactions,
	@NonSubscribedTransactions,
	null,
	null,
	@MaxSubscriptionLatency,
	@ReplicationType,
	null,
	null,
	null,
	null,
	null,
	null,
	@Publication,
	@PublicationDescription,
	@Articles	
END
go

if (object_id('p_UpdateReplicationTopology') is not null)
begin
drop procedure p_UpdateReplicationTopology
end
go

create PROCEDURE [dbo].[p_UpdateReplicationTopology]
	-- Add the parameters for the stored procedure here
	@Role int,
	@PublisherInstance nvarchar(128),
	@PublisherDB nvarchar(128),
	@DistributorInstance nvarchar(128) = null,
	@DistributorDB nvarchar(128) = null,
	@SubscriberInstance nvarchar(128) = null,
	@SubscriberDB nvarchar(128) = null,
	@LastSnapshotDateTime datetime = null,
	@SubscribedTransactions int = null,
	@NonSubscribedTransactions int = null,
	@NonDistributedTransactions int = null,
	@ReplicationLatency float = null,
	@MaxSubscriptionLatency int = null,
	@ReplicationType tinyint = null,
	@SubscriptionType tinyint = null,
	@LastSubscriberUpdate datetime = null,
	@LastSyncStatus tinyint = null,
	@LastSyncSummary nvarchar(128) = null,
	@LastSyncTime datetime = null,
	@SubscriptionStatus tinyint = null,
	@Publication nvarchar(128) = null,
	@PublicationDescription nvarchar(255) = null,
	@ArticleCount int = null
	as
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	declare @PublisherDatabaseID int,
			@SubscriberDatabaseID int,
			@DistributorDatabaseID int,
			@InnerReturnMessage nvarchar(128),
			@LookupServerID int

	if @PublisherInstance is not null
	begin
		select @LookupServerID = null
		select @LookupServerID = SQLServerID
		 from MonitoredSQLServers (nolock) where lower(InstanceName) =  lower(dbo.fn_GetServerName(@PublisherInstance))
		
		if @LookupServerID is not null and @PublisherDB is not null and @PublisherDB != ''
  		execute [p_InsertDatabaseName] 
		   @LookupServerID
		  ,@PublisherDB
		  ,0
		  ,null
		  ,@PublisherDatabaseID output
		  ,@InnerReturnMessage output
	end

	if @SubscriberInstance is not null
	begin
		select @LookupServerID = null		
		select @LookupServerID = SQLServerID
		 from MonitoredSQLServers (nolock) where lower(InstanceName) =  lower(dbo.fn_GetServerName(@SubscriberInstance))

		if @LookupServerID is not null and @SubscriberDB is not null and @SubscriberDB != ''
		execute [p_InsertDatabaseName] 
		   @LookupServerID
		  ,@SubscriberDB
		  ,0
		  ,null
		  ,@SubscriberDatabaseID output
		  ,@InnerReturnMessage output
	end

	if @DistributorInstance is not null
	begin
		select @LookupServerID = null
		select @LookupServerID = SQLServerID
		 from MonitoredSQLServers (nolock) 
		where lower(InstanceName) = lower(dbo.fn_GetServerName(@DistributorInstance)) 


		if @LookupServerID is not null and @DistributorDB is not null and @DistributorDB != ''
		execute [p_InsertDatabaseName] 
		   @LookupServerID
		  ,@DistributorDB
		  ,0
		  ,null
		  ,@DistributorDatabaseID output
		  ,@InnerReturnMessage output
	end

if not exists (select PublisherInstance from ReplicationTopology with (tablockx)
where PublisherInstance = @PublisherInstance 
	and PublisherDB = @PublisherDB
	and Publication = @Publication
	and SubscriberInstance = @SubscriberInstance
	and SubscriberDB = @SubscriberDB)
begin
INSERT INTO [ReplicationTopology]
           (PublisherInstance,
			PublisherDB,
			PublisherDBID,
			DistributorInstance,
			DistributorDB,
			DistributorDBID,
			SubscriberInstance,
			SubscriberDB,
			SubscriberDBID,
			LastPublisherSnapshotDateTime,
			SubscribedTransactions,
			NonSubscribedTransactions,
			NonDistributedTransactions,
			ReplicationLatency,
			MaxSubscriptionLatency,
			ReplicationType,
			SubscriptionType,
			LastSubscriberUpdate,
			LastSyncStatus,
			LastSyncSummary,
			LastSyncTime,
			SubscriptionStatus,
			Publication,
			PublicationDescription,
			ArticleCount)
     VALUES
           (@PublisherInstance,
			@PublisherDB,
			@PublisherDatabaseID,
			@DistributorInstance,
			@DistributorDB,
			@DistributorDatabaseID,
			@SubscriberInstance,
			@SubscriberDB,
			@SubscriberDatabaseID,
			@LastSnapshotDateTime,
			@SubscribedTransactions,
			@NonSubscribedTransactions,
			@NonDistributedTransactions,
			@ReplicationLatency,
			@MaxSubscriptionLatency,
			@ReplicationType,
			@SubscriptionType,
			@LastSubscriberUpdate,
			@LastSyncStatus,
			@LastSyncSummary,
			@LastSyncTime,
			@SubscriptionStatus,
			@Publication,
			@PublicationDescription,
			@ArticleCount)

	--if we have just added a record with a valid subscriber
	--check if there is an old orphaned publication
	if (@SubscriberInstance is not null and @SubscriberInstance <> '')
		and (@SubscriberDB is not null and @SubscriberDB <> '')
		and exists (select PublisherInstance from ReplicationTopology with (tablockx)
			where PublisherInstance = @PublisherInstance 
				and PublisherDB = @PublisherDB
				and Publication = @Publication
				and (SubscriberInstance is null or SubscriberInstance = '')
				and (SubscriberDB is null or SubscriberDB = ''))
	begin
		Delete from ReplicationTopology with (tablockx)
		where PublisherInstance = @PublisherInstance 
					and PublisherDB = @PublisherDB
					and Publication = @Publication
					and (SubscriberInstance is null or SubscriberInstance = '')
					and (SubscriberDB is null or SubscriberDB = '')
	end	

end
else
begin
	if @Role = 0 --publisher
	begin
		update [ReplicationTopology] with (tablockx)
           set PublisherDBID = @PublisherDatabaseID,
			DistributorInstance = @DistributorInstance,
			DistributorDB = @DistributorDB,
			DistributorDBID = @DistributorDatabaseID,
			SubscriberInstance = @SubscriberInstance,
			SubscriberDB = @SubscriberDB,
			SubscriberDBID = @SubscriberDatabaseID,
			LastPublisherSnapshotDateTime = @LastSnapshotDateTime,
			SubscribedTransactions = @SubscribedTransactions,
			NonSubscribedTransactions = @NonSubscribedTransactions,
			NonDistributedTransactions = @NonDistributedTransactions,
			ReplicationLatency = @ReplicationLatency,
			MaxSubscriptionLatency = @MaxSubscriptionLatency,
			ArticleCount = @ArticleCount,
			SubscriptionStatus = @SubscriptionStatus
			where PublisherInstance = @PublisherInstance 
			and PublisherDB = @PublisherDB 
			and SubscriberInstance = @SubscriberInstance
			and SubscriberDB = @SubscriberDB
			and Publication = @Publication
	end
	else if @Role = 1 -- subscriber
	begin
	update [ReplicationTopology] with (tablockx)
           set LastSubscriberSnapshotDateTime = @LastSnapshotDateTime,
			ReplicationType = @ReplicationType,
			SubscriptionType = @SubscriptionType,
			LastSubscriberUpdate = @LastSubscriberUpdate,
			LastSyncStatus = @LastSyncStatus,
			LastSyncSummary = @LastSyncSummary,
			LastSyncTime = @LastSyncTime,
			Publication = @Publication
			where PublisherInstance = @PublisherInstance 
			and PublisherDB = @PublisherDB
			and SubscriberInstance = @SubscriberInstance
			and SubscriberDB = @SubscriberDB
			and Publication = @Publication
	end
	else if @Role = 2 --distributor
	begin
		update [ReplicationTopology] with (tablockx)
           set 
            PublisherDBID = @PublisherDatabaseID,
			DistributorInstance = @DistributorInstance,
			DistributorDB = @DistributorDB,
			DistributorDBID = @DistributorDatabaseID,
			SubscriberInstance = @SubscriberInstance,
			SubscriberDB = @SubscriberDB,
			SubscriberDBID = @SubscriberDatabaseID,
			LastDistributorSnapshotDateTime = @LastSnapshotDateTime,
			SubscribedTransactions = @SubscribedTransactions,
			NonSubscribedTransactions = @NonSubscribedTransactions,
			MaxSubscriptionLatency = @MaxSubscriptionLatency,
		    Publication = @Publication,
			PublicationDescription = @PublicationDescription,
			ArticleCount = case @ReplicationType when 2 then ArticleCount else isnull(@ArticleCount, ArticleCount) end,
			ReplicationType = @ReplicationType
			where PublisherInstance = @PublisherInstance 
			and PublisherDB = @PublisherDB
			and SubscriberInstance = @SubscriberInstance
			and SubscriberDB = @SubscriberDB
			and Publication = @Publication
	end
end			
END
 
GO 

---------- P_UPDATERUNQUERYSCRIPT.SQL
if (object_id('p_UpdateRunQueryScript') is not null)
begin
drop procedure [p_UpdateRunQueryScript]
end
go

create procedure [p_UpdateRunQueryScript]
	@ScriptID INT,
	@Name NVARCHAR(100),
	@ScriptText nvarchar(max)
as
begin
	UPDATE RunQueryScripts
	SET
		Name = @Name,
		ScriptText = @ScriptText
	WHERE
		ScriptID = @ScriptID
end
 
GO 

---------- P_UPDATESERVERTAGS.SQL
IF (object_id('p_UpdateServerTags') IS NOT NULL)
BEGIN
DROP PROCEDURE p_UpdateServerTags
END
GO

CREATE PROCEDURE [dbo].[p_UpdateServerTags]
(
	@SQLServerID INT,
	@Tags nvarchar(max),
	@Synchronize BIT = 1
)
AS
BEGIN
	DECLARE @error INT
	DECLARE @xmlDoc INT

	IF (@Tags IS NOT NULL)
	BEGIN
		DECLARE @TagIds TABLE(TagId INT)

		EXEC sp_xml_preparedocument @xmlDoc OUTPUT, @Tags
		INSERT INTO @TagIds	
			SELECT TagId
				FROM OPENXML(@xmlDoc, '//Tag', 1) WITH (TagId INT)
		EXEC sp_xml_removedocument @xmlDoc

		IF (@Synchronize = 1)
		BEGIN
			DELETE FROM ServerTags 
			WHERE 
				SQLServerId = @SQLServerID AND
				TagId NOT IN (SELECT TagId FROM @TagIds)
		END

		DELETE FROM @TagIds
		WHERE TagId IN (SELECT TagId FROM ServerTags WHERE SQLServerId = @SQLServerID)

		INSERT INTO ServerTags
			SELECT @SQLServerID, TagId FROM @TagIds
	END
	ELSE
	BEGIN
		DELETE FROM ServerTags WHERE SQLServerId = @SQLServerID	
	END

	SELECT TagId FROM ServerTags WHERE SQLServerId = @SQLServerID

	SELECT @error = @@error
	RETURN @error
END
 
GO 

---------- P_UPDATESERVERVERSION.SQL
if (object_id('p_UpdateServerVersion') is not null)
begin
drop procedure p_UpdateServerVersion
end
go
create procedure p_UpdateServerVersion
@SQLServerID int,
@ServerVersion nvarchar(30),
@ServerEdition nvarchar(30)
as 
begin

	update [MonitoredSQLServers] 
	set [ServerVersion] = @ServerVersion,
		[ServerEdition] = @ServerEdition
	where [SQLServerID] = @SQLServerID

end
 
GO 

---------- P_UPDATESQLSAFELASTBACKUPACTIONID.SQL

IF (object_id('p_UpdateSQLsafeLastBackupActionId') IS NOT NULL)
BEGIN
DROP PROCEDURE p_UpdateSQLsafeLastBackupActionId
END
GO

CREATE PROCEDURE [dbo].[p_UpdateSQLsafeLastBackupActionId]
(
	@Id	INT,
	@ActionId INT
)
AS
BEGIN
	if exists (select [LastBackupActionId] from MonitoredServerSQLsafeInstance where SQLServerID = @Id)
	BEGIN
		update MonitoredServerSQLsafeInstance set LastBackupActionId = @ActionId where SQLServerID = @Id
	END
END
 
GO 

---------- P_UPDATESQLSAFELASTDEFRAGACTIONID.SQL

IF (object_id('p_UpdateSQLsafeLastDefragActionId') IS NOT NULL)
BEGIN
DROP PROCEDURE p_UpdateSQLsafeLastDefragActionId
END
GO

CREATE PROCEDURE [dbo].[p_UpdateSQLsafeLastDefragActionId]
(
	@Id	INT,
	@ActionId INT
)
AS
BEGIN
	if exists (select [LastDefragActionId] from MonitoredServerSQLsafeInstance where SQLServerID = @Id)
	BEGIN
		update MonitoredServerSQLsafeInstance set LastDefragActionId = @ActionId where SQLServerID = @Id
	END
END
 
GO 

---------- P_UPDATESQLSAFEREPOSITORY.SQL

IF (object_id('p_UpdateSQLsafeRepository') IS NOT NULL)
BEGIN
DROP PROCEDURE p_UpdateSQLsafeRepository
END
GO

CREATE PROCEDURE [dbo].[p_UpdateSQLsafeRepository]
(
	@Id INT,
	@DatabaseName nvarchar(128),
	@SecurityMode bit,
	@UserName nvarchar(128),
	@EncryptedPassword nvarchar(128),
	@FriendlyName nvarchar(256)
)
AS
BEGIN
	IF EXISTS(SELECT RepositoryId from SQLsafeConnections where RepositoryId = @Id)
	BEGIN
		update SQLsafeConnections set DatabaseName = @DatabaseName, FriendlyName = @FriendlyName, SecurityMode = @SecurityMode, UserName = @UserName, EncryptedPassword = @EncryptedPassword
			where RepositoryId = @Id
	END
END
 
GO 

---------- P_UPDATESTATISTICSRUNTIME.SQL
if (object_id('p_UpdateStatisticsRunTime') is not null)
begin
drop procedure p_UpdateStatisticsRunTime
end
go
create procedure p_UpdateStatisticsRunTime
@SQLServerID int,
@LastGrowthStatisticsRunTime datetime = null,
@LastGrowthStatisticsRunTimeUTC datetime = null,
@LastReorgStatisticsRunTime datetime = null,
@LastReorgStatisticsRunTimeUTC datetime = null
as 
begin

	update MonitoredSQLServers 
	set 
		[LastGrowthStatisticsRunTime] = isnull(@LastGrowthStatisticsRunTime,[LastGrowthStatisticsRunTime]) ,
		[LastGrowthStatisticsRunTimeUTC] = isnull(@LastGrowthStatisticsRunTimeUTC,[LastGrowthStatisticsRunTimeUTC]) ,
		[LastReorgStatisticsRunTime] = isnull(@LastReorgStatisticsRunTime,[LastReorgStatisticsRunTime]) ,
		[LastReorgStatisticsRunTimeUTC] = isnull(@LastReorgStatisticsRunTimeUTC,[LastReorgStatisticsRunTimeUTC])
	where [SQLServerID] = @SQLServerID

end
 
GO 

---------- P_UPDATETAG.SQL
IF (object_id('p_UpdateTag') IS NOT NULL)
BEGIN
DROP PROCEDURE p_UpdateTag
END
GO

CREATE PROCEDURE [dbo].[p_UpdateTag]
(
	@Id	INT,
	@NewName NVARCHAR(50)
)
AS
BEGIN
	IF NOT EXISTS 
	(
		SELECT [Id] 
		FROM [Tags]
		WHERE 
			[Id] <> @Id AND
			LOWER([Name]) = LOWER(@NewName)
	)
	BEGIN
		UPDATE [Tags] SET	
			[Name] = @NewName
		WHERE [Id] = @Id
	END
END
 
GO 

---------- P_UPDATETAGCONFIGURATION.SQL
IF (object_id('p_UpdateTagConfiguration') IS NOT NULL)
BEGIN
DROP PROCEDURE p_UpdateTagConfiguration
END
GO

CREATE PROCEDURE [dbo].[p_UpdateTagConfiguration]
(
	@TagId INT OUTPUT,
	@NewTagName NVARCHAR(50) = NULL,
	@LinkedServers nvarchar(max) = NULL,
	@LinkedCustomCounters nvarchar(max) = NULL,
	@LinkedPermissions nvarchar(max) = NULL,
	@Synchronize bit = 1
)
AS
BEGIN
	DECLARE @err INT
	DECLARE @xmlDoc INT
	
	IF (@TagId = -1)
		EXEC p_AddTag @NewTagName, @TagId OUTPUT	
	ELSE
		IF (@NewTagName IS NOT NULL)
			EXEC p_UpdateTag @TagId, @NewTagName

	IF (@LinkedServers IS NOT NULL)
	BEGIN
		DECLARE @ServerIds TABLE(ServerId INT) 

		EXEC sp_xml_preparedocument @xmlDoc OUTPUT, @LinkedServers

		INSERT INTO @ServerIds	
			SELECT ServerId
				FROM OPENXML(@xmlDoc, '//Server', 1) WITH (ServerId INT)

		EXEC sp_xml_removedocument @xmlDoc

		IF (@Synchronize = 1) 
		BEGIN
			DELETE FROM ServerTags 
			WHERE 
				TagId = @TagId and
				SQLServerId NOT IN (SELECT ServerId FROM @ServerIds)
		END

		DELETE FROM @ServerIds 
		WHERE ServerId IN (SELECT SQLServerId FROM ServerTags WHERE TagId = @TagId)

		INSERT INTO ServerTags
		SELECT ServerId, @TagId FROM @ServerIds
	END

	IF (@LinkedCustomCounters IS NOT NULL)
	BEGIN
		DECLARE @CustomCounterIds TABLE(CustomCounterId INT) 

		EXEC sp_xml_preparedocument @xmlDoc OUTPUT, @LinkedCustomCounters

		INSERT INTO @CustomCounterIds	
			SELECT CustomCounterId
				FROM OPENXML(@xmlDoc, '//CustomCounter', 1) WITH (CustomCounterId INT)

		EXEC sp_xml_removedocument @xmlDoc

		IF (@Synchronize = 1) 
		BEGIN
			DELETE FROM CustomCounterTags 
			WHERE 
				TagId = @TagId and
				Metric NOT IN (SELECT CustomCounterId FROM @CustomCounterIds)
		END

		DELETE FROM @CustomCounterIds 
		WHERE CustomCounterId IN (SELECT Metric FROM CustomCounterTags WHERE TagId = @TagId)

		INSERT INTO CustomCounterTags
		SELECT CustomCounterId, @TagId FROM @CustomCounterIds
	END

	IF (@LinkedPermissions IS NOT NULL)
	BEGIN
		DECLARE @PermissionIds TABLE(PermissionId INT) 

		EXEC sp_xml_preparedocument @xmlDoc OUTPUT, @LinkedPermissions

		INSERT INTO @PermissionIds	
			SELECT PermissionId
				FROM OPENXML(@xmlDoc, '//Permission', 1) WITH (PermissionId INT)

		EXEC sp_xml_removedocument @xmlDoc

		IF (@Synchronize = 1) 
		BEGIN
			DELETE FROM PermissionTags 
			WHERE 
				TagId = @TagId and
				PermissionId NOT IN (SELECT PermissionId FROM @PermissionIds)
		END

		DELETE FROM @PermissionIds 
		WHERE PermissionId IN (SELECT PermissionId FROM PermissionTags WHERE TagId = @TagId)

		INSERT INTO PermissionTags
		SELECT PermissionId, @TagId FROM @PermissionIds
	END

	exec p_SyncCustomCounterThresholds

	SELECT @err = @@error
	RETURN @err
END
 
GO 

---------- P_UPDATETASK.SQL
if (object_id('p_UpdateTask') is not null)
begin
drop procedure [p_UpdateTask]
end
go

create procedure [p_UpdateTask]
	@TaskID int,
	@Status tinyint,
	@Owner nvarchar(256),
	@Comments nvarchar(1024)
as
begin
	DECLARE @err int
	DECLARE @completed datetime

	-- if no create date is specified then set one
	SELECT @completed = null;
	if @Status = 16
		SELECT @completed = GetUTCDate()

	UPDATE Tasks SET
			[Comments] = @Comments,
			[Owner] = @Owner,
			[Status] = @Status,
			[CompletedOn] = @completed
		WHERE [TaskID] = @TaskID

	SELECT @err = @@error
	
	RETURN @err
end
 
GO 

---------- P_UPDATEWEBAPPPERMISSIONSTATUS.SQL
if (object_id('p_UpdateWebAppPermissionStatus') is not null)
begin
drop procedure [p_UpdateWebAppPermissionStatus]
end

GO
--SQLdm 8.5 <Ankit Srivastava> - created new procedure for updating only the web app access
Create procedure [dbo].[p_UpdateWebAppPermissionStatus]
	@PermissionID int,
	@WebAppPermission bit
as
begin
	DECLARE @err int
	
	-- update Permission table
	update [dbo].[Permission]
	set WebAppPermission = @WebAppPermission
	where PermissionID = @PermissionID
	
	SELECT @err = @@error
	RETURN @err
end
 
 
GO 

---------- P_UPGRADEALERTDATA.SQL
if (object_id('p_UpgradeAlertData') is not null)
begin
drop procedure p_UpgradeAlertData
end
go

create procedure p_UpgradeAlertData
as
begin


	declare @TimeOut datetime,
			@LeftToDo bigint,
			@BeginDate datetime,
			@EndDate datetime
				

	set @TimeOut = DATEADD(ss, 180, GETDATE())
			
	if (select count([Internal_Value]) from [dbo].[RepositoryInfo] where [Name] = 'UpgradedTo7.0') <> 0
	begin

		declare @VersionUpgradeDate datetime
		
		select @VersionUpgradeDate = Character_Value from [dbo].[RepositoryInfo] where [Name] = 'UpgradedTo7.0'

		select @BeginDate = Character_Value from RepositoryInfo where Name = 'AlertsLastDateUpgraded'
		if (@BeginDate is null)
		begin
			set @BeginDate = @VersionUpgradeDate
		end
		
		Select @LeftToDo = Internal_Value from RepositoryInfo where Name = 'AlertsLeftToDo'

		while (GETDATE() < @TimeOut) and (@LeftToDo > 0)
		begin	
			if (object_id('AlertsTempData') is null)
			begin
				create table AlertsTempData (
					AlertID int,
					UTCOccurrenceDateTime datetime,
					Severity tinyint)
			end
			
			truncate table AlertsTempData
			
			insert into AlertsTempData 
				select 
					AlertID, 
					UTCOccurrenceDateTime, 
					Severity*2 
				from 
					[dbo].Alerts 
				where 
					UTCOccurrenceDateTime < @VersionUpgradeDate and
					Severity in (2,4)

			set @EndDate = DATEADD(dd, -1, @BeginDate)

			update 
				Alerts 
					set Alerts.Severity = new.Severity
				from 
					AlertsTempData new
				where 
					new.UTCOccurrenceDateTime <= @BeginDate and
					new.UTCOccurrenceDateTime >= @EndDate and
					Alerts.AlertID = new.AlertID
		
			delete from AlertsTempData where UTCOccurrenceDateTime <= @BeginDate and UTCOccurrenceDateTime >= @EndDate
		
			Select @LeftToDo = Count(AlertID) from AlertsTempData
			
			update RepositoryInfo set Character_Value = @EndDate where Name = 'AlertsLastDateUpgraded'
			update RepositoryInfo set Internal_Value = @LeftToDo where Name = 'AlertsLeftToDo'
			
			Set @BeginDate = @EndDate

		end
		
		if (GETDATE() > @TimeOut)
		begin
			Select 'Time Expired'
			return
		end
		
		if @LeftToDo = 0
		BEGIN
			drop table AlertsTempData
		END
		
		-- SeverActivity
		select @BeginDate = Character_Value from RepositoryInfo where Name = 'SALastDateUpgraded'
		if (@BeginDate is null)
		begin
			set @BeginDate = @VersionUpgradeDate
		end

		Select @LeftToDo = Internal_Value from RepositoryInfo where Name = 'SALeftToDo'
		
		while (GETDATE() < @TimeOut) and (@LeftToDo > 0)
		begin
		
			if (object_id('SATempData') is null)
			begin
				create table SATempData (
					SQLServerID int,
					UTCCollectionDateTime datetime,
					StateOverview xml)
			end
			
			truncate table SATempData
			
			set @EndDate = DATEADD(dd, -1, @BeginDate)
			
			insert into SATempData
				select
						SQLServerID,
						UTCCollectionDateTime,
						CAST(StateOverview as XML)
					from
						ServerActivity
					Where
						UTCCollectionDateTime <= @BeginDate and
						UTCCollectionDateTime >= @EndDate
			
			while exists (select * from SATempData where StateOverview.exist('/Servers/Server//State/@Severity[.="4"]') = 1)
				update SATempData 
					  set StateOverview.modify('replace value of (/Servers/Server//State/@Severity[.="4"])[1] with "8"')

			while exists (select * from SATempData where StateOverview.exist('/Servers/Server//State/@Severity[.="2"]') = 1)
				update SATempData 
					set StateOverview.modify('replace value of (/Servers/Server//State/@Severity[.="2"])[1] with "4"')

			update [dbo].[ServerActivity] 
					set [ServerActivity].[StateOverview] = convert(nvarchar(max), b.StateOverview) 
				from 
					SATempData b 
				where 
					ServerActivity.SQLServerID = b.SQLServerID 
					and ServerActivity.UTCCollectionDateTime = b.UTCCollectionDateTime
					
			Select @LeftToDo = count(*) from ServerActivity where UTCCollectionDateTime < @EndDate
					
			update RepositoryInfo set Character_Value = @EndDate where Name = 'SALastDateUpgraded'
			update RepositoryInfo set Internal_Value = @LeftToDo where Name = 'SALeftToDo'
			
			Set @BeginDate = @EndDate

		end
		
		if @LeftToDo = 0
		BEGIN
			drop table SATempData
		END
		
		if (GETDATE() > @TimeOut)
		begin
			Select 'Time Expired'
			return
		end
		
		-- Tasks
		select @BeginDate = Character_Value from RepositoryInfo where Name = 'TasksLastDateUpgraded'
		if (@BeginDate is null)
		begin
			set @BeginDate = @VersionUpgradeDate
		end

		Select @LeftToDo = Internal_Value from RepositoryInfo where Name = 'TasksLeftToDo'

		while (GETDATE() < @TimeOut) and (@LeftToDo > 0)
		begin
			set @EndDate = DATEADD(dd, -1, @BeginDate)
			
			update Tasks set Severity = Severity*2 where CreatedOn <= @BeginDate and CreatedOn >= @EndDate and Severity in (2,4)
		
			select @LeftToDo = Count(TaskID) from Tasks where CreatedOn < @EndDate and Severity in (2,4)
			
			update RepositoryInfo set Character_Value = @EndDate where Name = 'TasksLastDateUpgraded'
			update RepositoryInfo set Internal_Value = @LeftToDo where Name = 'TasksLeftToDo'
			
			set @BeginDate = @EndDate
		end
		
		if (GETDATE() > @TimeOut)
		begin
			Select 'Time Expired'
			return
		end
		
	end
end
 
GO 

---------- P_UPGRADEDATABASESTATISTICS.SQL
if (object_id('p_UpgradeDatabaseStatistics') is not null)
begin
drop procedure [p_UpgradeDatabaseStatistics]
end
go
IF (OBJECT_ID('DatabaseStatistics_upgrade') IS NULL)
begin
exec('
create procedure [p_UpgradeDatabaseStatistics]
	@RowsRemaining bigint output
as
begin
	set @RowsRemaining = 0
	return @RowsRemaining
end')
end
else
begin
exec('
create procedure [p_UpgradeDatabaseStatistics]
	@RowsRemaining bigint output
as	
begin
if exists(select top 1 * from DatabaseStatistics_upgrade)
begin

	declare @DatabaseID int, @MaxDate datetime, @LoopDate datetime, @delay char(12), @TimeoutTime datetime
	
	-- The service has a 10 minute timeout
	-- Since this timeout is being checked in a loop and we could get unlucky on timing, set internal timeout to 5 minutes
	-- Timeout has no bad effects - will just return to service and restart where it left off
	select @TimeoutTime = dateadd(mi,5,GetUTCDate())
	
	set statistics io off
	select @DatabaseID = min(DatabaseID) from DatabaseStatistics_upgrade
	select @LoopDate = min(UTCCollectionDateTime), @MaxDate = max(UTCCollectionDateTime) from DatabaseStatistics_upgrade where DatabaseID = @DatabaseID
	
	if not exists(select top 1 Character_Value from RepositoryInfo where Name = ''DBUpgradeDelay'')
		insert into RepositoryInfo(Name,Internal_Value,Character_Value) values (''DBUpgradeDelay'',null,''00:00:00.01'')
		
	select @delay = Character_Value from RepositoryInfo where Name = ''DBUpgradeDelay'' 
	
	while (1=1)
	begin
		-- Timeout if necessary
		if (GetUTCDate() > @TimeoutTime)           
			break;
			
		-- Prevent excessive looping
		waitfor delay @delay
		
		set @LoopDate = dateadd(dd,1,@LoopDate)

		insert into DatabaseSize(
			[DatabaseID],
			[UTCCollectionDateTime],
			[DatabaseStatus],
			[DataFileSizeInKilobytes],
			[LogFileSizeInKilobytes],
			[DataSizeInKilobytes],
			[LogSizeInKilobytes],
			[TextSizeInKilobytes],
			[IndexSizeInKilobytes],
			[LogExpansionInKilobytes],
			[DataExpansionInKilobytes],
			[PercentLogSpace],
			[PercentDataSize],
			[TimeDeltaInSeconds],
			[DatabaseStatisticsTime]
			)
		select 
			[DatabaseID],
			[UTCCollectionDateTime],
			[DatabaseStatus],
			[DataFileSizeInKilobytes],
			[LogFileSizeInKilobytes],
			[DataSizeInKilobytes],
			[LogSizeInKilobytes],
			[TextSizeInKilobytes],
			[IndexSizeInKilobytes],
			[LogExpansionInKilobytes],
			[DataExpansionInKilobytes],
			[PercentLogSpace],
			[PercentDataSize],
			[TimeDeltaInSeconds],
			[UTCCollectionDateTime]
		from DatabaseStatistics_upgrade 
		where
			DatabaseID = @DatabaseID
			and UTCCollectionDateTime <= @LoopDate
		option (recompile)

		insert into DatabaseStatistics(
			[DatabaseID],
			[UTCCollectionDateTime],
			[DatabaseStatus],
			[Transactions],
			[LogFlushWaits],
			[LogFlushes],
			[LogKilobytesFlushed],
			[LogCacheReads],
			[LogCacheHitRatio],
			[TimeDeltaInSeconds],
			[NumberReads],
			[NumberWrites],
			[BytesRead],
			[BytesWritten],
			[IoStallMS],
			[DatabaseSizeTime]
			)
		select
			[DatabaseID],
			[UTCCollectionDateTime],
			[DatabaseStatus],
			[Transactions],
			[LogFlushWaits],
			[LogFlushes],
			[LogKilobytesFlushed],
			[LogCacheReads],
			[LogCacheHitRatio],
			[TimeDeltaInSeconds],
			[NumberReads],
			[NumberWrites],
			[BytesRead],
			[BytesWritten],
			[IoStallMS],
			[UTCCollectionDateTime]
		from DatabaseStatistics_upgrade
		where
			DatabaseID = @DatabaseID
			and UTCCollectionDateTime <= @LoopDate
		option (recompile)

		delete from DatabaseStatistics_upgrade
		where
			DatabaseID = @DatabaseID
			and UTCCollectionDateTime <= @LoopDate

	
		if (@LoopDate > @MaxDate)
			break;
			
		if (@LoopDate is null)
			break;

	end

	if exists (select 1 from DatabaseSizeDateTime where DatabaseID = @DatabaseID)
	begin
		-- If the Database entry is present in the DatabaseSizeDateTime table then update other wise insert the row
		update DatabaseSizeDateTime set DatabaseID = @DatabaseID, UTCCollectionDateTime = @MaxDate where DatabaseID = @DatabaseID
	end
	else
	begin
		insert into DatabaseSizeDateTime (DatabaseID, UTCCollectionDateTime) values (@DatabaseID, @MaxDate)
	end
	
	select 
		@RowsRemaining = sum(rows)
	from
		sys.partitions
	where
		object_id = object_id(''DatabaseStatistics_upgrade'')
		and index_id < 2 
end
else
begin
	set @RowsRemaining = 0
end
	return @RowsRemaining
end
')

end
 
GO 

---------- P_UPSERTBASELINETEMPLATE.SQL
IF (OBJECT_ID('p_UpsertBaselineTemplate') is not null)
BEGIN
	DROP PROCEDURE [p_UpsertBaselineTemplate]
END

GO

CREATE PROCEDURE [dbo].[p_UpsertBaselineTemplate]
(	
	@SqlServerId int,
	@baselineConfigList xml
)
AS
BEGIN
	if(@baselineConfigList is NOT NULL)
		BEGIN
		INSERT INTO [dbo].[BaselineTemplates]
			   ([SQLServerID]
			,[Template]
			,[BaselineName]
			,[Active])		 
		 SELECT	
			@SqlServerId,	 			
			A.B.value('(TemplateXML)[1]','nvarchar(1024)') AS [Template],
			A.B.value('(BaselineName/text())[1]','nvarchar(500)') AS [BaselineName] ,
			'1'
		 FROM
			@baselineConfigList.nodes('/ArrayOfBaselineConfiguration/BaselineConfiguration') A(B)
		WHERE
			A.B.value('(TemplateID)[1]','int') < 0 
						
		UPDATE [dbo].[BaselineTemplates]
   SET Active = '0'
 WHERE TemplateID IN (SELECT							
			A.B.value('(TemplateID)[1]','int') AS [TemplateID] --TAG			
		 FROM
			@baselineConfigList.nodes('/ArrayOfBaselineConfiguration/BaselineConfiguration') A(B)
		WHERE
			A.B.value('(TemplateID)[1]','int') > 0 AND A.B.value('(IsChanged)[1]','nvarchar(20)') = 'true'
		)
		INSERT INTO [dbo].[BaselineTemplates]
			   ([SQLServerID]
			,[Template]
			,[BaselineName]
			,[Active])		 
		 SELECT	
			@SqlServerId,	 			
			A.B.value('(TemplateXML)[1]','nvarchar(1024)') AS [Template],
			A.B.value('(BaselineName/text())[1]','nvarchar(500)') AS [BaselineName] ,
			'1'
		 FROM
			@baselineConfigList.nodes('/ArrayOfBaselineConfiguration/BaselineConfiguration') A(B)
		WHERE
			A.B.value('(TemplateID)[1]','int') > 0 AND A.B.value('(IsChanged)[1]','nvarchar(20)') = 'true'
		END

END
 
GO 

---------- P_UPSERTCUSTOMDASHBOARD.SQL
if (object_id('p_UpsertCustomDashboard') is not null)
begin
drop procedure [p_UpsertCustomDashboard]
end
go

create procedure [p_UpsertCustomDashboard] 
@dashboardName nvarchar(500),
@isDefaultOnUI bit,
@SID nvarchar(200),
@tags varchar(max) = null,
@RecordTimestamp datetime,
@customDashboardID INT OUT

as
begin
DECLARE @countCustomDashboard int


BEGIN TRY
   -- Start A Transaction
BEGIN TRANSACTION


	DECLARE @TotalCountInCustom BIGINT;
-- check if for record, it is update or insert call
	select @countCustomDashboard = count(CustomDashboardName) 
	from [CustomDashboard] WITH (NOLOCK)
	where CustomDashboardId = @customDashboardID
	
	SELECT @TotalCountInCustom = COUNT(0) FROM [CustomDashboard] WITH (NOLOCK);
	
	
	IF(@isDefaultOnUI = 1)
	BEGIN
		UPDATE [CustomDashboard] SET [IsDefaultOnUI] = 0 WHERE [IsDefaultOnUI] = 1
	END
	--[START] SQLdm 10.0 (Gaurav Karwal) - we need to have atleast 1 dashboard which is a default on UI so overriding the passed value in case there is only one record
	IF(@isDefaultOnUI = 0 AND @TotalCountInCustom IN (0,1))
	BEGIN
		SELECT @isDefaultOnUI = 1;
	END
	--[END] SQLdm 10.0 (Gaurav Karwal) - we need to have atleast 1 dashboard which is a default on UI so overriding the passed value in case there is only one record
	
	--set @@RecordTimestamp= CURRENT_TIMESTAMP
	-- update if permission exists.
	if (@countCustomDashboard != 0 )
		begin
			-- update existing record in table
			update [dbo].[CustomDashboard]
			set [CustomDashboardName] = @dashboardName, [IsDefaultOnUI] = @isDefaultOnUI,
			[UserSID] = LOWER(@SID),
			Tags = @tags, [RecordUpdateDateTimestamp]=@RecordTimestamp
			where CustomDashboardId = @customDashboardID
		end
	else
		begin
			-- insert new record in table
			INSERT INTO [dbo].[CustomDashboard]
				   ([CustomDashboardName]
				   ,[IsDefaultOnUI]
				   ,[UserSID]
				   ,[RecordCreatedTimestamp]
				   ,[RecordUpdateDateTimestamp])
			 VALUES
				   (@dashboardName, @isDefaultOnUI, LOWER(@SID),@RecordTimestamp,@RecordTimestamp)
			SET @customDashboardID = SCOPE_IDENTITY()
		  end
	 
	
COMMIT

END TRY
BEGIN CATCH
	ROLLBACK  -- Roll back
	SELECT ERROR_NUMBER();

END CATCH
end
 
GO 
 
GO 

---------- P_UPSERTCUSTOMDASHBOARDWIDGET.SQL
if (object_id('p_UpsertCustomDashboardWidget') is not null)
begin
drop procedure [p_UpsertCustomDashboardWidget]
end
go

create procedure [p_UpsertCustomDashboardWidget] 
@dashboardID int,
@widgetName nvarchar(500),
@widgetTypeID int,
@metricID INT ,
@match INT,
@tagId XML,
@list XML,

@recordTimestamp datetime,
@widgetID int OUT
as
begin
DECLARE @countCustomDashboard int
DECLARE @sourceIdCount INT
DECLARE @recSourceCount INT


BEGIN TRY
   -- Start A Transaction
   BEGIN TRANSACTION

-- check if for record, it is update or insert call
	--select @widgetID = [WidgetID]
	--from [CustomDashboardWidgets] 
	--where [WidgetName] = @widgetName AND [DashboardID] =@dashboardID
	
	
	--set @recordTimestamp= CURRENT_TIMESTAMP
	-- update if dashboarrd widget exists.
	if (@widgetID  IS NOT NULL )
		begin
			-- update existing record in table
			IF(@match = 3)
			BEGIN
				update [dbo].[CustomDashboardWidgets]
				set [WidgetTypeID] = @widgetTypeID, [MetricID]=@metricID, 
				[MatchId] =@match, 
				[WidgetName] = @widgetName,
				[RecordUpdateDateTimestamp] = @recordTimestamp
				where [WidgetID] = @widgetID AND DashboardID =@dashboardID

				DELETE FROM [dbo].[WidgetTagMapping] WHERE WidgetID = @widgetID
				--update widget-tag mapping table too
				CREATE TABLE #tempTagUpdate(widgetId int, tagId int)
					INSERT INTO #tempTagUpdate SELECT @widgetID, A.B.value('(ID)[1]', 'int' ) ID
					FROM    @tagId.nodes('/Root/Tag') A(B)

				
					--insert into widget-tag mapping table too
					INSERT INTO [dbo].[WidgetTagMapping](WidgetID, TagId)			
					SELECT widgetId,tagId from #tempTagUpdate 
				DELETE FROM [dbo].WidgetSourceMapping WHERE WidgetID = @widgetID

			END
			ELSE IF(@match = 4)
			BEGIN
				update [dbo].[CustomDashboardWidgets]
				set [WidgetTypeID] = @widgetTypeID, [MetricID]=@metricID, [WidgetName] = @widgetName,
				[MatchId] =@match,
				[RecordUpdateDateTimestamp] = @recordTimestamp
				where [WidgetID] = @widgetID AND DashboardID =@dashboardID

				
			END
			ELSE
			BEGIN
				update [dbo].[CustomDashboardWidgets]
				set [WidgetTypeID] = @widgetTypeID, [MetricID]=@metricID, 
				[MatchId] =@match, 
				[RecordUpdateDateTimestamp] = @recordTimestamp,[WidgetName] = @widgetName
				where [WidgetID] = @widgetID AND DashboardID =@dashboardID
				
				DELETE FROM [dbo].[WidgetTagMapping] WHERE WidgetID = @widgetID
				DELETE FROM [dbo].WidgetSourceMapping WHERE WidgetID = @widgetID
				--update widget-source mapping table too
				CREATE TABLE #tempSourceUpdate(widgetId int, sourceId int)
		INSERT INTO #tempSourceUpdate SELECT @widgetID, A.B.value('(ID)[1]', 'int' ) ID
		FROM    @list.nodes('/Root/Source') A(B)

		SET @sourceIdCount = (SELECT COUNT([SQLServerID]) FROM [MonitoredSQLServers] WHERE [Active] = 1 AND [Deleted] = 0 AND [SQLServerID] IN (SELECT sourceId FROM #tempSourceUpdate))
		SET @recSourceCount = (SELECT COUNT(sourceId) FROM #tempSourceUpdate)
		if(@sourceIdCount = @recSourceCount )
		BEGIN  
				--update widget-source mapping table too
				

				INSERT INTO [dbo].WidgetSourceMapping(WidgetID, SourceServerID)			
				SELECT widgetId,sourceId from #tempSourceUpdate 
		END 
		ELSE
		BEGIN
			ROLLBACK
			RAISERROR('Sources supplied is/are invalid.', 16, 1);
		END

			END
		end
	else
		begin
		IF(@match = 4)
			BEGIN
			INSERT INTO [dbo].[CustomDashboardWidgets] WITH(TABLOCK)
				   ([DashboardID]
				   ,[WidgetName]
				   ,[WidgetTypeID]
				   ,[MetricID]
				   ,[MatchId] 
				   ,[RecordCreatedTimestamp]
				   ,[RecordUpdateDateTimestamp])
			 VALUES
				   (@dashboardID, @widgetName, @widgetTypeID,@metricID,@match,@recordTimestamp,@recordTimestamp)

				   SET @widgetID = SCOPE_IDENTITY()
			END
		ELSE IF(@match = 3)
		BEGIN
			INSERT INTO [dbo].[CustomDashboardWidgets] WITH(TABLOCK)
				   ([DashboardID]
				   ,[WidgetName]
				   ,[WidgetTypeID]
				   ,[MetricID]
				   ,[MatchId] 
				   ,[RecordCreatedTimestamp]
				   ,[RecordUpdateDateTimestamp])
			 VALUES
				   (@dashboardID, @widgetName, @widgetTypeID,@metricID,@match,@recordTimestamp,@recordTimestamp)
				   
				   SET @widgetID = SCOPE_IDENTITY()
				   CREATE TABLE #tempTag(widgetId int, tagId int)
					INSERT INTO #tempTag SELECT @widgetID, A.B.value('(ID)[1]', 'int' ) ID
					FROM    @tagId.nodes('/Root/Tag') A(B)

				
					--insert into widget-tag mapping table too
					INSERT INTO [dbo].[WidgetTagMapping](WidgetID, TagId)			
					SELECT widgetId,tagId from #tempTag 
		END
		ELSE
		BEGIN
		
			-- insert new record in table
			INSERT INTO [dbo].[CustomDashboardWidgets] WITH(TABLOCK)
				   ([DashboardID]
				   ,[WidgetName]
				   ,[WidgetTypeID]
				   ,[MetricID]
				   ,[MatchId]
				   ,[RecordCreatedTimestamp]
				   ,[RecordUpdateDateTimestamp])
			 VALUES
				   (@dashboardID, @widgetName, @widgetTypeID,@metricID,@match,@recordTimestamp,@recordTimestamp)
				   
				SET @widgetID = SCOPE_IDENTITY()
				 
		CREATE TABLE #tempSource(widgetId int, sourceId int)
		INSERT INTO #tempSource SELECT @widgetID, A.B.value('(ID)[1]', 'int' ) ID
		FROM    @list.nodes('/Root/Source') A(B)

		SET @sourceIdCount = (SELECT COUNT([SQLServerID]) FROM [MonitoredSQLServers] WHERE [Active] = 1 AND [Deleted] = 0 AND [SQLServerID] IN (SELECT sourceId FROM #tempSource))
		SET @recSourceCount = (SELECT COUNT(sourceId) FROM #tempSource)
		if(@sourceIdCount = @recSourceCount )
		BEGIN  
				--update widget-source mapping table too
				
				INSERT INTO [dbo].WidgetSourceMapping(WidgetID, SourceServerID)			
				SELECT widgetId,sourceId from #tempSource 
		END 
		ELSE
		BEGIN
			ROLLBACK
			RAISERROR('Sources supplied is/are invalid.', 16, 1);
		END
		END
	END
COMMIT

END TRY
BEGIN CATCH
 Print 'Transaction Failed - Will Rollback'
  -- Any Error Occurred during Transaction. Rollback
  ROLLBACK  -- Roll back
END CATCH

end
 
GO 
 
GO 

---------- P_UPSERTPRESCRIPTIVESNAPSHOTVALUES.SQL
-- SQLdm 10.0 (Srishti Purohit)

-- Prescriptive Analysis
-- Save Snapshot Values for server which is need to generate SDR-M16 Recomm
-- Details are stored and used every time analysis is triggered
if (object_id('p_UpsertPrescriptiveSnapshotValues') is not null)
begin
drop procedure [p_UpsertPrescriptiveSnapshotValues]
end
go

create procedure [p_UpsertPrescriptiveSnapshotValues] 
@MonitoredServerID INT,
		 @ActiveNetworkCards INT,
         @TotalNetworkBandwidth BIGINT,
         @AllowedProcessorCount INT,
         @TotalNumberOfLogicalProcessors BIGINT ,
        @TotalMaxClockSpeed BIGINT ,
         @TotalPhysicalMemory BIGINT,
         @MaxServerMemory BIGINT, 
		 @WindowsVersion nvarchar(100),
		 @ProductVersion nvarchar(100),
		 @SQLVersionString nvarchar(100)
as
begin


BEGIN TRY
   -- Start A Transaction
   BEGIN TRANSACTION
   
	
	--set @recordTimestamp= CURRENT_TIMESTAMP
	-- update if dashboarrd widget exists.
	if EXISTS(select [ActiveNetworkCards] from [PrescriptiveAnalysisSnapshotValuesPrevious] WHERE [MonitoredServerID] = @MonitoredServerID)
		begin
				update [dbo].[PrescriptiveAnalysisSnapshotValuesPrevious]
				set [ActiveNetworkCards] = @ActiveNetworkCards
		, [TotalNetworkBandwidth] = @TotalNetworkBandwidth
      ,[AllowedProcessorCount] = @AllowedProcessorCount
	  ,[TotalNumberOfLogicalProcessors] = @TotalNumberOfLogicalProcessors
      ,[TotalMaxClockSpeed] = @TotalMaxClockSpeed
      ,[TotalPhysicalMemory] = @TotalPhysicalMemory
	  ,[MaxServerMemory] = @MaxServerMemory
	  ,[WindowsVersion] = @WindowsVersion
	  ,[ProductVersion] = @ProductVersion
	  ,[SQLVersionString] = @SQLVersionString
				WHERE [MonitoredServerID] = @MonitoredServerID
			END
			ELSE
			BEGIN
			INSERT INTO [dbo].[PrescriptiveAnalysisSnapshotValuesPrevious]
			([MonitoredServerID]
           ,[ActiveNetworkCards]
           ,[TotalNetworkBandwidth]
           ,[AllowedProcessorCount]
           ,[TotalNumberOfLogicalProcessors]
           ,[TotalMaxClockSpeed]
           ,[TotalPhysicalMemory]
           ,[MaxServerMemory]
           ,[WindowsVersion]
           ,[ProductVersion]
           ,[SQLVersionString])
     VALUES
           (@MonitoredServerID,
		   @ActiveNetworkCards
		,@TotalNetworkBandwidth
      ,@AllowedProcessorCount
	  ,@TotalNumberOfLogicalProcessors
      ,@TotalMaxClockSpeed
      ,@TotalPhysicalMemory
	  ,@MaxServerMemory
	  ,@WindowsVersion
	  ,@ProductVersion
	  ,@SQLVersionString
		   )
		   		END
COMMIT

END TRY
BEGIN CATCH
 Print 'Transaction Failed - Will Rollback'
  -- Any Error Occurred during Transaction. Rollback
  ROLLBACK  -- Roll back
END CATCH

end
 
GO 
 
GO 

---------- DATABASELOAD.SQL
set nocount on
	-- Load MetricInfo 
	
truncate table DBMetrics
insert into DBMetrics
select 8
union select 9
union select 14
union select 59
union select 60
union select 109
union select 110
--START: SQLdm 9.1 (Abhishek Joshi) -Filegroup and Mount Point Monitoring improvements --Added new metrices for filegroup space full alerts
union select 126
union select 127
--END: SQLdm 9.1 (Abhishek Joshi) -Filegroup and Mount Point Monitoring improvements --Added new metrices for filegroup space full alerts
-- SQLdm 10.0 (Vandana Gogna) - Database backup alerts
union select 130
-- Setting ansiwarnings on to handle upgrade issue from 8.5 to 10.0
-- for defect DE46195
set ansi_warnings on


if (select isnull(object_id('tempdb..#upgrade_metric_info'), 0)) <> 0 
begin 
	print 'truncating #upgrade_metric_info'
	truncate table #upgrade_metric_info
end 
else
begin
	print 'creating #upgrade_metric_info'
	CREATE TABLE #upgrade_metric_info (
		[Metric] [int] NOT NULL,
		[UTCLastChangeDateTime] [datetime] NOT NULL DEFAULT (GETUTCDATE()),
		[Rank] [int] NOT NULL,
		[Category] [nvarchar](64) NOT NULL,
		[Name] [nvarchar] (128) NOT NULL,
		[Description] [nvarchar](512) NOT NULL,
		[Comments] [nvarchar] (max) NULL,
		PRIMARY KEY CLUSTERED ([Metric])
	)
end

INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (0, 30, 'Resources', 'SQL Server CPU Usage (Percent)', 'Percentage of CPU Time used by the SQL Server instance out of the total on the SQL Server computer.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (1, 50, 'Sessions', 'User Connections (Percent)', 'Percentage of the user connections allowed by the SQL Server instance that are currently used.',NULL)
--INSERT INTO MetricInfo (Metric, Rank, Category, Name, Description, Comments) 
--VALUES (2, 50, 'Resources', 'Peak Thread Usage (Percent)', 'No longer being used',NULL)
--INSERT INTO MetricInfo (Metric, Rank, Category, Name, Description, Comments) 
--VALUES (3, 50, 'Resources', 'Current Thread Usage (Percent)', 'Current Thread Usage (Percent)',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (4, 50, 'Services', 'Non-Distributed Transactions (Count)', 'Number of replication transactions published by the Publisher but not received by the Distributor.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (5, 50, 'Services', 'Unsubscribed Transactions (Count)', 'Number of replication transactions received by the Distributor and not received by a Subscriber.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (6, 50, 'Sessions', 'Oldest Open Transaction (Minutes)', 'Time in minutes that the longest running transaction in the database has used since issuing the Begin Transaction statement.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (7, 50, 'Databases', 'Table Fragmentation (Percent)', 'Percentage of pages in the table that are fragmented.  Any changes made to the thresholds will be used to determine the alert state during the next table statistics collection.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (8, 40, 'Databases', 'Database Full (Percent)', 'DB-SPECIFIC ALERT. Percentage of the allowable disk space for the database currently used by the sum of the data, text, and indexes. By default, this percentage includes the current allocated space, auto-growth settings, and available disk space in its calculation. Note that this alert may be configured to calculate using only the current file size under Advanced > Autogrow Settings.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (9, 40, 'Databases', 'Log Full (Percent)', 'DB-SPECIFIC ALERT. Percentage of the allowable disk space currently used by the transaction log. By default, this percentage includes the current allocated space, auto-growth settings, and available disk space in its calculation. Note that this alert may be configured to calculate using only the current file size under Advanced > Autogrow Settings.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (10, 10, 'Services', 'SQL Server Agent Status', 'Status of the SQL Server Agent service.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (11, 50, 'Databases', 'Database Read/Write Error Occurred', 'An I/O error occurred while attempting to read from or write to a database file.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (12, 5, 'Services', 'SQL Server Status', 'Status of the SQL Server service.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (13, 30, 'Resources', 'SQL Server Memory Usage (Percent)', 'Percentage of memory used by the SQL Server instance out of the total memory on the SQL Server computer.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (14, 50, 'Databases', 'Database Status', 'Operational status of the database such as Normal, Offline or Suspect',NULL)
-- INSERT INTO MetricInfo (Metric, Rank, Category, Name, Description, Comments) 
-- VALUES (15, 50, 'Resources', 'DM Start', 'DM Start',NULL)
-- INSERT INTO MetricInfo (Metric, Rank, Category, Name, Description, Comments) 
-- VALUES (16, 5, 'General', 'DM Stop', 'DM Stop',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (17, 50, 'Services', 'Unsubscribed Transactions (Seconds)', 'Time in seconds that a replication transaction has been holding at the Distributor and waiting to be received by a Subscriber.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (18, 20, 'Services', 'DTC Status', 'Status of the Distributed Transaction Coordinator service.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (19, 30, 'Services', 'Full-Text Search Status', 'Status of the Full-Text Search service.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (20, 50, 'Databases', 'Index Row Hits (Percent)', 'Percentage of density of an index as used by the SQL Query Optimizer to determine index effectiveness. A high density indicates many duplicates and an inefficient index while a low density indicates high selectivity and an effective index. This alert is for visual indicators in the Desktop Client only. No notifications will be sent.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (21, 50, 'Services', 'Last Full-Text Catalog Update (Hours)', 'Time in hours since the last Full-Text Catalog update was performed and beyond which the statistics data is considered outdated. This alert is for visual indicators in the Desktop Client only. No notifications will be sent.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (22, 50, 'Sessions', 'SQL Server Response Time (Milliseconds)', 'Time in milliseconds SQL diagnostic manager currently needs to send a simple SQL command to the SQL Server instance, have it processed, and receive the returned result set.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (23, 50, 'Operational', 'OS Metrics Collection Status', 'Status of SQL diagnostic manager OS Metrics Collection.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (24, 50, 'Resources', 'OS Memory Usage (Percent)', 'Percentage of total memory used on the SQL Server computer.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (25, 50, 'Resources', 'OS Paging (Per Second)', 'Page fault rate for all processes on the SQL Server computer.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (26, 50, 'Resources', 'OS Processor Time (Percent)', 'Percentage of CPU time used by all processes on the SQL Server computer.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (27, 50, 'Resources', 'OS Privileged Time (Percent)', 'Percentage of CPU time spent by all processes executing in privileged mode on the SQL Server computer.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (28, 50, 'Resources', 'OS User Time (Percent)', 'Percentage of CPU time spent by all processes executing in user mode on the SQL Server computer.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (29, 40, 'Resources', 'OS Processor Queue Length (Count)', 'Number of ready threads in the processor queue on the SQL Server Computer.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (30, 50, 'Resources', 'OS Disk Time (Percent)', 'Percentage of elapsed time that all the disks were busy servicing read and write requests on the SQL Server computer.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (31, 40, 'Resources', 'OS Average Disk Queue Length (Count)', 'Average number of both read and write requests that were queued for all the disks on the SQL Server computer.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (32, 50, 'Sessions', 'Session CPU Time (Seconds)', 'CPU Time in seconds used by the SQL Server session since the last scheduled refresh.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (33, 40, 'Sessions', 'Blocking Session Wait Time (Seconds)', 'Time in seconds that a SQL Server session has been blocking other sessions. Select the "Non-Query activities>Capture Blocking (SQL 2005+)" check box to retrieve the blocking sessions report for SQLdm.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (34, 50, 'Services', 'SQL Server Agent Long Running Job (Percent)', 'Percentage of time a scheduled SQL Server Agent job is taking over the average successful completion time for this job in the current job history.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (35, 50, 'Services', 'SQL Server Agent Job Failure', 'The scheduled SQL Server Agent job ended with a Failed status.',NULL)
--INSERT INTO MetricInfo (Metric, Rank, Category, Name, Description, Comments) 
--VALUES (36, 50, 'General', 'Language', 'Language',NULL)
--INSERT INTO MetricInfo (Metric, Rank, Category, Name, Description, Comments) 
--VALUES (37, 50, 'General', 'Login Has Administrator Rights', 'Login Has Administrator Rights',NULL)
--INSERT INTO MetricInfo (Metric, Rank, Category, Name, Description, Comments) 
--VALUES (38, 50, 'General', 'Max Connections', 'Max Connections',NULL)
--INSERT INTO MetricInfo (Metric, Rank, Category, Name, Description, Comments) 
--VALUES (39, 50, 'General', 'Physical Memory', 'Physical Memory',NULL)
--INSERT INTO MetricInfo (Metric, Rank, Category, Name, Description, Comments) 
--VALUES (40, 50, 'General', 'Processor Count', 'Processor Count',NULL)
--INSERT INTO MetricInfo (Metric, Rank, Category, Name, Description, Comments) 
--VALUES (41, 50, 'General', 'Processor Type', 'Processor Type',NULL)
--INSERT INTO MetricInfo (Metric, Rank, Category, Name, Description, Comments) 
--VALUES (42, 50, 'General', 'Product Version', 'Product Version',NULL)
--INSERT INTO MetricInfo (Metric, Rank, Category, Name, Description, Comments) 
--VALUES (43, 50, 'General', 'Real Server Name', 'Real Server Name',NULL)
-- INSERT INTO MetricInfo (Metric, Rank, Category, Name, Description, Comments) 
-- VALUES (44, 50, 'General', 'Server Open Transactions', 'Server Open Transactions',NULL)
--INSERT INTO MetricInfo (Metric, Rank, Category, Name, Description, Comments) 
--VALUES (45, 50, 'General', 'Server Time', 'Server Time',NULL)
--INSERT INTO MetricInfo (Metric, Rank, Category, Name, Description, Comments) 
--VALUES (46, 50, 'General', 'Windows Version', 'Windows Version',NULL)
-- INSERT INTO MetricInfo (Metric, Rank, Category, Name, Description, Comments) 
-- VALUES (47, 50, 'General', 'Database File Size', 'Database File Size',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (48, 60, 'Operational', 'Maintenance Mode Enabled', 'Maintenance Mode has been enabled for the SQL Server instance.  SQL diagnostic manager will not collect scheduled data or process alerts.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (49, 50, 'Operational', 'CLR Enabled', 'The Common Language Runtime (CLR) configuration option has been enabled for the SQL Server instance. Managed code can be run in the .NET Framework. Use the Server Configuration view to reconfigure this option on SQL Server 2005 instances.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (50, 50, 'Operational', 'OLE Automation Disabled', 'The OLE Automation Procedures configuration option has been disabled (2005) or the procedures have been dropped (2000) for the SQL Server instance. SQL diagnostic manager will not collect data such as OS metrics and service details. Use the Server Configuration view to reconfigure this option on SQL Server 2005 instances.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (51, 50, 'Queries', 'Query Monitor Events (Count)', 'The number of queries captured by the Query Monitor on the SQL Server instance during the last scheduled refresh.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (52, 50, 'Operational', 'SQL diagnostic manager Service Status', 'Status of the SQL diagnostic manager service.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (53, 50, 'Operational', 'SQL Server Agent XPs Disabled', 'The Agent XPs configuration option has been disabled (2005) or the procedures have been dropped (2000) for the SQL Server instance. SQL diagnostic manager will not collect SQL Agent job details. Note that Agent XPs are disabled when SQL Server Agent is stopped, but they may be re-enabled through the Server Configuration view to allow agent job histories to be shown even when the agent is not running.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (54, 50, 'Operational', 'WMI Service Unavailable', 'The WMI service is unavailable on the SQL Server computer. SQL diagnostic manager will not collect OS metrics.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (55, 50, 'Operational', 'xp_cmdshell Disabled', 'The xp_cmdshell configuration option has been disabled (2005) or the procedure has been dropped (2000) for the SQL Server instance. SQL diagnostic manager will not collect SQL Agent logs, or be able to start and stop services. Use the Server Configuration view to reconfigure this option on SQL Server 2005 instances.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (56, 50, 'Operational', 'Operational Alert', 'An internal SQLdm operational issue has been encountered. This is an internal item for alerting only.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (57, 50, 'Sessions', 'Client Computers (Count)', 'Number of unique client computers connected to the SQL Server instance.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (58, 50, 'Sessions', 'Blocked Sessions (Count)', 'Number of sessions on the SQL Server instance being blocked by other sessions holding requested locks. Note: The "Non-Query activities>Capture deadlocks (SQL 2005+)" must be enabled for this alert to function.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (59, 40, 'Operational', 'SQL Server Data Used (Percent)', 'Percentage of allocated data space used across all data files on the SQL Server instance.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (60, 40, 'Operational', 'SQL Server Log Used (Percent)', 'Percentage of allocated log space used across all log files on the SQL Server instance.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (62, 40, 'Resources', 'OS Disk Time Per Disk (Percent)', 'Percentage of elapsed time that an individual disk was busy servicing read and write requests on the SQL Server computer.  This will alert separately for each disk on a server.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (63, 40, 'Resources', 'OS Average Disk Queue Length Per Disk (Count)', 'Average number of both read and write requests that were queued for an individual disk on the SQL Server computer.  This will alert separately for each disk on a server.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (64, 40, 'Resources', 'OS Disk Full (Percent)', 'DISK-SPECIFIC ALERT. Percentage of space used on a logical disk on the SQL Server computer.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (65, 50, 'Services', 'SQL Server Agent Long Running Job (Minutes)', 'Maximum number of minutes a scheduled SQL Server Agent job should take to complete.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (66, 50, 'Logs', 'SQL Server Error Log', 'When configuring this alert, specify which SQL error severities (0-30) correspond to Critical, Warning, or OK.  Use the advanced options to specify text matches and set log size limits.  The number of SQL Server error log events requiring attention will be reflected in the alert.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (67, 50, 'Logs', 'SQL Server Agent Log', 'When configuring this alert, specify which Agent Log Message Severity (1-3) corresponds to Critical, Warning, or OK. Use the advanced options to specify text matches and set log size limits. The number of SQL Agent log events requiring attention will be reflected in the alert.',NULL)

INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (68, 50, 'Databases', 'Mirroring Unsent Log (KB)', 'Size of the unsent log in the send queue on the principal in kilobytes.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (69, 50, 'Databases', 'Mirroring Unrestored Log (KB)', 'Size of the redo queue on the mirror in kilobytes.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (70, 50, 'Databases', 'Mirroring Oldest Unsent Transaction (Minutes)', 'The age of the oldest unsent transaction in minutes on the principal. This is only meaningful on the principal server instance.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (71, 50, 'Databases', 'Mirror Commit Overhead (Milliseconds)', 'Average delay in milliseconds on the principal server instance for each transaction because of database mirroring.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (72, 50, 'Databases', 'Mirroring Status', 'Status of the mirrored database such as synchronized, suspended or disconnected.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (73, 50, 'Databases', 'Mirroring Preferred Configuration', 'This operational configuration of this mirroring session has changed. ',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (74, 50, 'Databases', 'Mirrored Server Role Change', 'A mirrored database role change has taken place.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (75, 50, 'Databases', 'Mirroring Witness Connection', 'The mirroring witness is not connected.',NULL)

INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (76, 50, 'Resources', 'Page Life Expectancy', 'The number of seconds a page will stay in the buffer pool without references.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (77, 50, 'Services', 'Cluster Failover', 'A cluster failover has occurred.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (78, 50, 'Services', 'Cluster Active Node', 'The active node of the cluster is a non-preferred node.  The preferred node may be configured under Server Properties>Cluster Settings.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (79, 50, 'Services', 'Distribution Latency (Seconds)', 'Time in seconds that a replication transaction has been holding at the Publisher and waiting to be received by a Distributor.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (80, 50, 'Sessions', 'Deadlock', 'A deadlock occurred on the monitored server.  Note: The "Non-Query activities>Capture deadlocks (SQL 2005+)" must be enabled for this alert to function.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (81, 50, 'Resources', 'Procedure Cache Hit Ratio', 'The percentage of procedure cache hits to cache lookups.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (82, 50, 'Resources', 'Average Disk Milliseconds Per Read', 'Average time, in milliseconds, of a read operation of data from the disk.  This is a per-disk metric.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (83, 50, 'Resources', 'Average Disk Milliseconds Per Transfer', 'Average time, in milliseconds, of a disk transfer operation.  This is a per-disk metric.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (84, 50, 'Resources', 'Average Disk Milliseconds Per Write', 'Average time, in milliseconds, of a write operation of data to the disk.  This is a per-disk metric.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (85, 50, 'Resources', 'Disk Reads Per Second', 'Rate of read operations on the disk.  This is a per-disk metric.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (86, 50, 'Resources', 'Disk Transfers Per Second', 'Rate of transfer operations on the disk.  This is a per-disk metric.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (87, 50, 'Resources', 'Disk Writes Per Second', 'Rate of write operations on the disk.  This is a per-disk metric.',NULL)
INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) 
VALUES (88, 50, 'Services', 'SQL Server Agent Job Completion', 'The SQL Server Agent job/step has completed.',NULL)


declare 
@MetricID int
,@Rank int
,@Category nvarchar(64)
,@Name nvarchar(128)
,@Description512 nvarchar(512)
,@Comments nvarchar(max)


-- 89 - Version Store Generation Rate

select
@MetricID = 89
,@Rank = 50
,@Category = 'Databases'
,@Name = 'Version Store Generation Ratio'
,@Description512 = 'Amount, in percent, by which the tempdb version store generation rate exceeds the cleanup rate. This alert may only be raised on instances running SQL 2005 or above.'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 90 - Version Store Size

select
@MetricID = 90
,@Rank = 50
,@Category = 'Databases'
,@Name = 'Version Store Size (MB)'
,@Description512 = 'Size, in megabytes, of the tempdb version store. This alert may only be raised on instances running SQL 2005 or above.'
,@Comments = null



INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 91 - Longest Running Version Store Transaction

select
@MetricID = 91
,@Rank = 50
,@Category = 'Databases'
,@Name = 'Longest Running Version Store Transaction (Minutes)'
,@Description512 = 'Time in minutes that the longest version store transaction has been open and preventing version store cleanup. This alert may only be raised on instances running SQL 2005 or above.'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 92 - Session Tempdb Space Usage

select
@MetricID = 92
,@Rank = 50
,@Category = 'Databases'
,@Name = 'Session Tempdb Space Usage (MB)'
,@Description512 = 'Amount of tempdb space being used by a running session. This alert may only be raised on instances running SQL 2005 or above.'
,@Comments = null



INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)


-- 93 - Tempdb Contention

select
@MetricID = 93
,@Rank = 50
,@Category = 'Databases'
,@Name = 'Tempdb Contention (ms)'
,@Description512 = 'Current wait time for tempdb allocation maps (GAM, SGAM, and PFS), in milliseconds. This alert may only be raised on instances running SQL 2005 or above.'
,@Comments = null



INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 94 - Log Autogrow

select
@MetricID = 94
,@Rank = 50
,@Category = 'Databases'
,@Name = 'Log File Autogrow'
,@Description512 = 'Log file autogrow occurred on the specified database. Note: The "Non-Query activities>Capture Autogrow" must be enabled for this alert to function.'
,@Comments = null



INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 95 - Data Autogrow

select
@MetricID = 95
,@Rank = 50
,@Category = 'Databases'
,@Name = 'Data File Autogrow'
,@Description512 = 'Data file autogrow occurred on the specified database. Note: The "Non-Query activities>Capture Autogrow" must be enabled for this alert to function.'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 96 - VM Config Change

select
@MetricID = 96
,@Rank = 50
,@Category = 'Virtualization'
,@Name = 'VM Resource Configuration Change'
,@Description512 = 'A resource configuration change occurred for the virtual machine hosting the monitored SQL Server instance. This alert is enabled by default and is only relevant to instances hosted on virtual machines enabled for VM monitoring in the SQLdm VM Configuration window.'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 97 - VM Host Server Change

select
@MetricID = 97
,@Rank = 50
,@Category = 'Virtualization'
,@Name = 'VM Host Server Change'
,@Description512 = 'The virtual machine hosting the monitored SQL Server instance moved to a different host. This alert is disabled by default and is only relevant to instances hosted on virtual machines enabled for VM monitoring in the SQLdm VM Configuration window.'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 98 - VM CPU Utilization

select
@MetricID = 98
,@Rank = 50
,@Category = 'Virtualization'
,@Name = 'VM CPU Usage (Percent)'
,@Description512 = 'The percentage of available virtual CPU time used by the virtual machine hosting the monitored SQL Server. This may differ from the processor utilization percentage reported by the guest OS. A high percentage may indicate a large number of active client sessions. This alert is disabled by default and is only relevant to instances hosted on virtual machines enabled for VM monitoring in the SQLdm VM Configuration window.'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 99 - ESX CPU Utilization

select
@MetricID = 99
,@Rank = 50
,@Category = 'Virtualization'
,@Name = 'Host CPU Usage (Percent)'
,@Description512 = 'The percentage of available CPU time used by the host server hosting the virtual machine on which the monitored SQL Server is currently running. This alert is enabled by default and is only relevant to instances hosted on virtual machines enabled for VM monitoring in the SQLdm VM Configuration window.'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 100 - VM Memory Utilization

select
@MetricID = 100
,@Rank = 50
,@Category = 'Virtualization'
,@Name = 'VM Memory Usage (Percent)'
,@Description512 = 'The percentage of available memory used by the virtual machine hosting the monitored SQL Server. This may differ from the memory usage percentage reported by the guest OS. This alert is disabled by default and is only relevant to instances hosted on virtual machines enabled for VM monitoring in the SQLdm VM Configuration window.'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 101 - ESX Memory Usage (Percent)

select
@MetricID = 101
,@Rank = 50
,@Category = 'Virtualization'
,@Name = 'Host Memory Usage (Percent)'
,@Description512 = 'The percentage of available memory used by the host server hosting the virtual machine on which the monitored SQL Server resides. This alert is enabled by default and is only relevant to instances hosted on virtual machines enabled for VM monitoring in the SQLdm VM Configuration window.'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 102 - VM CPU Ready Wait Time

select
@MetricID = 102
,@Rank = 50
,@Category = 'Virtualization'
,@Name = 'VM CPU Ready Wait Time (ms)'
,@Description512 = 'The time in milliseconds that a virtual CPU has been waiting for a physical CPU to become available for processing for the virtual machine on which the monitored SQL Server resides. A spike in this value may indicate CPU pressure on the host server. This alert is enabled by default and is only relevant to instances hosted on virtual machines enabled for VM monitoring in the SQLdm VM Configuration window.'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 103 - VM Reclaimed/Ballooned Memory (KB)

select
@MetricID = 103
,@Rank = 50
,@Category = 'Virtualization'
,@Name = 'VM Reclaimed/Ballooned Memory (KB)'
,@Description512 = 'The amount of memory that is reclaimed by the host and is no longer available to the virtual machine on which the monitored SQL Server instance is running. A spike in this value may be a sign of memory pressure on the host. This alert is enabled by default and is only relevant to instances hosted on virtual machines enabled for VM monitoring in the SQLdm VM Configuration window.'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 104 - VM Memory Swap Delay Detected

select
@MetricID = 104
,@Rank = 50
,@Category = 'Virtualization'
,@Name = 'VM Memory Swap Delay Detected'
,@Description512 = 'Memory being swapped to disk is causing a performance delay on the virtual machine on which the monitored SQL Server instance is running. This alert is triggered if the Memory Swap in Rate (KB/s) or CPU Swap Rate (ms) counters are non-zero. This alert is enabled by default and is only relevant to instances hosted on virtual machines enabled for VM monitoring in the SQLdm VM Configuration window.'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 105 - ESX Memory Swap Detected

select
@MetricID = 105
,@Rank = 50
,@Category = 'Virtualization'
,@Name = 'Host Memory Swap Detected'
,@Description512 = 'Memory is being swapped to disk for the host server hosting the virtual machine on which the monitored SQL Server is currently running. This may be an indication of memory pressure on the host. This alert is disabled by default and is only relevant to instances hosted on virtual machines enabled for VM monitoring in the SQLdm VM Configuration window.'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 106 - VM Resource Limits are set

select
@MetricID = 106
,@Rank = 50
,@Category = 'Virtualization'
,@Name = 'VM Resource Limits Detected'
,@Description512 = 'Either CPU or memory resource limits are set for the virtual machine hosting the monitored SQL Server instance. Resource limits are soft limits set by the VM Administrator on the total amount of resources that a VM is allowed to consume.  This alert is disabled by default and is available only on instances hosted on virtual machines that are enabled for VM monitoring.'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 107 - VM Power State

select
@MetricID = 107
,@Rank = 50
,@Category = 'Virtualization'
,@Name = 'VM Power State'
,@Description512 = 'This is the power state of the VM as reported by the vCenter or HyperV host servers. This alert is enabled by default and is only relevant to instances hosted on virtual machines enabled for VM monitoring in the SQLdm VM Configuration window.'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 108 - ESX Power State

select
@MetricID = 108
,@Rank = 50
,@Category = 'Virtualization'
,@Name = 'Host Power State'
,@Description512 = 'This is the state of the host as reported by the vCenter or HyperV host servers. This alert is enabled by default and is only relevant to instances hosted on virtual machines enabled for VM monitoring in the SQLdm VM Configuration window.'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 109 - Database Size Mb

select
@MetricID = 109
,@Rank = 50
,@Category = 'Databases'
,@Name = 'Database Full (Size)'
,@Description512 = 'DB-SPECIFIC ALERT. The amount of disk space (in MB) currently used by the database as the sum of data, text, and indexes.   This value is the actual amount of used data within the database file, not the size of the database file itself.'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 110 - Log File Size Mb

select
@MetricID = 110
,@Rank = 50
,@Category = 'Databases'
,@Name = 'Log Full (Size)'
,@Description512 = 'DB-SPECIFIC ALERT. The amount of disk space (in MB) currently used by the transaction log for this database.   This value is the actual amount of data within the log, not the size of the database log file itself.'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 111 - OS Disk Free Space

select
@MetricID = 111
,@Rank = 50
,@Category = 'Resources'
,@Name = 'OS Disk Free Space (Size)'
,@Description512 = 'DISK-SPECIFIC ALERT. Amount of space (in MB) available on a logical disk on the SQL Server computer.'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

---- 112 - SQLsafe Backup Operation Status

--select
--@MetricID = 112
--,@Rank = 50
--,@Category = 'Databases'
--,@Name = 'SQLsafe Backup Operation Status'
--,@Description512 = 'DB-SPECIFIC ALERT. The status of a SQLsafe backup operation.'
--,@Comments = null
--

--INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

---- 113 - SQLsafe Restore Operation Status

--select
--@MetricID = 113
--,@Rank = 50
--,@Category = 'Databases'
--,@Name = 'SQLsafe Restore Operation Status'
--,@Description512 = 'DB-SPECIFIC ALERT. The status of a SQLsafe restore operation.'
--,@Comments = null
--

--INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

---- 114 - SQLsafe Defragmentation Operation Status

--select
--@MetricID = 114
--,@Rank = 50
--,@Category = 'Databases'
--,@Name = 'SQLsafe Defragmentation Operation Status'
--,@Description512 = 'DB-SPECIFIC ALERT. The status of a SQLsafe defragmentation operation.'
--,@Comments = null
--

--INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

---- 115 - SQLsafe Connection Status

--select
--@MetricID = 115
--,@Rank = 50
--,@Category = 'Operational'
--,@Name = 'SQLsafe Connection Status'
--,@Description512 = 'Alerts when there is a problem connecting to a SQLsafe repository.'
--,@Comments = null
--

--INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 116 - Availability Group Role Change 
select
@MetricID = 116
,@Rank = 50
,@Category = 'Databases'
,@Name = 'Availability Group Role Change'
,@Description512 = 'Primary role changed to a secondary replica. Alert includes affected database(s) for the entire availability group.'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 117 - Availability Group Estimated Data Loss (Seconds)
select
@MetricID = 117
,@Rank = 50
,@Category = 'Databases'
,@Name = 'Availability Group Estimated Data Loss (Seconds)'
,@Description512 = 'The time period in seconds that data is not synchronized to the secondary replica.  Value reflects the time difference of the last commit between the primary and secondary replicas. Alert includes affected database(s).'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 118 - Availability Group Synchronization Health 
select
@MetricID = 118
,@Rank = 50
,@Category = 'Databases'
,@Name = 'Availability Group Synchronization Health'
,@Description512 = 'Reflects database synchronization state in the availability group.  Possible values include: not healthy, partially healthy, and healthy.'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 119 - Availability Group Estimated Recovery Time (Seconds)
select
@MetricID = 119
,@Rank = 50
,@Category = 'Databases'
,@Name = 'Availability Group Estimated Recovery Time (Seconds)'
,@Description512 = 'The required time in seconds that the secondary replica needs to catch up with the primary replica. Alert includes affected database(s).'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 120 - Availability Group Synchronization Performance (Seconds)
select
@MetricID = 120
,@Rank = 50
,@Category = 'Databases'
,@Name = 'Availability Group Synchronization Performance (Seconds)'
,@Description512 = 'The time required in seconds to complete synchronization between the primary and secondary replicas.'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 121 - Availability Group Log Send Queue Size (KB)
select
@MetricID = 121
,@Rank = 50
,@Category = 'Databases'
,@Name = 'Availability Group Log Send Queue Size (KB)'
,@Description512 = 'Amount of log records in KB needed to ship to the secondary replica to complete synchronization. Alert includes affected database(s).'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 122 - Availability Group Redo Queue Size (KB) 
select
@MetricID = 122
,@Rank = 50
,@Category = 'Databases'
,@Name = 'Availability Group Redo Queue Size (KB)'
,@Description512 = 'Amount of log records from log files in KB that need redoing in the secondary replica to complete synchronization. Alert includes affected database(s).'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 123 - Availability Group Redo Rate (KB/sec) 
select
@MetricID = 123
,@Rank = 50
,@Category = 'Databases'
,@Name = 'Availability Group Redo Rate (KB/sec)'
,@Description512 = 'Rate in KB per second at which log records are redone in the secondary database to complete synchronization. Alert includes affected database(s).'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

--SQLdm 8.6 (Ankit Srivastava) -- Added new metric for Preferred Node feature
-- 124 - Availability Group Preferred Replica Unavailability
select
@MetricID = 124
,@Rank = 50
,@Category = 'Databases'
,@Name = 'Availability Group Preferred Replica' --SQLdm 8.6 (Ankit Srivastava)  -- Fixed the defects DE43718
,@Description512 = 'Alert is raised when the database is no longer on the preferred replica.'
,@Comments = null


INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- start- SQLdm 9.0 (Ankit Srivastava) -- Added new metric for Grooming Timed Out
-- 125 - SQLdm Repository Grooming Timed Out
select
@MetricID=125
,@Rank = 50
,@Category = 'Operational'
,@Name = 'SQLdm Repository Grooming Timed Out'
,@Description512 = 'Grooming timed out on your SQL Server Repository. SQL diagnostic manager no longer deletes stored metrics in the SQLdm Repository at the set schedule. To review your grooming settings access Tools > Grooming Options.'
,@Comments = null

INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)
-- end- SQLdm 9.0 (Ankit Srivastava) -- Added new metric for Grooming Timed Out

--START: SQLdm 9.1 (Abhishek Joshi) -Filegroup and Mount Point Monitoring improvements --Added new metrices for filegroup space full alerts
-- 126 - Filegroup space full (Percent)
select
@MetricID = 126
,@Rank = 50
,@Category = 'Databases'
,@Name = 'Filegroup Space Full (Percent)'
,@Description512 = 'DB-SPECIFIC ALERT. Percentage of the allowable file group space for the database currently used by all the files in a file group.  By default, this percentage includes allocated space, auto-growth settings, and available disk space in its calculation.'
,@Comments = null

INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 127 - Filegroup space full (Percent)
select
@MetricID = 127
,@Rank = 50
,@Category = 'Databases'
,@Name = 'Filegroup Space Full (Size)'
,@Description512 = 'DB-SPECIFIC ALERT. The amount of disk space (in MB) currently used by the database as the sum of all the files in a file group.'
,@Comments = null

INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)
--END: SQLdm 9.1 (Abhishek Joshi) -Filegroup and Mount Point Monitoring improvements --Added new metrices for filegroup space full alerts


--START: SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --add new service alerts
-- 128 - SQL Browser Service Status
select
@MetricID = 128
,@Rank = 30
,@Category = 'Services'
,@Name = 'SQL Server Browser Service Status'
,@Description512 = 'Status of the SQL Server Browser service.'
,@Comments = null

INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)

-- 129 - SQL Active Directory Helper Service Status
select
@MetricID = 129
,@Rank = 40
,@Category = 'Services'
,@Name = 'SQL Server Active Directory Helper Service Status'
,@Description512 = 'Status of the SQL Server Active Directory Helper service.'
,@Comments = null

INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)
--END: SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --add new service alerts

--START SQLdm 10.0 (Vandana Gogna) - Database backup alerts
-- 130 - Days since last backup
select
@MetricID = 130
,@Rank = 50
,@Category = 'Backup'
,@Name = 'Days since last backup'
,@Description512 = 'Days since the database have not been backed up.'
,@Comments = null

INSERT INTO #upgrade_metric_info (Metric, Rank, Category, Name, Description, Comments) values (@MetricID, @Rank, @Category, @Name, @Description512, @Comments)
--END SQLdm 10.0 (Vandana Gogna) - Database backup alerts

-- insert new rows 
INSERT INTO [MetricInfo] ([Metric], [Rank], [Category], [Name], [Description], Comments)
	SELECT [Metric], [Rank], [Category], [Name], [Description], [Comments] FROM #upgrade_metric_info 
		WHERE [Metric] not in (select Metric from MetricInfo)
-- update all 
UPDATE [MetricInfo]
	SET   [MetricInfo].[UTCLastChangeDateTime] = [TMI].[UTCLastChangeDateTime]
		, [MetricInfo].[Name] = [TMI].[Name]
		, [MetricInfo].[Category] = [TMI].[Category]
		, [MetricInfo].[Description] = [TMI].[Description]
		-- [Comments] is the only user updatable column that we need to preserve for records we ship
		, [MetricInfo].[Comments] = coalesce([MetricInfo].[Comments],[TMI].[Comments])
		, [MetricInfo].[Rank] = [TMI].[Rank]
	FROM #upgrade_metric_info [TMI]
	WHERE
		[MetricInfo].[Metric] = [TMI].[Metric] 

-- Metric 52 was removed after 5.0 beta
DELETE FROM DefaultMetricThresholds where Metric = 52
DELETE FROM MetricThresholds where Metric = 52

----------------------------------------------------------------------------

-- No user maintained fields in MetricMetaData
if (select isnull(object_id('tempdb..#upgrade_metric_metadata'), 0)) <> 0 
begin 
	print 'truncating #upgrade_metric_metadata'
	truncate table #upgrade_metric_metadata
end 
else
begin
	print 'creating #upgrade_metric_metadata'
	CREATE TABLE #upgrade_metric_metadata (
		[Metric] [int] NOT NULL,
		[UTCLastChangeDateTime] [datetime] DEFAULT (GETUTCDATE()),
		[Deleted] [bit] NOT NULL DEFAULT ((0)),
		[Class] [int] NOT NULL,
		[Flags] [int] NOT NULL,
		[MinValue] [int] NOT NULL,
		[MaxValue] [bigint] NOT NULL,
		[DefaultWarningValue] [bigint] NOT NULL,
		[DefaultCriticalValue] [bigint] NOT NULL,
		[DoNotifications] [bit] NOT NULL,
		[EventCategory] [int] NULL,
		[DefaultMessageID] [int] NULL,
		[AlertEnabledDefault] [bit] NOT NULL,
		[ValueComparison] [int] NOT NULL,
		[ValueType] [nvarchar](128) NOT NULL,
		[Rank] int NULL, 
		[DefaultInfoValue] [bigint] NOT NULL,
		[IsValidForSqlExpress] [BIT] NOT NULL,
		[BaselineMaxValue] [bigint] NOT NULL,
		[BaselineDefaultWarningValue] [bigint] NOT NULL,
		[BaselineDefaultCriticalValue] [bigint] NOT NULL,
		[BaselineDefaultInfoValue] [bigint] NOT NULL,
		PRIMARY KEY CLUSTERED ([Metric])
	)
end

INSERT INTO #upgrade_metric_metadata   ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,90,0,75,1,3,3,100,0,0,30,0,'System.Int32',50,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,95,0,80,1,3,3,100,1,0,50,0,'System.Int32',50,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,5,0,1,1,3,131,2147483647,4,0,50,0,'System.Int32',0,0, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,5,0,1,1,3,131,2147483647,5,0,50,0,'System.Int32',0,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,10,0,5,1,3,131,99999,6,0,50,0,'System.Int32',3,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,90,0,75,1,3,3,100,7,0,50,0,'System.Int32',50,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,90,0,75,1,3,579,100,8,0,40,0,'System.Int32',50,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,90,0,75,1,3,579,100,9,0,40,0,'System.Int32',50,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,0,2,0,1,3,18,100,10,0,10,0,'Idera.SQLdm.Common.Snapshots.ServiceState',0,0, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,1,0,1,1,3,35,100,11,0,50,0,'System.Int32',1,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,0,3,0,1,3,18,100,12,0,5,0,'Idera.SQLdm.Common.Snapshots.ServiceState',0,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,90,0,75,1,3,3,100,13,0,30,0,'System.Int32',50,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,0,0,0,1,3,82,100,14,0,50,0,'Idera.SQLdm.Common.Events.DBStatus',0,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,60,0,30,1,3,131,10000,17,0,50,0,'System.Int32',15,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,0,2,0,1,3,18,100,18,0,20,0,'Idera.SQLdm.Common.Snapshots.ServiceState',0,0, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,0,1,0,1,3,18,100,19,0,30,0,'Idera.SQLdm.Common.Snapshots.ServiceState',0,0, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,10,0,5,1,3,3,100,20,0,50,0,'System.Int32',3,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,48,0,24,1,3,3,100,21,0,50,0,'System.Int32',12,0, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,5000,0,2000,1,3,3,10000,22,0,50,0,'System.Int32',1500,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,0,0,0,1,3,18,100,23,0,50,0,'Idera.SQLdm.Common.Snapshots.OSMetricsStatus',0,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,90,0,75,1,3,3,100,24,0,50,0,'System.Int32',50,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,1000,0,100,1,3,131,10000,25,0,50,0,'System.Int32',50,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,90,0,75,1,3,3,100,26,0,50,0,'System.Int32',50,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,90,0,75,1,3,3,100,27,0,50,0,'System.Int32',50,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,90,0,75,1,3,3,100,28,0,50,0,'System.Int32',50,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,5,0,3,1,3,131,999,29,0,40,0,'System.Int32',1,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,90,0,75,1,3,3,100,30,0,50,0,'System.Int32',50,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,5,0,3,1,3,131,999,31,0,40,0,'System.Int32',1,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,60,0,20,1,3,131,999,32,0,50,0,'System.Int32',10,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,150,0,20,1,3,131,43200,33,0,40,0,'System.Int32',10,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,90,0,50,1,3,195,999,34,0,50,0,'System.Int32',20,0, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (0,0,1,0,1,1,3,99,100,35,0,50,0,'System.Int32',1,0, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,3,0,0,0,0,3,34,100,48,0,60,0,'Idera.SQLdm.Common.Events.OptionStatus',0,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,0,0,0,1,3,34,100,49,0,50,0,'Idera.SQLdm.Common.Events.OptionStatus',0,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,0,0,0,1,3,34,100,50,0,50,0,'Idera.SQLdm.Common.Events.OptionStatus',0,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (0,0,1,0,1,1,3,3,1000,51,0,50,0,'System.Int32',1,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,2,0,0,0,1,3,18,100,52,0,50,0,'Idera.SQLdm.Common.Events.SQLdmServiceState',0,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,0,0,0,1,3,34,100,53,0,50,0,'Idera.SQLdm.Common.Events.OptionStatus',0,0, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,0,0,0,1,3,34,100,54,0,50,0,'Idera.SQLdm.Common.Events.OptionStatus',0,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,0,0,0,1,3,34,100,55,0,50,0,'Idera.SQLdm.Common.Events.OptionStatus',0,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,0,0,0,1,3,34,100,56,0,50,0,'System.Object',0,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,50,0,25,1,3,131,100000,57,0,50,0,'System.Int32',10,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,1,0,1,1,3,131,10000,58,0,50,0,'System.Int32',1,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (0,0,90,0,75,1,3,3,100,59,0,40,0,'System.Int32',50,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (0,0,90,0,75,1,3,3,100,60,0,40,0,'System.Int32',50,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,90,0,75,1,4,195,999999999999999,61,0,50,1,'System.Int64',50,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,90,0,75,1,3,67,100,62,0,40,0,'System.Int32',50,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,5,0,3,1,3,131,999,63,0,40,0,'System.Int32',1,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,90,0,75,1,3,579,100,64,0,40,0,'System.Int32',50,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (0,0,20,0,10,1,3,195,9999,65,0,50,0,'System.Int32',5,0, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (0,0,18,0,11,1,3,195,30,66,1,50,0,'System.Int32',8,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (0,0,1,0,2,1,3,67,3,67,1,50,1,'System.Int32',3,0, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (0,0,64,0,48,1,3,195,99999,68,1,50,0,'System.Int32',24,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (0,0,64,0,48,1,3,195,99999,69,1,50,0,'System.Int32',24,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (0,0,5,0,10,1,3,195,99999,70,1,50,0,'System.Int32',20,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (0,0,10,0,20,1,3,195,99999,71,1,50,0,'System.Int32',30,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,0,0,0,1,3,82,100,72,0,50,0,'Idera.SQLdm.Common.Snapshots.MirroringMetrics+MirroringStateEnum',0,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,1,0,1,1,3,99,100,73,0,50,0,'System.Int32',1,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,1,0,1,1,3,99,100,74,0,50,0,'System.Int32',1,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,1,0,1,1,3,99,100,75,0,50,0,'System.Int32',1,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,1600,0,3600,1,4,195,999999999999999,76,0,50,1,'System.Int64',4800,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,1,0,1,1,3,99,100,77,0,50,0,'System.Int32',1,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (0,0,1,0,1,1,3,99,100,78,0,50,0,'System.Int32',1,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,60,0,30,1,3,131,10000,79,0,50,0,'System.Int32',15,0, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (1,0,1,0,1,1,3,99,100,80,0,50,0,'System.Int32',1,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (0,0,65,0,80,1,3,3,100,81,0,50,1,'System.Int32',100,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (0,0,20,0,10,1,3,131,99999,82,0,50,0,'System.Int32',5,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (0,0,20,0,10,1,3,131,99999,83,0,50,0,'System.Int32',5,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (0,0,20,0,10,1,3,131,99999,84,0,50,0,'System.Int32',5,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (0,0,500,0,200,1,3,131,99999,85,0,50,0,'System.Int32',100,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (0,0,500,0,200,1,3,131,99999,86,0,50,0,'System.Int32',100,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (0,0,500,0,200,1,3,131,99999,87,0,50,0,'System.Int32',100,1, 300, 100, 120, 50)
INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (0,0,0,0,0,1,6,18,100,88,0,50,0,'Idera.SQLdm.Common.Snapshots.JobStepCompletionStatus',0,0, 300, 100, 120, 50)


declare
@Metric int,
@UTCLastChangeDateTime datetime,
@Deleted bit,
@Class int, -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
@Flags int, --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024, Single Alert Type Value per Instance  =1024
@MinValue int,
@MaxValue bigint,
@DefaultWarningValue bigint,
@DefaultCriticalValue bigint,
@DoNotifications bit,
@EventCategory int, -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
@DefaultMessageID int,
@AlertEnabledDefault bit,
@ValueComparison int, -- 0 = GE, 1 = LE
@ValueType nvarchar(128),
@DefaultInfoValue bigint-- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@IsValidForSqlExpress bit
,@BaselineMaxValue bigint, --START-- 10.0 SQLdm srishti -- For Baseline alert
@BaselineDefaultWarningValue bigint,
@BaselineDefaultCriticalValue bigint,
@BaselineDefaultInfoValue bigint--END-- 10.0 SQLdm srishti -- For Baseline alert

-- 89 - Version Store Generation Rate
select
@Metric = 89
,@AlertEnabledDefault = 0
,@MinValue = 0
,@MaxValue = 9999
,@DefaultInfoValue = 30
,@DefaultWarningValue = 50
,@DefaultCriticalValue = 80
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 195 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int32'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)

-- 90 - Version Store Size
select
@Metric = 90
,@AlertEnabledDefault = 0
,@MinValue = 0
,@MaxValue = 9999
,@DefaultInfoValue = 100
,@DefaultWarningValue = 200
,@DefaultCriticalValue = 300
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 195 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int32'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)

-- 91 - Longest Running Version Store Transaction

select
@Metric = 91
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 9999
,@DefaultInfoValue = 5
,@DefaultWarningValue = 10
,@DefaultCriticalValue = 15
,@Class = 2 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 195 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 20
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int32'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)


-- 92 - Session Tempdb Space Usage

select
@Metric = 92
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 99999
,@DefaultInfoValue = 50
,@DefaultWarningValue = 100
,@DefaultCriticalValue = 150
,@Class = 2 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 195 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int32'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)

-- 93 - Tempdb Contention

select
@Metric = 93
,@AlertEnabledDefault = 1
,@MinValue = 1
,@MaxValue = 99999
,@DefaultInfoValue = 100
,@DefaultWarningValue = 250
,@DefaultCriticalValue = 500
,@Class = 2 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 195 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int32'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)


-- 94 - Log Autogrow
select
@Metric = 94
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 1
,@DefaultInfoValue = 0
,@DefaultWarningValue = 1
,@DefaultCriticalValue = 0
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 32 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Boolean'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)


-- 95 - Data Autogrow

select
@Metric = 95
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 1
,@DefaultInfoValue = 0
,@DefaultWarningValue = 1
,@DefaultCriticalValue = 0
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 32 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Boolean'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)

-- 96 - VM Config Change

select
@Metric = 96
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 1
,@DefaultInfoValue = 1
,@DefaultWarningValue = 0
,@DefaultCriticalValue = 0
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 32 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Boolean'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)


-- 97 - VM Host Server Change

select
@Metric = 97
,@AlertEnabledDefault = 0
,@MinValue = 0
,@MaxValue = 1
,@DefaultInfoValue = 1
,@DefaultWarningValue = 0
,@DefaultCriticalValue = 0
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 32 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Boolean'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)


-- 98 - VM CPU Utilization

select
@Metric = 98
,@AlertEnabledDefault = 0
,@MinValue = 0
,@MaxValue = 100
,@DefaultInfoValue = 50
,@DefaultWarningValue = 75
,@DefaultCriticalValue = 90
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 3 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int32'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)



-- 99 - ESX CPU Utilization

select
@Metric = 99
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 100
,@DefaultInfoValue = 50
,@DefaultWarningValue = 75
,@DefaultCriticalValue = 90
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 3 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int32'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)


-- 100 - VM Memory Utilization

select
@Metric = 100
,@AlertEnabledDefault = 0
,@MinValue = 0
,@MaxValue = 100
,@DefaultInfoValue = 50
,@DefaultWarningValue = 75
,@DefaultCriticalValue = 90
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 3 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int32'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)


-- 101 - ESX Memory Usage (Percent)

select
@Metric = 101
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 100
,@DefaultInfoValue = 50
,@DefaultWarningValue = 75
,@DefaultCriticalValue = 90
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 3 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int32'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)


-- 102 - VM CPU Ready Wait Time

select
@Metric = 102
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 9999999
,@DefaultInfoValue = 100
,@DefaultWarningValue = 250
,@DefaultCriticalValue = 500
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 131 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int32'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)


-- 103 - VM Reclaimed/Ballooned Memory (KB)

select
@Metric = 103
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 9999999
,@DefaultInfoValue = 500
,@DefaultWarningValue = 1000
,@DefaultCriticalValue = 2000
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 131 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int32'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)


-- 104 - VM Memory Swap Delay Detected

select
@Metric = 104
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 1
,@DefaultInfoValue = 0
,@DefaultWarningValue = 1
,@DefaultCriticalValue = 0
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 32 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Boolean'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)


-- 105 - ESX Memory Swap Detected

select
@Metric = 105
,@AlertEnabledDefault = 0
,@MinValue = 0
,@MaxValue = 1
,@DefaultInfoValue = 0
,@DefaultWarningValue = 1
,@DefaultCriticalValue = 0
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 32 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Boolean'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)


-- 106 - VM Resource Limits Detected

select
@Metric = 106
,@AlertEnabledDefault = 0
,@MinValue = 0
,@MaxValue = 1
,@DefaultInfoValue = 1
,@DefaultWarningValue = 0
,@DefaultCriticalValue = 0
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 32 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Boolean'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)


-- 107 - VM Power State

select
@Metric = 107
,@AlertEnabledDefault = 0
,@MinValue = 0
,@MaxValue = 100
,@DefaultInfoValue = 0
,@DefaultWarningValue = 0
,@DefaultCriticalValue = 0
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 18 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'Vim25Api.VirtualMachinePowerState, Vim25Service'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)


-- 108 - ESX Power State

select
@Metric = 108
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 100
,@DefaultInfoValue = 0
,@DefaultWarningValue = 0
,@DefaultCriticalValue = 0
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 18 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'Vim25Api.HostSystemPowerState, Vim25Service'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)

-- 109 - Database Size

select
@Metric = 109
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 999999999
,@DefaultInfoValue = 100000
,@DefaultWarningValue = 500000
,@DefaultCriticalValue = 1000000
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 707 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int64'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)

-- 110 - Log Size

select
@Metric = 110
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 999999999
,@DefaultInfoValue = 100000
,@DefaultWarningValue = 500000
,@DefaultCriticalValue = 1000000
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 707 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int64'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)

-- 111 - OS Disk Free

select
@Metric = 111
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 999999999
,@DefaultInfoValue = 1000000
,@DefaultWarningValue = 500000
,@DefaultCriticalValue = 100000
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 707 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 1 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int64'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 50
,@BaselineDefaultInfoValue = 120

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)

---- 112 - SQLsafe Backup Operation Status

--select
--@Metric = 112
--,@AlertEnabledDefault = 0
--,@MinValue = 0
--,@MaxValue = 100
--,@DefaultInfoValue = 0
--,@DefaultWarningValue = 0
--,@DefaultCriticalValue = 0
--,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
--,@DefaultMessageID = 0
--,@DoNotifications = 1
--,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
--,@Flags = 530 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
--,@Rank = 50
--,@ValueComparison = 0 -- 0 = GE, 1 = LE
--,@ValueType = 'Idera.SQLsafe.Shared.Service.Backup.OperationStatusCode, SQLsafeShared'

--INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)

---- 113 - SQLsafe Restore Operation Status

--select
--@Metric = 113
--,@AlertEnabledDefault = 0
--,@MinValue = 0
--,@MaxValue = 100
--,@DefaultInfoValue = 0
--,@DefaultWarningValue = 0
--,@DefaultCriticalValue = 0
--,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
--,@DefaultMessageID = 0
--,@DoNotifications = 1
--,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
--,@Flags = 530 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
--,@Rank = 50
--,@ValueComparison = 0 -- 0 = GE, 1 = LE
--,@ValueType = 'Idera.SQLsafe.Shared.Service.Backup.OperationStatusCode, SQLsafeShared'

--INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)

---- 114 - SQLsafe Defrag Operation Status

--select
--@Metric = 114
--,@AlertEnabledDefault = 0
--,@MinValue = 0
--,@MaxValue = 100
--,@DefaultInfoValue = 0
--,@DefaultWarningValue = 0
--,@DefaultCriticalValue = 0
--,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
--,@DefaultMessageID = 0
--,@DoNotifications = 1
--,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
--,@Flags = 530 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
--,@Rank = 50
--,@ValueComparison = 0 -- 0 = GE, 1 = LE
--,@ValueType = 'Idera.SQLsafe.Shared.Service.Backup.OperationStatusCode, SQLsafeShared'

--INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)

---- 115 - SQLsafe Connection Status

--select
--@Metric = 115
--,@AlertEnabledDefault = 1
--,@MinValue = 0
--,@MaxValue = 100
--,@DefaultInfoValue = 0
--,@DefaultWarningValue = 0
--,@DefaultCriticalValue = 0
--,@Class = 2 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
--,@DefaultMessageID = 0
--,@DoNotifications = 1
--,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
--,@Flags = 34 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
--,@Rank = 50
--,@ValueComparison = 0 -- 0 = GE, 1 = LE
--,@ValueType = 'Idera.SQLdm.Common.Events.OptionStatus'

--INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)



-- 116 - Availability Group Role Change 

select
@Metric = 116
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 1
,@DefaultInfoValue = 0
,@DefaultWarningValue = 1
,@DefaultCriticalValue = 0
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 32 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Boolean'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)

-- 117 - Availability Group Estimated Data Loss (Seconds)

select
@Metric = 117
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 9999999
,@DefaultInfoValue = 600
,@DefaultWarningValue = 900
,@DefaultCriticalValue = 1800
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 131 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int32'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)


-- 118 - Availability Group Synchronization Health 

select
@Metric = 118
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 1
,@DefaultInfoValue = 0
,@DefaultWarningValue = 1
,@DefaultCriticalValue = 0
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 32 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Boolean'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)


-- 119 - Availability Group Estimated Recovery Time (Seconds)

select
@Metric = 119
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 9999999
,@DefaultInfoValue = 600
,@DefaultWarningValue = 900
,@DefaultCriticalValue = 1800
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 131 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int32'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)


-- 120 - Availability Group Synchronization Performance (seconds)

select
@Metric = 120
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 9999999
,@DefaultInfoValue = 600
,@DefaultWarningValue = 900
,@DefaultCriticalValue = 1800
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 131 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int32'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)



-- 121 - Availability Group Log Send Queue Size (KB)

select
@Metric = 121
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 9999999
,@DefaultInfoValue = 1024
,@DefaultWarningValue = 4096
,@DefaultCriticalValue = 10240
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 131 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int32'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)


-- 122 - Availability Group Redo Queue Size (KB)
 
select
@Metric = 122
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 9999999
,@DefaultInfoValue = 1024
,@DefaultWarningValue = 4096
,@DefaultCriticalValue = 10240
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 131 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int32'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)


-- 123 - Availability Group Redo Rate (KB/sec) 

select
@Metric = 123
,@AlertEnabledDefault = 0
,@MinValue = 1
,@MaxValue = 9999999
,@DefaultInfoValue = 2000
,@DefaultWarningValue = 1000
,@DefaultCriticalValue = 500
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 131 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 1 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int32'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 50
,@BaselineDefaultInfoValue = 120

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)

--SQLdm 8.6 (Ankit Srivastava) -- Added new metric for Preferred Node feature
select
@Metric = 124
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 1
,@DefaultInfoValue = 1
,@DefaultWarningValue = 1
,@DefaultCriticalValue = 1
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 1568 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int32'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)

-- start- SQLdm 9.0 (Ankit Srivastava) -- Added new metric for Grooming Timed Out
select
@Metric = 125
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 1
,@DefaultInfoValue = 1
,@DefaultWarningValue = 1
,@DefaultCriticalValue = 1
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 34 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int32'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)

-- end- SQLdm 9.0 (Ankit Srivastava) -- Added new metric for Grooming Timed Out

-- START: SQLdm 9.1 (Abhishek Joshi) -Filegroup and Mount Point Monitoring improvements --Added new metrices for filegroup space full alerts
select
@Metric = 126
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 100
,@DefaultInfoValue = 50
,@DefaultWarningValue = 75
,@DefaultCriticalValue = 90
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 579 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int32'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)

select
@Metric = 127
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 999999999
,@DefaultInfoValue = 100000
,@DefaultWarningValue = 500000
,@DefaultCriticalValue = 1000000
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 707 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int64'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)

-- END: SQLdm 9.1 (Abhishek Joshi) -Filegroup and Mount Point Monitoring improvements --Added new metrices for filegroup space full alerts

--START: SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --add the meta data corresponding to new SQL services

select
@Metric = 128
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 100
,@DefaultInfoValue = 0
,@DefaultWarningValue = 0
,@DefaultCriticalValue = 0
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 3
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 18 
,@Rank = 30
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'Idera.SQLdm.Common.Snapshots.ServiceState'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)

select
@Metric = 129
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 100
,@DefaultInfoValue = 0
,@DefaultWarningValue = 0
,@DefaultCriticalValue = 0
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 3
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 18 
,@Rank = 40
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'Idera.SQLdm.Common.Snapshots.ServiceState'
,@IsValidForSqlExpress =0
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)

--END: SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --add the meta data corresponding to new SQL services

--START SQLdm 10.0 (Vandana Gogna) - Database backup alerts
-- 130 - Database Last Backed up since

select
@Metric = 130
,@AlertEnabledDefault = 1
,@MinValue = 0
,@MaxValue = 99999999
,@DefaultInfoValue = 5
,@DefaultWarningValue = 10
,@DefaultCriticalValue = 30
,@Class = 0 -- ServerThreshold = 0, ScheduledJobs = 1, Processes = 2, Hardcoded = 3
,@DefaultMessageID = 0
,@DoNotifications = 1
,@EventCategory = 3 -- From messages DLL, probably should be 3, defaults to General - General = 1, Audit = 2, Alert = 3, Custom = 4 4
,@Flags = 707 --NumericValue = 1, OKDisabled = 2, WarningDisabled = 4, CriticalDisabled = 8, ContainedValueList = 16, MutuallyExclusive = 32, AdditionalData = 64, CalculateMaxValue = 128, InfoDisabled = 256, Multi-Instance = 512, Single Alert Type Value per Instance  =1024
,@Rank = 50
,@ValueComparison = 0 -- 0 = GE, 1 = LE
,@ValueType = 'System.Int64'
,@IsValidForSqlExpress =1
,@BaselineMaxValue = 300
,@BaselineDefaultWarningValue = 100
,@BaselineDefaultCriticalValue = 120
,@BaselineDefaultInfoValue = 50

INSERT INTO #upgrade_metric_metadata ([AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress], [BaselineMaxValue], [BaselineDefaultWarningValue], [BaselineDefaultCriticalValue], [BaselineDefaultInfoValue]) VALUES (@AlertEnabledDefault, @Class, @DefaultCriticalValue, @DefaultMessageID, @DefaultWarningValue, @DoNotifications, @EventCategory, @Flags, @MaxValue, @Metric, @MinValue, @Rank, @ValueComparison, @ValueType, @DefaultInfoValue,@IsValidForSqlExpress, @BaselineMaxValue, @BaselineDefaultWarningValue, @BaselineDefaultCriticalValue ,@BaselineDefaultInfoValue)
--END SQLdm 10.0 (Vandana Gogna) - Database backup alerts

-- insert new rows 
INSERT INTO [MetricMetaData]                                                                                                                                                
	(
			[AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress]
			,[BaselineMaxValue], [BaselineDefaultWarningValue], --10.0 SQLdm srishti purohit
	[BaselineDefaultCriticalValue], --10.0 SQLdm srishti purohit
	[BaselineDefaultInfoValue] --10.0 SQLdm srishti purohit
	)
	(SELECT [AlertEnabledDefault],[Class],[DefaultCriticalValue],[DefaultMessageID],[DefaultWarningValue],[DoNotifications],[EventCategory],[Flags],[MaxValue],[Metric],[MinValue],[Rank],[ValueComparison],[ValueType],[DefaultInfoValue],[IsValidForSqlExpress],[BaselineMaxValue]
	, [BaselineDefaultWarningValue], --10.0 SQLdm srishti purohit
	[BaselineDefaultCriticalValue], --10.0 SQLdm srishti purohit
	[BaselineDefaultInfoValue] --10.0 SQLdm srishti purohit
		FROM #upgrade_metric_metadata 
		WHERE [Metric] not in (select [Metric] from [MetricMetaData])
	)
-- update all 
UPDATE [MetricMetaData]
	SET   
		 [MetricMetaData].[AlertEnabledDefault] = [TMD].[AlertEnabledDefault]
		,[MetricMetaData].[Class] = [TMD].[Class] 
		,[MetricMetaData].[DefaultCriticalValue] = [TMD].[DefaultCriticalValue]
		,[MetricMetaData].[DefaultMessageID] = [TMD].[DefaultMessageID]
		,[MetricMetaData].[DefaultWarningValue] = [TMD].[DefaultWarningValue]
		,[MetricMetaData].[DoNotifications] = [TMD].[DoNotifications]
		,[MetricMetaData].[EventCategory] = [TMD].[EventCategory]
		,[MetricMetaData].[Flags] = [TMD].[Flags]
		,[MetricMetaData].[MaxValue] = [TMD].[MaxValue]
		,[MetricMetaData].[MinValue] = [TMD].[MinValue]
		,[MetricMetaData].[Rank] = [TMD].[Rank]
		,[MetricMetaData].[ValueComparison] = [TMD].[ValueComparison]
		,[MetricMetaData].[ValueType] = [TMD].[ValueType]
		,[MetricMetaData].[DefaultInfoValue] = [TMD].[DefaultInfoValue]
		,[MetricMetaData].[IsValidForSqlExpress] = [TMD].[IsValidForSqlExpress]
		,[MetricMetaData].[BaselineMaxValue] = [TMD].[BaselineMaxValue]
		,[MetricMetaData].[BaselineDefaultWarningValue] = [TMD].[BaselineDefaultWarningValue]
		,[MetricMetaData].[BaselineDefaultCriticalValue] = [TMD].[BaselineDefaultCriticalValue]
		,[MetricMetaData].[BaselineDefaultInfoValue] = [TMD].[BaselineDefaultInfoValue]
	FROM #upgrade_metric_metadata [TMD]
	WHERE
		[MetricMetaData].[Metric] = [TMD].[Metric] 

--Updating metrtic metadata with table and column mappings

UPDATE MetricMetaData Set TableName='ServerStatistics', ColumnName='SqlServerServiceStatus' Where Metric = 12
UPDATE MetricMetaData Set TableName='DatabaseStatistics', ColumnName='DatabaseStatus' Where Metric = 14
UPDATE MetricMetaData Set TableName='ServerStatistics', ColumnName='DTCServiceStatus' Where Metric = 15
UPDATE MetricMetaData Set TableName='ServerStatistics', ColumnName='FullTextSearchStatus' Where Metric = 16
UPDATE MetricMetaData Set TableName='ServerStatistics', ColumnName='ResponseTimeInMilliseconds' Where Metric = 22
UPDATE MetricMetaData Set TableName='ServerStatistics', ColumnName='(CONVERT(decimal(18, 0),([PhysicalMemoryInKilobytes] - [TotalServerMemoryInKilobytes])) / [PhysicalMemoryInKilobytes] * 100)' Where Metric = 24
UPDATE MetricMetaData Set TableName='ServerStatistics', ColumnName='AgentServiceStatus' Where Metric = 10
UPDATE MetricMetaData Set TableName='ServerStatistics', ColumnName='CPUActivityPercentage' Where Metric = 0
UPDATE MetricMetaData Set TableName='ServerStatistics', ColumnName='[OldestOpenTransactionsInMinutes]' Where Metric = 6
UPDATE MetricMetaData Set TableName='OSStatistics', ColumnName='PagesPerSecond' Where Metric = 25
UPDATE MetricMetaData Set TableName='OSStatistics', ColumnName='ProcessorTimePercent' Where Metric = 26
UPDATE MetricMetaData Set TableName='OSStatistics', ColumnName='PrivilegedTimePercent' Where Metric = 27
UPDATE MetricMetaData Set TableName='TableReorganization', ColumnName='LogicalFragmentation' Where Metric = 7
UPDATE MetricMetaData Set TableName='OSStatistics', ColumnName='UserTimePercent' Where Metric = 28
UPDATE MetricMetaData Set TableName='OSStatistics', ColumnName='ProcessorQueueLength' Where Metric = 29
UPDATE MetricMetaData Set TableName='OSStatistics', ColumnName='DiskTimePercent' Where Metric = 30
UPDATE MetricMetaData Set TableName='OSStatistics', ColumnName='DiskQueueLength' Where Metric = 31
UPDATE MetricMetaData Set TableName='ServerStatistics', ColumnName='ClientComputers' Where Metric = 57
UPDATE MetricMetaData Set TableName='ServerStatistics', ColumnName='BlockedProcesses' Where Metric = 58
UPDATE MetricMetaData Set TableName='OSStatistics', ColumnName='DiskTimePercent' Where Metric = 62
UPDATE MetricMetaData Set TableName='OSStatistics', ColumnName='DiskQueueLength' Where Metric = 63
UPDATE MetricMetaData Set TableName='DiskDrives', ColumnName='CONVERT(DECIMAL(18,2),(1- [UnusedSizeKB] / [TotalSizeKB]) * 100)' Where Metric = 64
UPDATE MetricMetaData Set TableName='MirroringStatistics', ColumnName='unsent_log' Where Metric = 68
UPDATE MetricMetaData Set TableName='MirroringStatistics', ColumnName='unrestored_log' Where Metric = 69
UPDATE MetricMetaData Set TableName='MirroringStatistics', ColumnName='average_delay' Where Metric = 71
UPDATE MetricMetaData Set TableName='MirroringParticipants', ColumnName='mirroring_state' Where Metric = 72
UPDATE MetricMetaData Set TableName='ServerStatistics', ColumnName='PageLifeExpectancy' Where Metric = 76
UPDATE MetricMetaData Set TableName='MonitoredSQLServers', ColumnName='ActiveClusterNode' Where Metric = 78
UPDATE MetricMetaData Set TableName='ServerStatistics', ColumnName='DistributionLatencyInSeconds' Where Metric = 79
UPDATE MetricMetaData Set TableName='Deadlocks', ColumnName='COUNT(DeadlockID)' Where Metric = 80
UPDATE MetricMetaData Set TableName='ServerStatistics', ColumnName='ProcedureCacheHitRatioPercentage' Where Metric = 81
UPDATE MetricMetaData Set TableName='DiskDrives', ColumnName='AverageDiskMillisecondsPerRead' Where Metric = 82
UPDATE MetricMetaData Set TableName='DiskDrives', ColumnName='AverageDiskMillisecondsPerTransfer' Where Metric = 83
UPDATE MetricMetaData Set TableName='DiskDrives', ColumnName='AverageDiskMillisecondsPerWrite' Where Metric = 84
UPDATE MetricMetaData Set TableName='DiskDrives', ColumnName='DiskReadsPerSecond' Where Metric = 85
UPDATE MetricMetaData Set TableName='DiskDrives', ColumnName='DiskTransfersPerSecond' Where Metric = 86
UPDATE MetricMetaData Set TableName='DiskDrives', ColumnName='DiskWritesPerSecond' Where Metric = 87
UPDATE MetricMetaData Set TableName='TempdbFileData', ColumnName='VersionStoreInKilobytes' Where Metric = 90
UPDATE MetricMetaData Set TableName='ServerStatistics', ColumnName='([TempdbPFSWaitTimeMilliseconds] + [TempdbGAMWaitTimeMilliseconds] + [TempdbSGAMWaitTimeMilliseconds])' Where Metric = 93
UPDATE MetricMetaData Set TableName='DatabaseSize', ColumnName='PercentDataSize' Where Metric = 8
UPDATE MetricMetaData Set TableName='DatabaseSize', ColumnName='PercentLogSpace' Where Metric = 9
UPDATE MetricMetaData Set TableName='DatabaseSize', ColumnName='LogExpansionInKilobytes' Where Metric =94
UPDATE MetricMetaData Set TableName='DatabaseSize', ColumnName='DataExpansionInKilobytes' Where Metric = 95
UPDATE MetricMetaData Set TableName='VMStatistics', ColumnName='CPUUsage' Where Metric = 98
UPDATE MetricMetaData Set TableName='ESXStatistics', ColumnName='CPUUsage' Where Metric = 99
UPDATE MetricMetaData Set TableName='VMStatistics', ColumnName='MemUsage' Where Metric = 100
UPDATE MetricMetaData Set TableName='ESXStatistics', ColumnName='MemUsage' Where Metric = 101
UPDATE MetricMetaData Set TableName='VMStatistics', ColumnName='CPUReady' Where Metric = 102
UPDATE MetricMetaData Set TableName='VMStatistics', ColumnName='MemBalooned' Where Metric = 103
UPDATE MetricMetaData Set TableName='DatabaseSize', ColumnName='DataSizeInKilobytes' Where Metric = 109
UPDATE MetricMetaData Set TableName='DatabaseSize', ColumnName='LogSizeInKilobytes' Where Metric = 110
UPDATE MetricMetaData Set TableName='AlwaysOnStatistics', ColumnName='EstimatedDataLossTime' Where Metric = 117
UPDATE MetricMetaData Set TableName='AlwaysOnStatistics', ColumnName='SynchronizationHealth' Where Metric = 118
UPDATE MetricMetaData Set TableName='AlwaysOnStatistics', ColumnName='EstimatedRecoveryTime' Where Metric = 119
UPDATE MetricMetaData Set TableName='AlwaysOnStatistics', ColumnName='SynchronizationPerformance' Where Metric = 120
UPDATE MetricMetaData Set TableName='AlwaysOnStatistics', ColumnName='LogSedQueueSize' Where Metric = 121
UPDATE MetricMetaData Set TableName='AlwaysOnStatistics', ColumnName='RedoQueueSize' Where Metric = 122
UPDATE MetricMetaData Set TableName='AlwaysOnStatistics', ColumnName='RedoRate' Where Metric = 123
UPDATE MetricMetaData Set TableName='ServerStatistics', ColumnName='CONVERT(DECIMAL(18,2),([UserProcesses] * 100) / [MaxConnections])' Where Metric = 1
UPDATE MetricMetaData Set TableName='ServerStatistics', ColumnName='(CASE when([TotalServerMemoryInKilobytes] / [PhysicalMemoryInKilobytes]) >= 1 then 100 else  CONVERT(DECIMAL(18,2),([TotalServerMemoryInKilobytes] / [PhysicalMemoryInKilobytes]) *100) END)' Where Metric = 13
UPDATE MetricMetaData Set TableName='ServerStatistics', ColumnName='(CASE WHEN ([VersionStoreCleanupKilobytes] / [TimeDeltaInSeconds]) = 0 THEN 9999 ELSE CONVERT(DECIMAL(18,2),(([VersionStoreGenerationKilobytes] / [VersionStoreCleanupKilobytes]) -1 ) *100) END)' Where Metric = 89

--START: SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --add the meta data corresponding to new SQL services
UPDATE MetricMetaData Set TableName='ServerStatistics', ColumnName='SQLBrowserServiceStatus' Where Metric = 128
UPDATE MetricMetaData Set TableName='ServerStatistics', ColumnName='SQLActiveDirectoryHelperServiceStatus' Where Metric = 129
--END: SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --add the meta data corresponding to new SQL services
--START SQLdm 10.0 (Vandana Gogna) - Database backup alerts
UPDATE MetricMetaData Set TableName='DatabaseStatistics', ColumnName='(CASE WHEN [LastBackupDateTime] is NULL THEN 9999999 ELSE DATEDIFF(D,LastBackupDateTime, UTCCollectionDateTime) END)' Where Metric = 130
--END SQLdm 10.0 (Vandana Gogna) - Database backup alerts
--START SQLdm 10.0 (Gaurav Karwal) - mapping with column name
UPDATE MetricMetaData Set TableName='DiskDrives', ColumnName='UnusedSizeKB' Where Metric = 111
UPDATE MetricMetaData Set TableName='BlockingSessionStatistics', ColumnName='BlockingDurationMilliseconds' Where Metric = 33
UPDATE MetricMetaData Set TableName='ServerStatistics', ColumnName='(ISNULL((DataFileSpaceUsedInKilobytes),0)/ISNULL((DataFileSpaceAllocatedInKilobytes),1))*100' Where Metric = 59
UPDATE MetricMetaData Set TableName='ServerStatistics', ColumnName='(ISNULL((LogFileSpaceUsedInKilobytes),0)/ISNULL((LogFileSpaceAllocatedInKilobytes),1))*100' Where Metric = 60
UPDATE MetricMetaData Set TableName='ReplicationTopology', ColumnName='NonDistributedTransactions' Where Metric = 4
UPDATE MetricMetaData Set TableName='ReplicationTopology', ColumnName='NonSubscribedTransactions' Where Metric = 5
UPDATE MetricMetaData Set TableName='ServerStatistics', ColumnName='ReplicationLatencyInSeconds' Where Metric = 17
--START SQLdm 10.0 (srishti purohit) - Adding values in table name and column name for Query Monitor Events count
UPDATE MetricMetaData Set TableName='QueryMonitorStatistics', ColumnName='COUNT(0)' Where Metric = 51

--END SQLdm 10.0 (Gaurav Karwal) - mapping with column name

print 'MetricMetaDataMessages'
DELETE FROM MetricMetaDataMessages
--START: SQLdm 10.0 (Tarun Sapra)- Template for the baseline alerts
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (0, 0, 101, N'SQL Server CPU usage is {1:F2}%', N'SQL Server instance {0} is currently using {1:F2}% of the CPU.', N'SQL Server CPU usage is {1:F2}% on {0}', N'SQL Server CPU usage is {1:F2}%.',
N'Percentage of baseline for SQL Server CPU usage is {1:F2}%', N'SQL Server instance {0} is currently using {1:F2}% of the baseline of the CPU.', N'SQL Server CPU usage is {1:F2}% of the baseline on {0}', N'SQL Server CPU usage is {1:F2}% of the baseline.')

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (1, 0, 202, N'User connections are at {1:F2}%', N'SQL Server instance {0} has {2} user connections and is at {1:F2}% of the maximum connections allowed.', N'User connections are at {1:F2}% on {0}', N'User connections are at {1:F2}%.',
N'Percentage of baseline for User connections are at {1:F2}%', N'SQL Server instance {0} has {2} user connections and is at {1:F2}% of the baseline.', N'User connections are at {1:F2}% of the baseline on {0}', N'User connections are at {1:F2}% of the baseline.')

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (4, 0, 708, N'Non-Distributed transaction count is {1}', N'SQL Server instance {0} has {1} replication transactions published by the Publisher but not received by the Distributor.', N'Non-Distributed transactions count is {1} on {0}', N'Non-Distributed transaction count is {1}.',
N'Percentage of baseline for Non-Distributed transaction count is {1}%', N'SQL Server instance {0} has {1}% of baseline value for replication transactions published by the Publisher but not received by the Distributor.', N'Percentage of baseline for Non-Distributed transactions count is {1}% on {0}', N'Percentage of baseline for Non-Distributed transaction count is {1}%.')

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline])  
VALUES (5, 0, 809, N'Unsubscribed transaction count is {1}', N'SQL Server instance {0} has {1} unsubscribed replication transactions received by the Distributor and not received by a Subscriber.', N'Unsubscribed transaction count is {1} on {0}', N'Unsubscribed transaction count is {1}.',
N'Percentage of baseline for Unsubscribed transaction count is {1}%', N'SQL Server instance {0} has {1}% of baseline of unsubscribed replication transactions received by the Distributor and not received by a Subscriber.', N'Percentage of baseline for Unsubscribed transaction count is {1}% on {0}', N'Percentage of basleine for Unsubscribed transaction count is {1}%.')

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) VALUES (6, 0, 910, 
N'A transaction in session {6} has been active for {1} minute(s) and running since {8}', 
N'SQL Server instance {0} - A transaction in session {6} has been active for {1} minute(s) and running since {8}. The transaction is being run on database [{2}] with application name ''{3}'' by user ''{5}'' on host ''{4}''. Last command issued: {7}', 
N'A transaction in session {6} has been active for {1} minute(s) and running since {8} on {0}', 
N'A transaction in session {6} has been active for {1} minute(s) and running since {8}.',
N'A transaction in session {6} has been active for {1}% of it''s baseline and running since {8}.',--'A transaction in session {6} has been active for {1} minute(s) and {8}% of baseline', 
N'SQL Server instance {0} - A transaction in session {6} has been active for {1}% of it''s baseline and running since {8}. The transaction is being run on database [{2}] with application name ''{3}'' by user ''{5}'' on host ''{4}''. Last command issued: {7}', 
N'A transaction in session {6} has been active for {1}% of it''s baseline and running since {8} on {0}', 
N'A transaction in session {6} has been active for {1}% of it''s baseline and running since {8}.'
)
--END: SQLdm 10.0 (Tarun Sapra)- Template for the baseline alerts

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (7, 0, 1011, N'Fragmentation > {5}% on {1} table{2} in database [{3}]', N'SQL Server instance {0} - {6}', N'Fragmentation > {5}% on {1} table{2} in database [{3}] on {0}', N'Fragmentation > {5}% on {1} table{2} in database [{3}].')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (8, 0, 1112, N'Data files are {1:F2}% full for database [{2}]', N'SQL Server instance {0} - Database [{2}] has data files that are {1:F2}% full.

If this percentage appears incorrect, you may need to run DBCC UPDATEUSAGE to have SQL Server update the information.', N'Data files are {1:F2}% full for database [{2}] on {0}', N'Data files are {1:F2}% full for database [{2}].')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (9, 0, 1213, N'Log files are {1:F2}% full for database [{2}]', N'SQL Server instance {0} - Database [{2}] has transaction log files that are {1:F2}% full.

If this percentage appears incorrect, you may need to run DBCC UPDATEUSAGE to have SQL Server update the information.', N'Log files are {1:F2}% full for database [{2}] on {0}', N'Log files are {1:F2}% full for database [{2}].')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (10, 0, 1314, N'SQL Agent running', N'SQL Server instance {0} - The SQL Server Agent service is running.', N'SQL Agent running on {0}', N'SQL Agent is running.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (10, 1, 1315, N'SQL Agent stopped', N'SQL Server instance {0} - The SQL Server Agent service is stopped.', N'SQL Agent stopped on {0}', N'SQL Agent is stopped.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (10, 2, 1316, N'SQL Agent is {1}', N'SQL Server instance {0} - The SQL Server Agent service has a status of {1}.', N'SQL Agent is {1} on {0}', N'SQL Agent is {1}.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (11, 0, 1417, N'I/O error count is {1:F0}', N'SQL Server instance {0} has experienced {1:F0} I/O errors while reading or writing to data files.', N'I/O error count is {1:F0} on {0}', N'I/O error count is {1:F0}.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (12, 0, 1518, N'SQL Server running', N'SQL Server instance {0} - The SQL Server service is running.', N'SQL Server running on {0}', N'SQL Server is running.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (12, 1, 1520, N'SQL Server paused', N'SQL Server instance {0} is paused.', N'SQL Server paused on {0}', N'SQL Server is paused.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (12, 2, 1519, N'SQL Server stopped', N'SQL Server instance {0} - The SQL Server service is stopped.', N'SQL Server stopped on {0}', N'SQL Server is stopped.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (12, 3, 1523, N'SQL Server is {1}', N'SQL Server instance {0} - The SQL Server service status is {1}. 

{3}', N'SQL Server is {1} on {0}', N'SQL Server is {1}.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (12, 4, 1523, N'SQL Server status: {1}', N'SQL Server instance {0} - The SQL Server service status is: {1}. 

{3}', N'SQL Server is: {1} on {0}', N'SQL Server status is {1}.')

--START: SQLdm 10.0 (Tarun Sapra)- Template for the baseline alerts
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (13, 0, 1624, N'SQL Server memory is {1:F2}%', N'SQL Server instance {0} is currently using {1:F2}% of the server memory.', N'SQL Server memory is {1:F2}% on {0}', N'SQL Server memory usage is {1:F2}%.',
N'Percentage of baseline for SQL Server memory is {1:F2}%', N'SQL Server instance {0} is currently using {1:F2}% of the Percentage of baseline of server memory.', N'Percentage of baseline of SQL Server memory is {1:F2}% on {0}', N'Percentage of baseline of SQL Server memory usage is {1:F2}%.')
--END: SQLdm 10.0 (Tarun Sapra)- Template for the baseline alerts

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (14, 0, 1725, N'Database status for [{2}] is {1}', N'SQL Server instance {0} - Database [{2}] has a status of {1}.', N'Database status for [{2}] is {1} on {0}', N'Database status for [{2}] is {1}.')

--START: SQLdm 10.0 (Tarun Sapra)- Template for the baseline alerts
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (17, 0, 2028, N'Unsubscribed transaction time is {3} hours {4} minutes {5} seconds ({1} total seconds)', N'SQL Server instance {0} has unsubscribed replication transactions that have been holding at the Distributor for {3} hours {4} minutes {5} seconds ({1} total seconds).', N'Unsubscribed transaction time is {3} hours {4} minutes {5} seconds ({1} total seconds) on {0}', N'Unsubscribed transaction time is {1} seconds.',
N'Unsubscribed transaction time is {3} hours {4} minutes {5} seconds ({1}% of baseline value)', N'SQL Server instance {0} has unsubscribed replication transactions that have been holding at the Distributor for {3} hours {4} minutes {5} seconds ({1}% of baseline value).', N'Unsubscribed transaction time is {3} hours {4} minutes {5} seconds ({1}% of baseline value) on {0}', N'Unsubscribed transaction time is {1}% of baseline value.')
--END: SQLdm 10.0 (Tarun Sapra)- Template for the baseline alerts

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (18, 0, 2129, N'DTC running', N'SQL Server instance {0} - The Distributed Transaction Coordinator service is running.', N'DTC running on {0}', N'DTC is running.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (18, 1, 2130, N'DTC stopped', N'SQL Server instance {0} - The Distributed Transaction Coordinator service is stopped.', N'DTC stopped on {0}', N'DTC is stopped.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (18, 2, 2131, N'DTC is {1}', N'SQL Server instance {0} - The Distributed Transaction Coordinator service has a status of {1}.', N'DTC is {1} on {0}', N'DTC is {1}.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (19, 0, 2232, N'Full-Text Search running', N'SQL Server instance {0} - The Full-Text Search service is running.', N'Full-Text Search running on {0}', N'Full-Text Search is running.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (19, 1, 2233, N'Full-Text Search is {1}', N'SQL Server instance {0} - The Full-Text Search service has a status of {1}.', N'Full-Text Search is {1} on {0}', N'Full-Text Search is {1}.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (20, 0, 0, N'SQL Server memory is {1:F2}%', N'SQL Server instance {0} is currently using {1:F2}% of the server memory.', N'SQL Server memory is {1:F2}% on {0}', N'SQL Server memory is {1:F2}%.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (21, 0, 0, N'SQL Server memory is {1:F2}%', N'SQL Server instance {0} is currently using {1:F2}% of the server memory.', N'SQL Server memory is {1:F2}% on {0}', N'SQL Server memory is {1:F2}%.')

--START: SQLdm 10.0 (Tarun Sapra)- Template for the baseline alerts
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (22, 0, 2534, N'Server response time is {1} ms', N'SQL Server instance {0} has a response time of {1} ms.', N'Server response time is {1} ms on {0}', N'Server response time is {1} ms.',
N'Percentage of baseline of Server response time is {1}% ', N'SQL Server instance {0} has a Percentage of baseline of response time is {1}%.', N'Percentage of Server response time is {1}% on {0}', N'Percentage of Server response time is {1}%.')
--END: SQLdm 10.0 (Tarun Sapra)- Template for the baseline alerts

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (23, 0, 4010, N'OS metrics data available', N'SQL Server instance {0} - The operating system metrics data is available.', N'OS metrics data available on {0}', N'OS metrics data is available.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (23, 1, 4012, N'OS metrics data unavailable', N'SQL Server instance {0} - The operating system metrics data is not available.', N'OS metrics data unavailable on {0}', N'OS metrics data is unavailable.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (23, 2, 4011, N'OS metrics data unavailable', N'SQL Server instance {0} - The operating system metrics data is not available because the WMI service did not respond or could not be started.', N'OS metrics data unavailable on {0}', N'OS metrics data is unavailable.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (23, 3, 4013, N'OS metrics data unavailable', N'SQL Server instance {0} - The operating system metrics data is not available because OLE Automation is not enabled.', N'OS metrics data unavailable on {0}', N'OS metrics data is unavailable.')

--START: SQLdm 10.0 (Tarun Sapra)- Template for the baseline alerts
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (24, 0, 4020, N'OS memory used is {1:F2}%', N'SQL Server instance {0} - The operating system has {1:F2}% of memory in use.', N'OS memory used is {1:F2}% on {0}', N'OS memory usage is {1:F2}%.',
N'Percentage of baseline of OS memory used is {1:F2}%', N'SQL Server instance {0} - The operating system has {1:F2}% of the baseline value of memory in use.', N'OS memory used is {1:F2}% of the baseline value on {0}', N'OS memory usage is {1:F2}% of the baseline value.')

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (25, 0, 4030, N'OS paging is {1:F2} pages/second', N'SQL Server instance {0} - The operating system is paging at {1:F2} pages/second.', N'OS paging is {1:F2} pages/second on {0}', N'OS paging is {1:F2} pages/second.',
N'Percentage of baseline for OS paging is {1:F2} pages/second', N'SQL Server instance {0} - The operating system is paging at {1:F2}% of the baseline of OS Paging.', N'Percentage of baseline of OS paging is {1:F2}% on {0}', N'Percentage of baseline of OS paging is {1:F2}%.')

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (26, 0, 4040, N'OS CPU usage is {1:F2}%', N'SQL Server instance {0} - The operating system CPU usage is {1:F2}%.', N'OS CPU usage is {1:F2}% on {0}', N'OS CPU usage is {1:F2}%.',
N'Percentage of baseline of OS CPU usage is {1:F2}%', N'SQL Server instance {0} - The Percentage of baseline of operating system CPU usage is {1:F2}%.', N'Percentage of baseline of OS CPU usage is {1:F2}% on {0}', N'Percentage of baseline is OS CPU usage is {1:F2}%.')

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (27, 0, 4050, N'OS privileged CPU usage is {1:F2}%', N'SQL Server instance {0} - The operating system privileged CPU usage is {1:F2}%.', N'OS privileged CPU usage is {1:F2}% on {0}', N'OS privileged CPU usage is {1:F2}%.',
N'Percentage of baseline of OS privileged CPU usage is {1:F2}%', N'SQL Server instance {0} - The Percentage of baseline of operating system privileged CPU usage is {1:F2}%.', N'Percentage of baseline of OS privileged CPU usage is {1:F2}% on {0}', N'Percentage of baseline of OS privileged CPU usage is {1:F2}%.')

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (28, 0, 4060, N'OS user CPU usage is {1:F2}%', N'SQL Server instance {0} - The operating system user CPU usage is {1:F2}%.', N'OS user CPU usage is {1:F2}% on {0}', N'OS user CPU usage is {1:F2}%.',
N'Percentage of baseline for OS user CPU usage is {1:F2}%', N'SQL Server instance {0} - The Percentage of baseline for operating system user CPU usage is {1:F2}%.', N'Percentage of baseline for OS user CPU usage is {1:F2}% on {0}', N'Percentage of baseline for OS user CPU usage is {1:F2}%.')

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (29, 0, 4070, N'OS processor queue length is {1}', N'SQL Server instance {0} - The operating system processor queue length is {1}.', N'OS processor queue length is {1} on {0}', N'OS processor queue length is {1}.'
, N'Percentage of baseline for OS processor queue length is {1}', N'SQL Server instance {0} - The Percentage of baseline for operating system processor queue length is {1}.', N'Percentage of baseline for OS processor queue length is {1} on {0}', N'Percentage of baseline for OS processor queue length is {1}.')

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (30, 0, 4080, N'OS disk time is currently {1:F2}%', N'SQL Server instance {0} - The operating system physical disks are {1:F2}% busy.', N'OS disk time is currently {1:F2}% on {0}', N'OS disk time is currently {1:F2}%.'
, N'Percentage of basleine of OS disk time is currently {1:F2}%', N'SQL Server instance {0} - Percentage of baseline of operating system physical disks are {1:F2}% busy.', N'Percentage of baseline of OS disk time is currently {1:F2}% on {0}', N'Percentage of baseline of OS disk time is currently {1:F2}%.')

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline])  
VALUES (31, 0, 4090, N'OS average disk queue length is {1:F2}', N'SQL Server instance {0} - The operating system average disk queue length is {1:F2}.', N'OS average disk queue length is {1:F2} on {0}', N'OS average disk queue length is {1:F2}.'
, N'Percentage of baseline of OS average disk queue length is {1:F2}', N'SQL Server instance {0} - The Percentage of baseline of operating system average disk queue length is {1:F2}.', N'Percentage of baseline of OS average disk queue length is {1:F2} on {0}', N'Percentage of baseline of OS average disk queue length is {1:F2}.')
--END: SQLdm 10.0 (Tarun Sapra)- Template for the baseline alerts

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (32, 0, 2737, N'Session CPU time is {1:F2} seconds for session {2}', N'SQL Server instance {0} - Session {2} which logged in at {3} has a cumulative CPU time of {1:F2} seconds since login. 

Last Command: {4}', N'Session CPU time is {1:F2} seconds for session {2} on {0}', N'Session CPU time is {1:F2} seconds for session {2}.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (33, 0, 2838, N'Session {3} blocking for {1} seconds, since {8}.', N'SQL Server instance {0} - Session {3} has been blocking other sessions for {1} seconds, since {8}.

The session is being run on database [{2}] with application name ''{5}'' by user ''{4}'' on host ''{6}''. 

Last command issued at {8}: 

{7}', N'Session {3} blocking for {1} seconds on {0}, from {8}', N'Session {3} blocking for {1} seconds, since {8}.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (34, 0, 2940, N'SQL Agent job ''{2}'' {10} running {3}% long', N'SQL Server instance {0} - SQL Agent job ''{2}'' started at {6} is in step ''{7}''{9} has run for {5} seconds which is {3}% longer than the average of {4} seconds.

Job Description: {8}', N'SQL Agent job ''{2}'' {10} running {3}% long on {0}', N'SQL Agent job ''{2}'' {10} running {3}% longer than average.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (35, 0, 3039, N'SQL Agent job {2} failed', N'SQL Server instance {0} - SQL Agent job {2} failed with a Sql Severity of {5}. 

This job has run {10} times and failed {11} times since {12}.  The most recent job to fail started at {3} and was in step {4} which issued the command ''{8}''.

Sql Message ID: {6} 
Message: 
{7}

Job Description: {9}', N'SQL Agent job {2} failed on {0}', N'SQL Agent job ''{2}'' failed.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (35, 1, 3039, N'SQL Agent job ''{2}'' succeeded', N'SQL Server instance {0} - SQL Agent job ''{2}'' has run successfully. 

This job last ran at {3} with a duration of {4} milliseconds.', N'SQL Agent job ''{2}'' succeeded on {0}', N'SQL Agent job ''{2}'' succeeded.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (48, 0, 4002, N'SQLdm maintenance mode ended', N'SQL Server {0} is no longer in SQL diagnostic manager maintenance mode.', N'SQLdm maintenance mode ended on {0}', N'SQLdm maintenance mode ended.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (48, 1, 4001, N'SQLdm maintenance mode started', N'SQL Server {0} is in SQL diagnostic manager maintenance mode and will be in maintenance mode until {1}.', N'SQLdm maintenance mode started on {0}', N'SQLdm maintenance mode started.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (49, 0, 4200, N'CLR configuration option  is {1}', N'SQL Server instance {0} has the CLR configuration option  {1}.', N'CLR configuration option  is {1} on {0}', N'CLR configuration option is {1}.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (50, 0, 4210, N'OLE Automation is {1}', N'SQL Server instance {0} has OLE Automation {1}.', N'OLE Automation is {1} on {0}', N'OLE Automation is {1}.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (51, 0, 4220, N'Query Monitor returned {1} statements', N'SQL Server instance {0} - Query Monitor returned {1} statements.', N'Query Monitor returned {1} statements on {0}', N'Query Monitor returned {1} statements.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (52, 0, 4230, N'SQLdm collection service is {1}', N'The SQL diagnostic manager collection service with service name {0} is {1}', N'SQLdm collection service is {1}', N'SQLdm collection service is {1}.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (52, 1, 4231, N'SQLdm management service is {2}', N'The SQL diagnostic manager management service with service name {0} is {2}', N'SQLdm management service is {2}', N'SQLdm management service is {2}.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (52, 2, 4231, N'SQLdm management service is {2}', N'The SQL diagnostic manager management service with service name {0} is {2}.  {3}', N'SQLdm management service is {2}', N'SQLdm management service is {2}.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (53, 0, 4240, N'Agent XPs are {1}', N'SQL Server instance {0} has Agent XPs {1}.', N'Agent XPs are {1} on {0}', N'Agent XPs are {1}.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (54, 0, 4250, N'WMI unavailable', N'SQL Server instance {0} - WMI is not available on the server', N'WMI unavailable on {0}', N'WMI is unavailable.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (55, 0, 4260, N'xp_cmdshell is {1}', N'SQL Server instance {0} has xp_cmdshell {1}.', N'xp_cmdshell is {1} on {0}', N'xp_cmdshell is {1}.')

--START: SQLdm 10.0 (Tarun Sapra)- Alert messaging if the metric is baselined enabled
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (57, 0, 4310, N'Client computers is {1}', N'SQL Server instance {0} has {1} client computers connected.', N'Client computers is {1} on {0}', N'Client computers is {1}.',
N'Percentage of baseline of Client computers is {1}%', N'SQL Server instance {0} has {1}% of baseline of connected client computers.', N'Percentage of baseline of Client computers is {1}% on {0}', N'Percentage of baseline of Client computers is {1}%.')

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (58, 0, 4320, N'Blocked sessions count is {1}', N'SQL Server instance {0} has {1} sessions which are blocked by other sessions.', N'Blocked sessions count is {1} on {0}', N'Blocked sessions count is {1}.',
N'Percentage of baseline of Blocked sessions count is {1}%', N'SQL Server instance {0} has {1}% of baseline of sessions which are blocked by other sessions.', N'Percentage of baseline of Blocked sessions count is {1}% on {0}', N'Percentage of baseline of Blocked sessions count is {1}%.')

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline])  
VALUES (
59, 0, 4330, N'SQL Server Data used is {1:F2}%', N'SQL Server instance {0} has {1:F2}% of the total allocated database file space in use.

If this percentage appears incorrect, you may need to run DBCC UPDATEUSAGE to have SQL Server update the information.', N'SQL Server Data used is {1:F2}% on {0}', N'SQL Server Data used is {1:F2}%.'
, N'Percentage of baseline of SQL Server Data used is {1:F2}%', N'SQL Server instance {0} has {1:F2}% of the Percentage of baseline of SQL Server Data used .

If this percentage appears incorrect, you may need to run DBCC UPDATEUSAGE to have SQL Server update the information.', N'Percentage of baseline of SQL Server Data used is {1:F2}% on {0}', N'Percentage of baseline of SQL Server Data used is {1:F2}%.'
)

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (60, 0, 4340, N'SQL Server Log used is {1:F2}%', N'SQL Server instance {0} has {1:F2}% of the total allocated database transaction log file space in use.

If this percentage appears incorrect, you may need to run DBCC UPDATEUSAGE to have SQL Server update the information.', N'SQL Server Log used is {1:F2}% on {0}', N'SQL Server Log used is {1:F2}%.'
, N'Percentage of baseline of SQL Server Log used is {1:F2}%', N'SQL Server instance {0} has {1:F2}% Percentage of baseline of SQL Server Log used.

If this percentage appears incorrect, you may need to run DBCC UPDATEUSAGE to have SQL Server update the information.', N'Percentage of baseline of SQL Server Log used is {1:F2}% on {0}', N'Percentage of baseline of SQL Server Log used is {1:F2}%.')
--END: SQLdm 10.0 (Tarun Sapra)- Alert messaging if the metric is baselined enabled

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (61, -1, 4351, N'Custom counter {2} failed', N'Collection for custom counter {2} failed.  {3}', N'Custom counter {2} failed. {3}', N'Custom counter {2} failed.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (61, 0, 4350, N'{2} is {1:F2}', N'SQL Server instance {0} - {2} is {1:F2}.', N'{2} is {1:F2}% on {0}', N'{2} is {1:F2}.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (62, 0, 4110, N'OS disk time on disk {2} is currently {1:F2}%', N'SQL Server instance {0} - The operating system disk {2} is {1:F2}% busy.', N'OS disk time on disk {2} is currently {1:F2}% on server {0}', N'OS disk time on disk {2} is currently {1:F2}%.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (63, 0, 4120, N'OS average disk queue length is {1:F2} on disk {2}', N'SQL Server instance {0} - The operating system average disk queue length is {1:F2} on disk {2}.', N'OS average disk queue length for disk {2} is {1:F2} on {0}', N'OS average disk queue length is {1:F2} on disk {2}.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (64, 0, 4100, N'Disk {2} is {1:F2}% full', N'SQL Server instance {0} - Disk {2} is {1:F2}% full.', N'Disk {2} is {1:F2}% full', N'Disk {2} is {1:F2}% full.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (65, 0, 2940, N'SQL Agent job ''{2}'' {10} running for {5} minutes', N'SQL Server instance {0} - SQL Agent job ''{2}'' started at {6} is in step ''{7}''{9} has run for {5} minutes.

Job Description: {8}', N'SQL Agent job ''{2}'' {10} running for {5} minutes on {0}', N'SQL Agent job ''{2}'' {10} running for {5} minutes.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (66, 0, 4400, N'Error log recorded {1} alertable message{3}', N'SQL Server instance {0} recorded {1} error log message{3} requiring attention.

The message{3} are shown below in context (if applicable):	
{2}', N'Error log recorded {1} alertable message{3}', N'Error log recorded {1} alertable message{3}.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (66, 1, 5300, N'Error log file size limit of {4} MB has been exceeded.', 'Error log file size limit of {4} MB has been exceeded on server {0}. Current Error Log size is {1} MB and the log is no longer being parsed. It is highly recommended that you cycle your log. You can do this from the advanced settings for the Error Log alert.', 'Error log file size limit of {4} MB has been exceeded on server {0}. Current Error Log size is {1} MB. Consider cycling the error log.', 'Error Log size exceeded.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (67, 0, 4410, N'Agent log recorded {1} alertable message{3}', N'SQL Server instance {0} recorded {1} agent log message{3} requiring attention.

The message{3} are shown below in context (if applicable):	
{2}', N'Agent log recorded {1} alertable message{3}', N'Agent log recorded {1} alertable message{3}.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (67, 1, 5310, N'Agent log file size limit limit of {4} MB has been exceeded.', 'Agent log file size limit of {4} MB has been exceeded on server {0}. Current Agent Log size is {1} MB and the log is no longer being parsed. It is highly recommended that you cycle your log. You can do this from the advanced settings for the Agent Log alert.', 'Agent log file size limit of {4} MB has been  exceeded on server {0}. Current Agent Log size is {1} MB. Consider cycling the Agent log.', 'Agent Log size exceeded.')

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (68, 0, 5105, N'Unsent Log for database [{2}] is {1} KB', N'The amount of unsent log on principal server {0} for database [{2}] is {1} KB.', N'Unsent log for database [{2}] on server {0} is {1} KB', N'Unsent Log for database [{2}] is {1} KB.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (69, 0, 5106, N'The size of the redo queue on the mirror database [{2}], server {0} is {1} KB.', N'The size of the redo queue on the mirror database [{2}], server {0} is {1} KB.', N'The size of the redo queue on the mirror database [{2}], server {0} is {1} KB.', N'The size of the redo queue on the mirror database [{2}] is {1} KB.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (70, 0, 5107, N'The oldest unsent transaction for database [{2}] is {1} minutes old.', N'The oldest unsent transaction on principal server {0} for database [{2}] is {1} minutes old.', N'The oldest unsent transaction on principal server {0} for database [{2}] is {1} minutes old.', N'The oldest unsent transaction for database [{2}] is {1} minutes old.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (71, 0, 5108, N'Mirror commit overhead for [{2}] on {0} is {1} milliseconds', N'The average delay on principal server {0} for mirroring of database [{2}] is {1} milliseconds.', N'The average delay on principal server {0} for mirroring of database [{2}] is {1} milliseconds.', N'Mirror commit overhead for database [{2}] is {1} milliseconds.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (72, 0, 5109, N'Database mirroring status for [{2}] is {1}', N'SQL Server instance {0} - Database [{2}] has a mirroring status of {1}.', N'Database mirroring status for [{2}] is {1}', N'Database mirroring status for database [{2}] is {1}.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (73, 0, 5110, N'Preferred mirroring session configuration change for database [{2}]. {1}', N'Mirroring session participant server {0}, Database [{2}] operational configuration has changed. {1}.', N'Preferred mirroring session operational configuration for server {0}, database [{2}] has changed. {1}', N'Preferred mirroring session configuration change for database [{2}]. {1}')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (74, 0, 5111, N'Database mirroring role for [{2}] has changed to {1}', N'SQL Server instance {0} - Database [{2}] has a changed to a new mirroring role of {1}.', N'Database mirroring role for [{2}] has changed to {1} on {0}', N'Database mirroring role for database [{2}] has changed to {1}.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (75, 0, 5112, N'Witness ({1}) for {0}..[{2}] is not connected.', N'Witness ({1}) for {0}..[{2}] is not connected.', N'Witness ({1}) for {0}..[{2}] is not connected.', N'Witness ({1}) for database [{2}] is not connected.')

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (76, 0, 4130, N'Page life expectancy for {0} is currently {1}.', N'Page life expectancy for {0} is currently {1}.', N'Page life expectancy for {0} is currently {1}.', N'Page Life Expectancy is {1}.'
, N'Percentage of baseline of Page life expectancy for {0} is currently {1}%.', N'Percentage of baseline of Page life expectancy for {0} is currently {1}%.', N'Percentage of baseline of Page life expectancy for {0} is currently {1}%.', N'Percentage of baseline of Page Life Expectancy is {1}%.')

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (77, 0, 4500, N'Clustered server {0} failed over from {1} to {2} at {3}', N'Clustered server {0} failed over from {1} to {2} at {3}.  The active node changed from {1} to {2}.', N'Clustered server {0} failed over from {1} to {2} at {3}', N'Clustered server failed over from {1} to {2} at {3}.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (78, 0, 4510, N'Clustered server {0} is running on node {1}', N'Clustered server {0} is running on node {1}.  The preferred node is {2}.', N'Clustered server {0} is running on node {1}', N'Clustered server is running on node {1}.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (79, 0, 5120, N'Non-distributed transaction time is {1} seconds', N'SQL Server instance {0} has non-distributed replication transactions that have been holding at the Publisher for {1} seconds.', N'Non-distributed transaction time is {1} seconds on {0}', N'Non-distributed transaction time is {1} seconds.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (80, 0, 2840, N'A deadlock occurred on server {0}', N'A deadlock occurred on server {0}.  Full details are available in the SQLdm Desktop Client.

{6}The {7}deadlock victim was spid {1} with application name ''{2}'' by user ''{3}'' on host ''{4}''. {8} 

Last command issued: 

{5}', N'A deadlock occurred on server {0}.', N'{6}The {7}deadlock victim was spid {1} with application name ''{2}'' by user ''{3}'' on host ''{4}''.')

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (81, 0, 4140, N'SQL Server procedure cache hit ratio is {1:F2}%', N'The ratio of procedure cache hits to lookups is {1:F2}% for SQL Server instance {0}.', N'Procedure cache hit ratio is {1:F2}% on {0}', N'SQL Server procedure cache hit ratio is {1:F2}%.'
, N'Percentage of baseline of SQL Server procedure cache hit ratio is {1:F2}%', N'The Percentage of baseline of SQL Server procedure cache hit ratio is {1:F2}% for SQL Server instance {0}.', N'Percentage of baseline of Procedure cache hit ratio is {1:F2}% on {0}', N'Percentage of baseline of SQL Server procedure cache hit ratio is {1:F2}%.')

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (82, 0, 4150, N'Average disk milliseconds per read is {1} for the {2} drive of {0}', N'The average time of a read operation from disk on the {2} drive of SQL Server instance {0} is {1} ms.', N'Average disk milliseconds per read is {1} for the {2} drive', N'Average disk milliseconds per read is {1} for the {2} drive.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (83, 0, 4160, N'Average disk milliseconds per transfer is {1} for the {2} drive of {0}', N'The average time of a disk transfer operation on the {2} drive of SQL Server instance {0} is {1} ms.', N'Average disk milliseconds per transfer is {1} for the {2} drive', N'Average disk milliseconds per transfer is {1} for the {2} drive.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (84, 0, 4170, N'Average disk milliseconds per write is {1} for the {2} drive of {0}', N'The average time of a write operation to disk on the {2} drive of SQL Server instance {0} is {1} ms.', N'Average disk milliseconds per write is {1} for the {2} drive', N'Average disk milliseconds per write is {1} for the {2} drive.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (85, 0, 4180, N'The rate of disk reads per second is {1:F2} for the {2} drive of {0}', N'The rate of reads on the {2} drive of SQL Server instance {0} is {1:F2} reads per second.', N'Disk reads per second is {1:F2} for the {2} drive', N'The rate of disk reads per second is {1:F2} for the {2} drive.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (86, 0, 4185, N'The rate of disk transfers per second {1:F2} for the {2} drive of {0}', N'The rate of transfers on the {2} drive of SQL Server instance {0} is {1:F2} transfers per second.', N'Disk transfers per second is {1:F2} for the {2} drive', N'The rate of disk transfers per second {1:F2} for the {2} drive.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (87, 0, 4190, N'The rate of disk writes per second {1:F2} for the {2} drive of {0}', N'The rate of writes on the {2} drive of SQL Server instance {0} is {1:F2} writes per second.', N'Disk writes per second is {1:F2} for the {2} drive', N'The rate of disk writes per second {1:F2} for the {2} drive.')
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (88, 0, 3140, N'SQL Agent job {2} completed with a status of ''{3}''.', N'SQL Server Instance {0} - SQL Agent job {2} completed with a status of ''{3}'' at {4}.
	The most recent run of this job started at {5} and completed with the message ''{6}''.
	Since {7} this job {8}had the following statistics.
		Completed successfully {9} times,
		Retried {10} times,
		Failed {11} times,
		Canceled {12} times.', N'SQL Agent job {2} completed with a status of ''{3}''', N'SQL Agent job {2} completed with a status of ''{3}''.')
		
declare 
@MessageID int
,@EventID bigint -- For messages dll
,@HeaderTemplate nvarchar(256)
,@BodyTemplate nvarchar(512)
,@TodoTemplate nvarchar(512)
,@PulseTemplate nvarchar(256)	
--SQLdm 10.0 (Tarun Sapra)- Alert msg in case baseline alerts are enabled
,@HeaderTemplate_Baseline nvarchar(256)
,@BodyTemplate_Baseline nvarchar(512)
,@TodoTemplate_Baseline nvarchar(512)
,@PulseTemplate_Baseline nvarchar(256)		
--SQLdm 10.0 (Tarun Sapra)- Alert msg in case baseline alerts are enabled

-- 89 - Version Store Generation Rate
select
@Metric = 89
,@MessageID = 0
,@EventID = 5130
,@HeaderTemplate = N'Version store generation rate is {1:F1}% {6} than cleanup.'
,@BodyTemplate = N'The tempdb version store generation rate is {1:F1}% {6} than the cleanup rate on {0}.

The current generation rate is {2:F2} kilobytes per second and the current cleanup rate is {3:F2} kilobytes per second.  The version store size is {4:F0} MB and tempdb file size is {5:F0} MB.'
,@TodoTemplate = N'Version store generation rate is {1:F1}% {6} than cleanup on {0}.'
,@PulseTemplate = N'Version store generation rate is {1:F1}% {6} than cleanup.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

select
@Metric = 89
,@MessageID = 1
,@EventID = 5130
,@HeaderTemplate = N'Version store generation is occurring without cleanup.'
,@BodyTemplate = N'New version data is being generated in the tempdb version store but cleanup is not occurring.

The current generation rate is {2:F2} kilobytes per second and the current cleanup rate is {3:F2} kilobytes per second.  The version store size is {4:F0} MB and tempdb file size is {5:F0} MB.'
,@TodoTemplate = N'Version store generation is occurring without cleanup on {0}.'
,@PulseTemplate = N'Version store generation is occurring without cleanup.'
		
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)
		
-- 90 - Version Store Size
select
@Metric = 90
,@MessageID = 0
,@EventID = 5131
,@HeaderTemplate = N'The tempdb version store is using {1:F1} MB'
,@BodyTemplate = N'The tempdb version store is using {1:F1} MB on {0}.

The current generation rate is {2:F2} kilobytes per second and the current cleanup rate is {3:F2} kilobytes per second.  The total tempdb file size is {5:F0} MB.'
,@TodoTemplate = N'The tempdb version store is using {1:F1} MB on {0}.'
,@PulseTemplate = N'The tempdb version store is using {1:F1} MB'
		
		
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

-- 91 - Longest Running Version Store Transaction
select
@Metric = 91
,@MessageID = 0
,@EventID = 5135
,@HeaderTemplate = N'A transaction in session id {12} has been utilizing the version store for {1} minute{6}.'
,@BodyTemplate = N'A transaction has been utilizing the version store for {1} minute{6} on {0}. 

Long running version store transactions prevent cleanup of the version store. Left unresolved this can cause tempdb autogrowth or fill tempdb entirely. The current version generation rate is {2:F2} KB/sec and the cleanup rate is {3:F2} KB/sec.  The version store size is {4:F0} MB and tempdb file size is {5:F0} MB.

Session ID: {12}
Database: {7} 
Application Name: {8} 
User: {9}
Host: {10}
Last command issued: 

{11}'
,@TodoTemplate = N'A transaction in session id {12} has been utilizing the version store for {1} minute{6} on {0}.'
,@PulseTemplate = N'A transaction in session id {12} has been utilizing the version store for {1} minute{6}.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

		
select
@Metric = 91
,@MessageID = 1
,@EventID = 5135
,@HeaderTemplate = N'No transactions are currently utilizing the version store.'
,@BodyTemplate = N'No transactions are currently utilizing the version store.

The current version generation rate is {2:F2} kilobytes per second and the current cleanup rate is {3:F2} kilobytes per second.  The version store size is {4:F0} MB and tempdb file size is {5:F0} MB.'
,@TodoTemplate = N'No transactions are currently utilizing the version store.'
,@PulseTemplate = N'No transactions are currently utilizing the version store.'
		
	
		
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

-- 92 - Session Tempdb Space Usage

select
@Metric = 92
,@MessageID = 0
,@EventID = 5136
,@HeaderTemplate = N'Session id {19} on {2} is using {1} of space in tempdb.'
,@BodyTemplate = N'A session is using {1} of space in tempdb on {0}.

Session User Space: {7} (Allocated: {8}/ Deallocated: {9})
Session Internal Space: {10} (Allocated: {11}/ Deallocated: {12})

Task User Space: {13} (Allocated: {14}/ Deallocated: {15})
Task Internal Space: {16} (Allocated: {17}/ Deallocated: {18})

The session is being run on database [{2}] with application name ''{3}'' by user ''{4}'' on host ''{5}''.  The session id is {19}.

Last command issued: 

{6}'
,@TodoTemplate = N'Session id {19} on {2} is using {1} MB of space in tempdb.'
,@PulseTemplate = N'Session id {19} on {2} is using {1} MB of space in tempdb.'
		
		
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)



select
@Metric = 92
,@MessageID = 1
,@EventID = 5136
,@HeaderTemplate = N'Session id {19} is no longer using space in tempdb.'
,@BodyTemplate = N'Session id {19} is no longer using space in tempdb.'
,@TodoTemplate = N'Session id {19} is no longer using space in tempdb.'
,@PulseTemplate = N'Session id {19} is no longer using space in tempdb.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

-- 93 - Tempdb Contention

select
@Metric = 93
,@MessageID = 0
,@EventID = 5132
,@HeaderTemplate = N'Tempdb contention has been detected: wait time is {1} ms.'
,@BodyTemplate = N'Tempdb latch contention has been detected on {0}.  The total wait time detected is {1} milliseconds.  This is an indication that performance is being impacted by contention on allocation maps in tempdb. If this is a regular problem it may be alleviated by following best practices with respect to tempdb file count, size, and IO subsystem.

PFS Wait Time: {2} ms
GAM Wait Time: {3} ms
SGAM Wait Time: {4} ms'
,@TodoTemplate = N'Tempdb contention has been detected: wait time is {1} ms.'
,@PulseTemplate = N'Tempdb contention has been detected: wait time is {1} ms.'
		
		
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

select
@Metric = 93
,@MessageID = 1
,@EventID = 5132
,@HeaderTemplate = N'No tempdb contention detected.

PFS Wait Time: {2} ms
GAM Wait Time: {3} ms
SGAM Wait Time: {4} ms'
,@BodyTemplate = N'No tempdb contention detected.'
,@TodoTemplate = N'No tempdb contention detected.'
,@PulseTemplate = N'No tempdb contention detected.'
		
		
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

-- 94 - Log Autogrow
select
@Metric = 94
,@MessageID = 0
,@EventID = 1115
,@HeaderTemplate = N'Log file autogrow occurred on database {1}.'
,@BodyTemplate = N'Log file autogrow occurred on database {1}.'
,@TodoTemplate = N'Log file autogrow occurred on database {1}.'
,@PulseTemplate = N'Log file autogrow occurred on database {1}.'
		
		
INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

-- 95 - Data Autogrow
select
@Metric = 95
,@MessageID = 0
,@EventID = 1116
,@HeaderTemplate = N'Data file autogrow occurred on database {1}.'
,@BodyTemplate = N'Data file autogrow occurred on database {1}.'
,@TodoTemplate = N'Data file autogrow occurred on database {1}.'
,@PulseTemplate = N'Data file autogrow occurred on database {1}.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

-- 96 - VM Config Change

select
@Metric = 96
,@MessageID = 0
,@EventID = 5200
,@HeaderTemplate = N'A configuration change occurred on the virtual machine hosting {0}.'
,@BodyTemplate = N'A configuration change occurred on the virtual machine hosting {0}.  

Configuration (Previous --> Current):
CPU Count: {1} --> {2}
CPU Limit (MHz): {3} --> {4}
CPU Reservation (MHz): {5} --> {6}
Memory (MB): {7} --> {8} 
Memory Limit (MB): {9} --> {10}
Memory Reservation (MB): {11} --> {12}'
,@TodoTemplate = N'A configuration change occurred on the virtual machine hosting {0}.'
,@PulseTemplate = N'A configuration change occurred on the virtual machine hosting {0}.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)


-- 97 - VM Host Server Change

select
@Metric = 97
,@MessageID = 0
,@EventID = 5201
,@HeaderTemplate = N'The virtual machine hosting {0} has been moved to {1}.'
,@BodyTemplate = N'The virtual machine hosting {0} was moved from {2} to {1}.  

Configuration of the new host:
# of Physical CPUs: {3}
CPU Speed (MHz): {4}
Memory (GB): {5}
CPU Utilization %: {6}
Memory Utilization %: {7}'
,@TodoTemplate = N'The virtual machine hosting {0} has been moved to {1}.'
,@PulseTemplate = N'The virtual machine hosting {0} has been moved to {1}.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

--START: SQLdm 10.0 (Tarun Sapra)- Alert messaging in case alerts are configured on alerts
-- 98 - VM CPU Utilization
select
@Metric = 98
,@MessageID = 0
,@EventID = 5202
,@HeaderTemplate = N'vCPU usage is {1:F2}%'
,@BodyTemplate = N'SQL Server instance {0} is currently using {1:F2}% of the virtual CPU for its VM.'
,@TodoTemplate = N'vCPU usage is {1:F2}%'
,@PulseTemplate = N'vCPU usage is {1:F2}%'
,@HeaderTemplate_Baseline = N'Percentage of baseline of vCPU usage is {1:F2}%'
,@BodyTemplate_Baseline = N'SQL Server instance {0} is currently using {1:F2}% of baseline of vCPU usage.'
,@TodoTemplate_Baseline = N'Percentage of baseline of vCPU usage is {1:F2}%'
,@PulseTemplate_Baseline = N'Percentage of baseline of vCPU usage is {1:F2}%'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate,@HeaderTemplate_Baseline,@BodyTemplate_Baseline,@TodoTemplate_Baseline,@PulseTemplate_Baseline)
--END: SQLdm 10.0 (Tarun Sapra)- Alert messaging in case alerts are configured on alerts

-- 99 - ESX CPU Utilization

select
@Metric = 99
,@MessageID = 0
,@EventID = 5250
,@HeaderTemplate = N'CPU usage for Host server {2} is {1:F2}%'
,@BodyTemplate = N'CPU Usage for the Host hosting the VM for {0} is currently at {1:F2}%.'
,@TodoTemplate = N'CPU usage for Host server {2} is {1:F2}%'
,@PulseTemplate = N'CPU usage for Host server {2} is {1:F2}%'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)


-- 100 - VM Memory Utilization

select
@Metric = 100
,@MessageID = 0
,@EventID = 5203
,@HeaderTemplate = N'Memory usage for the VM hosting {0} is at {1:F2}%'
,@BodyTemplate = N'Memory usage for the VM hosting {0} is currently at {1:F2}%.'
,@TodoTemplate = N'Memory usage for the VM hosting {0} is at {1:F2}%'
,@PulseTemplate = N'Memory usage for the VM hosting {0} is at {1:F2}%'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)


-- 101 - ESX Memory Usage (Percent)

select
@Metric = 101
,@MessageID = 0
,@EventID = 5251
,@HeaderTemplate = N'Memory usage for host server {2} is at {1:F2}%'
,@BodyTemplate = N'Memory usage for the Host hosting the VM for {0} is currently at {1:F2}%.'
,@TodoTemplate = N'Memory usage for host server {2} is at {1:F2}%'
,@PulseTemplate = N'Memory usage for host server {2} is at {1:F2}%'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)


-- 102 - VM CPU Ready Wait Time

select
@Metric = 102
,@MessageID = 0
,@EventID = 5204
,@HeaderTemplate = N'vCPU Ready Time for the VM hosting {0} is at {1} ms'
,@BodyTemplate = N'The virtual CPU for the VM hosting {0} has been waiting for {1} ms for a physical processor on {2} to become available.  This could be an indicator that the CPU for {2} is over committed.'
,@TodoTemplate = N'vCPU Ready Time for the VM hosting {0} is at {1} ms'
,@PulseTemplate = N'vCPU Ready Time for the VM hosting {0} is at {1} ms'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)


-- 103 - VM Reclaimed/Ballooned Memory (KB)

select
@Metric = 103
,@MessageID = 0
,@EventID = 5205
,@HeaderTemplate = N'Ballooned Memory for the VM hosting {0} is at {1} KB'
,@BodyTemplate = N'The Host ({2}) has reclaimed {1} KB of available memory from the VM hosting {0}.  This generally indicates that {2} is under memory pressure and this could ultimately impact the performance of {0}.'
,@TodoTemplate = N'Ballooned Memory for the VM hosting {0} is at {1} KB'
,@PulseTemplate = N'Ballooned Memory for the VM hosting {0} is at {1} KB'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)


-- 104 - VM Memory Swap Delay Detected

select
@Metric = 104
,@MessageID = 0
,@EventID = 5206
,@HeaderTemplate = N'VM hosting {0} is actively swapping memory'
,@BodyTemplate = N'The VM hosting {0} is actively swapping memory.  Memory swapping impacts performance for the VM because processing halts as data is swapped from disk to active memory.'
,@TodoTemplate = N'VM hosting {0} is actively swapping memory'
,@PulseTemplate = N'VM hosting {0} is actively swapping memory'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)


-- 105 - ESX Memory Swap Detected

select
@Metric = 105
,@MessageID = 0
,@EventID = 5252
,@HeaderTemplate = N'Host {1} is actively swapping memory'
,@BodyTemplate = N'The Host server that hosts the VM that is hosting {0} is actively swapping memory.  The VM hosting {0} may not actually be actively swapping memory, but other VMs on {1} are, which could tie up resources needed by the VM hosting {0}.'
,@TodoTemplate = N'Host {1} is actively swapping memory'
,@PulseTemplate = N'Host {1} is actively swapping memory'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

-- 106 - VM Resource Limits Detected

select
@Metric = 106
,@MessageID = 0
,@EventID = 5207
,@HeaderTemplate = N'Resource limits detected in the VM configuration'
,@BodyTemplate = N'Resource limits have been detected within the configuration of the VM running {0}.  

Resource limits are often used to throttle CPU or Memory resources using soft limits on the amount of memory or CPU processing power a VM can consume.

The CPU Limit is {1} MHz
The Memory Limit is {2} MB'
,@TodoTemplate = N'Resource limits detected in the VM configuration'
,@PulseTemplate = N'Resource limits detected in the VM configuration'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

-- 107 - VM Overall State

select
@Metric = 107
,@MessageID = 0
,@EventID = 5208
,@HeaderTemplate = N'The VM running {0} is {1}.'
,@BodyTemplate = N'The virtual machine that {0} is running on is {1}.  Check your vCenter or HyperV host servers or contact your VM Administrator for further action if necessary.'
,@TodoTemplate = N'The VM running {0} is {1}.'
,@PulseTemplate = N'The VM running {0} is {1}.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

-- 108 - ESX Overall State

select
@Metric = 108
,@MessageID = 0
,@EventID = 5253
,@HeaderTemplate = N'The Host server hosting the VM for {0} is {1}.'
,@BodyTemplate = N'The Host server that hosts the VM for {0} is {1}.  Check your vCenter or HyperV host servers or contact your VM Administrator for further action if necessary.'
,@TodoTemplate = N'The Host server hosting the VM for {0} is {1}.'
,@PulseTemplate = N'The Host server hosting the VM for {0} is {1}.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

-- 109 - Database Size
select
@Metric = 109
,@MessageID = 0
,@EventID = 1113
,@HeaderTemplate = N'The {2} database has grown to {1:F2} {3}.'
,@BodyTemplate = N'SQL Server Instance {0} - Database {2} has data files that have grown to {1:F2} {3} in size.

- If this size appears incorrect, you may need to run DBCC UPDATEUSAGE to have SQL Server update the information for this database.'
,@TodoTemplate = N'The {2} database has grown to {1:F2} {3}.'
,@PulseTemplate = N'The {2} database has grown to {1:F2} {3}.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)


-- 110 - Log File Size
select
@Metric = 110
,@MessageID = 0
,@EventID = 1214
,@HeaderTemplate = N'The log file for the {2} database has grown to {1:F2} {3}.'
,@BodyTemplate = N'SQL Server Instance {0} - Database {2} has transaction log files that have grown to {1:F2} {3} in size.

- If this size appears incorrect, you may need to run DBCC UPDATEUSAGE to have SQL Server update the information for this database.'
,@TodoTemplate = N'The log file for the {2} database has grown to {1:F2} {3}.'
,@PulseTemplate = N'The log file for the {2} database has grown to {1:F2} {3}.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)


-- 111 - OS Disk Used
select
@Metric = 111
,@MessageID = 0
,@EventID = 4101
,@HeaderTemplate = N'Disk {2} has {1:F2} {3} of unused space remaining.'
,@BodyTemplate = N'SQL Server instance {0} - Disk {2} contains {4:F2} {5} of data and has {1:F2} {3} of unused disk space remaining.'
,@TodoTemplate = N'Disk {2} has {1:F2} {3} of unused space remaining.'
,@PulseTemplate = N'Disk {2} has {1:F2} {3} of unused space remaining.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

---- 112 - SQLsafe Backup Operation Status
--select
--@Metric = 112
--,@MessageID = 0
--,@EventID = 4101
--,@HeaderTemplate = N'SQLsafe Backup Operation for {1} has {2}'
--,@BodyTemplate = N'A SQLsafe backup operation for database {1} on SQL Server instance {0} completed with a status of {2}.

--The SQLsafe result text is ''{3}'''
--,@TodoTemplate = N'SQLsafe Backup Operation for {1} has {2}'
--,@PulseTemplate = N'SQLsafe Backup Operation for {1} has {2}'

--INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

---- 113 - SQLsafe Restore Operation Status
--select
--@Metric = 113
--,@MessageID = 0
--,@EventID = 4101
--,@HeaderTemplate = N'SQLsafe Restore Operation for {1} has {2}'
--,@BodyTemplate = N'A SQLsafe restore operation for database {1} on SQL Server instance {0} completed with a status of {2}.

--The SQLsafe result text is ''{3}'''
--,@TodoTemplate = N'SQLsafe Restore Operation for {1} has {2}'
--,@PulseTemplate = N'SQLsafe Restore Operation for {1} has {2}'

--INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

---- 114 - SQLsafe Defrag Operation Status
--select
--@Metric = 114
--,@MessageID = 0
--,@EventID = 4101
--,@HeaderTemplate = N'SQLsafe Defragmentation Operation for {1} has {2}'
--,@BodyTemplate = N'A SQLsafe Defragmention operation on index/partition {3} in database {1} has {2}. 
--Listed below are the stats of the objects included in this options
--{4}'
--,@TodoTemplate = N'SQLsafe Defragmentation Operation for {1} has {2}'
--,@PulseTemplate = N'SQLsafe Defragmentation Operation for {1} has {2}'

--INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

---- 115 - SQLsafe Connection Status
--select
--@Metric = 115
--,@MessageID = 0
--,@EventID = 4101
--,@HeaderTemplate = N'A connection to the SQLsafe repository could not be made'
--,@BodyTemplate = N'A connection attempt was made to connect to the SQLsafe repository on {1} at {2}.  The connection attempt failed with the following error:
--{3}'
--,@TodoTemplate =N'A connection to the SQLsafe repository could not be made'
--,@PulseTemplate = N'A connection to the SQLsafe repository could not be made'

--INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)



-- 116 - Availability Group Role Change 
select
@Metric = 116
,@MessageID = 0
,@EventID = 5301
,@HeaderTemplate = N'Role changed for replica {0} from {1} to {2}.'
,@BodyTemplate = N'Role changed for replica {0} from {1} to {2}. Affected database(s): {3}'
,@TodoTemplate = N'Role changed for replica {0} from {1} to {2}.'
,@PulseTemplate = N'Role changed for replica {0} from {1} to {2}.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)


--START: SQLdm 10.0 (Tarun Sapra)- Alert messaging if baseline alerts are enabled
-- 117 - Availability Group Estimated Data Loss (Seconds)
select
@Metric = 117
,@MessageID = 0
,@EventID = 5302
,@HeaderTemplate = N'The data is not synchronized to the secondary replica since {0} seconds'
,@BodyTemplate = N'The data is not synchronized to the secondary replica since {0} seconds. Affected database(s): {1}'
,@TodoTemplate = N'The data is not synchronized to the secondary replica since {0} seconds'
,@PulseTemplate = N'The data is not synchronized to the secondary replica since {0} seconds'
,@HeaderTemplate_Baseline = N'Percentage of baseline of Availability Group Estimated Data Loss is {0}%'
,@BodyTemplate_Baseline = N'Percentage of baseline of Availability Group Estimated Data Loss is {0}%. Affected database(s): {1}'
,@TodoTemplate_Baseline = N'Percentage of baseline of Availability Group Estimated Data Loss is {0}%'
,@PulseTemplate_Baseline = N'Percentage of baseline of Availability Group Estimated Data Loss is {0}%'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate,@HeaderTemplate_Baseline,@BodyTemplate_Baseline,@TodoTemplate_Baseline,@PulseTemplate_Baseline)
--END: SQLdm 10.0 (Tarun Sapra)- Alert messaging if baseline alerts are enabled

-- 118 - Availability Group Synchronization Health 
select
@Metric = 118
,@MessageID = 0
,@EventID = 5303
,@HeaderTemplate = N'The synchronization state of the database {2} in the availability group {0} for replica {3} is {1} healthy.'
,@BodyTemplate = N'The synchronization state of the database {2} in the availability group {0} for replica {3} is {1} healthy.'
,@TodoTemplate = N'The synchronization state of the database {2} in the availability group {0} for replica {3} is {1} healthy.'
,@PulseTemplate = N'The synchronization state of the database {2} in the availability group {0} for replica {3} is {1} healthy.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)


-- 119 - Availability Group Estimated Recovery Time (Seconds)
select
@Metric = 119
,@MessageID = 0
,@EventID = 5304
,@HeaderTemplate = N'{0} seconds required to recover the estimated data loss.'
,@BodyTemplate = N'{0} seconds required to recover the estimated data loss. Affected database(s): {1}'
,@TodoTemplate = N'{0} seconds required to recover the estimated data loss.'
,@PulseTemplate = N'{0} seconds required to recover the estimated data loss.'
,@HeaderTemplate_Baseline = N'Percentage of baseline Availability Group Estimated Recovery Time is {0}%.'
,@BodyTemplate_Baseline = N'Percentage of baseline Availability Group Estimated Recovery Time is {0}%. Affected database(s): {1}'
,@TodoTemplate_Baseline = N'Percentage of baseline Availability Group Estimated Recovery Time is {0}%.'
,@PulseTemplate_Baseline = N'Percentage of baseline Availability Group Estimated Recovery Time is {0}%.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate,@HeaderTemplate_Baseline,@BodyTemplate_Baseline,@TodoTemplate_Baseline,@PulseTemplate_Baseline)

-- 120 - Availability Group Synchronization Performance (seconds)
select
@Metric = 120
,@MessageID = 0
,@EventID = 5305
,@HeaderTemplate = N'{0} seconds required to synchronize the database {1} in replica {2}.'
,@BodyTemplate = N'{0} seconds required to synchronize the database {1} in replica {2}.'
,@TodoTemplate = N'{0} seconds required to synchronize the database {1} in replica {2}.'
,@PulseTemplate = N'{0} seconds required to synchronize the database {1} in replica {2}.'
,@HeaderTemplate_Baseline = N'Percentage of baseline of Availability Group Synchronization Performance is {0}%, while synchronizing the database {1} in replica {2}.'
,@BodyTemplate_Baseline = N'Percentage of baseline of Availability Group Synchronization Performance is {0}%, while synchronizing the database {1} in replica {2}.'
,@TodoTemplate_Baseline = N'Percentage of baseline of Availability Group Synchronization Performance is {0}%, while synchronizing the database {1} in replica {2}.'
,@PulseTemplate_Baseline = N'Percentage of baseline of Availability Group Synchronization Performance is {0}%, while synchronizing the database {1} in replica {2}.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate,@HeaderTemplate_Baseline,@BodyTemplate_Baseline,@TodoTemplate_Baseline,@PulseTemplate_Baseline)

-- 121 - Availability Group Log Send Queue Size (KB)
select
@Metric = 121
,@MessageID = 0
,@EventID = 5306
,@HeaderTemplate = N'The log send queue size for the {0} replica has grown to {1} KB.'
,@BodyTemplate = N'The log send queue size for the {0} replica has grown to {1} KB. Affected database(s): {2}'
,@TodoTemplate = N'The log send queue size for the {0} replica has grown to {1} KB.'
,@PulseTemplate = N'The log send queue size for the {0} replica has grown to {1} KB.'
,@HeaderTemplate_Baseline = N'For the {0} replica, Percentage of baseline of Availability Group Log Send Queue Size is {1}%.'
,@BodyTemplate_Baseline = N'For the {0} replica, Percentage of baseline of Availability Group Log Send Queue Size is {1}%. Affected database(s): {2}'
,@TodoTemplate_Baseline = N'For the {0} replica, Percentage of baseline of Availability Group Log Send Queue Size is {1}%.'
,@PulseTemplate_Baseline = N'For the {0} replica, Percentage of baseline of Availability Group Log Send Queue Size is {1}%.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate,@HeaderTemplate_Baseline,@BodyTemplate_Baseline,@TodoTemplate_Baseline,@PulseTemplate_Baseline)


-- 122 - Availability Group Redo Queue Size (KB) 
select
@Metric = 122
,@MessageID = 0
,@EventID = 5307
,@HeaderTemplate = N'The redo queue size for the {0} replica has grown to {1} KB.'
,@BodyTemplate = N'The redo queue size for the {0} replica has grown to {1} KB. Affected database(s): {2}'
,@TodoTemplate = N'The redo queue size for the {0} replica has grown to {1} KB.'
,@PulseTemplate = N'The redo queue size for the {0} replica has grown to {1} KB.'
,@HeaderTemplate_Baseline = N'For the {0} replica, Percentage of baseline of Availability Group Redo Queue Size is {1}%.'
,@BodyTemplate_Baseline = N'For the {0} replica, Percentage of baseline of Availability Group Redo Queue Size is {1}%. Affected database(s): {2}'
,@TodoTemplate_Baseline = N'For the {0} replica, Percentage of baseline of Availability Group Redo Queue Size is {1}%.'
,@PulseTemplate_Baseline = N'For the {0} replica, Percentage of baseline of Availability Group Redo Queue Size is {1}%.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate,@HeaderTemplate_Baseline,@BodyTemplate_Baseline,@TodoTemplate_Baseline,@PulseTemplate_Baseline)


-- 123 - Availability Group Redo Rate (KB/sec) 
select
@Metric = 123
,@MessageID = 0
,@EventID = 5308
,@HeaderTemplate = N'The redo logs synchronization rate for the {0} replica has reduced to {1} KB/s.'
,@BodyTemplate = N'The redo logs synchronization rate for the {0} replica has reduced to {1} KB/s. Affected database(s): {2}'
,@TodoTemplate = N'The redo logs synchronization rate for the {0} replica has reduced to {1} KB/s.'
,@PulseTemplate = N'The redo logs synchronization rate for the {0} replica has reduced to {1} KB/s.'
,@HeaderTemplate_Baseline = N'For the {0} replica , Percentage of baseline of Availability Group Redo Rate is {1}%.'
,@BodyTemplate_Baseline = N'For the {0} replica , Percentage of baseline of Availability Group Redo Rate is {1}%. Affected database(s): {2}'
,@TodoTemplate_Baseline = N'For the {0} replica , Percentage of baseline of Availability Group Redo Rate is {1}%.'
,@PulseTemplate_Baseline = N'For the {0} replica , Percentage of baseline of Availability Group Redo Rate is {1}%.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate], [HeaderTemplate_Baseline], [BodyTemplate_Baseline], [TodoTemplate_Baseline], [PulseTemplate_Baseline]) 
VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate,@HeaderTemplate_Baseline,@BodyTemplate_Baseline,@TodoTemplate_Baseline,@PulseTemplate_Baseline)

-- 124 - Preferred Node Unavailability
select
@Metric = 124
,@MessageID = 0
,@EventID = 5320
,@HeaderTemplate = N'Database [{2}] is no longer on the preferred replica.'
,@BodyTemplate =   N'Database [{2}] is no longer on the preferred replica, [{0}] .' -- SQLdm 8.6 (Ankit Srivastava) - fixed defect DE43718
,@TodoTemplate =   N'Database [{2}] is no longer on the preferred replica, [{0}] .'
,@PulseTemplate =  N'Database [{2}] is no longer on the preferred replica, [{0}] .'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

--SQLdm 8.6 (Ankit Srivastava) - Preferred Node Feature -- added another message  for available  scenario
select
@Metric = 124
,@MessageID = 1
,@EventID = 5322
,@HeaderTemplate = N'Database [{2}] is back on the preferred replica.' -- SQLdm 8.6 (Ankit Srivastava) - fixed defect DE43718
,@BodyTemplate =   N'Preferred Replica Server [{0}] for database [{2}] is back as the primary replica now.'
,@TodoTemplate =   N'Preferred Replica Server [{0}] for database [{2}] is back as the primary replica now.'
,@PulseTemplate =  N'Preferred Replica Server [{0}] for database [{2}] is back as the primary replica now.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

-- start- SQLdm 9.0 (Ankit Srivastava) -- Added messages for new metric  Grooming Timed Out
select
@Metric =125
,@MessageID = 0
,@EventID = 5324
,@HeaderTemplate = N'SQLdm Repository grooming for [{0}] timed out.'
,@BodyTemplate =   N'SQLdm Repository grooming for [{0}] timed out.{1:Therefore the instances could not be groomed are:;; } {2}'
,@TodoTemplate =   N'SQLdm Repository grooming for [{0}] timed out.{1:Therefore the instances could not be groomed are:;; } {2}'
,@PulseTemplate =  N'SQLdm Repository grooming for [{0}] timed out.{1:Therefore the instances could not be groomed are:;; } {2}'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

select
@Metric =125
,@MessageID = 1
,@EventID = 5326
,@HeaderTemplate = N'SQLdm Repository grooming for [{0}] Completed successfully.'
,@BodyTemplate =   N'SQLdm Repository grooming for [{0}] Completed successfully.'
,@TodoTemplate =   N'SQLdm Repository grooming for [{0}] Completed successfully.'
,@PulseTemplate =  N'SQLdm Repository grooming for [{0}] Completed successfully.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)
-- end- SQLdm 9.0 (Ankit Srivastava) -- Added messages for new metric  Grooming Timed Out

--START: SQLdm 9.1 (Abhishek Joshi) -Filegroup and Mount Point Monitoring improvements --Added alert messages for new metrices for filegroup space full alerts

-- 126 - Filegroup Space Full (Percent)
select
@Metric = 126
,@MessageID = 0
,@EventID = 5328
,@HeaderTemplate = N'File group is {1:F2}% full for database {2}'
,@BodyTemplate = N'SQL Server instance {0} - Database [{2}] has a file group [{4}] that is {1:F2}% full.

If this percentage appears incorrect, you may need to run DBCC UPDATEUSAGE to have SQL Server update the information.'
,@TodoTemplate = N'File group is {1:F2}% full for database [{2}] on {0}'
,@PulseTemplate = N'File group is {1:F2}% full for database [{2}]'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

-- 127 - Filegroup Space Full (Size)
select
@Metric = 127
,@MessageID = 0
,@EventID = 5330
,@HeaderTemplate = N'The {2} database has grown to {1:F2} {3}'
,@BodyTemplate = N'SQL Server Instance {0} - Database {2} has a file group [{4}] that has grown to {1:F2} {3} in size.

If this size appears incorrect, you may need to run DBCC UPDATEUSAGE to have SQL Server update the information for this database.'
,@TodoTemplate = N'The {2} database has grown to {1:F2} {3}.'
,@PulseTemplate = N'The {2} database has grown to {1:F2} {3}'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

--END: SQLdm 9.1 (Abhishek Joshi) -Filegroup and Mount Point Monitoring improvements --Added alert messages for new metrices for filegroup space full alerts

-- START: SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --add messages for the new service alerts

-- 128 - SQL Browser Service Status
select
@Metric = 128
,@MessageID = 0
,@EventID = 5332
,@HeaderTemplate = N'SQL Server Browser running'
,@BodyTemplate = N'SQL Server instance {0} - The SQL Server Browser service is running.'
,@TodoTemplate = N'SQL Browser running on {0}'
,@PulseTemplate = N'SQL Browser is running.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

select
@Metric = 128
,@MessageID = 1
,@EventID = 5334
,@HeaderTemplate = N'SQL Server Browser paused'
,@BodyTemplate = N'SQL Server instance {0} - The SQL Server Browser service is paused.'
,@TodoTemplate = N'SQL Server Browser paused on {0}'
,@PulseTemplate = N'SQL Server Browser is paused.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

select
@Metric = 128
,@MessageID = 2
,@EventID = 5336
,@HeaderTemplate = N'SQL Server Browser stopped'
,@BodyTemplate = N'SQL Server instance {0} - The SQL Browser service is stopped.'
,@TodoTemplate = N'SQL Server Browser stopped on {0}'
,@PulseTemplate = N'SQL Server Browser is stopped.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

select
@Metric = 128
,@MessageID = 3
,@EventID = 5338
,@HeaderTemplate = N'SQL Browser is {1}'
,@BodyTemplate = N'SQL Server instance {0} - The SQL Browser service has a status of {1}.'
,@TodoTemplate = N'SQL Browser is {1} on {0}'
,@PulseTemplate = N'SQL Browser is {1}.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

select
@Metric = 128
,@MessageID = 4
,@EventID = 5340
,@HeaderTemplate = N'SQL Browser status: {1}'
,@BodyTemplate = N'SQL Server instance {0} - The SQL Browser service status is: {1}. 

{3}'
,@TodoTemplate = N'SQL Browser is: {1} on {0}'
,@PulseTemplate = N'SQL Browser status is {1}.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

-- 129 - SQL Active Directory Helper Service Status
select
@Metric = 129
,@MessageID = 0
,@EventID = 5342
,@HeaderTemplate = N'SQL Server Active Directory Helper running'
,@BodyTemplate = N'SQL Server instance {0} - The SQL Active Directory Helper service is running.'
,@TodoTemplate = N'SQL Server Active Directory Helper running on {0}'
,@PulseTemplate = N'SQL Server Active Directory Helper is running.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

select
@Metric = 129
,@MessageID = 1
,@EventID = 5344
,@HeaderTemplate = N'SQL Server  Active Directory Helper paused'
,@BodyTemplate = N'SQL Server instance {0} - The SQL Active Directory Helper service is paused.'
,@TodoTemplate = N'SQL Server  Active Directory Helper paused on {0}'
,@PulseTemplate = N'SQL Server  Active Directory Helper is paused.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

select
@Metric = 129
,@MessageID = 2
,@EventID = 5346
,@HeaderTemplate = N'SQL Active Directory Helper stopped'
,@BodyTemplate = N'SQL Server instance {0} - The SQL Active Directory Helper service is stopped.'
,@TodoTemplate = N'SQL Active Directory Helper stopped on {0}'
,@PulseTemplate = N'SQL Active Directory Helper is stopped.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

select
@Metric = 129
,@MessageID = 3
,@EventID = 5348
,@HeaderTemplate = N'SQL Server Active Directory Helper is {1}'
,@BodyTemplate = N'SQL Server instance {0} - The SQL Active Directory Helper service has a status of {1}.'
,@TodoTemplate = N'SQL Server  Active Directory Helper is {1} on {0}'
,@PulseTemplate = N'SQL Server  Active Directory Helper is {1}.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)

select
@Metric = 129
,@MessageID = 4
,@EventID = 5350
,@HeaderTemplate = N'SQL Active Directory Helper status: {1}'
,@BodyTemplate = N'SQL Server instance {0} - The SQL Active Directory Helper service status is: {1}. 

{3}'
,@TodoTemplate = N'SQL Active Directory Helper is: {1} on {0}'
,@PulseTemplate = N'SQL Active Directory Helper status is {1}.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)
-- END: SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --add messages for the new service alerts

--START SQLdm 10.0 (Vandana Gogna) - Database backup alerts
-- 130 - Database not backed up since
select
@Metric = 130
,@MessageID = 0
,@EventID = 1115
,@HeaderTemplate = N'Database {2} is not backed up for {1} days.'
,@BodyTemplate = N'Database {2} is not backed up for {1} days.'
,@TodoTemplate = N'Database {2} is not backed up for {1} days.'
,@PulseTemplate = N'Database {2} is not backed up for {1} days.'

INSERT [MetricMetaDataMessages] ([Metric], [MessageID], [EventID], [HeaderTemplate], [BodyTemplate], [TodoTemplate], [PulseTemplate]) VALUES (@Metric,@MessageID,@EventID,@HeaderTemplate,@BodyTemplate,@TodoTemplate,@PulseTemplate)
--END SQLdm 10.0 (Vandana Gogna) - Database backup alerts


DELETE FROM MetricMetaDataMessageMap
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (0,10,0)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,10,1)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,10,2)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (2,10,3)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (2,10,4)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (0,12,0)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,12,1)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (2,12,2)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (3,12,3)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (4,12,4)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) values (4,12,5)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) values (4,12,6)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) values (4,12,7)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) values (4,12,8)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) values (4,12,9)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (0,18,0)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,18,1)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,18,2)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (2,18,3)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (2,18,4)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (0,19,0)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,19,1)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,19,2)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,19,3)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,19,4)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (0,23,0)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,23,1)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (2,23,2)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (3,23,3)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (3,23,4)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (0,48,0)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,48,1)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,35,1)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (0,35,2)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (0,35,4)

INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,52,100)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,52,101)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,52,102)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,52,103)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,52,104)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,52,105)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (2,52,200)

INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (0,89,0)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,89,9999)

INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (0,91,1)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,91,0)

INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (0,92,1)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,92,0)

INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (0,93,1)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,93,0)

INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (0,66,0)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,66,-1)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (0,67,0)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,67,-1)

--SQLdm 8.6 (Ankit Srivastava) - Preferred Node Feature -- added two message mapping for different scenario
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (0,124,1)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,124,0)

--START: SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --add the message transition details for new service alerts
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (0,128,0)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,128,1)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (2,128,2)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (3,128,3)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (4,128,4)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (4,128,5)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (4,128,6)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (4,128,7)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (4,128,8)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (4,128,9)

INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (0,129,0)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (1,129,1)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (2,129,2)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (3,129,3)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (4,129,4)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (4,129,5)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (4,129,6)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (4,129,7)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (4,129,8)
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (4,129,9)
--END: SQLdm 9.1 (Abhishek Joshi) -Monitor additonal SQL Server services --add the message transition details for new service alerts
--START SQLdm 10.0 (Vandana Gogna) - Database backup alerts
INSERT INTO [dbo].[MetricMetaDataMessageMap] ([MessageID],[Metric],[Value]) VALUES (0,130,0)
--END SQLdm 10.0 (Vandana Gogna) - Database backup alerts

drop table #upgrade_metric_info
drop table #upgrade_metric_metadata


truncate table [BaselineMetaData]
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (4,'Available Memory',NULL,NULL,'KB','{0:G;0} - {1:G;0} {2}','0 {2}',-1000,'[OSStatistics] S','OSAvailableMemoryInKilobytes',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (5,'OS Memory Usage',NULL,NULL,'Percent','{0:G;0} - {1:G;0} {2}','0 {2}',24,'[OSStatistics] S','1 - (convert(dec(15,4),OSAvailableMemoryInKilobytes )/ nullif(OSTotalPhysicalMemoryInKilobytes,0))',1,NULL,100,100.0000000000)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (7,'Batches Per Second',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',-7,'[ServerStatistics] S','Transactions/nullif(TimeDeltaInSeconds,0)',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (8,'Blocked Sessions',NULL,NULL,'Count','{0:G;0} - {1:G;0} {2}','0 {2}',58,'[ServerStatistics] S','BlockedProcesses',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (9,'Buffer Cache Hit Ratio',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',-9,'[ServerStatistics] S','BufferCacheHitRatioPercentage',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (10,'Buffer Cache Size',NULL,NULL,'KB','{0:G;0} - {1:G;0} {2}','0 {2}',-10,'[ServerStatistics] S','BufferCacheSizeInKilobytes',1,NULL,NULL,0.0009765625)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (12,'Checkpoint Writes Per Second',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','CheckpointWrites/nullif(TimeDeltaInSeconds,0)',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (13,'Client Computers',NULL,NULL,'Count','{0:G;0} - {1:G;0} {2}','0 {2}',57,'[ServerStatistics] S','ClientComputers',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (16,'SQL Server CPU Usage',NULL,NULL,'Percent','{0:G;0} - {1:G;0} {2}','0 {2}',0,'[ServerStatistics] S','CPUActivityPercentage',1,NULL,100,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (17,'Database Count',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','DatabaseCount',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (18,'Data File Count',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','DataFileCount',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (19,'Data File Space Allocated',NULL,NULL,'MB','{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','DataFileSpaceAllocatedInKilobytes',1,NULL,NULL,0.0009765625)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (20,'Data File Space Used',NULL,NULL,'MB','{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','DataFileSpaceUsedInKilobytes',1,NULL,NULL,0.0009765625)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (21,'OS Average Disk Queue Length',NULL,NULL,'Count','{0:G;0} - {1:G;0} {2}','0 {2}',31,'[OSStatistics] S','DiskQueueLength',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (22,'OS Disk Time',NULL,NULL,'Percent','{0:G;0} - {1:G;0} {2}','0 {2}',30,'[OSStatistics] S','DiskTimePercent',1,NULL,100,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (23,'Full Scans Per Second',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','FullScans/nullif(TimeDeltaInSeconds,0)',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (26,'Lazy Writer Writes Per Second',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','LazyWriterWrites/nullif(TimeDeltaInSeconds,0)',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (29,'Lock Waits Per Second',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','LockWaits/nullif(TimeDeltaInSeconds,0)',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (30,'Log File Count',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','LogFileCount',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (31,'Log File Space Allocated',NULL,NULL,'MB','{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','LogFileSpaceAllocatedInKilobytes',1,NULL,NULL,0.0009765625)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (32,'Log File Space Used',NULL,NULL,'MB','{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','LogFileSpaceUsedInKilobytes',1,NULL,NULL,0.0009765625)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (34,'Log Flushes Per Second',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','LogFlushes/nullif(TimeDeltaInSeconds,0)',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (37,'Open Transactions',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','OpenTransactions',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (39,'OS Privileged Time',NULL,NULL,'Percent','{0:G;0} - {1:G;0} {2}','0 {2}',27,'[OSStatistics] S','PrivilegedTimePercent',1,NULL,100,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (40,'OS User Time',NULL,NULL,'Percent','{0:G;0} - {1:G;0} {2}','0 {2}',28,'[OSStatistics] S','UserTimePercent',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (41,'OS Processor Time',NULL,NULL,'Percent','{0:G;0} - {1:G;0} {2}','0 {2}',26,'[OSStatistics] S','ProcessorTimePercent',1,NULL,100,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (43,'Packet Errors Per Second',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',-43,'[ServerStatistics] S','PacketErrors/nullif(TimeDeltaInSeconds,0)',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (45,'Packets Received Per Second',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',-45,'[ServerStatistics] S','PacketsReceived/nullif(TimeDeltaInSeconds,0)',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (47,'Packets Sent Per Second',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',-47,'[ServerStatistics] S','PacketsSent/nullif(TimeDeltaInSeconds,0)',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (48,'Page Life Expectancy',NULL,NULL,'Seconds','{0:G;0} - {1:G;0} {2}','0 {2}',76,'[ServerStatistics] S','PageLifeExpectancy',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (50,'Page Lookups Per Second',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',-50,'[ServerStatistics] S','PageLookups/nullif(TimeDeltaInSeconds,0)',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (52,'Page Reads Per Second',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',-52,'[ServerStatistics] S','PageReads/nullif(TimeDeltaInSeconds,0)',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (53,'OS Paging',NULL,NULL,'Per Second','{0:G;0} - {1:G;0} {2}','0 {2}',25,'[OSStatistics] S','PagesPerSecond',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (55,'Page Splits Per Second',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',-55,'[ServerStatistics] S','PageSplits/nullif(TimeDeltaInSeconds,0)',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (57,'Page Writes Per Second',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',-1001,'[ServerStatistics] S','PageWrites/nullif(TimeDeltaInSeconds,0)',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (58,'Physical Memory',NULL,NULL,'KB','{0:G;0} - {1:G;0} {2}','0 {2}',-1002,'[OSStatistics] S','OSTotalPhysicalMemoryInKilobytes',1,NULL,NULL,0.0009765625)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (59,'Procedure Cache Hit Ratio',NULL,NULL,'Ratio / %','{0:G;0} - {1:G;0} {2}','0 {2}',81,'[ServerStatistics] S','ProcedureCacheHitRatioPercentage',1,NULL,100,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (60,'Procedure Cache Size',NULL,NULL,'KB','{0:G;0} - {1:G;0} {2}','0 {2}',-1003,'[ServerStatistics] S','ProcedureCacheSizeInKilobytes',1,NULL,NULL,0.0009765625)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (61,'OS Processor Queue Length',NULL,NULL,'Count','{0:G;0} - {1:G;0} {2}','0 {2}',29,'[OSStatistics] S','ProcessorQueueLength',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (63,'Read Ahead Pages Per Second',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',-63,'[ServerStatistics] S','ReadAheadPages/nullif(TimeDeltaInSeconds,0)',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (65,'SQL Server Response Time',NULL,NULL,'Milliseconds','{0:G;0} - {1:G;0} {2}','0 {2}',22,'[ServerStatistics] S','ResponseTimeInMilliseconds',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (69,'Sql Compilations Per Second',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','SqlCompilations/nullif(TimeDeltaInSeconds,0)',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (70,'Sql Memory Allocated',NULL,NULL,'KB','{0:G;0} - {1:G;0} {2}','0 {2}',-70,'[ServerStatistics] S','SqlMemoryAllocatedInKilobytes',1,NULL,NULL,0.0009765625)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (71,'Sql Memory Used',NULL,NULL,'KB','{0:G;0} - {1:G;0} {2}','0 {2}',-71,'[ServerStatistics] S','SqlMemoryUsedInKilobytes',1,NULL,NULL,0.0009765625)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (72,'SQL Server Memory Usage',NULL,NULL,'Percent','{0:G;0} - {1:G;0} {2}','0 {2}',13,'[ServerStatistics] S','convert(dec(15,4),SqlMemoryUsedInKilobytes)/nullif(PhysicalMemoryInKilobytes,0)',1,NULL,100,100.0000000000)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (74,'Sql Recompilations Per Second',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','SqlRecompilations/nullif(TimeDeltaInSeconds,0)',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (75,'System Processes',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','SystemProcesses',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (76,'System Processes Consuming CPU',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','SystemProcessesConsumingCPU',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (78,'User Processes',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',-78,'[ServerStatistics] S','UserProcesses',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (79,'User Processes Consuming CPU',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','UserProcessesConsumingCPU',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (82,'Workfiles Created Per Second',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',-82,'[ServerStatistics] S','WorkFilesCreated/nullif(TimeDeltaInSeconds,0)',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (84,'Worktables Created Per Second',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',-84,'[ServerStatistics] S','WorkTablesCreated/nullif(TimeDeltaInSeconds,0)',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (85,'Non-Distributed Transactions',NULL,NULL,'Count','{0:G;0} - {1:G;0} {2}','0 {2}',4,'[ServerStatistics] S','ReplicationUndistributed',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (86,'Unsubscribed Transactions',NULL,NULL,'Count','{0:G;0} - {1:G;0} {2}','0 {2}',5,'[ServerStatistics] S','ReplicationUnsubscribed',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (87,'User Connections',NULL,NULL,'Percent','{0:G;0} - {1:G;0} {2}','0 {2}',1,'[ServerStatistics] S','convert(dec(15,4),UserProcesses)/MaxConnections',1,NULL,100,100.0000000000)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (88,'Oldest Open Transaction',NULL,NULL,'Minutes','{0:G;0} - {1:G;0} {2}','0 {2}',6,'[ServerStatistics] S','OldestOpenTransactionsInMinutes',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (89,'SQL Server Data Used',NULL,NULL,'Percent','{0:G;0} - {1:G;0} {2}','0 {2}',59,'[ServerStatistics] S','convert(dec(15,4),DataFileSpaceUsedInKilobytes)/DataFileSpaceAllocatedInKilobytes',1,NULL,100,100.0000000000)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (90,'SQL Server Log Used',NULL,NULL,'Percent','{0:G;0} - {1:G;0} {2}','0 {2}',60,'[ServerStatistics] S','convert(dec(15,4),LogFileSpaceUsedInKilobytes)/LogFileSpaceAllocatedInKilobytes',1,NULL,100,100.0000000000)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (91,'Unsubscribed Transactions',NULL,NULL,'Seconds','{0:G;0} - {1:G;0} {2}','0 {2}',17,'[ServerStatistics] S','ReplicationLatencyInSeconds',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (114,NULL,'Not currently used',NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','IdleTimePercentage',1,NULL,100,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (115,'IOActivityPercentage','Not currently used',NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',-135,'[ServerStatistics] S','IOActivityPercentage',1,NULL,100,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (122,NULL,'Not currently used',NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','Logins/nullif(TimeDeltaInSeconds,0)',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (130,NULL,'Not currently used',NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','PageErrors/nullif(TimeDeltaInSeconds,0)',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (140,NULL,'Not currently used',NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','ProcedureCacheSizePercent',1,NULL,100,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (145,NULL,'Not currently used',NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','ReplicationSubscribed',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (155,NULL,'Not currently used',NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','TableLockEscalations/nullif(TimeDeltaInSeconds,0)',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (156,NULL,'Not currently used',NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','TempDBSizeInKilobytes',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (157,NULL,'Not currently used',NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','TempDBSizePercent',1,NULL,100,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (158,'Version Store Size',NULL,NULL,'Milliseconds','{0:G;0} - {1:G;0} {2}','0 {2}',-93,'[ServerStatistics] S','(TempdbPFSWaitTimeMilliseconds + TempdbGAMWaitTimeMilliseconds + TempdbSGAMWaitTimeMilliseconds)',1,0,NULL,NULL)

insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (159,'VM CPU Usage',NULL,NULL,'Percent','{0:G;0} - {1:G;0} {2}','0 {2}',98,'[VMStatistics] S','CPUUsage',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (160,'VM CPU Usage',NULL,NULL,'MHz','{0:G;0} - {1:G;0} {2}','0 {2}',-99,'[VMStatistics] S','CPUUsageMHz',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (161,'VM CPU Ready',NULL,NULL,'Milliseconds','{0:G;0} - {1:G;0} {2}','0 {2}',-100,'[VMStatistics] S','CPUReady',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (162,'VM CPU Swap Wait',NULL,NULL,'Milliseconds','{0:G;0} - {1:G;0} {2}','0 {2}',-101,'[VMStatistics] S','CPUSwapWait',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (163,'VM Memory Swap In Wait',NULL,NULL,'KB/s','{0:G;0} - {1:G;0} {2}','0 {2}',-102,'[VMStatistics] S','MemSwapInRate',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (164,'VM Memory Swap Out Rate',NULL,NULL,'KB/s','{0:G;0} - {1:G;0} {2}','0 {2}',-103,'[VMStatistics] S','MemSwapOutRate',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (165,'VM Memory Swapped',NULL,NULL,'KB','{0:G;0} - {1:G;0} {2}','0 {2}',-104,'[VMStatistics] S','MemSwapped',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (166,'VM Memory Active',NULL,NULL,'KB','{0:G;0} - {1:G;0} {2}','0 {2}',-105,'[VMStatistics] S','MemActive',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (167,'VM Memory Consumed',NULL,NULL,'KB','{0:G;0} - {1:G;0} {2}','0 {2}',-106,'[VMStatistics] S','MemConsumed',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (168,'VM Memory Granted',NULL,NULL,'KB','{0:G;0} - {1:G;0} {2}','0 {2}',-107,'[VMStatistics] S','MemGranted',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (169,'VM Memory Ballooned',NULL,NULL,'KB','{0:G;0} - {1:G;0} {2}','0 {2}',-108,'[VMStatistics] S','MemBalooned',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (170,'VM Memory Usage',NULL,NULL,'Percent','{0:G;0} - {1:G;0} {2}','0 {2}',-109,'[VMStatistics] S','MemUsage',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (171,'VM Disk Read',NULL,NULL,'KB/s','{0:G;0} - {1:G;0} {2}','0 {2}',-110,'[VMStatistics] S','DiskRead',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (172,'VM Disk Write',NULL,NULL,'KB/s','{0:G;0} - {1:G;0} {2}','0 {2}',-111,'[VMStatistics] S','DiskWrite',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (173,'VM Disk Usage',NULL,NULL,'KB/s','{0:G;0} - {1:G;0} {2}','0 {2}',-112,'[VMStatistics] S','DiskUsage',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (174,'VM Net Usage',NULL,NULL,'KB/s','{0:G;0} - {1:G;0} {2}','0 {2}',-113,'[VMStatistics] S','NetUsage',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (175,'VM Net Received',NULL,NULL,'KB/s','{0:G;0} - {1:G;0} {2}','0 {2}',-115,'[VMStatistics] S','NetReceived',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (176,'VM Net Transmitted',NULL,NULL,'KB/s','{0:G;0} - {1:G;0} {2}','0 {2}',-114,'[VMStatistics] S','NetTransmitted',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (177,'Host CPU Usage',NULL,NULL,'Percent','{0:G;0} - {1:G;0} {2}','0 {2}',-116,'[ESXStatistics] S','CPUUsage',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (178,'Host CPU UsageMHz',NULL,NULL,'MHz','{0:G;0} - {1:G;0} {2}','0 {2}',-117,'[ESXStatistics] S','CPUUsageMHz',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (179,'Host Memory Swap In Rate',NULL,NULL,'KB/s','{0:G;0} - {1:G;0} {2}','0 {2}',-118,'[ESXStatistics] S','MemSwapInRate',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (180,'Host Memory Swap Out Rate',NULL,NULL,'KB/s','{0:G;0} - {1:G;0} {2}','0 {2}',-119,'[ESXStatistics] S','MemSwapOutRate',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (181,'Host Memory Active',NULL,NULL,'KB','{0:G;0} - {1:G;0} {2}','0 {2}',-120,'[ESXStatistics] S','MemActive',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (182,'Host Memory Consumed',NULL,NULL,'KB','{0:G;0} - {1:G;0} {2}','0 {2}',-121,'[ESXStatistics] S','MemConsumed',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (183,'Host Memory Granted',NULL,NULL,'KB','{0:G;0} - {1:G;0} {2}','0 {2}',-122,'[ESXStatistics] S','MemGranted',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (184,'Host Memory Ballooned',NULL,NULL,'KB','{0:G;0} - {1:G;0} {2}','0 {2}',-123,'[ESXStatistics] S','MemBalooned',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (185,'Host Memory Usage',NULL,NULL,'Percent','{0:G;0} - {1:G;0} {2}','0 {2}',-124,'[ESXStatistics] S','MemUsage',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (186,'Host Disk Read',NULL,NULL,'KB/s','{0:G;0} - {1:G;0} {2}','0 {2}',-125,'[ESXStatistics] S','DiskRead',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (187,'Host Disk Write',NULL,NULL,'KB/s','{0:G;0} - {1:G;0} {2}','0 {2}',-126,'[ESXStatistics] S','DiskWrite',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (188,'Host Disk Device Latency',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ESXStatistics] S','DiskDeviceLatency',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (189,'Host Disk Kernel Latency',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ESXStatistics] S','DiskKernelLatency',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (190,'Host Disk Queue Latency',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ESXStatistics] S','DiskQueueLatency',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (191,'Host Disk Total Latency',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ESXStatistics] S','DiskTotalLatency',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (192,'Host Disk Usage',NULL,NULL,'KB/s','{0:G;0} - {1:G;0} {2}','0 {2}',-127,'[ESXStatistics] S','DiskUsage',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (193,'Host Net Usage',NULL,NULL,'KB/s','{0:G;0} - {1:G;0} {2}','0 {2}',-132,'[ESXStatistics] S','NetUsage',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (194,'Host Net Received',NULL,NULL,'KB/s','{0:G;0} - {1:G;0} {2}','0 {2}',-134,'[ESXStatistics] S','NetReceived',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (195,'Host Net Transmitted',NULL,NULL,'KB/s','{0:G;0} - {1:G;0} {2}','0 {2}',-133,'[ESXStatistics] S','NetTransmitted',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (196,'Logins per Second',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',-137,'[ServerStatistics] S','Logins',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (197,'Distribution Latency',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','DistributionLatencyInSeconds',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (198,'Replication Subscribed',NULL,NULL,'/s','{0:G;0} - {1:G;0} {2}','0 {2}',-1005,'[ServerStatistics] S','ReplicationSubscribed/nullif(TimeDeltaInSeconds, 0)',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (199,'Table Lock Escalations',NULL,NULL,'/s','{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','TableLockEscalations/nullif(TimeDeltaInSeconds, 0)',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (200,'TempDB Size',NULL,NULL,'KB','{0:G;0} - {1:G;0} {2}','0 {2}',-136,'[ServerStatistics] S','TempDBSizeInKilobytes',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (201,'TempDB Size Percent',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','TempDBSizePercent',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (203,'Version Store Generation',NULL,NULL,'/s','{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','VersionStoreGenerationKilobytes/nullif(TimeDeltaInSeconds, 0)',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (204,'Tempdb PFS Wait Time Milliseconds',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','TempdbPFSWaitTimeMilliseconds',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (205,'Tempdb GAM Wait Time Milliseconds',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','TempdbGAMWaitTimeMilliseconds',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (206,'Tempdb SGAM Wait Time Milliseconds',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',NULL,'[ServerStatistics] S','TempdbSGAMWaitTimeMilliseconds',1,NULL,NULL,NULL)

--AlwaysOn metrics
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (207,'Availability Group Role Change',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',-1006,'[AlwaysOnStatistics] S','ReplicaRole',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (208,'Availability Group Estimated Data Loss',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',117,'[AlwaysOnStatistics] S','EstimatedDataLossTime',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (209,'Availability Group Synchronization Health',NULL,NULL,NULL,'{0:G;0} - {1:G;0} {2}','0 {2}',-1008,'[AlwaysOnStatistics] S','SynchronizationHealth',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (210,'Availability Group Estimated Recovery Time',NULL,NULL,'Seconds','{0:G;0} - {1:G;0} {2}','0 {2}',119,'[AlwaysOnStatistics] S','1',1,NULL,NULL,NULL)
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (211,'Availability Group Synchronization Performance',NULL,NULL,'Seconds','{0:G;0} - {1:G;0} {2}','0 {2}',120,'[AlwaysOnStatistics] S','SynchronizationPerformance',1,NULL,NULL,NULL)  
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (212,'Availability Group Log Send Queue Size',NULL,NULL,'KB','{0:G;0} - {1:G;0} {2}','0 {2}',121,'[AlwaysOnStatistics] S','LogSedQueueSize',1,NULL,NULL,NULL)  
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (213,'Availability Group Redo Queue Size',NULL,NULL,'KB','{0:G;0} - {1:G;0} {2}','0 {2}',122,'[AlwaysOnStatistics] S','RedoQueueSize',1,NULL,NULL,NULL)  
insert into [BaselineMetaData]([ItemID],[Name],[Description],[Category],[Unit],[Format],[NullFormat],[MetricID],[StatisticTable],[MetricValue],[Decimals],[LLimit],[ULimit],[Scale]) Values (214,'Availability Group Redo Rate',NULL,NULL,'KB/s','{0:G;0} - {1:G;0} {2}','0 {2}',123,'[AlwaysOnStatistics] S','RedoRate',1,NULL,NULL,NULL)  

----------------------------------------------------------------------------------------------------------------
--- AuditableActions
TRUNCATE TABLE AuditableActions

INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (1, 'Server Added to Monitor', 'Added "{0}" server for monitoring', 2 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (2, 'Monitored Server Deleted', 'Deleted "{0}" server from monitoring', 2 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (3, 'Server Properties Changed', 'Changed server properties', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (4, 'Alert Configuration Changed', 'Changed alert configuration', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (5, 'Alert Configuration Copied from One Server to Servers', 'Copied alert configuration from "{0}" server to servers', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (6, 'Maintenance Mode Manually Enabled', 'Enabled maintenance mode manually', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (7, 'Maintenance Mode Manually Disabled', 'Disabled maintenance mode manually', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (8, 'Maintenance Mode Schedule Changed', 'Changed maintenance mode schedule', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (9, 'Alert template Applied to Servers', 'Applied "{0}" alert template to servers', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (10, 'Single Alert Snoozed', 'Repository user "{0}" snoozed a single alert', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (11, 'Multiple Alerts Snoozed', 'Repository user "{0}" snoozed multiple alerts', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (12, 'Tag Added', 'Repository user "{0}" added tag', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (13, 'Tag Removed', 'Repository user "{0}" removed tag', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (14, 'Session Killed', 'Repository user "{0}" killed session "{1}" from workstation "{2}"', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (15, 'License Updated', 'Updated License', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (16, 'Multiple Alerts Resumed', 'Repository user "{0}" resumed alerts on server', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (17, 'Alert Configuration Copied from Server', 'Alert configuration copied from "{0}" server', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (18, 'Maintenance Mode Schedule Started', 'Started maintenance mode according to schedule', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (19, 'Maintenance Mode Schedule Stopped', 'Stopped maintenance mode according to schedule', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (20, 'Alert Response Added', 'Added "{0}" alert response', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (21, 'Alert Response Edited', 'Edited "{0}" alert response', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (22, 'Alert Response Removed', 'Removed "{0}" alert response', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (23, 'Alert Response Copied', 'Copied "{0}" alert response from "{1}" alert response', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (24, 'Predictive Analytics Enabled', 'Enabled predictive analytics for alert forecasting', 2 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (25, 'Predictive Analytics Disabled', 'Disabled predictive analytics for alert forecasting', 2 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (26, 'Alert Template Added', 'Added "{0}" alert template', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (27, 'Alert Template Deleted', 'Deleted "{0}" alert template', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (28, 'Default Alert Template Set', 'Set default alert template', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (29, 'Alert Template Edited', 'Edited "{0}" alert template', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (30, 'Baseline Configuration Changed', 'Changed performance baseline configuration', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (31, 'vCenter Added', 'Added vCenter "{0}"', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (32, 'vCenter Edited', 'Edited vCenter "{0}"', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (33, 'vCenter Removed', 'Removed vCenter "{0}"', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (34, 'Grooming Configuration Changed', 'Changed grooming configuration', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (35, 'Custom Counter Linked to Tag', 'Linked custom counter "{0}" to tag "{1}"', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (36, 'Aggregate Now Triggered', 'Repository user "{0}" triggered Aggregate Now event', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (37, 'Groom Now Triggered', 'Repository user "{0}" triggered Groom Now event', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (38, 'Server Added to Tag', 'Added "{0}" server to tag', 2 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (39, 'Server Deleted from Tag', 'Deleted "{0}" server from tag', 2 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (40, 'Action Provider Added', 'Added "{0}" action provider', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (41, 'Action Provider Edited', 'Edited "{0}" action provider', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (42, 'Action Provider Removed', 'Removed "{0}" action provider', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate] ,[SecurityRequired]) VALUES (43, 'Server Linked to vCenter', 'Linked server to vCenter', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate] ,[SecurityRequired]) VALUES (44, 'Server Unlinked from vCenter', 'Unlinked server from vCenter', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate] ,[SecurityRequired]) VALUES (45, 'Server Link Configuration to vCenter Changed', 'Changed server link configuration to vCenter', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (46, 'Full-Text Search Optimized', 'Repository user "{0}" optimized Full-Text search', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (47, 'Full-Text Search Rebuilt', 'Repository user "{0}" rebuilt Full-Text search', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (48, 'Clear Procedure Cache Triggered', 'Repository user "{0}" triggered Clear Procedure Cache', 2 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (49, 'Blocked Process Threshold Edited', 'Repository user "{0}" edited Blocked Process Threshold', 2 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (50, 'SQL Server Agent Service Started', 'Repository user "{0}" started "SQL Server Agent" Service', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (51, 'SQL Server Agent Service Stopped', 'Repository user "{0}" stopped "SQL Server Agent" Service', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (52, 'SQL Job Started', 'Repository user "{0}" started SQL Job "{1}"', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate] ,[SecurityRequired]) VALUES (53, 'SQL Job Stopped', 'Repository user "{0}" stopped SQL Job "{1}"', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate] ,[SecurityRequired]) VALUES (54, 'Application Security Enabled', 'Application Security Enabled', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate] ,[SecurityRequired]) VALUES (55, 'Application Security Disabled', 'Application Security Disabled', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate] ,[SecurityRequired]) VALUES (56, 'User Account Deleted', 'Deleted "{0}" user account', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate] ,[SecurityRequired]) VALUES (57, 'User Account Edited', 'Edited "{0}" user account', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate] ,[SecurityRequired]) VALUES (58, 'User Account Added', 'Added "{0}" user account', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (59, 'Distributed Transaction Coordinator Service Started', 'Repository user "{0}" started "Distributed Transaction Coordinator" Service', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (60, 'Distributed Transaction Coordinator Service Stopped', 'Repository user "{0}" stopped "Distributed Transaction Coordinator" Service', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (61, 'Full-Text Search Service Started', 'Repository user "{0}" started "Full-Text Search" Service', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (62, 'Full-Text Search Service Stopped', 'Repository user "{0}" stopped "Full-Text Search" Service', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (63, 'SQL Server Service Started', 'Repository user "{0}" started "SQL Server" Service', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (64, 'SQL Server Service Stopped', 'Repository user "{0}" stopped "SQL Server" Service', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (65, 'SQL Server Logs Recycling Triggered', 'Repository user "{0}" triggered SQL server logs recycling', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (66, 'SQL Server Agent Logs Recycling Triggered', 'Repository user "{0}" triggered SQL server agent logs recycling', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (67, 'Query Executed', 'Executed query on "{0}" server', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (68, 'All Server Alerts Snoozed', 'Repository user "{0}" snoozed on multiple servers all alerts', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (69, 'All Server Alerts Resumed', 'Repository user "{0}" resumed alerts on multiple servers', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (70, 'Statistics Updated', 'Repository user "{0}" Updated Statistics', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (71, 'Configuration Value Changed', 'Configuration Value "{0}" Changed', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (72, 'Mirroring Session Resumed', 'Resumed mirroring session for database "{0}"', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (73, 'Mirroring Fail Over Triggered', 'Triggered mirroring fail over for database "{0}"', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (74, 'Mirroring Session Suspended', 'Suspended mirroring session for database "{0}"', 1)
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (75, 'Session Traced', 'Repository user "{0}" traced session', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (76, 'Custom Counter Unlinked from Tag', 'Unlinked custom counter "{0}" from tag "{1}"', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (77, 'Application Security User linked to Tag', 'Linked application security user "{0}" to "{1}"', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (78, 'Application Security User unlinked from Tag', 'Unlinked application security user "{0}" from "{1}"', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (79, 'HyperV Added', 'Added HyperV "{0}"', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (80, 'HyperV Edited', 'Edited HyperV "{0}"', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate], [SecurityRequired]) VALUES (81, 'HyperV Removed', 'Removed HyperV "{0}"', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate] ,[SecurityRequired]) VALUES (82, 'Server Linked to HyperV', 'Linked server to HyperV', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate] ,[SecurityRequired]) VALUES (83, 'Server Unlinked from HyperV', 'Unlinked server from HyperV', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate] ,[SecurityRequired]) VALUES (84, 'Server Link Configuration to HyperV Changed', 'Changed server link configuration to HyperV', 1 )
INSERT INTO [AuditableActions] ([ActionID], [Name], [HeaderTemplate] ,[SecurityRequired]) VALUES (89, 'Analysis Configuration Changed', 'Changed Analysis Configurations', 1 )
----------------------------------------------------------------------------------------------------------------
---Report interval dropdowns
delete from ReportIntervals
insert into ReportIntervals values (0, 'Minutes')
insert into ReportIntervals values (1, 'Hours')
insert into ReportIntervals values (2, 'Days')
insert into ReportIntervals values (3, 'Months')
insert into ReportIntervals values (4, 'Years')

delete from ReportPeriods
insert into ReportPeriods values (0, 'Today')
insert into ReportPeriods values (1, 'Last 7 Days')
insert into ReportPeriods values (2, 'Last 30 Days')
insert into ReportPeriods values (3, 'Last 365 Days')
insert into ReportPeriods values (4, 'Custom')

delete from ReportPeriodIntervals
--Insert default period intervals
insert into ReportPeriodIntervals values(-1, 0,0)
insert into ReportPeriodIntervals values(-1, 0,1)
insert into ReportPeriodIntervals values(-1, 1,1)
insert into ReportPeriodIntervals values(-1, 1,2)
insert into ReportPeriodIntervals values(-1, 2,2)
insert into ReportPeriodIntervals values(-1, 3,2)
insert into ReportPeriodIntervals values(-1, 3,3)
insert into ReportPeriodIntervals values(-1, 4,0)
insert into ReportPeriodIntervals values(-1, 4,1)
insert into ReportPeriodIntervals values(-1, 4,2)
insert into ReportPeriodIntervals values(-1, 4,3)
insert into ReportPeriodIntervals values(-1, 4,4)
--Top Tables by Fragmentation
insert into ReportPeriodIntervals values(16, 1, 2)
insert into ReportPeriodIntervals values(16, 2, 2)
insert into ReportPeriodIntervals values(16, 3, 2)
insert into ReportPeriodIntervals values(16, 3, 3)
insert into ReportPeriodIntervals values(16, 4, 1)
insert into ReportPeriodIntervals values(16, 4, 2)
insert into ReportPeriodIntervals values(16, 4, 3)
insert into ReportPeriodIntervals values(16, 4, 4)
----------------------------------------------------------------------------------------------------------------------
--CounterMasterList for custom reports
----------------------------------------------------------------------------------------------------------------------
print 'CounterMasterList'
truncate table [CounterMasterList]
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('ActiveProcesses','Active Processes',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('AgentServiceStatus','AgentServiceStatus',0,0)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('BlockedProcesses','Blocked Processes',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('BufferCacheHitRatioPercentage','Buffer Cache Hit Ratio (%)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('BufferCacheSizeInKilobytes','Buffer Cache Size (KB)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('CachePagesInKilobytes','Cached Pages (KB)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('CheckpointWrites','Checkpoint Writes',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('ClientComputers','Client Computers',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('ClusterNodeName','ClusterNodeName',0,0)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('CommittedInKilobytes','Committed (KB)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('ConnectionMemoryInKilobytes','ConnectionMemory (KB)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('CPUActivityPercentage','CPU Activity (%)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('CPUTimeDelta','CPUTimeDelta',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('CPUTimeRaw','CPUTimeRaw',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('DatabaseCount','Databases',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('DataFileCount','Data Files',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('DataFileSpaceAllocatedInKilobytes','Data File Space Allocated (KB)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('DataFileSpaceUsedInKilobytes','Data File Space Used (KB)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('DistributionLatencyInSeconds','Distribution Latency (s)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('DTCServiceStatus','DTCServiceStatus',0,0)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('FreeCachePagesInKilobytes','Free Cache Pages (KB)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('FreePagesInKilobytes','Free Pages (KB)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('FullScans','Full Scans',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('FullTextSearchStatus','FullTextSearchStatus',0,0)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('GrantedWorkspaceMemoryInKilobytes','Granted Workspace Memory (KB)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('IdleTimeDelta','IdleTimeDelta',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('IdleTimePercentage','Idle Time (%)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('IdleTimeRaw','IdleTimeRaw',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('IOActivityPercentage','IO Activity (%)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('IOTimeDelta','IOTimeDelta',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('IOTimeRaw','IOTimeRaw',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('IsClustered','IsClustered',0,0)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('LazyWriterWrites','Lazy Writer Writes',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('LeadBlockers','Lead Blockers',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('LockMemoryInKilobytes','Lock Memory (KB)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('LockWaits','Lock Waits',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('LogFileCount','Log File Count',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('LogFileSpaceAllocatedInKilobytes','Log File Space Allocated (KB)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('LogFileSpaceUsedInKilobytes','Log File Space Used (KB)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('LogFlushes','Log Flushes',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('Logins','Logins',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('MaxConnections','Max Connections',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('OldestOpenTransactionsInMinutes','Oldest Open Transactions (minutes)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('OpenTransactions','Open Transactions',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('OptimizerMemoryInKilobytes','Optimizer Memory (KB)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('OsStatisticAvailability','OsStatisticAvailability',0,0)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('PacketErrors','Packet Errors',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('PacketsReceived','Packets Received',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('PacketsSent','Packets Sent',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('PageErrors','Page Errors',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('PageLifeExpectancy','Page Life Expectancy',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('PageLookups','Page Lookups',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('PageReads','Page Reads',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('PageSplits','Page Splits',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('PageWrites','Page Writes',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('PhysicalMemoryInKilobytes','Physical Memory (KB)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('ProcedureCacheHitRatioPercentage','Procedure Cache Hit Ratio (%)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('ProcedureCacheSizeInKilobytes','Procedure Cache Size (KB)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('ProcedureCacheSizePercent','Procedure Cache Size (%)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('ProcessorCount','Processor Count',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('ProcessorsUsed','Processors Used',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('ProcessorType','ProcessorType',0,0)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('ReadAheadPages','Read Ahead Pages',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('RealServerName','RealServerName',0,0)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('ReplicationLatencyInSeconds','Subscription Latency (s)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('ReplicationSubscribed','Subscribed Trans',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('ReplicationUndistributed','Undistributed Trans',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('ReplicationUnsubscribed','Unsubscribed Trans',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('ResponseTimeInMilliseconds','Response Time (ms)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('RunningSince','RunningSince',0,0)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('ServerHostName','ServerHostName',0,0)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('ServerVersion','ServerVersion',0,0)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('SqlCompilations','Sql Compilations',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('SqlMemoryAllocatedInKilobytes','Sql Memory Allocated (KB)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('SqlMemoryUsedInKilobytes','Sql Memory Used (KB)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('SqlRecompilations','Sql Recompilations',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('SqlServerEdition','SqlServerEdition',0,0)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('SQLServerID','SQLServerID',0,0)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('SqlServerServiceStatus','SqlServerServiceStatus',0,0)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('SystemProcesses','System Processes',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('SystemProcessesConsumingCPU','System Processes Consuming CPU',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('TableLockEscalations','Table Lock Escalations',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('TempDBSizeInKilobytes','Tempdb Size (KB)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('TempDBSizePercent','Tempdb Size Percent',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('TimeDeltaInSeconds','TimeDeltaInSeconds',0,0)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('TotalLocks','Total Locks',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('TotalServerMemoryInKilobytes','Total Server Memory (KB)',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('Transactions','Batches',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('UserProcesses','User Processes',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('UserProcessesConsumingCPU','User Processes Consuming CPU',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('UTCCollectionDateTime','UTCCollectionDateTime',0,0)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('WindowsVersion','WindowsVersion',0,0)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('WorkFilesCreated','Work Files Created',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('WorkTablesCreated','Work Tables Created',0,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('DiskQueueLength','Disk Queue Length',1,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('DiskTimePercent','Disk Time Percent',1,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('OSAvailableMemoryInKilobytes','OS Available Memory (KB)',1,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('OSTotalPhysicalMemoryInKilobytes','OS Total Physical Memory (KB)',1,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('PagesPerSecond','Pages/s',1,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('PrivilegedTimePercent','Privileged Time (%)',1,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('ProcessorQueueLength','Processor Queue Length',1,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('ProcessorTimePercent','Processor Time (%)',1,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('SQLServerID','SQLServerID',1,0)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('UserTimePercent','User Time (%)',1,1)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('UTCCollectionDateTime','UTCCollectionDateTime',1,0)
INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES('SQLMemoryUsagePercent','Sql Memory Usage Percent',0,1)

--SQLdm 8.5 (Ankit Srivastava): for Virtualization Counters -New Master data starts here
Insert Into CounterMasterList (CounterName,CounterFriendlyName,CounterType,AvailableInCustomReport) Values('CPUUsage','CPU Usage',3,1)
Insert Into CounterMasterList (CounterName,CounterFriendlyName,CounterType,AvailableInCustomReport) Values('CPUUsageMHz','CPU Usage(MHz)',3,1)
Insert Into CounterMasterList (CounterName,CounterFriendlyName,CounterType,AvailableInCustomReport) Values('CPUReady','CPU Ready',3,1)
Insert Into CounterMasterList (CounterName,CounterFriendlyName,CounterType,AvailableInCustomReport) Values('CPUSwapWait','CPU Swap Wait',3,1)
Insert Into CounterMasterList (CounterName,CounterFriendlyName,CounterType,AvailableInCustomReport) Values('MemSwapInRate','Memory Swap In Rate',3,1)
Insert Into CounterMasterList (CounterName,CounterFriendlyName,CounterType,AvailableInCustomReport) Values('MemSwapOutRate','Memory Swap Out Rate',3,1)
Insert Into CounterMasterList (CounterName,CounterFriendlyName,CounterType,AvailableInCustomReport) Values('MemSwapped','Memory Swapped',3,1)
Insert Into CounterMasterList (CounterName,CounterFriendlyName,CounterType,AvailableInCustomReport) Values('MemActive','Memory Active',3,1)
Insert Into CounterMasterList (CounterName,CounterFriendlyName,CounterType,AvailableInCustomReport) Values('MemConsumed','Memory Consumed',3,1)
Insert Into CounterMasterList (CounterName,CounterFriendlyName,CounterType,AvailableInCustomReport) Values('MemGranted','Memory Granted',3,1)
Insert Into CounterMasterList (CounterName,CounterFriendlyName,CounterType,AvailableInCustomReport) Values('MemBalooned','Memory Balooned',3,1)
Insert Into CounterMasterList (CounterName,CounterFriendlyName,CounterType,AvailableInCustomReport) Values('MemUsage','Memory Usage',3,1)
Insert Into CounterMasterList (CounterName,CounterFriendlyName,CounterType,AvailableInCustomReport) Values('DiskRead','Disk Read',3,1)
Insert Into CounterMasterList (CounterName,CounterFriendlyName,CounterType,AvailableInCustomReport) Values('DiskWrite','Disk Write',3,1)
Insert Into CounterMasterList (CounterName,CounterFriendlyName,CounterType,AvailableInCustomReport) Values('DiskUsage','Disk Usage',3,1)
Insert Into CounterMasterList (CounterName,CounterFriendlyName,CounterType,AvailableInCustomReport) Values('NetUsage','Net Usage',3,1)
Insert Into CounterMasterList (CounterName,CounterFriendlyName,CounterType,AvailableInCustomReport) Values('NetReceived','Net Received',3,1)
Insert Into CounterMasterList (CounterName,CounterFriendlyName,CounterType,AvailableInCustomReport) Values('NetTransmitted','Net Transmitted',3,1)
Insert Into CounterMasterList (CounterName,CounterFriendlyName,CounterType,AvailableInCustomReport) Values('PagePerSecVM','Pages/s -VM',3,1)
Insert Into CounterMasterList (CounterName,CounterFriendlyName,CounterType,AvailableInCustomReport) Values('AvailableByteVm','Available Byte VM',3,1)
--SQLdm 8.5 (Ankit Srivastava): for Virtualization Counters -New Master data ends here
--

declare
@CounterName nvarchar(255)
,@CounterFriendlyName nvarchar(255)
,@CounterType nvarchar(255)
,@AvailableInCustomReport bit

-- 89 - Version Store Generation Rate
select
@CounterName = 'VersionStoreGenerationKilobytes'
,@CounterFriendlyName = 'Version Store Generation Rate (KB)'
,@CounterType = 0
,@AvailableInCustomReport = 1

INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES(@CounterName,@CounterFriendlyName,@CounterType,@AvailableInCustomReport)

select
@CounterName = 'VersionStoreCleanupKilobytes'
,@CounterFriendlyName = 'Version Store Cleanup Rate (KB)'
,@CounterType = 0
,@AvailableInCustomReport = 1

INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES(@CounterName,@CounterFriendlyName,@CounterType,@AvailableInCustomReport)


-- 93 - Tempdb Contention

select
@CounterName = 'TempdbPFSWaitTimeMilliseconds'
,@CounterFriendlyName = 'Tempdb PFS Wait Time (ms)'
,@CounterType = 0
,@AvailableInCustomReport = 1

INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES(@CounterName,@CounterFriendlyName,@CounterType,@AvailableInCustomReport)


select
@CounterName = 'TempdbGAMWaitTimeMilliseconds'
,@CounterFriendlyName = 'Tempdb GAM Wait Time (ms)'
,@CounterType = 0
,@AvailableInCustomReport = 1

INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES(@CounterName,@CounterFriendlyName,@CounterType,@AvailableInCustomReport)


select
@CounterName = 'TempdbSGAMWaitTimeMilliseconds'
,@CounterFriendlyName = 'Tempdb SGAM Wait Time (ms)'
,@CounterType = 0
,@AvailableInCustomReport = 1

INSERT INTO [CounterMasterList] ([CounterName],[CounterFriendlyName],[CounterType],[AvailableInCustomReport])VALUES(@CounterName,@CounterFriendlyName,@CounterType,@AvailableInCustomReport)

---------------------------------------------------------------------------------------------------------------------------------------
-- Upgrade
---------------------------------------------------------------------------------------------------------------------------------------
if (select count([Internal_Value]) from [dbo].[RepositoryInfo] where [Name] = 'UpgradedTo5.6') = 0
begin

	declare @warningThreshold nvarchar(4000),
			@criticalThreshold nvarchar(4000),
			@SQLServerID int, 
			--@MetricID int,
			@WarningThresholdXML nvarchar(256),
			@CriticalThresholdXML nvarchar(256),
			@ComparisonText nvarchar(16),
			--@DefaultWarningValue bigint,
			--@DefaultCriticalValue bigint,
			--@AlertEnabledDefault bit,
			@InfoThresholdXML nvarchar(256)
			--@DefaultInfoValue bigint
			,@BaselineWarningThresholdXML nvarchar(256),
			@BaselineCriticalThresholdXML nvarchar(256),
			@BaselineInfoThresholdXML nvarchar(256)

	declare @LoopMetrics table(MetricID int, GroupCode int)
	
	--Update the Default Metric Thresholds

	insert into @LoopMetrics select 65,1
	insert into @LoopMetrics select 64,1
	insert into @LoopMetrics select 62,1
	insert into @LoopMetrics select 63,1
	insert into @LoopMetrics select 10,2
	insert into @LoopMetrics select 12,2
	insert into @LoopMetrics select 18,2
	insert into @LoopMetrics select 19,2

	
	if (select count(*) from [DefaultMetricThresholds]) > 0 
	begin
			
		select @MetricID = min(MetricID) from @LoopMetrics where GroupCode = 1

		while isnull(@MetricID,0) > 0
		begin

			-- insert default alert configuration row
			set @WarningThresholdXML = 
				'<?xml version="1.0" encoding="utf-16"?><Threshold xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" Op="' 
			set @CriticalThresholdXML = @WarningThresholdXML
			set @InfoThresholdXML = @WarningThresholdXML

			set @ComparisonText = 'GE'
			
			set @WarningThresholdXML = @WarningThresholdXML + @ComparisonText + '" Enabled="true"><Value xsi:type="xsd:float">'
			set @CriticalThresholdXML = @CriticalThresholdXML + @ComparisonText + '" Enabled="true"><Value xsi:type="xsd:float">'
			set @InfoThresholdXML = @InfoThresholdXML + @ComparisonText + '" Enabled="false"><Value xsi:type="xsd:float">'

			-- append value
			select 
				@DefaultWarningValue = [DefaultWarningValue],
				@DefaultCriticalValue = [DefaultCriticalValue],
				@AlertEnabledDefault = [AlertEnabledDefault],
				@DefaultInfoValue = 0
			from [MetricMetaData]
				where Metric = @MetricID

			set @WarningThresholdXML = @WarningThresholdXML + CAST(@DefaultWarningValue AS nvarchar(32)) + '</Value></Threshold>'
			set @CriticalThresholdXML = @CriticalThresholdXML + CAST(@DefaultCriticalValue AS nvarchar(32)) + '</Value></Threshold>'
			set @InfoThresholdXML = @InfoThresholdXML + CAST(@DefaultInfoValue AS nvarchar(32)) + '</Value></Threshold>'

			exec p_AddDefaultMetricThreshold 
				0, 
				@MetricID, 
				@AlertEnabledDefault, 
				@WarningThresholdXML, 
				@CriticalThresholdXML, 
				null,
				@InfoThresholdXML

			select @MetricID = min(MetricID) from @LoopMetrics where MetricID > @MetricID and GroupCode = 1
		end


		select @MetricID = min(MetricID) from @LoopMetrics where GroupCode = 2
			
		while isnull(@MetricID,0) > 0
		begin
			select @warningThreshold = [WarningThreshold],
				   @criticalThreshold = [CriticalThreshold] from [dbo].[DefaultMetricThresholds] where Metric = @MetricID

			exec p_RemoveFromMetricThreshold @warningThreshold, 'UnableToMonitor', 'ServiceState', @warningThreshold OUTPUT
			exec p_RemoveFromMetricThreshold @criticalThreshold, 'UnableToMonitor', 'ServiceState', @criticalThreshold OUTPUT
			exec p_RemoveFromMetricThreshold @warningThreshold, 'Undetermined', 'ServiceState', @warningThreshold OUTPUT
			exec p_RemoveFromMetricThreshold @criticalThreshold, 'Undetermined', 'ServiceState', @criticalThreshold OUTPUT
			exec p_AppendToMetricThreshold @criticalThreshold, 'UnableToConnect', 'ServiceState', @criticalThreshold OUTPUT
			exec p_AppendToMetricThreshold @criticalThreshold, 'UnableToMonitor', 'ServiceState', @criticalThreshold OUTPUT

			update [dbo].[DefaultMetricThresholds]
				set WarningThreshold = @warningThreshold, CriticalThreshold = @criticalThreshold where Metric = @MetricID

			select @MetricID = min(MetricID) from @LoopMetrics where MetricID > @MetricID and GroupCode = 2
		end

		select @warningThreshold = [WarningThreshold],
			   @criticalThreshold = [CriticalThreshold] from [dbo].[DefaultMetricThresholds] where Metric = 14

		exec p_RemoveFromMetricThreshold @warningThreshold, 'Undetermined', 'DBStatus', @warningThreshold OUTPUT
		exec p_RemoveFromMetricThreshold @criticalThreshold, 'Undetermined', 'DBStatus', @criticalThreshold OUTPUT
		exec p_AppendToMetricThreshold @warningThreshold, 'PreRecovery', 'DBStatus', @warningThreshold OUTPUT
		exec p_AppendToMetricThreshold @criticalThreshold, 'EmergencyMode', 'DBStatus', @criticalThreshold OUTPUT

		update [dbo].[DefaultMetricThresholds]
			set WarningThreshold = @warningThreshold, CriticalThreshold = @criticalThreshold where Metric = 14
	end

	select @SQLServerID = min(SQLServerID) from MonitoredSQLServers

	while isnull(@SQLServerID,0) > 0
	begin

		--Update the Service Thresholds
		select @MetricID = min(MetricID) from @LoopMetrics
		
		while isnull(@MetricID,0) > 0
		begin
	
			if ((select GroupCode from @LoopMetrics where MetricID = @MetricID) = 1) 
			begin
				select @warningThreshold = [WarningThreshold],
					   @criticalThreshold = [CriticalThreshold] 
				from [dbo].[DefaultMetricThresholds] 
				where Metric = @MetricID 
			end
			else
			begin
				select @warningThreshold = [WarningThreshold],
					   @criticalThreshold = [CriticalThreshold] from [dbo].[MetricThresholds] where Metric = @MetricID and SQLServerID = @SQLServerID

				exec p_RemoveFromMetricThreshold @warningThreshold, 'UnableToMonitor', 'ServiceState', @warningThreshold OUTPUT
				exec p_RemoveFromMetricThreshold @criticalThreshold, 'UnableToMonitor', 'ServiceState', @criticalThreshold OUTPUT
				exec p_RemoveFromMetricThreshold @warningThreshold, 'Undetermined', 'ServiceState', @warningThreshold OUTPUT
				exec p_RemoveFromMetricThreshold @criticalThreshold, 'Undetermined', 'ServiceState', @criticalThreshold OUTPUT
				exec p_AppendToMetricThreshold @criticalThreshold, 'UnableToConnect', 'ServiceState', @criticalThreshold OUTPUT
				exec p_AppendToMetricThreshold @criticalThreshold, 'UnableToMonitor', 'ServiceState', @criticalThreshold OUTPUT
			end

			if (select count(*) from [dbo].[MetricThresholds] where Metric = @MetricID and SQLServerID = @SQLServerID) > 0
			begin
				update [dbo].[MetricThresholds]
						set WarningThreshold = @warningThreshold, 
						CriticalThreshold = @criticalThreshold 
				where Metric = @MetricID and SQLServerID = @SQLServerID				
			end
			else
			begin
				insert into  [dbo].[MetricThresholds] (SQLServerID, Metric, Enabled, WarningThreshold,CriticalThreshold)
					select @SQLServerID, @MetricID, 1, @warningThreshold, @criticalThreshold
			end

			select @MetricID = min(MetricID) from @LoopMetrics where MetricID > @MetricID
		end

		--Update the Database Thresholds
		select @warningThreshold = [WarningThreshold],
			   @criticalThreshold = [CriticalThreshold] from [dbo].[MetricThresholds] where Metric = 14 and SQLServerID = @SQLServerID

		exec p_RemoveFromMetricThreshold @warningThreshold, 'Undetermined', 'DBStatus', @warningThreshold OUTPUT
		exec p_RemoveFromMetricThreshold @criticalThreshold, 'Undetermined', 'DBStatus', @criticalThreshold OUTPUT
		exec p_AppendToMetricThreshold @warningThreshold, 'PreRecovery', 'DBStatus', @warningThreshold OUTPUT
		exec p_AppendToMetricThreshold @criticalThreshold, 'EmergencyMode', 'DBStatus', @criticalThreshold OUTPUT

		update [dbo].[MetricThresholds]
			set WarningThreshold = @warningThreshold, CriticalThreshold = @criticalThreshold where Metric = 14 and SQLServerID = @SQLServerID

		select @SQLServerID = min(SQLServerID) from MonitoredSQLServers where SQLServerID > @SQLServerID
	end
		
	-- if server is in maintenance mode during the upgrade, set the type to MaintnanceModeAlways
	update [dbo].[MonitoredSQLServers] set MaintenanceModeType = 1 where MaintenanceModeEnabled = 1

	-- Ensure the last scheduled collection time stored in the server table matches the time of the last alerts stored				
	if (select isnull(object_id('tempdb..#upgrade_last_collection_time'), 0)) <> 0 
	begin 
		truncate table #upgrade_last_collection_time
	end 
	else	
	begin
		CREATE TABLE #upgrade_last_collection_time (
			[SQLServerID] [int] NOT NULL,
			[LastScheduledCollectionTime] datetime
		)
		CREATE INDEX #IX_upgrade_last_collection_time 
			ON #upgrade_last_collection_time(SQLServerID, LastScheduledCollectionTime DESC)
	end

	insert into #upgrade_last_collection_time
		select SQLServerID, max(A.UTCOccurrenceDateTime)		
			from MonitoredSQLServers MS
			left outer join Alerts A on A.Active=1 and ServerName = [InstanceName]
			group by MS.SQLServerID
	
	insert into #upgrade_last_collection_time
		select MS.SQLServerID, max(UTCCollectionDateTime)
			from MonitoredSQLServers MS
			left outer join ServerStatistics S on MS.SQLServerID = S.SQLServerID
			group by MS.SQLServerID

	update MonitoredSQLServers 
		set LastScheduledCollectionTime = 
			COALESCE(
				(select max(LastScheduledCollectionTime) from #upgrade_last_collection_time S where MS.SQLServerID = S.SQLServerID),
				MS.LastScheduledCollectionTime)
		from MonitoredSQLServers MS

	drop table #upgrade_last_collection_time

	-- add the upgrade info to the RepositoryInfo so the upgrade will not happen again
	insert into [dbo].[RepositoryInfo] ([Name], [Internal_Value],[Character_Value]) values ('UpgradedTo5.6', 1, '')
end

-- get rid of objects that are no longer used
if (OBJECT_ID('OutstandingEvents') IS NOT NULL)
begin
	drop table [OutstandingEvents]
end
if (object_id('p_InsertOutstandingEvent') is not null)
begin
	drop procedure [p_InsertOutstandingEvent]
end
if (object_id('p_GetOutstandingEvents') is not null)
begin
	drop procedure [p_GetOutstandingEvents]
end
if (object_id('p_DeleteOutstandingEvents') is not null)
begin
	drop procedure [p_DeleteOutstandingEvents]
end

if (select count([Internal_Value]) from [dbo].[RepositoryInfo] where [Name] = 'UpgradedTo6.1') = 0
begin
	-- INSERT 6.1 UPGRADE STUFF HERE
	delete from NotificationProviders where ProviderId in
		( '75B6B4A9-CB0F-4B81-A72C-219C78C520BB', '24263D39-D8D7-475B-ABF6-97841A5E4772' )	

	-- if the field is still part of query monitor
	-- enable deadlock collection if query monitor is enabled
	IF (not exists(select id from syscolumns where id = OBJECT_ID('MonitoredSQLServers') and name = 'QueryMonitorDeadlockEventsEnabled' collate database_default))
		exec('UPDATE [MonitoredSQLServers] SET [ActivityMonitorDeadlockEventsEnabled]=1')
	else
		exec('UPDATE [MonitoredSQLServers] SET [QueryMonitorDeadlockEventsEnabled]=1')
	
	insert into [dbo].[RepositoryInfo] ([Name], [Internal_Value],[Character_Value]) values ('UpgradedTo6.1', 1, '')
end

if not exists (select [Internal_Value] from RepositoryInfo where [Name] = 'GroomingMaxNumberMinutes')
begin
	insert into [RepositoryInfo] ([Name],[Internal_Value]) values ('GroomingMaxNumberMinutes',180);
end

-- INSERT 6.6 UPGRADE STUFF HERE
if (select count([SQLServerID]) from [dbo].[MetricThresholds]) > 0
begin
	if (select count([Internal_Value]) from [dbo].[RepositoryInfo] where [Name] = 'UpgradedTo6.6') = 0
	begin
		
		declare @SQLServerID66 int, 
				@MetricID66 int,
				@WarningThresholdXML66 nvarchar(512),
				@CriticalThresholdXML66 nvarchar(512),
				@InfoThresholdXML66 nvarchar(512),
				@ComparisonText66 nvarchar(16),
				@DefaultWarningValue66 nvarchar(256),
				@DefaultCriticalValue66 nvarchar(256),
				@AlertEnabledDefault66 bit

			-- Add metric threshold for the Job Completion metric (disable during upgrade)
			set @MetricID66 = 88

			-- insert default alert configuration row
			set @WarningThresholdXML66 = 
				'<?xml version="1.0" encoding="utf-16"?><Threshold xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" Op="' 
			set @CriticalThresholdXML66 = @WarningThresholdXML66
			set @InfoThresholdXML66 = @WarningThresholdXML66

			set @ComparisonText66 = 'EQ'
			
			set @WarningThresholdXML66 = @WarningThresholdXML66 + @ComparisonText66 + '" Enabled="true"><Value xsi:type="ArrayOfAnyType">'
			set @CriticalThresholdXML66 = @CriticalThresholdXML66 + @ComparisonText66 + '" Enabled="true"><Value xsi:type="ArrayOfAnyType">'
			set @InfoThresholdXML66 = @InfoThresholdXML66 + @ComparisonText66 + '" Enabled="false"><Value xsi:type="ArrayOfAnyType">'

			-- append value
			set @DefaultWarningValue66 = '<anyType xsi:type="JobStepCompletionStatus">Cancelled</anyType><anyType xsi:type="JobStepCompletionStatus">Retry</anyType>'
			set	@DefaultCriticalValue66 = '<anyType xsi:type="JobStepCompletionStatus">Failed</anyType><anyType xsi:type="JobStepCompletionStatus">Unknown</anyType>'
			-- Intensionally left the Info value out here because Informational settings are left disabled and blank by default

			set @WarningThresholdXML66 = @WarningThresholdXML66 + @DefaultWarningValue66 + '</Value></Threshold>'
			set @CriticalThresholdXML66 = @CriticalThresholdXML66 + @DefaultCriticalValue66 + '</Value></Threshold>'
			set @InfoThresholdXML66 = @InfoThresholdXML66 + '</Value></Threshold>'
			exec p_AddDefaultMetricThreshold 
				0, 
				@MetricID66, 
				0, 
				@WarningThresholdXML66, 
				@CriticalThresholdXML66, 
				null,
				@InfoThresholdXML66

		insert into [dbo].[RepositoryInfo] ([Name], [Internal_Value],[Character_Value]) values ('UpgradedTo6.6', 1, '')
		
	end
end

-- INSERT 7.0 UPGRADE STUFF HERE
if (select count([Internal_Value]) from [dbo].[RepositoryInfo] where [Name] = 'UpgradedTo7.0') = 0
begin

	-- Set the Default Info Value for Custom Counters to half of the default warning value
    update [MetricMetaData] set [DefaultInfoValue] = ([DefaultWarningValue]/2) where [Metric] >= 1000 and [DefaultInfoValue] is null

	-- DefaultMetricThresholds
	select [Metric], cast([WarningThreshold] as XML) as [WarningThreshold], cast(null as nvarchar(1024)) as [InfoThreshold] into #MetricTable from [dbo].[DefaultMetricThresholds]

	set ansi_warnings on
	update #MetricTable set InfoThreshold = 
		'<Threshold xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" Op="' +
		Convert(varchar(20), WarningThreshold.query('data(//@Op)')) +
		'" Enabled="false"><Value xsi:type="' +
		Convert(varchar(20), WarningThreshold.query('data(/Threshold/Value/@xsi:type)')) + '"' + 
		case Convert(varchar(20), WarningThreshold.query('data(/Threshold/Value/@xsi:type)')) 
					when 'ArrayOfAnyType' then ' /></Threshold>'
					when 'OptionStatus' then 
											case b.Metric
												when 49 then '>Enabled</Value></Threshold>'
												else '>Disabled</Value></Threshold>'
											end
					else '>'+ Convert(varchar(20), b.[DefaultInfoValue]) + '</Value></Threshold>'
				end
	from #MetricTable a inner join [dbo].[MetricMetaData] b on a.Metric = b.[Metric]
	
	update [dbo].[DefaultMetricThresholds] set [DefaultMetricThresholds].[InfoThreshold] = b.[InfoThreshold] from #MetricTable b where [DefaultMetricThresholds].[Metric] = b.[Metric] and [DefaultMetricThresholds].InfoThreshold is null

	drop table #MetricTable

	-- Metric Thresholds
	select SQLServerID, Metric, CAST(WarningThreshold as XML) as WarningThreshold, CAST(null as varchar(1024)) as InfoThreshold, cast(CriticalThreshold as XML) as CriticalThreshold into #NewThresholds from MetricThresholds

	update #NewThresholds set InfoThreshold = 
            '<Threshold xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" Op="' +
            Convert(varchar(2), WarningThreshold.query('data(//@Op)')) +
            '" Enabled="false"><Value xsi:type="' +
            Convert(varchar(15), WarningThreshold.query('data(/Threshold/Value/@xsi:type)')) + '"' + 
            case Convert(varchar(15), WarningThreshold.query('data(/Threshold/Value/@xsi:type)')) 
                              when 'ArrayOfAnyType' then ' /></Threshold>'
                              when 'OptionStatus' then 
													case b.Metric
														when 49 then '>Enabled</Value></Threshold>'
														else '>Disabled</Value></Threshold>'
													end
                              else '>'+ case CONVERT(char(2), WarningThreshold.query('data(//@Op)'))
                                                when 'GE' then case when CAST(convert(varchar(20), WarningThreshold.query('data(/Threshold/Value)')) as bigint) = b.DefaultWarningValue
                                                                              then CONVERT(varchar(20), b.DefaultInfoValue)
                                                                              else Convert(varchar(20),(CAST(convert(varchar(20), WarningThreshold.query('data(/Threshold/Value)')) as bigint)- b.MinValue) / 2)
                                                                        end
                                                when 'LE' then case when CAST(convert(varchar(20), WarningThreshold.query('data(/Threshold/Value)')) as bigint) = b.DefaultWarningValue
                                                                              then CONVERT(varchar(20), b.DefaultInfoValue)
                                                                              else Convert(varchar(20), (abs((CAST(convert(varchar(20), CriticalThreshold.query('data(/Threshold/Value)')) as bigint) - CAST(convert(varchar(20), WarningThreshold.query('data(/Threshold/Value)')) as bigint)) / 2 ) + CAST(convert(varchar(20), WarningThreshold.query('data(/Threshold/Value)')) as bigint)))
                                                                        end
                                                else Convert(varchar(20), WarningThreshold.query('data(/Threshold/Value)')) 
                                            end
                                                + '</Value></Threshold>'
                        end
            from #NewThresholds a left join MetricMetaData b on a.Metric = b.Metric
	
	
	update [dbo].[MetricThresholds] set [MetricThresholds].[InfoThreshold] = b.[InfoThreshold] from #NewThresholds b where [MetricThresholds].[SQLServerID] = b.SQLServerID and [MetricThresholds].[Metric] = b.[Metric] and [MetricThresholds].InfoThreshold is null

	drop table #NewThresholds

	-- Notification Rules
	declare @RuleTable table
	(
		RuleID uniqueidentifier,
		RuleObj xml
	)

	insert into @RuleTable (RuleID, RuleObj) select RuleID, Convert(xml, SerializedObject) from [dbo].[NotificationRules]

	update @RuleTable set RuleObj.modify('
			insert (
				attribute IsInformational {"false"}
				) as last into (/NotificationRule/StateValue)[1]')
			where RuleObj.exist('/NotificationRule/StateValue/@IsInformational[1]') = 0

	update [dbo].[NotificationRules] set [SerializedObject] = Convert(nvarchar(max), [RuleObj]) from @RuleTable b where [NotificationRules].[RuleID] = b.[RuleID] 

	-- Predictive Forcasts (breaking these updates into two separate statements seems to be much faster
	update [dbo].[PredictiveForecasts] set [Severity] = 8 where [Severity] = 4
	update [dbo].[PredictiveForecasts] set [Severity] = 4 where [Severity] = 2

	-- Predictive Models
	update [dbo].[PredictiveModels] set [Severity] = 8 where [Severity] = 4
	update [dbo].[PredictiveModels] set [Severity] = 4 where [Severity] = 2

	--------------------------------------------------------------------------------
	-- Set up Files below get migrated in another process
	--------------------------------------------------------------------------------	
	declare @LeftToDo int
	declare @Today datetime
	
	set @Today = GETDATE()
	
	-- Alerts Table
	Select @LeftToDo = COUNT(AlertID) from Alerts where Severity in (2,4)
	insert into [dbo].[RepositoryInfo] ([Name], [Internal_Value], [Character_Value]) values ('AlertsLeftToDo', @LeftToDo,'')
	insert into [dbo].[RepositoryInfo] ([Name], [Internal_Value],[Character_Value]) values ('AlertsLastDateUpgraded', 1, Convert(nvarchar(30), @Today, 121))
	-- Server Activity
	Select @LeftToDo = Count(*) from ServerActivity
	insert into [dbo].[RepositoryInfo] ([Name], [Internal_Value], [Character_Value]) values ('SALeftToDo', @LeftToDo,'')
	insert into [dbo].[RepositoryInfo] ([Name], [Internal_Value],[Character_Value]) values ('SALastDateUpgraded', 1, Convert(nvarchar(30), @Today, 121))
	-- Tasks
	Select @LeftToDo = Count(TaskID) from Tasks where Severity in (2,4)
	insert into [dbo].[RepositoryInfo] ([Name], [Internal_Value], [Character_Value]) values ('TasksLeftToDo', @LeftToDo,'')
	insert into [dbo].[RepositoryInfo] ([Name], [Internal_Value],[Character_Value]) values ('TasksLastDateUpgraded', 1, Convert(nvarchar(30), @Today, 121))


    -- Update SMTP and SNMP Notification Providers to stick the ID in the Serialized Object
	declare @Providers table (
		id uniqueidentifier,
		obj xml)
	
	insert into @Providers 
		Select 
			ProviderId, 
			cast(SerializedObject as xml)
		from 
			[dbo].[NotificationProviders]
		where 
			SerializedType in ('SmtpNotificationProviderInfo','SnmpNotificationProviderInfo')

	update @Providers
		set obj.modify('replace value of (//@Id)[1] with sql:column("id")')
		
	update [dbo].[NotificationProviders]
		set SerializedObject = cast(obj as nvarchar(max)) from @Providers where ProviderId = id
		
	declare @sampleRunQuery nvarchar(1000)

	set @sampleRunQuery =
	'select 
		[Database Name] = d.name,
		[Most Recent Backup Date] = isnull(convert(nvarchar(20),max(s.backup_finish_date),20),''Never''),
		[Days Since Most Recent Backup] = isnull(cast(datediff(dd,max(s.backup_finish_date),getdate()) as nvarchar(20)),''Never'')
	from 
		master..sysdatabases d
		left join msdb..backupset s
		on d.name = s.database_name
	group by
		d.name
	order by
		d.name'
		
	exec [p_InsertRunQueryScript] @Name = 'Backup History',@ScriptText = @sampleRunQuery
		
	-- Finished 7.0 Upgrade
	insert into [dbo].[RepositoryInfo] ([Name], [Internal_Value],[Character_Value]) values ('UpgradedTo7.0', 1, Convert(nvarchar(30), @Today, 121))
end

-- Remove all alerting in xp_cmdshell 
DELETE FROM DefaultMetricThresholds where Metric = 55
DELETE FROM MetricInfo where Metric = 55
DELETE FROM MetricMetaData where Metric = 55
DELETE FROM MetricMetaDataMessageMap where Metric = 55
DELETE FROM MetricMetaDataMessages where Metric = 55
DELETE FROM MetricThresholds where Metric = 55
	
if (select count([Internal_Value]) from [dbo].[RepositoryInfo] where [Name] = 'UpgradedTo7.5') = 0
begin
	update [DefaultMetricThresholds] set [ThresholdEnabled] = [Enabled]
	update [MetricThresholds] set [ThresholdEnabled] = [Enabled]
		
	-- Finished 7.5 Upgrade
	insert into [dbo].[RepositoryInfo] ([Name], [Internal_Value],[Character_Value]) values ('UpgradedTo7.5', 1, Convert(nvarchar(30), @Today, 121))
end

--START SQLdm 10.0 (Vandana Gogna) - Database backup alerts
-- INSERT 10.0 UPGRADE STUFF HERE

if (select count([Internal_Value]) from [dbo].[RepositoryInfo] where [Name] = 'UpgradedTo10.0') = 0
begin
	if (select count([SQLServerID]) from [dbo].[MetricThresholds]) > 0
	begin		
		declare @SQLServerID10 int, 
				@MetricID10 int,
				@WarningThresholdXML10 nvarchar(512),
				@CriticalThresholdXML10 nvarchar(512),
				@InfoThresholdXML10 nvarchar(512),
				@ComparisonText10 nvarchar(16),
				@DefaultWarningValue10 nvarchar(256),
				@DefaultCriticalValue10 nvarchar(256),
				@DefaultInfoValue10 nvarchar(256),
				@AlertEnabledDefault10 bit

		-- Add metric threshold for the Job Completion metric (disable during upgrade)
		set @MetricID10 = 130

		select @SQLServerID10 = min(SQLServerID) from MonitoredSQLServers
		
		while isnull(@SQLServerID10,0) > 0
		begin
				-- insert default alert configuration row
				set @WarningThresholdXML10 = 
					'<?xml version="1.0" encoding="utf-16"?><Threshold xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" Op="' 
				set @CriticalThresholdXML10 = @WarningThresholdXML10
				set @InfoThresholdXML10 = @WarningThresholdXML10

				set @ComparisonText10 = 'GE'
			
				set @WarningThresholdXML10 = @WarningThresholdXML10 + @ComparisonText10 + '" Enabled="true"><Value xsi:type="xsd:int">'
				set @CriticalThresholdXML10 = @CriticalThresholdXML10 + @ComparisonText10 + '" Enabled="true"><Value xsi:type="xsd:int">'
				set @InfoThresholdXML10 = @InfoThresholdXML10 + @ComparisonText10 + '" Enabled="true"><Value xsi:type="xsd:int">'

				-- append value			
				select @DefaultWarningValue10 = [DefaultWarningValue],
					   @DefaultCriticalValue10 = [DefaultCriticalValue],
					   @DefaultInfoValue10 = [DefaultInfoValue],
					   @AlertEnabledDefault10 = [AlertEnabledDefault]
				from [dbo].[MetricMetaData] 
				where Metric = @MetricID10

				set @WarningThresholdXML10 = @WarningThresholdXML10 + @DefaultWarningValue10 + '</Value></Threshold>'
				set @CriticalThresholdXML10 = @CriticalThresholdXML10 + @DefaultCriticalValue10 + '</Value></Threshold>'
				set @InfoThresholdXML10 =  @InfoThresholdXML10 + @DefaultInfoValue10 + '</Value></Threshold>'
				exec p_AddDefaultMetricThreshold 
					0, 
					@MetricID10, 
					@AlertEnabledDefault10, 
					@WarningThresholdXML10, 
					@CriticalThresholdXML10, 
					null,
					@InfoThresholdXML10
							
			select @SQLServerID10 = min(SQLServerID) from MonitoredSQLServers where SQLServerID > @SQLServerID10
		end
	
		--END SQLdm 10.0 (Vandana Gogna) - Database backup alerts
				
	end
	
	-- START --Srishti Purohit -- To accomadate baseline alert feature -- Adding thresholds values for baseline for all metrics
				DECLARE 	-- START --Srishti Purohit -- To accomadate baseline alert feature
				@BaselineWarningThresholdXML10 nvarchar(512),
				@BaselineCriticalThresholdXML10 nvarchar(512),
				@BaselineInfoThresholdXML10 nvarchar(512),
				@BaselineDefaultWarningValue10 nvarchar(256),
				@BaselineDefaultCriticalValue10 nvarchar(256),
				@BaselineDefaultInfoValue10 nvarchar(256),
				@xmSignature nvarchar(256),
				@xmlValueForBaselineToCastWarning xml,
				@xmlValueForBaselineToCastCritical xml,
				@xmlValueForBaselineToCastInfo xml
				-- END --Srishti Purohit -- To accomadate baseline alert feature
				DECLARE @MetricIDFor10Up INT	
				select @MetricIDFor10Up = min(Metric) from DefaultMetricThresholds
				set ansi_warnings on
	
		while isnull(@MetricIDFor10Up,-1) > -1
		begin
			-- append value			
				select @BaselineDefaultWarningValue10 = [BaselineDefaultWarningValue],
						@BaselineDefaultCriticalValue10 = [BaselineDefaultCriticalValue],
						@BaselineDefaultInfoValue10 = [BaselineDefaultInfoValue]
				from [dbo].[MetricMetaData] 
				where Metric = @MetricIDFor10Up

				--To get operation type from xml of thresholds
				select @xmlValueForBaselineToCastWarning = CAST(WarningThreshold as XML) ,
				 @xmlValueForBaselineToCastCritical = CAST(CriticalThreshold as XML) ,
				@xmlValueForBaselineToCastInfo = CAST(InfoThreshold as XML) FROM DefaultMetricThresholds where Metric = @MetricIDFor10Up
				
			--ANSI_WARNINGS is not honored when passing parameters in a stored procedure , so setting it on	
				SET @WarningThresholdXML10 = CONVERT( nvarchar(512), @xmlValueForBaselineToCastWarning.query('data(//@Op)'))
				SET @CriticalThresholdXML10 = CONVERT(nvarchar(512), @xmlValueForBaselineToCastCritical.query('data(//@Op)'))
				SET @InfoThresholdXML10 = CONVERT(nvarchar(512), @xmlValueForBaselineToCastInfo.query('data(//@Op)'))
	
				-- START --Srishti Purohit -- To accomadate baseline alert feature
				
				SET @xmSignature ='<?xml version="1.0" encoding="utf-16"?><Threshold xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" Op="'

				SET @xmSignature = @xmSignature 
			
				set	@BaselineWarningThresholdXML10 = @xmSignature + @WarningThresholdXML10 + '" Enabled="true"><Value xsi:type="xsd:float">' + @BaselineDefaultWarningValue10 + '</Value></Threshold>'
				set	@BaselineCriticalThresholdXML10 = @xmSignature + @CriticalThresholdXML10 + '" Enabled="true"><Value xsi:type="xsd:float">' +  @BaselineDefaultCriticalValue10 + '</Value></Threshold>'
				set	@BaselineInfoThresholdXML10 = @xmSignature + @InfoThresholdXML10 + '" Enabled="true"><Value xsi:type="xsd:float">' +  @BaselineDefaultInfoValue10 + '</Value></Threshold>'
				-- END --Srishti Purohit -- To accomadate baseline alert feature
				
			update [dbo].[DefaultMetricThresholds]
				set [IsBaselineEnabled] = 0, [BaselineWarningThreshold] = @BaselineWarningThresholdXML10, [BaselineCriticalThreshold] = @BaselineCriticalThresholdXML10, [BaselineInfoThreshold] = @BaselineInfoThresholdXML10 where Metric = @MetricIDFor10Up

			update [dbo].[MetricThresholds]
				set [IsBaselineEnabled] = 0, [BaselineWarningThreshold] = @BaselineWarningThresholdXML10, [BaselineCriticalThreshold] = @BaselineCriticalThresholdXML10, [BaselineInfoThreshold] = @BaselineInfoThresholdXML10 where Metric = @MetricIDFor10Up

			
			select @MetricIDFor10Up = min(Metric) from DefaultMetricThresholds where Metric > @MetricIDFor10Up
		end
		
		-- END --Srishti Purohit -- To accomadate baseline alert feature -- Adding thresholds values for baseline for all metrics
		-- START SQLdm 10.0 (Gaurav Karwal) - Populating the master table for cloud providers
		IF (OBJECT_ID('CloudProviders') IS NOT NULL)
		BEGIN 
			DECLARE @CloudProviderId INT;
			SELECT @CloudProviderId = 1;
			IF((SELECT COUNT(0) FROM CloudProviders WHERE CloudProviderId = @CloudProviderId) = 0)
			BEGIN
				INSERT INTO CloudProviders(CloudProviderId,CloudProviderName) VALUES (@CloudProviderId,'Amazon RDS');
			END
			
			SELECT @CloudProviderId = 2;
			
			IF((SELECT COUNT(0) FROM CloudProviders WHERE CloudProviderId = @CloudProviderId) = 0)
			BEGIN
				INSERT INTO CloudProviders(CloudProviderId,CloudProviderName) VALUES (@CloudProviderId,'Microsoft Azure');
			END
		END
		-- END SQLdm 10.0 (Gaurav Karwal) - Populating the master table for cloud providers
	insert into [dbo].[RepositoryInfo] ([Name], [Internal_Value],[Character_Value]) values ('UpgradedTo10.0', 1, '')
end


	

--------------------------------------------------------------------------------------------
--- Wait Stats
--
set identity_insert WaitCategories on

if (select count(1) from WaitCategories) = 0 
begin
	insert into WaitCategories(CategoryID,Category,ExcludeFromCollection)
	select 1, 'Excluded', 1
	union select 2, 'Backup', 0
	union select 3, 'I/O', 0
	union select 4, 'Lock', 0
	union select 5, 'Memory', 0
	union select 6, 'Non-I/O Page Latch', 0
	union select 7, 'Non-Page Latch', 0
	union select 8, 'Other', 0
	union select 9, 'Transaction Log', 0
end


set identity_insert WaitCategories off

declare @ReturnID int, @ReturnMessage nvarchar(128)
exec p_InsertWaitTypes @WaitType= 'ABR',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'ASSEMBLY_LOAD',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'ASYNC_DISKPOOL_LOCK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'ASYNC_IO_COMPLETION',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'ASYNC_NETWORK_IO',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'AUDIT_GROUPCACHE_LOCK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'AUDIT_LOGINCACHE_LOCK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'AUDIT_ON_DEMAND_TARGET_LOCK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'AUDIT_XE_SESSION_MGR',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'BACKUP',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'BACKUP_CLIENTLOCK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'BACKUP_OPERATOR',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'BACKUPBUFFER',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'BACKUPIO',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'BACKUPTHREAD',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'BAD_PAGE_PROCESS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'BROKER_CONNECTION_RECEIVE_TASK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'BROKER_ENDPOINT_STATE_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'BROKER_EVENTHANDLER',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'BROKER_INIT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'BROKER_MASTERSTART',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'BROKER_RECEIVE_WAITFOR',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'BROKER_REGISTERALLENDPOINTS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'BROKER_SERVICE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'BROKER_SHUTDOWN',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'BROKER_TASK_STOP',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'BROKER_TO_FLUSH',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'BROKER_TRANSMITTER',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'BROKER_XMIT_SHUTDOWN',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'BROKER_XMIT_START',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'BROKER_XMIT_TABLE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'BUILTIN_HASHKEY_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'CHECK_PRINT_RECORD',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'CHECKPOINT_QUEUE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'CHKPT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'CLEAR_DB',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'CLR_AUTO_EVENT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'CLR_CRST',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'CLR_JOIN',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'CLR_MANUAL_EVENT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'CLR_MEMORY_SPY',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'CLR_MONITOR',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'CLR_RWLOCK_READER',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'CLR_RWLOCK_WRITER',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'CLR_SEMAPHORE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'CLR_TASK_START',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'CLRHOST_STATE_ACCESS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'CMEMTHREAD',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'COMMIT_TABLE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'CURSOR',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'CURSOR_ASYNC',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'CXPACKET',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'CXROWSET_SYNC',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DAC_INIT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DBMIRROR_DBM_EVENT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DBMIRROR_DBM_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DBMIRROR_EVENTS_QUEUE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DBMIRROR_SEND',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DBMIRROR_WORKER_QUEUE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DBMIRRORING_CMD',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DBTABLE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DEADLOCK_ENUM_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DEADLOCK_TASK_SEARCH',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DEBUG',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DISABLE_VERSIONING',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DISKIO_SUSPEND',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DISPATCHER_QUEUE_SEMAPHORE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DLL_LOADING_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DROPTEMP',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DTC',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DTC_ABORT_REQUEST',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DTC_RESOLVE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DTC_STATE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DTC_TMDOWN_REQUEST',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DTC_WAITFOR_OUTCOME',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DUMP_LOG_COORDINATOR',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DUMP_LOG_COORDINATOR_QUEUE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'DUMPTRIGGER',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'EC',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'EE_PMOLOCK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'EE_SPECPROC_MAP_INIT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'ENABLE_VERSIONING',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'ERROR_REPORTING_MANAGER',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'EXCHANGE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'EXECSYNC',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'EXECUTION_PIPE_EVENT_INTERNAL',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'FAILPOINT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'FCB_REPLICA_READ',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'FCB_REPLICA_START',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'FCB_REPLICA_WRITE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'FILESTREAM_WORKITEM_QUEUE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'FS_FC_RWLOCK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'FS_GARBAGE_COLLECTOR_SHUTDOWN',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'FS_HEADER_RWLOCK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'FS_LOGTRUNC_RWLOCK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'FSA_FORCE_OWN_XACT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'FSAGENT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'FSTR_CONFIG_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'FSTR_CONFIG_RWLOCK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'FT_COMPROWSET_RWLOCK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'FT_IFTS_RWLOCK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'FT_IFTS_SCHEDULER_IDLE_WAIT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'FT_IFTSHC_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'FT_IFTSISM_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'FT_MASTER_MERGE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'FT_METADATA_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'FT_RESTART_CRAWL',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'FT_RESUME_CRAWL',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'FULLTEXT GATHERER',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'GUARDIAN',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'HTTP_ENDPOINT_COLLCREATE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'HTTP_ENUMERATION',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'HTTP_START',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'IMP_IMPORT_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'IMPPROV_IOWAIT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'INDEX_USAGE_STATS_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'INTERNAL_TESTING',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'IO_AUDIT_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'IO_COMPLETION',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'IO_RETRY',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'IOAFF_RANGE_QUEUE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'KSOURCE_WAKEUP',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'KTM_ENLISTMENT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'KTM_RECOVERY_MANAGER',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'KTM_RECOVERY_RESOLUTION',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LATCH_DT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LATCH_EX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LATCH_KP',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LATCH_NL',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LATCH_SH',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LATCH_UP',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LAZYWRITER_SLEEP',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LCK_M_BU',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LCK_M_IS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LCK_M_IU',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LCK_M_IX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LCK_M_RIn_NL',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LCK_M_RIn_S',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LCK_M_RIn_U',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LCK_M_RIn_X',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LCK_M_RS_S',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LCK_M_RS_U',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LCK_M_RX_S',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LCK_M_RX_U',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LCK_M_RX_X',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LCK_M_S',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LCK_M_SCH_M',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LCK_M_SCH_S',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LCK_M_SIU',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LCK_M_SIX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LCK_M_U',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LCK_M_UIX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LCK_M_X',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LOGBUFFER',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LOGGENERATION',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LOGMGR',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LOGMGR_FLUSH',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LOGMGR_QUEUE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LOGMGR_RESERVE_APPEND',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'LOWFAIL_MEMMGR_QUEUE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'METADATA_LAZYCACHE_RWLOCK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'MIRROR_SEND_MESSAGE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'MISCELLANEOUS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'MSQL_DQ',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'MSQL_SYNC_PIPE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'MSQL_XACT_MGR_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'MSQL_XACT_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'MSQL_XP',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'MSSEARCH',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'NET_WAITFOR_PACKET',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'NODE_CACHE_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'OLEDB',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'ONDEMAND_TASK_QUEUE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PAGEIOLATCH_DT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PAGEIOLATCH_EX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PAGEIOLATCH_KP',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PAGEIOLATCH_NL',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PAGEIOLATCH_SH',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PAGEIOLATCH_UP',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PAGELATCH_DT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PAGELATCH_EX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PAGELATCH_KP',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PAGELATCH_NL',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PAGELATCH_SH',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PAGELATCH_UP',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PARALLEL_BACKUP_QUEUE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PERFORMANCE_COUNTERS_RWLOCK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PLACEHOLDER1',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PLACEHOLDER2',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_ABR',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_AUDIT_ACCESS_EVENTLOG',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_AUDIT_ACCESS_SECLOG',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_CLOSEBACKUPMEDIA',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_CLOSEBACKUPTAPE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_CLOSEBACKUPVDIDEVICE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_CLUSAPI_CLUSTERRESOURCECONTROL',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_COCREATEINSTANCE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_COGETCLASSOBJECT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_CREATEACCESSOR',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_DELETEROWS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_GETCOMMANDTEXT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_GETDATA',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_GETNEXTROWS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_GETRESULT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_GETROWSBYBOOKMARK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_LBFLUSH',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_LBLOCKREGION',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_LBREADAT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_LBSETSIZE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_LBSTAT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_LBUNLOCKREGION',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_LBWRITEAT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_QUERYINTERFACE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_RELEASE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_RELEASEACCESSOR',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_RELEASEROWS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_RELEASESESSION',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_RESTARTPOSITION',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_SEQSTRMREAD',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_SEQSTRMREADANDWRITE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_SETDATAFAILURE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_SETPARAMETERINFO',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_SETPARAMETERPROPERTIES',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_STRMLOCKREGION',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_STRMSEEKANDREAD',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_STRMSEEKANDWRITE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_STRMSETSIZE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_STRMSTAT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_COM_STRMUNLOCKREGION',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_CONSOLEWRITE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_CREATEPARAM',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_DEBUG',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_DFSADDLINK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_DFSLINKEXISTCHECK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_DFSLINKHEALTHCHECK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_DFSREMOVELINK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_DFSREMOVEROOT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_DFSROOTFOLDERCHECK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_DFSROOTINIT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_DFSROOTSHARECHECK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_DTC_ABORT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_DTC_ABORTREQUESTDONE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_DTC_BEGINTRANSACTION',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_DTC_COMMITREQUESTDONE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_DTC_ENLIST',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_DTC_PREPAREREQUESTDONE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_FILESIZEGET',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_FSAOLEDB_ABORTTRANSACTION',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_FSAOLEDB_COMMITTRANSACTION',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_FSAOLEDB_STARTTRANSACTION',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_FSRECOVER_UNCONDITIONALUNDO',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_GETRMINFO',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_LOCKMONITOR',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_MSS_RELEASE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_ODBCOPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OLE_UNINIT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OLEDB_ABORTORCOMMITTRAN',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OLEDB_ABORTTRAN',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OLEDB_GETDATASOURCE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OLEDB_GETLITERALINFO',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OLEDB_GETPROPERTIES',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OLEDB_GETPROPERTYINFO',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OLEDB_GETSCHEMALOCK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OLEDB_JOINTRANSACTION',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OLEDB_RELEASE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OLEDB_SETPROPERTIES',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OLEDBOPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_ACCEPTSECURITYCONTEXT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_ACQUIRECREDENTIALSHANDLE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_AUTHENTICATIONOPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_AUTHORIZATIONOPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_AUTHZGETINFORMATIONFROMCONTEXT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_AUTHZINITIALIZECONTEXTFROMSID',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_AUTHZINITIALIZERESOURCEMANAGER',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_BACKUPREAD',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_CLOSEHANDLE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_CLUSTEROPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_COMOPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_COMPLETEAUTHTOKEN',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_COPYFILE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_CREATEDIRECTORY',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_CREATEFILE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_CRYPTACQUIRECONTEXT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_CRYPTIMPORTKEY',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_CRYPTOPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_DECRYPTMESSAGE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_DELETEFILE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_DELETESECURITYCONTEXT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_DEVICEIOCONTROL',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_DEVICEOPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_DIRSVC_NETWORKOPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_DISCONNECTNAMEDPIPE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_DOMAINSERVICESOPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_DSGETDCNAME',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_DTCOPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_ENCRYPTMESSAGE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_FILEOPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_FINDFILE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_FLUSHFILEBUFFERS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_FORMATMESSAGE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_FREECREDENTIALSHANDLE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_FREELIBRARY',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_GENERICOPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_GETADDRINFO',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_GETCOMPRESSEDFILESIZE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_GETDISKFREESPACE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_GETFILEATTRIBUTES',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_GETFILESIZE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_GETLONGPATHNAME',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_GETPROCADDRESS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_GETVOLUMENAMEFORVOLUMEMOUNTPOINT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_GETVOLUMEPATHNAME',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_INITIALIZESECURITYCONTEXT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_LIBRARYOPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_LOADLIBRARY',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_LOGONUSER',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_LOOKUPACCOUNTSID',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_MESSAGEQUEUEOPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_MOVEFILE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_NETGROUPGETUSERS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_NETLOCALGROUPGETMEMBERS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_NETUSERGETGROUPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_NETUSERGETLOCALGROUPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_NETUSERMODALSGET',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_NETVALIDATEPASSWORDPOLICY',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_NETVALIDATEPASSWORDPOLICYFREE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_OPENDIRECTORY',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_PIPEOPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_PROCESSOPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_QUERYREGISTRY',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_QUERYSECURITYCONTEXTTOKEN',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_REMOVEDIRECTORY',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_REPORTEVENT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_REVERTTOSELF',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_RSFXDEVICEOPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_SECURITYOPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_SERVICEOPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_SETENDOFFILE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_SETFILEPOINTER',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_SETFILEVALIDDATA',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_SETNAMEDSECURITYINFO',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_SQLCLROPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_SQMLAUNCH',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_VERIFYSIGNATURE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_VSSOPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_WAITFORSINGLEOBJECT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_WINSOCKOPS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_WRITEFILE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_WRITEFILEGATHER',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_OS_WSASETLASTERROR',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_REENLIST',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_RESIZELOG',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_ROLLFORWARDREDO',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_ROLLFORWARDUNDO',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_SB_STOPENDPOINT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_SERVER_STARTUP',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_SETRMINFO',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_SHAREDMEM_GETDATA',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_SNIOPEN',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_SOSHOST',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_SOSTESTING',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_STARTRM',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_STREAMFCB_CHECKPOINT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_STREAMFCB_RECOVER',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_STRESSDRIVER',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_TESTING',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_TRANSIMPORT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_UNMARSHALPROPAGATIONTOKEN',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_VSS_CREATESNAPSHOT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_VSS_CREATEVOLUMESNAPSHOT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_XE_CALLBACKEXECUTE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_XE_DISPATCHER',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_XE_ENGINEINIT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_XE_GETTARGETSTATE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_XE_SESSIONCOMMIT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_XE_TARGETFINALIZE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_XE_TARGETINIT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_XE_TIMERRUN',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PREEMPTIVE_XETESTING',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'PRINT_ROLLBACK_PROGRESS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'QNMANAGER_ACQUIRE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'QPJOB_KILL',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'QPJOB_WAITFOR_ABORT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'QRY_MEM_GRANT_INFO_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'QUERY_ERRHDL_SERVICE_DONE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'QUERY_EXECUTION_INDEX_SORT_EVENT_OPEN',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'QUERY_NOTIFICATION_MGR_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'QUERY_NOTIFICATION_SUBSCRIPTION_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'QUERY_NOTIFICATION_TABLE_MGR_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'QUERY_NOTIFICATION_UNITTEST_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'QUERY_OPTIMIZER_PRINT_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'QUERY_TRACEOUT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'QUERY_WAIT_ERRHDL_SERVICE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'RECOVER_CHANGEDB',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'REPL_CACHE_ACCESS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'REPL_HISTORYCACHE_ACCESS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'REPL_SCHEMA_ACCESS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'REPL_TRANHASHTABLE_ACCESS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'REPLICA_WRITES',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'REQUEST_DISPENSER_PAUSE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'REQUEST_FOR_DEADLOCK_SEARCH',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'RESMGR_THROTTLED',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'RESOURCE_QUEUE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'RESOURCE_SEMAPHORE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'RESOURCE_SEMAPHORE_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'RESOURCE_SEMAPHORE_QUERY_COMPILE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'RESOURCE_SEMAPHORE_SMALL_QUERY',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'RFS_MSGPUMP',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'RFS_NOTIFYTHREAD',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'RFS_STARTUP',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'RG_RECONFIG',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SEC_DROP_TEMP_KEY',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SECURITY_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SEQUENTIAL_GUID',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SERVER_IDLE_CHECK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SHUTDOWN',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SLEEP_BPOOL_FLUSH',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SLEEP_DBSTARTUP',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SLEEP_DCOMSTARTUP',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SLEEP_MSDBSTARTUP',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SLEEP_SYSTEMTASK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SLEEP_TASK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SLEEP_TEMPDBSTARTUP',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SNI_CRITICAL_SECTION',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SNI_HTTP_ACCEPT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SNI_HTTP_WAITFOR_0_DISCON',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SNI_LISTENER_ACCESS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SNI_TASK_COMPLETION',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SOAP_READ',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SOAP_WRITE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SOS_CALLBACK_REMOVAL',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SOS_DISPATCHER_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SOS_LOCALALLOCATORLIST',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SOS_MEMORY_USAGE_ADJUSTMENT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SOS_OBJECT_STORE_DESTROY_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SOS_PROCESS_AFFINITY_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SOS_RESERVEDMEMBLOCKLIST',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SOS_SCHEDULER_YIELD',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SOS_SMALL_PAGE_ALLOC',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SOS_STACKSTORE_INIT_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SOS_SYNC_TASK_ENQUEUE_EVENT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SOS_VIRTUALMEMORY_LOW',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SOSHOST_EVENT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SOSHOST_INTERNAL',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SOSHOST_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SOSHOST_RWLOCK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SOSHOST_SEMAPHORE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SOSHOST_SLEEP',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SOSHOST_TRACELOCK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SOSHOST_WAITFORDONE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SP_SERVER_DIAGNOSTICS_SLEEP',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SQLCLR_APPDOMAIN',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SQLCLR_ASSEMBLY',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SQLCLR_DEADLOCK_DETECTION',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SQLCLR_QUANTUM_PUNISHMENT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SQLSORT_NORMMUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SQLSORT_SORTMUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SQLTRACE_BUFFER_FLUSH',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SQLTRACE_LOCK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SQLTRACE_SHUTDOWN',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SQLTRACE_WAIT_ENTRIES',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'SRVPROC_SHUTDOWN',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'TEMPOBJ',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'THREADPOOL',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'TIMEPRIV_TIMEPERIOD',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'TRACE_EVTNOTIF',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'TRACEWRITE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'TRAN_MARKLATCH_DT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'TRAN_MARKLATCH_EX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'TRAN_MARKLATCH_KP',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'TRAN_MARKLATCH_NL',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'TRAN_MARKLATCH_SH',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'TRAN_MARKLATCH_UP',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'TRANSACTION_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'UTIL_PAGE_ALLOC',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'VIA_ACCEPT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'VIEW_DEFINITION_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'WAIT_FOR_RESULTS',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'WAITFOR',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'WAITFOR_TASKSHUTDOWN',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'WAITSTAT_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'WCC',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'WORKTBL_DROP',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'WRITE_COMPLETION',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'WRITELOG',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'XACT_OWN_TRANSACTION',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'XACT_RECLAIM_SESSION',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'XACTLOCKINFO',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'XACTWORKSPACE_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'XE_BUFFERMGR_ALLPROCESSED_EVENT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'XE_BUFFERMGR_FREEBUF_EVENT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'XE_DISPATCHER_CONFIG_SESSION_LIST',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'XE_DISPATCHER_JOIN',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'XE_DISPATCHER_WAIT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'XE_MODULEMGR_SYNC',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'XE_OLS_LOCK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'XE_PACKAGE_LOCK_BACKOFF',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'XE_SERVICES_EVENTMANUAL',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'XE_SERVICES_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'XE_SERVICES_RWLOCK',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'XE_SESSION_CREATE_SYNC',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'XE_SESSION_FLUSH',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'XE_SESSION_SYNC',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'XE_STM_CREATE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'XE_TIMER_EVENT',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'XE_TIMER_MUTEX',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage
exec p_InsertWaitTypes @WaitType= 'XE_TIMER_TASK_DONE',@ReturnID=@ReturnID, @ReturnMessage=@ReturnMessage


-- add defintions for each wait type
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'ABR'
update WaitTypes set Description = 'Caused when there is exclusive access to assembly loading.' where WaitType = 'ASSEMBLY_LOAD'
update WaitTypes set Description = 'Caused when parallel threads that are executing tasks such as file creation or initialization are attempting to synchronize.' where WaitType = 'ASYNC_DISKPOOL_LOCK'
update WaitTypes set Description = 'Caused when a task is waiting for an asynchronous I/O operation to finish.' where WaitType = 'ASYNC_IO_COMPLETION'
update WaitTypes set Description = 'Caused when network writes are blocked behind the network. Ensure the client is processing server data.' where WaitType = 'ASYNC_NETWORK_IO'
update WaitTypes set Description = 'Caused when there is a wait on a lock that controls access to a special cache. This cache has information on the audits that are being used to audit each audit action group.' where WaitType = 'AUDIT_GROUPCACHE_LOCK'
update WaitTypes set Description = 'Caused when there is a wait on a lock that controls access to a special cache.  This cache has information on the audits that are being used to audit each audit action group.' where WaitType = 'AUDIT_LOGINCACHE_LOCK'
update WaitTypes set Description = 'Caused when there is a wait on a lock that ensures single initialization of audit related Extended Event targets.' where WaitType = 'AUDIT_ON_DEMAND_TARGET_LOCK'
update WaitTypes set Description = 'Caused when there is a wait on a lock that synchronizes the start and stop of audit related Extended Events sessions.' where WaitType = 'AUDIT_XE_SESSION_MGR'
update WaitTypes set Description = 'Caused when tasks are blocked as part of backup processing.' where WaitType = 'BACKUP'
update WaitTypes set Description = '' where WaitType = 'BACKUP_CLIENTLOCK'
update WaitTypes set Description = 'Caused when tasks are waiting for a tape mount. ' where WaitType = 'BACKUP_OPERATOR'
update WaitTypes set Description = 'Caused when a backup task is either waiting for data, or is waiting for a buffer to store data. This type is typically seen only when a task is waiting for a tape mount.' where WaitType = 'BACKUPBUFFER'
update WaitTypes set Description = 'Caused when a backup task is either waiting for data, or is waiting for a buffer to store data. This type is typically seen only when a task is waiting for a tape mount.' where WaitType = 'BACKUPIO'
update WaitTypes set Description = 'Caused when a task is waiting for a backup task to finish. Wait times may be long, from several minutes to several hours. If the task that is being waited on is in an I/O process, this type does not indicate a problem.' where WaitType = 'BACKUPTHREAD'
update WaitTypes set Description = 'Caused when the background suspect page logger is attempting to avoid running more than every five seconds. Excessive suspect pages cause the logger to run frequently.' where WaitType = 'BAD_PAGE_PROCESS'
update WaitTypes set Description = 'Caused when waiting for access to receive a message on a connection endpoint.' where WaitType = 'BROKER_CONNECTION_RECEIVE_TASK'
update WaitTypes set Description = 'Caused when contention exists to access the state of a Service Broker connection endpoint.' where WaitType = 'BROKER_ENDPOINT_STATE_MUTEX'
update WaitTypes set Description = 'Caused when a task is waiting in the primary event handler of the Service Broker.' where WaitType = 'BROKER_EVENTHANDLER'
update WaitTypes set Description = 'Caused when initializing Service Broker in each active database.' where WaitType = 'BROKER_INIT'
update WaitTypes set Description = 'Caused when a task is waiting for the primary event handler of the Service Broker to start. ' where WaitType = 'BROKER_MASTERSTART'
update WaitTypes set Description = 'Caused when RECEIVE WAITFOR is waiting. This happens when no messages are ready to be received.' where WaitType = 'BROKER_RECEIVE_WAITFOR'
update WaitTypes set Description = 'Caused during the initialization of a Service Broker connection endpoint.' where WaitType = 'BROKER_REGISTERALLENDPOINTS'
update WaitTypes set Description = 'Caused when the Service Broker destination list that is associated with a target service is updated or re-prioritized.' where WaitType = 'BROKER_SERVICE'
update WaitTypes set Description = 'Caused when there is a planned shutdown of Service Broker. ' where WaitType = 'BROKER_SHUTDOWN'
update WaitTypes set Description = 'Caused when the Service Broker queue task handler tries to shut down the task. The state check is serialized and must be in a running state beforehand.' where WaitType = 'BROKER_TASK_STOP'
update WaitTypes set Description = 'Caused when the Service Broker lazy flusher flushes the in-memory transmission objects to a work table.' where WaitType = 'BROKER_TO_FLUSH'
update WaitTypes set Description = 'Caused when the Service Broker transmitter is waiting for work.' where WaitType = 'BROKER_TRANSMITTER'
update WaitTypes set Description = '' where WaitType = 'BROKER_XMIT_SHUTDOWN'
update WaitTypes set Description = '' where WaitType = 'BROKER_XMIT_START'
update WaitTypes set Description = '' where WaitType = 'BROKER_XMIT_TABLE'
update WaitTypes set Description = 'Caused when when the instances is started while internal data structures are initializing. Will not occur once the data structures have initialized.' where WaitType = 'BUILTIN_HASHKEY_MUTEX'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'CHECK_PRINT_RECORD'
update WaitTypes set Description = 'Caused when the checkpoint task is waiting for the next checkpoint request.' where WaitType = 'CHECKPOINT_QUEUE'
update WaitTypes set Description = 'Caused when the checkpoint thread is told that it can start at server startup.' where WaitType = 'CHKPT'
update WaitTypes set Description = 'Caused when operations occur that change the state of a database, such as the opening or closing a database.' where WaitType = 'CLEAR_DB'
update WaitTypes set Description = 'Caused when a task is currently performing common language runtime (CLR) execution and is waiting for a particular autoevent to be initiated. Long waits are typical, and do not indicate a problem.' where WaitType = 'CLR_AUTO_EVENT'
update WaitTypes set Description = 'Caused when a task is currently performing a CLR execution and is waiting to enter a critical area that is currently being used by another task.' where WaitType = 'CLR_CRST'
update WaitTypes set Description = 'Caused when a task is currently performing a CLR execution and waiting for another task to end. This wait state occurs when there is a join between tasks.' where WaitType = 'CLR_JOIN'
update WaitTypes set Description = 'Caused when a task is currently performing a CLR execution and is waiting for a specific manual event to begin.' where WaitType = 'CLR_MANUAL_EVENT'
update WaitTypes set Description = 'Caused when waiting on lock acquisition for a data structure that is used to record all virtual memory allocations that come from CLR. The data structure is locked to maintain its integrity if there is parallel access.' where WaitType = 'CLR_MEMORY_SPY'
update WaitTypes set Description = 'Caused when a task is performing a CLR execution and is waiting to obtain a lock on the monitor.' where WaitType = 'CLR_MONITOR'
update WaitTypes set Description = 'Caused when a task is performing a CLR execution and is waiting for a reader lock.' where WaitType = 'CLR_RWLOCK_READER'
update WaitTypes set Description = 'Caused when a task is performing a CLR execution and is waiting for a writer lock.' where WaitType = 'CLR_RWLOCK_WRITER'
update WaitTypes set Description = 'Caused when a task is performing a CLR execution and is waiting for a semaphore.' where WaitType = 'CLR_SEMAPHORE'
update WaitTypes set Description = 'Caused when waiting for a CLR task to complete startup.' where WaitType = 'CLR_TASK_START'
update WaitTypes set Description = 'Caused when a task is waiting acquire exclusive access to the CLR-hosting data structures. This wait type occurs while setting up or tearing down the CLR runtime.' where WaitType = 'CLRHOST_STATE_ACCESS'
update WaitTypes set Description = 'Caused when a task is waiting on a thread-safe memory object. The wait time might increase when there is contention caused by multiple tasks trying to allocate memory from the same memory object.' where WaitType = 'CMEMTHREAD'
update WaitTypes set Description = '' where WaitType = 'COMMIT_TABLE'
update WaitTypes set Description = '' where WaitType = 'CURSOR'
update WaitTypes set Description = '' where WaitType = 'CURSOR_ASYNC'
update WaitTypes set Description = 'Caused when parallelized query threads have an unequal workload, causing a block on the entire query until the longest-running thread is complete. See help for further discussion.' where WaitType = 'CXPACKET'
update WaitTypes set Description = 'Caused when a parallel range scan is in progress.' where WaitType = 'CXROWSET_SYNC'
update WaitTypes set Description = 'Caused when the dedicated administrator connection is initializing.' where WaitType = 'DAC_INIT'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'DBMIRROR_DBM_EVENT'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'DBMIRROR_DBM_MUTEX'
update WaitTypes set Description = 'Caused when database mirroring is waiting for events to process.' where WaitType = 'DBMIRROR_EVENTS_QUEUE'
update WaitTypes set Description = 'Caused when a task is waiting for a communications backlog at the network layer to clear. This wait indicates that the communications layer is starting to become overloaded and is affecting the database mirroring data throughput.' where WaitType = 'DBMIRROR_SEND'
update WaitTypes set Description = 'Caused when the database mirroring worker task is waiting for more work.' where WaitType = 'DBMIRROR_WORKER_QUEUE'
update WaitTypes set Description = 'Caused when a task is waiting for log records to be flushed to disk. This wait is typically held for a long period of time.' where WaitType = 'DBMIRRORING_CMD'
update WaitTypes set Description = '' where WaitType = 'DBTABLE'
update WaitTypes set Description = 'Caused when the deadlock monitor and sys.dm_os_waiting_tasks try to make sure that SQL Server is not running multiple deadlock searches at the same time.' where WaitType = 'DEADLOCK_ENUM_MUTEX'
update WaitTypes set Description = 'Caused when the server is executing queries on top of sys.dm_os_waiting_tasks, and these queries are blocking the deadlock monitor from running deadlock searches. Queries on top of the sys.dm_os_waiting_tasks use DEADLOCK_ENUM_MUTEX and this wait type is only used by the deadlock monitor.' where WaitType = 'DEADLOCK_TASK_SEARCH'
update WaitTypes set Description = 'Caused when Transact-SQL and CLR are debugging for internal synchronization.' where WaitType = 'DEBUG'
update WaitTypes set Description = 'Caused when SQL Server polls the version transaction manager to see whether the timestamp of the earliest active transaction is later than the timestamp of when the state started changing. If the timestamp is later, all the snapshot transactions that were started before the ALTER DATABASE statement was run have finished. This wait state is used when SQL Server disables versioning by using the ALTER DATABASE statement.' where WaitType = 'DISABLE_VERSIONING'
update WaitTypes set Description = 'Caused when a task is waiting to access a file when an external backup is active. This is reported for each waiting user process. A count larger than five per user process may indicate that the SNAPSHOT BACKUP is taking too much time to finish.' where WaitType = 'DISKIO_SUSPEND'
update WaitTypes set Description = 'Caused when a thread from the dispatcher pool is waiting for more work to process. When the dispatcher is idle the wait time will increase.' where WaitType = 'DISPATCHER_QUEUE_SEMAPHORE'
update WaitTypes set Description = 'Caused once while waiting for the XML parser DLL to load.' where WaitType = 'DLL_LOADING_MUTEX'
update WaitTypes set Description = 'Caused between attempts to drop a temporary object if the previous attempt failed. The wait duration grows exponentially with each failed drop attempt.' where WaitType = 'DROPTEMP'
update WaitTypes set Description = 'Caused when tasks are waiting on an event that is used to manage state transition. The manage state transition controls when the recovery of Microsoft Distributed Transaction Coordinator (MS DTC) transactions occurs after SQL Server receives notification that the MS DTC service has become unavailable. This state also describes a task that is waiting when a commit of a MS DTC transaction is initiated by SQL Server and SQL Server is waiting for the MS DTC commit to finish.' where WaitType = 'DTC'
update WaitTypes set Description = 'Caused in a MS DTC worker session when the session is waiting to take ownership of a MS DTC transaction. After MS DTC owns the transaction, the session can roll back the transaction. Generally, the session will wait for another session that is using the transaction.' where WaitType = 'DTC_ABORT_REQUEST'
update WaitTypes set Description = 'Caused when a recovery task is waiting for the master database in a cross-database transaction so that the task can query the outcome of the transaction.' where WaitType = 'DTC_RESOLVE'
update WaitTypes set Description = 'Caused when a task is waiting for an event that protects changes to the internal MS DTC global state object. This wait should be very short.' where WaitType = 'DTC_STATE'
update WaitTypes set Description = 'Caused in a MS DTC worker session when SQL Server receives notification that the MS DTC service is not available. The worker waits for the MS DTC recovery process to start. Once the recovery process starts, the worker waits to obtain the outcome of the distributed transaction that the worker is working on. This continues until the connection with the MS DTC service has been reestablished.' where WaitType = 'DTC_TMDOWN_REQUEST'
update WaitTypes set Description = 'Caused when recovery tasks wait for MS DTC to become active to enable the resolution of prepared transactions.' where WaitType = 'DTC_WAITFOR_OUTCOME'
update WaitTypes set Description = 'Caused when a main task is waiting for a subtask to generate data. This state does not occur normally. A long wait time indicates an unexpected blockage. ' where WaitType = 'DUMP_LOG_COORDINATOR'
update WaitTypes set Description = '' where WaitType = 'DUMP_LOG_COORDINATOR_QUEUE'
update WaitTypes set Description = 'Caused  for informational purposes only. Not supported. Future compatibility is not guaranteed.' where WaitType = 'DUMPTRIGGER'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'EC'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'EE_PMOLOCK'
update WaitTypes set Description = 'Caused during the synchronization of internal procedure hash table creation. This wait only occurs during the initial accessing of the hash table after the SQL Server instance starts.' where WaitType = 'EE_SPECPROC_MAP_INIT'
update WaitTypes set Description = 'Caused when SQL Server waits for all update transactions in this database to finish before declaring the database ready to transition to snapshot isolation allowed state. This state is used when SQL Server enables snapshot isolation by using the ALTER DATABASE statement.' where WaitType = 'ENABLE_VERSIONING'
update WaitTypes set Description = 'Caused during the synchronization of multiple concurrent error log initializations.' where WaitType = 'ERROR_REPORTING_MANAGER'
update WaitTypes set Description = 'Caused during the synchronization in the query processor exchange iterator during parallel queries.' where WaitType = 'EXCHANGE'
update WaitTypes set Description = 'Caused during parallel queries while synchronizing in query processor in areas not related to the exchange iterator. Examples of such areas are bitmaps, large binary objects (LOBs), and the spool iterator. LOBs may frequently use this wait state.' where WaitType = 'EXECSYNC'
update WaitTypes set Description = 'Caused during the synchronization between producer and consumer parts of batch execution that are submitted through the connection context.' where WaitType = 'EXECUTION_PIPE_EVENT_INTERNAL'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'FAILPOINT'
update WaitTypes set Description = 'Caused when snapshot reads(or a temporary snapshot created by DBCC) sparse file are synchronized.' where WaitType = 'FCB_REPLICA_READ'
update WaitTypes set Description = '' where WaitType = 'FCB_REPLICA_START'
update WaitTypes set Description = 'Caused when snapshot page pushing or pulling of a (or a temporary snapshot created by DBCC) sparse file is synchronized.' where WaitType = 'FCB_REPLICA_WRITE'
update WaitTypes set Description = 'Caused when a wait by the FILESTREAM garbage collector to do either of the following occurs: (1) Disable garbage collection (used by backup and restore). (2) Execute one cycle of the FILESTREAM garbage collector.' where WaitType = 'FS_FC_RWLOCK'
update WaitTypes set Description = 'Caused when the FILESTREAM garbage collector is waiting for cleanup tasks to be completed.' where WaitType = 'FS_GARBAGE_COLLECTOR_SHUTDOWN'
update WaitTypes set Description = 'Caused when there is a wait to acquire access to the FILESTREAM header of a FILESTREAM data container to either read or update contents in the FILESTREAM header file (Filestream.hdr).' where WaitType = 'FS_HEADER_RWLOCK'
update WaitTypes set Description = 'Caused when there is a wait to acquire access to the FILESTREAM log truncation to do either of the following: (1) Temporarily disable the FILESTREAM log (FSLOG) truncation (used by backup and restore). (2) Execute one cycle of FSLOG truncation.' where WaitType = 'FS_LOGTRUNC_RWLOCK'
update WaitTypes set Description = 'Caused when a FILESTREAM file I/O operation needs to bind to the associated transaction, but the transaction is currently owned by another session.' where WaitType = 'FSA_FORCE_OWN_XACT'
update WaitTypes set Description = 'Caused when a FILESTREAM file I/O operation is waiting for a FILESTREAM agent resource that is being used by another file I/O operation.' where WaitType = 'FSAGENT'
update WaitTypes set Description = 'Caused when there is a wait for another FILESTREAM feature reconfiguration to be completed.' where WaitType = 'FSTR_CONFIG_MUTEX'
update WaitTypes set Description = 'Caused when there is a wait to serialize access to the FILESTREAM configuration parameters.' where WaitType = 'FSTR_CONFIG_RWLOCK'
update WaitTypes set Description = '' where WaitType = 'FT_COMPROWSET_RWLOCK'
update WaitTypes set Description = '' where WaitType = 'FT_IFTS_RWLOCK'
update WaitTypes set Description = 'Caused when a background task processing full-text search requests indicates it is waiting for work to do: Unless unexplained FTS issues are occuring, you can safely ignore this wait.' where WaitType = 'FT_IFTS_SCHEDULER_IDLE_WAIT'
update WaitTypes set Description = '' where WaitType = 'FT_IFTSHC_MUTEX'
update WaitTypes set Description = '' where WaitType = 'FT_IFTSISM_MUTEX'
update WaitTypes set Description = '' where WaitType = 'FT_MASTER_MERGE'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'FT_METADATA_MUTEX'
update WaitTypes set Description = 'Caused when a full-text crawl needs to restart from a last known good point to recover from a transient failure. The wait allows worker tasks currently working on that population to complete or exit the current step.' where WaitType = 'FT_RESTART_CRAWL'
update WaitTypes set Description = '' where WaitType = 'FT_RESUME_CRAWL'
update WaitTypes set Description = 'Caused when synchronizing full-text operations.' where WaitType = 'FULLTEXT GATHERER'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'GUARDIAN'
update WaitTypes set Description = '' where WaitType = 'HTTP_ENDPOINT_COLLCREATE'
update WaitTypes set Description = 'Caused when the enumeration of HTTP endpoints to start HTTP occurs at startup.' where WaitType = 'HTTP_ENUMERATION'
update WaitTypes set Description = 'Caused when a connection is waiting for HTTP to complete initialization.' where WaitType = 'HTTP_START'
update WaitTypes set Description = '' where WaitType = 'IMP_IMPORT_MUTEX'
update WaitTypes set Description = 'Caused when SQL Server waits for a bulkload I/O to finish.' where WaitType = 'IMPPROV_IOWAIT'
update WaitTypes set Description = '' where WaitType = 'INDEX_USAGE_STATS_MUTEX'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'INTERNAL_TESTING'
update WaitTypes set Description = 'Caused when synchronizing trace event buffers.' where WaitType = 'IO_AUDIT_MUTEX'
update WaitTypes set Description = 'Caused when waiting for I/O operations to complete. This wait type generally represents non-data page I/Os. Data page I/O completion waits appear as PAGEIOLATCH_* waits.' where WaitType = 'IO_COMPLETION'
update WaitTypes set Description = 'Caused when waiting for an I/O operation (read or a write to disk) fails due to insufficient resources. The operation has to try again.' where WaitType = 'IO_RETRY'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'IOAFF_RANGE_QUEUE'
update WaitTypes set Description = 'Caused when the service control task is waiting for requests from the Service Control Manager. Long waits are normal.' where WaitType = 'KSOURCE_WAKEUP'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'KTM_ENLISTMENT'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'KTM_RECOVERY_MANAGER'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'KTM_RECOVERY_RESOLUTION'
update WaitTypes set Description = 'Caused when waiting for a DT (destroy) latch. This does not include buffer latches or transaction mark latches. A listing of LATCH_* waits is available in sys.dm_os_latch_stats. Note that sys.dm_os_latch_stats groups LATCH_NL, LATCH_SH, LATCH_UP, LATCH_EX, and LATCH_DT waits together.' where WaitType = 'LATCH_DT'
update WaitTypes set Description = '' where WaitType = 'LATCH_EX'
update WaitTypes set Description = 'Caused when waiting for a KP (keep) latch. This does not include buffer latches or transaction mark latches. A listing of LATCH_* waits is available in sys.dm_os_latch_stats. Note that sys.dm_os_latch_stats groups LATCH_NL, LATCH_SH, LATCH_UP, LATCH_EX, and LATCH_DT waits together.' where WaitType = 'LATCH_KP'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'LATCH_NL'
update WaitTypes set Description = 'Caused when waiting for an SH (share) latch. This does not include buffer latches or transaction mark latches. A listing of LATCH_* waits is available in sys.dm_os_latch_stats. Note that sys.dm_os_latch_stats groups LATCH_NL, LATCH_SH, LATCH_UP, LATCH_EX, and LATCH_DT waits together.' where WaitType = 'LATCH_SH'
update WaitTypes set Description = 'Caused when waiting for an UP (update) latch. This does not include buffer latches or transaction mark latches. A listing of LATCH_* waits is available in sys.dm_os_latch_stats. Note that sys.dm_os_latch_stats groups LATCH_NL, LATCH_SH, LATCH_UP, LATCH_EX, and LATCH_DT waits together.' where WaitType = 'LATCH_UP'
update WaitTypes set Description = 'Caused when lazywriter tasks are suspended. This is a measure of the time spent by background tasks that are waiting. This wait can be safely ignored as wait times will cycle as Lazywriter is designed to sleep and wake-up every 1 second.' where WaitType = 'LAZYWRITER_SLEEP'
update WaitTypes set Description = 'Caused when a task is waiting to acquire a Bulk Update (BU) lock.' where WaitType = 'LCK_M_BU'
update WaitTypes set Description = 'Caused when a task is waiting to acquire an Intent Shared (IS) lock.' where WaitType = 'LCK_M_IS'
update WaitTypes set Description = 'Caused when a task is waiting to acquire an Intent Update (IU) lock. ' where WaitType = 'LCK_M_IU'
update WaitTypes set Description = 'Caused when a task is waiting to acquire an Intent Exclusive (IX) lock. ' where WaitType = 'LCK_M_IX'
update WaitTypes set Description = 'Caused when a task is waiting to acquire a NULL lock on the current key value, and an Insert Range lock between the current and previous key. ' where WaitType = 'LCK_M_RIn_NL'
update WaitTypes set Description = 'Caused when a task is waiting to acquire a shared lock on the current key value, and an Insert Range lock between the current and previous key. ' where WaitType = 'LCK_M_RIn_S'
update WaitTypes set Description = 'Caused when a task is waiting to acquire an Update lock on the current key value, and an Insert Range lock between the current and previous key. ' where WaitType = 'LCK_M_RIn_U'
update WaitTypes set Description = 'Caused when a task is waiting to acquire an Exclusive lock on the current key value, and an Insert Range lock between the current and previous key. ' where WaitType = 'LCK_M_RIn_X'
update WaitTypes set Description = 'Caused when a task is waiting to acquire a Shared lock on the current key value, and a Shared Range lock between the current and previous key. ' where WaitType = 'LCK_M_RS_S'
update WaitTypes set Description = 'Caused when a task is waiting to acquire an Update lock on the current key value, and an Update Range lock between the current and previous key. ' where WaitType = 'LCK_M_RS_U'
update WaitTypes set Description = 'Caused when a task is waiting to acquire a Shared lock on the current key value, and an Exclusive Range lock between the current and previous key. ' where WaitType = 'LCK_M_RX_S'
update WaitTypes set Description = 'Caused when a task is waiting to acquire an Update lock on the current key value, and an Exclusive range lock between the current and previous key. ' where WaitType = 'LCK_M_RX_U'
update WaitTypes set Description = 'Caused when a task is waiting to acquire an Exclusive lock on the current key value, and an Exclusive Range lock between the current and previous key. ' where WaitType = 'LCK_M_RX_X'
update WaitTypes set Description = 'Caused when a task is waiting to acquire a Shared lock. ' where WaitType = 'LCK_M_S'
update WaitTypes set Description = 'Caused when a task is waiting to acquire a Schema Modify lock. ' where WaitType = 'LCK_M_SCH_M'
update WaitTypes set Description = 'Caused when a task is waiting to acquire a Schema Share lock. ' where WaitType = 'LCK_M_SCH_S'
update WaitTypes set Description = 'Caused when a task is waiting to acquire a Shared With Intent Update lock. ' where WaitType = 'LCK_M_SIU'
update WaitTypes set Description = 'Caused when a task is waiting to acquire a Shared With Intent Exclusive lock. ' where WaitType = 'LCK_M_SIX'
update WaitTypes set Description = 'Caused when a task is waiting to acquire an Update lock. ' where WaitType = 'LCK_M_U'
update WaitTypes set Description = 'Caused when a task is waiting to acquire an Update With Intent Exclusive lock. ' where WaitType = 'LCK_M_UIX'
update WaitTypes set Description = 'Caused when a task is waiting to acquire an Exclusive lock. ' where WaitType = 'LCK_M_X'
update WaitTypes set Description = 'Caused when a task is waiting for space in the WRITELOG buffer to store a log record. This wait is typical when there is an I/O botteneck. Look for WRITERLOG waiters and if found the overall problem is an I/O bottleneck on the storage system associated with the transaction log.' where WaitType = 'LOGBUFFER'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'LOGGENERATION'
update WaitTypes set Description = 'Caused when a task is waiting for any outstanding log I/Os to finish before shutting down the log while closing the database.' where WaitType = 'LOGMGR'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'LOGMGR_FLUSH'
update WaitTypes set Description = 'Caused when the log writer task is waiting for work requests. You should be able to safely ignore this wait type unless you believe a problem exists in processing log blocks to flush to the transaction log. ' where WaitType = 'LOGMGR_QUEUE'
update WaitTypes set Description = 'Caused when a task is waiting to see whether log truncation frees up log space to enable the task to write a new log record. ' where WaitType = 'LOGMGR_RESERVE_APPEND'
update WaitTypes set Description = 'Caused while waiting for memory to be available for use.' where WaitType = 'LOWFAIL_MEMMGR_QUEUE'
update WaitTypes set Description = '' where WaitType = 'METADATA_LAZYCACHE_RWLOCK'
update WaitTypes set Description = '' where WaitType = 'MIRROR_SEND_MESSAGE'
update WaitTypes set Description = 'Used for informational purposes only. This wait is only seen in SQL Server 2000 and is listed as the default wait in the list and isn''t used to indicate ay real waiting.' where WaitType = 'MISCELLANEOUS'
update WaitTypes set Description = 'Caused when a task is waiting for a distributed query operation to finish. This is used to detect potential Multiple Active Result Set (MARS) application deadlocks. The wait ends when the distributed query call finishes.' where WaitType = 'MSQL_DQ'
update WaitTypes set Description = '' where WaitType = 'MSQL_SYNC_PIPE'
update WaitTypes set Description = 'Caused when a task is waiting to obtain ownership of the session transaction manager to perform a session level transaction operation.' where WaitType = 'MSQL_XACT_MGR_MUTEX'
update WaitTypes set Description = 'Caused during the synchronization of transaction usage. Requests must acquire the mutex before it can use the transaction.' where WaitType = 'MSQL_XACT_MUTEX'
update WaitTypes set Description = 'Caused when a task is waiting for an extended stored procedure to end. SQL Server uses this wait state to detect potential MARS application deadlocks. The wait ends when the extended stored procedure call completes.' where WaitType = 'MSQL_XP'
update WaitTypes set Description = 'Caused during Full-Text Search calls. This wait ends when the full-text operation completes. It does not indicate contention, but rather the duration of full-text operations.' where WaitType = 'MSSEARCH'
update WaitTypes set Description = 'Caused when a connection is waiting for a network packet during a network read.' where WaitType = 'NET_WAITFOR_PACKET'
update WaitTypes set Description = '' where WaitType = 'NODE_CACHE_MUTEX'
update WaitTypes set Description = 'Caused when SQL Server calls the SQL Server Native Client OLE DB Provider. This wait type indicates the duration of calls to the OLE DB provider.' where WaitType = 'OLEDB'
update WaitTypes set Description = 'Caused when a background task waits for high priority system task requests. A long wait time indicates that there have been no high priority requests to process, and should not cause concern.' where WaitType = 'ONDEMAND_TASK_QUEUE'
update WaitTypes set Description = 'Caused when a task is waiting on a latch for a buffer that is in an I/O request. The latch request is in Destroy mode. A long wait time may indicate problems with the disk subsystem.' where WaitType = 'PAGEIOLATCH_DT'
update WaitTypes set Description = 'Caused when a task is waiting on a latch for a buffer that is in an I/O request. The latch request is in Exclusive mode. A long wait time may indicate problems with the disk subsystem.' where WaitType = 'PAGEIOLATCH_EX'
update WaitTypes set Description = 'Caused when a task is waiting on a latch for a buffer that is in an I/O request. The latch request is in Keep mode. A long wait time may indicate problems with the disk subsystem.' where WaitType = 'PAGEIOLATCH_KP'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'PAGEIOLATCH_NL'
update WaitTypes set Description = 'Caused when a task is waiting on a latch for a buffer that is in an I/O request. The latch request is in Shared mode. A long wait time may indicate problems with the disk subsystem.' where WaitType = 'PAGEIOLATCH_SH'
update WaitTypes set Description = 'Caused when a task is waiting on a latch for a buffer that is in an I/O request. The latch request is in Update mode. A long wait time may indicate problems with the disk subsystem.' where WaitType = 'PAGEIOLATCH_UP'
update WaitTypes set Description = 'Caused when a task is waiting on a latch for a buffer that is not in an I/O request. The latch request is in Destroy mode.' where WaitType = 'PAGELATCH_DT'
update WaitTypes set Description = 'Caused when a task is waiting on a latch for a buffer that is not in an I/O request. The latch request is in Exclusive mode.' where WaitType = 'PAGELATCH_EX'
update WaitTypes set Description = 'Caused when a task is waiting on a latch for a buffer that is not in an I/O request. The latch request is in Keep mode.' where WaitType = 'PAGELATCH_KP'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'PAGELATCH_NL'
update WaitTypes set Description = 'Caused when a task is waiting on a latch for a buffer that is not in an I/O request. The latch request is in Shared mode.' where WaitType = 'PAGELATCH_SH'
update WaitTypes set Description = 'Caused when a task is waiting on a latch for a buffer that is not in an I/O request. The latch request is in Update mode.' where WaitType = 'PAGELATCH_UP'
update WaitTypes set Description = 'Caused when serializing output produced by RESTORE HEADERONLY, RESTORE FILELISTONLY, or RESTORE LABELONLY.' where WaitType = 'PARALLEL_BACKUP_QUEUE'
update WaitTypes set Description = '' where WaitType = 'PERFORMANCE_COUNTERS_RWLOCK'
update WaitTypes set Description = '' where WaitType = 'PLACEHOLDER1'
update WaitTypes set Description = '' where WaitType = 'PLACEHOLDER2'
update WaitTypes set Description = 'Caused when a worker is running coded in a non-SQLOS Sceduling Systems mode.' where WaitType = 'PREEMPTIVE_ABR'
update WaitTypes set Description = 'Caused when the SQL Server Operating System (SQLOS) scheduler switches to preemptive mode to write an audit event to the Windows event log.' where WaitType = 'PREEMPTIVE_AUDIT_ACCESS_EVENTLOG'
update WaitTypes set Description = 'Caused when the SQLOS scheduler switches to preemptive mode to write an audit event to the Windows Security log.' where WaitType = 'PREEMPTIVE_AUDIT_ACCESS_SECLOG'
update WaitTypes set Description = 'Caused when the SQLOS scheduler switches to preemptive mode to close backup media.' where WaitType = 'PREEMPTIVE_CLOSEBACKUPMEDIA'
update WaitTypes set Description = 'Caused when the SQLOS scheduler switches to preemptive mode to close a tape backup device.' where WaitType = 'PREEMPTIVE_CLOSEBACKUPTAPE'
update WaitTypes set Description = 'Caused when the SQLOS scheduler switches to preemptive mode to close a virtual backup device.' where WaitType = 'PREEMPTIVE_CLOSEBACKUPVDIDEVICE'
update WaitTypes set Description = 'Caused when the SQLOS scheduler switches to preemptive mode to perform Windows failover cluster operations.' where WaitType = 'PREEMPTIVE_CLUSAPI_CLUSTERRESOURCECONTROL'
update WaitTypes set Description = 'Caused when the SQLOS scheduler switches to preemptive mode to create a COM object.' where WaitType = 'PREEMPTIVE_COM_COCREATEINSTANCE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_COGETCLASSOBJECT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_CREATEACCESSOR'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_DELETEROWS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_GETCOMMANDTEXT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_GETDATA'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_GETNEXTROWS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_GETRESULT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_GETROWSBYBOOKMARK'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_LBFLUSH'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_LBLOCKREGION'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_LBREADAT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_LBSETSIZE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_LBSTAT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_LBUNLOCKREGION'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_LBWRITEAT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_QUERYINTERFACE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_RELEASE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_RELEASEACCESSOR'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_RELEASEROWS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_RELEASESESSION'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_RESTARTPOSITION'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_SEQSTRMREAD'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_SEQSTRMREADANDWRITE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_SETDATAFAILURE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_SETPARAMETERINFO'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_SETPARAMETERPROPERTIES'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_STRMLOCKREGION'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_STRMSEEKANDREAD'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_STRMSEEKANDWRITE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_STRMSETSIZE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_STRMSTAT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_COM_STRMUNLOCKREGION'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_CONSOLEWRITE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_CREATEPARAM'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_DEBUG'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_DFSADDLINK'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_DFSLINKEXISTCHECK'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_DFSLINKHEALTHCHECK'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_DFSREMOVELINK'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_DFSREMOVEROOT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_DFSROOTFOLDERCHECK'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_DFSROOTINIT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_DFSROOTSHARECHECK'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_DTC_ABORT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_DTC_ABORTREQUESTDONE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_DTC_BEGINTRANSACTION'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_DTC_COMMITREQUESTDONE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_DTC_ENLIST'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_DTC_PREPAREREQUESTDONE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_FILESIZEGET'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_FSAOLEDB_ABORTTRANSACTION'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_FSAOLEDB_COMMITTRANSACTION'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_FSAOLEDB_STARTTRANSACTION'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_FSRECOVER_UNCONDITIONALUNDO'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_GETRMINFO'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_LOCKMONITOR'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_MSS_RELEASE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_ODBCOPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OLE_UNINIT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OLEDB_ABORTORCOMMITTRAN'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OLEDB_ABORTTRAN'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OLEDB_GETDATASOURCE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OLEDB_GETLITERALINFO'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OLEDB_GETPROPERTIES'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OLEDB_GETPROPERTYINFO'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OLEDB_GETSCHEMALOCK'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OLEDB_JOINTRANSACTION'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OLEDB_RELEASE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OLEDB_SETPROPERTIES'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OLEDBOPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_ACCEPTSECURITYCONTEXT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_ACQUIRECREDENTIALSHANDLE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_AUTHENTICATIONOPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_AUTHORIZATIONOPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_AUTHZGETINFORMATIONFROMCONTEXT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_AUTHZINITIALIZECONTEXTFROMSID'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_AUTHZINITIALIZERESOURCEMANAGER'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_BACKUPREAD'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_CLOSEHANDLE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_CLUSTEROPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_COMOPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_COMPLETEAUTHTOKEN'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_COPYFILE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_CREATEDIRECTORY'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_CREATEFILE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_CRYPTACQUIRECONTEXT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_CRYPTIMPORTKEY'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_CRYPTOPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_DECRYPTMESSAGE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_DELETEFILE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_DELETESECURITYCONTEXT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_DEVICEIOCONTROL'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_DEVICEOPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_DIRSVC_NETWORKOPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_DISCONNECTNAMEDPIPE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_DOMAINSERVICESOPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_DSGETDCNAME'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_DTCOPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_ENCRYPTMESSAGE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_FILEOPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_FINDFILE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_FLUSHFILEBUFFERS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_FORMATMESSAGE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_FREECREDENTIALSHANDLE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_FREELIBRARY'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_GENERICOPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_GETADDRINFO'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_GETCOMPRESSEDFILESIZE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_GETDISKFREESPACE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_GETFILEATTRIBUTES'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_GETFILESIZE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_GETLONGPATHNAME'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_GETPROCADDRESS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_GETVOLUMENAMEFORVOLUMEMOUNTPOINT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_GETVOLUMEPATHNAME'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_INITIALIZESECURITYCONTEXT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_LIBRARYOPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_LOADLIBRARY'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_LOGONUSER'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_LOOKUPACCOUNTSID'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_MESSAGEQUEUEOPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_MOVEFILE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_NETGROUPGETUSERS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_NETLOCALGROUPGETMEMBERS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_NETUSERGETGROUPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_NETUSERGETLOCALGROUPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_NETUSERMODALSGET'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_NETVALIDATEPASSWORDPOLICY'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_NETVALIDATEPASSWORDPOLICYFREE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_OPENDIRECTORY'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_PIPEOPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_PROCESSOPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_QUERYREGISTRY'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_QUERYSECURITYCONTEXTTOKEN'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_REMOVEDIRECTORY'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_REPORTEVENT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_REVERTTOSELF'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_RSFXDEVICEOPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_SECURITYOPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_SERVICEOPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_SETENDOFFILE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_SETFILEPOINTER'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_SETFILEVALIDDATA'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_SETNAMEDSECURITYINFO'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_SQLCLROPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_SQMLAUNCH'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_VERIFYSIGNATURE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_VSSOPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_WAITFORSINGLEOBJECT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_WINSOCKOPS'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_WRITEFILE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_WRITEFILEGATHER'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_OS_WSASETLASTERROR'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_REENLIST'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_RESIZELOG'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_ROLLFORWARDREDO'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_ROLLFORWARDUNDO'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_SB_STOPENDPOINT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_SERVER_STARTUP'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_SETRMINFO'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_SHAREDMEM_GETDATA'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_SNIOPEN'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_SOSHOST'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'PREEMPTIVE_SOSTESTING'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_STARTRM'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_STREAMFCB_CHECKPOINT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_STREAMFCB_RECOVER'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'PREEMPTIVE_STRESSDRIVER'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'PREEMPTIVE_TESTING'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_TRANSIMPORT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_UNMARSHALPROPAGATIONTOKEN'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_VSS_CREATESNAPSHOT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_VSS_CREATEVOLUMESNAPSHOT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_XE_CALLBACKEXECUTE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_XE_DISPATCHER'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_XE_ENGINEINIT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_XE_GETTARGETSTATE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_XE_SESSIONCOMMIT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_XE_TARGETFINALIZE'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_XE_TARGETINIT'
update WaitTypes set Description = '' where WaitType = 'PREEMPTIVE_XE_TIMERRUN'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'PREEMPTIVE_XETESTING'
update WaitTypes set Description = 'Caused while waiting for user processes to end in a database that has been transitioned by using the ALTER DATABASE termination clause. ' where WaitType = 'PRINT_ROLLBACK_PROGRESS'
update WaitTypes set Description = '' where WaitType = 'QNMANAGER_ACQUIRE'
update WaitTypes set Description = 'Caused when a asynchronous automatic statistics update is canceled by a call to KILL as the update was starting to run. The terminating thread is suspended, waiting for it to start listening for KILL commands. An acceptable value is less than one second.' where WaitType = 'QPJOB_KILL'
update WaitTypes set Description = 'Caused when an asynchronous automatic statistics update is canceled by a call to KILL when it was running. The update has now completed but is suspended until the terminating thread message coordination is complete. This is an ordinary but rare state, and should be very short. An acceptable value is less than one second.' where WaitType = 'QPJOB_WAITFOR_ABORT'
update WaitTypes set Description = 'Caused when Query Execution memory management tries to control access to a static grant information list. This state lists information about the current granted and waiting memory requests and is a simple access control state. There should never be a long wait on this state.' where WaitType = 'QRY_MEM_GRANT_INFO_MUTEX'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'QUERY_ERRHDL_SERVICE_DONE'
update WaitTypes set Description = 'Caused when offline create index builds are run in parallel, and the different worker threads that are sorting synchronize access to the sort files.' where WaitType = 'QUERY_EXECUTION_INDEX_SORT_EVENT_OPEN'
update WaitTypes set Description = 'Caused  during synchronization of the garbage collection queue in the Query Notification Manager.' where WaitType = 'QUERY_NOTIFICATION_MGR_MUTEX'
update WaitTypes set Description = 'Caused during state synchronization for transactions in Query Notifications.' where WaitType = 'QUERY_NOTIFICATION_SUBSCRIPTION_MUTEX'
update WaitTypes set Description = 'Caused during internal synchronization within the Query Notification Manager.' where WaitType = 'QUERY_NOTIFICATION_TABLE_MGR_MUTEX'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'QUERY_NOTIFICATION_UNITTEST_MUTEX'
update WaitTypes set Description = 'Caused during synchronization of query optimizer diagnostic output production. This wait type only occurs if diagnostic settings have been enabled under direction of Microsoft Product Support.' where WaitType = 'QUERY_OPTIMIZER_PRINT_MUTEX'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'QUERY_TRACEOUT'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'QUERY_WAIT_ERRHDL_SERVICE'
update WaitTypes set Description = 'Caused during synchronization of database status in warm standby database.' where WaitType = 'RECOVER_CHANGEDB'
update WaitTypes set Description = 'Caused during synchronization on a replication article cache. During these waits, the replication log reader stalls, and data definition language (DDL) statements on a published table are blocked.' where WaitType = 'REPL_CACHE_ACCESS'
update WaitTypes set Description = '' where WaitType = 'REPL_HISTORYCACHE_ACCESS'
update WaitTypes set Description = 'Caused during synchronization of replication schema version information. This state exists when DDL statements are executed on the replicated object, and when the log reader builds or consumes versioned schema based on DDL occurrence.' where WaitType = 'REPL_SCHEMA_ACCESS'
update WaitTypes set Description = '' where WaitType = 'REPL_TRANHASHTABLE_ACCESS'
update WaitTypes set Description = 'Caused when a task is waiting for completion of page writes to database snapshots or DBCC replicas.' where WaitType = 'REPLICA_WRITES'
update WaitTypes set Description = 'Caused when a task is waiting for all outstanding I/O to complete, so that I/O to a file can be frozen for snapshot backup.' where WaitType = 'REQUEST_DISPENSER_PAUSE'
update WaitTypes set Description = 'Caused when the deadlock monitor waits to start the next deadlock search. This wait is expected between deadlock detections, and lengthy total waiting time on this resource does not indicate a problem.' where WaitType = 'REQUEST_FOR_DEADLOCK_SEARCH'
update WaitTypes set Description = 'Caused when a new request comes in and is throttled based on the GROUP_MAX_REQUESTS setting.' where WaitType = 'RESMGR_THROTTLED'
update WaitTypes set Description = 'Caused during synchronization of various internal resource queues.' where WaitType = 'RESOURCE_QUEUE'
update WaitTypes set Description = 'Caused when a query memory request cannot be granted immediately due to other concurrent queries. Long waits and wait times may indicate excessive number of concurrent queries, or excessive memory request amounts.' where WaitType = 'RESOURCE_SEMAPHORE'
update WaitTypes set Description = 'Caused when a query waits for its request for a thread reservation to be fulfilled. The wait also occurs when synchronizing query compile and memory grant requests.' where WaitType = 'RESOURCE_SEMAPHORE_MUTEX'
update WaitTypes set Description = 'Caused when the number of concurrent query compilations reaches a throttling limit. High waits and wait times may indicate excessive compilations, recompiles, or uncachable plans.' where WaitType = 'RESOURCE_SEMAPHORE_QUERY_COMPILE'
update WaitTypes set Description = 'Caused when memory request by a small query cannot be granted immediately due to other concurrent queries. Wait time should not exceed more than a few seconds, because the server transfers the request to the main query memory pool if it fails to grant the requested memory within a few seconds. High waits may indicate an excessive number of concurrent small queries while the main memory pool is blocked by waiting queries.' where WaitType = 'RESOURCE_SEMAPHORE_SMALL_QUERY'
update WaitTypes set Description = '' where WaitType = 'RFS_MSGPUMP'
update WaitTypes set Description = '' where WaitType = 'RFS_NOTIFYTHREAD'
update WaitTypes set Description = '' where WaitType = 'RFS_STARTUP'
update WaitTypes set Description = '' where WaitType = 'RG_RECONFIG'
update WaitTypes set Description = 'Caused after a failed attempt to drop a temporary security key before a retry attempt.' where WaitType = 'SEC_DROP_TEMP_KEY'
update WaitTypes set Description = 'Caused when there is a wait for mutexes that control access to the global list of Extensible Key Management (EKM) cryptographic providers and the session-scoped list of EKM sessions.' where WaitType = 'SECURITY_MUTEX'
update WaitTypes set Description = 'Caused when a new sequential GUID is being obtained.' where WaitType = 'SEQUENTIAL_GUID'
update WaitTypes set Description = 'Caused when synchronization of SQL Server instance idle status when a resource monitor is attempting to declare a SQL Server instance as idle or trying to wake up.' where WaitType = 'SERVER_IDLE_CHECK'
update WaitTypes set Description = 'Caused when a shutdown statement waits for active connections to exit.' where WaitType = 'SHUTDOWN'
update WaitTypes set Description = 'Caused when a checkpoint is throttling the issuance of new I/Os in order to avoid flooding the disk subsystem.' where WaitType = 'SLEEP_BPOOL_FLUSH'
update WaitTypes set Description = 'Caused during database startup while waiting for all databases to recover.' where WaitType = 'SLEEP_DBSTARTUP'
update WaitTypes set Description = 'Caused once at most during SQL Server instance startup while waiting for DCOM initialization to complete.' where WaitType = 'SLEEP_DCOMSTARTUP'
update WaitTypes set Description = 'Caused when SQL Trace waits for the msdb database to complete startup.' where WaitType = 'SLEEP_MSDBSTARTUP'
update WaitTypes set Description = 'Caused during the start of a background task while waiting for tempdb to complete startup.' where WaitType = 'SLEEP_SYSTEMTASK'
update WaitTypes set Description = 'Caused when a task sleeps while waiting for a generic event to occur.' where WaitType = 'SLEEP_TASK'
update WaitTypes set Description = 'Caused when a task waits for tempdb to complete startup.' where WaitType = 'SLEEP_TEMPDBSTARTUP'
update WaitTypes set Description = 'Caused when internal synchronization within SQL Server networking components.' where WaitType = 'SNI_CRITICAL_SECTION'
update WaitTypes set Description = '' where WaitType = 'SNI_HTTP_ACCEPT'
update WaitTypes set Description = 'Caused when a SQL Server shutdown occurs while waiting for outstanding HTTP connections to exit.' where WaitType = 'SNI_HTTP_WAITFOR_0_DISCON'
update WaitTypes set Description = 'Caused when waiting for non-uniform memory access (NUMA) nodes to update state change. The access to state change is serialized.' where WaitType = 'SNI_LISTENER_ACCESS'
update WaitTypes set Description = 'Caused when there is a wait for all tasks to finish during a NUMA node state change.' where WaitType = 'SNI_TASK_COMPLETION'
update WaitTypes set Description = 'Caused when waiting for an HTTP network read to complete.' where WaitType = 'SOAP_READ'
update WaitTypes set Description = 'Caused when waiting for an HTTP network write to complete.' where WaitType = 'SOAP_WRITE'
update WaitTypes set Description = 'Caused when performing synchronization on a callback list in order to remove a callback. It is not expected for this counter to change after server initialization is completed.' where WaitType = 'SOS_CALLBACK_REMOVAL'
update WaitTypes set Description = 'Caused when internal synchronization of the dispatcher pool. This includes when the pool is being adjusted.' where WaitType = 'SOS_DISPATCHER_MUTEX'
update WaitTypes set Description = 'Caused when internal synchronization in the SQL Server memory manager occurs.' where WaitType = 'SOS_LOCALALLOCATORLIST'
update WaitTypes set Description = 'Caused when memory usage is being adjusted among pools.' where WaitType = 'SOS_MEMORY_USAGE_ADJUSTMENT'
update WaitTypes set Description = 'Caused when internal synchronization in memory pools destroys objects from the pool.' where WaitType = 'SOS_OBJECT_STORE_DESTROY_MUTEX'
update WaitTypes set Description = 'Caused when synchronizing access to process affinity settings.' where WaitType = 'SOS_PROCESS_AFFINITY_MUTEX'
update WaitTypes set Description = 'Caused when internal synchronization in the SQL Server memory manager occurs.' where WaitType = 'SOS_RESERVEDMEMBLOCKLIST'
update WaitTypes set Description = 'Caused when a task voluntarily yields the scheduler for other tasks to execute. During this wait the task is waiting for its quantum to be renewed.' where WaitType = 'SOS_SCHEDULER_YIELD'
update WaitTypes set Description = 'Caused when the allocation and freeing of memory that is managed by some memory objects. You can safely ignore this wait if there are no unexplained problems with SQLTrace files not getting written to the disk properly.' where WaitType = 'SOS_SMALL_PAGE_ALLOC'
update WaitTypes set Description = 'Caused during the synchronization of internal store initialization.' where WaitType = 'SOS_STACKSTORE_INIT_MUTEX'
update WaitTypes set Description = 'Caused when tasks are started in a synchronous manner. Most tasks in SQL Server are started in an asynchronous manner, in which control returns to the starter immediately after the task request has been placed on the work queue.' where WaitType = 'SOS_SYNC_TASK_ENQUEUE_EVENT'
update WaitTypes set Description = 'Caused when a memory allocation waits for a resource manager to free up virtual memory.' where WaitType = 'SOS_VIRTUALMEMORY_LOW'
update WaitTypes set Description = 'Caused when a hosted component, such as CLR, waits on a SQL Server event synchronization object.' where WaitType = 'SOSHOST_EVENT'
update WaitTypes set Description = 'Caused during synchronization of memory manager callbacks used by hosted components, such as the CLR.' where WaitType = 'SOSHOST_INTERNAL'
update WaitTypes set Description = 'Caused when a hosted component, such as the CLR, waits on a SQL Server mutex synchronization object.' where WaitType = 'SOSHOST_MUTEX'
update WaitTypes set Description = 'Caused when a hosted component, such as the CLR, waits on a SQL Server reader-writer synchronization object.' where WaitType = 'SOSHOST_RWLOCK'
update WaitTypes set Description = 'Caused when a hosted component, such as the CLR, waits on a SQL Server semaphore synchronization object.' where WaitType = 'SOSHOST_SEMAPHORE'
update WaitTypes set Description = 'Caused when a hosted task sleeps while waiting for a generic event to occur. Hosted tasks are used by hosted components such as the CLR.' where WaitType = 'SOSHOST_SLEEP'
update WaitTypes set Description = 'Caused during synchronization of access to trace streams.' where WaitType = 'SOSHOST_TRACELOCK'
update WaitTypes set Description = 'Caused when a hosted component, such as the CLR, waits for a task to complete.' where WaitType = 'SOSHOST_WAITFORDONE'
update WaitTypes set Description = 'Caused when the CLR waits for an application domain to complete startup.' where WaitType = 'SQLCLR_APPDOMAIN'
update WaitTypes set Description = 'Caused when waiting for access to the loaded assembly list in the appdomain.' where WaitType = 'SQLCLR_ASSEMBLY'
update WaitTypes set Description = 'Caused when the CLR waits for deadlock detection to complete.' where WaitType = 'SQLCLR_DEADLOCK_DETECTION'
update WaitTypes set Description = 'Caused when a CLR task is throttled because it has exceeded its execution quantum. This throttling is done in order to reduce the effect of this resource-intensive task on other tasks.' where WaitType = 'SQLCLR_QUANTUM_PUNISHMENT'
update WaitTypes set Description = 'Caused during internal synchronization, while initializing internal sorting structures.' where WaitType = 'SQLSORT_NORMMUTEX'
update WaitTypes set Description = 'Caused during internal synchronization, while initializing internal sorting structures.' where WaitType = 'SQLSORT_SORTMUTEX'
update WaitTypes set Description = 'Caused when a task is waiting for a background task to flush trace buffers to disk every four seconds.' where WaitType = 'SQLTRACE_BUFFER_FLUSH'
update WaitTypes set Description = 'Caused during synchronization on trace buffers during a file trace.' where WaitType = 'SQLTRACE_LOCK'
update WaitTypes set Description = 'Caused when trace shutdown waits for outstanding trace events to complete.' where WaitType = 'SQLTRACE_SHUTDOWN'
update WaitTypes set Description = 'Caused when a SQL Trace event queue waits for packets to arrive on the queue.' where WaitType = 'SQLTRACE_WAIT_ENTRIES'
update WaitTypes set Description = 'Caused when the shutdown process waits for internal resources to be released to shutdown cleanly.' where WaitType = 'SRVPROC_SHUTDOWN'
update WaitTypes set Description = 'Caused when temporary object drops are synchronized. This wait is rare, and only occurs if a task has requested exclusive access for temp table drops.' where WaitType = 'TEMPOBJ'
update WaitTypes set Description = 'Caused when a task is waiting for a worker to run on. This can indicate that the maximum worker setting is too low, or that batch executions are taking unusually long, thus reducing the number of workers available to satisfy other batches.' where WaitType = 'THREADPOOL'
update WaitTypes set Description = 'Caused during internal synchronization of the Extended Events timer.' where WaitType = 'TIMEPRIV_TIMEPERIOD'
update WaitTypes set Description = '' where WaitType = 'TRACE_EVTNOTIF'
update WaitTypes set Description = 'Caused when the SQL Trace rowset trace provider waits for either a free buffer or a buffer with events to process.' where WaitType = 'TRACEWRITE'
update WaitTypes set Description = 'Caused when waiting for a destroy mode latch on a transaction mark latch. Transaction mark latches are used for synchronization of commits with marked transactions.' where WaitType = 'TRAN_MARKLATCH_DT'
update WaitTypes set Description = 'Caused when waiting for an exclusive mode latch on a marked transaction. Transaction mark latches are used for synchronization of commits with marked transactions.' where WaitType = 'TRAN_MARKLATCH_EX'
update WaitTypes set Description = 'Caused when waiting for a keep mode latch on a marked transaction. Transaction mark latches are used for synchronization of commits with marked transactions.' where WaitType = 'TRAN_MARKLATCH_KP'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'TRAN_MARKLATCH_NL'
update WaitTypes set Description = 'Caused when waiting for a shared mode latch on a marked transaction. Transaction mark latches are used for synchronization of commits with marked transactions.' where WaitType = 'TRAN_MARKLATCH_SH'
update WaitTypes set Description = 'Caused when waiting for an update mode latch on a marked transaction. Transaction mark latches are used for synchronization of commits with marked transactions.' where WaitType = 'TRAN_MARKLATCH_UP'
update WaitTypes set Description = 'Caused during synchronization of access to a transaction by multiple batches.' where WaitType = 'TRANSACTION_MUTEX'
update WaitTypes set Description = 'Caused when transaction log scans wait for memory to be available during memory pressure.' where WaitType = 'UTIL_PAGE_ALLOC'
update WaitTypes set Description = 'Caused when a Virtual Interface Adapter (VIA) provider connection is completed during startup.' where WaitType = 'VIA_ACCEPT'
update WaitTypes set Description = 'Caused during synchronization on access to cached view definitions.' where WaitType = 'VIEW_DEFINITION_MUTEX'
update WaitTypes set Description = 'Caused when waiting for a query notification to be triggered.' where WaitType = 'WAIT_FOR_RESULTS'
update WaitTypes set Description = 'Caused as a result of a WAITFOR Transact-SQL statement. The duration of the wait is determined by the parameters to the statement. This is a user-initiated wait.' where WaitType = 'WAITFOR'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'WAITFOR_TASKSHUTDOWN'
update WaitTypes set Description = 'Caused during synchronization of access to the collection of statistics used to populate sys.dm_os_wait_stats.' where WaitType = 'WAITSTAT_MUTEX'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'WCC'
update WaitTypes set Description = 'Caused when pausing before retrying, after a failed worktable drop.' where WaitType = 'WORKTBL_DROP'
update WaitTypes set Description = 'Caused when a write operation is in progress.' where WaitType = 'WRITE_COMPLETION'
update WaitTypes set Description = 'Caused when waiting for a log flush to complete. Common operations that cause log flushes are checkpoints and transaction commits.' where WaitType = 'WRITELOG'
update WaitTypes set Description = 'Caused when waiting to acquire ownership of a transaction.' where WaitType = 'XACT_OWN_TRANSACTION'
update WaitTypes set Description = 'Caused when waiting for the current owner of a session to release ownership of the session.' where WaitType = 'XACT_RECLAIM_SESSION'
update WaitTypes set Description = 'Caused during synchronization of access to the list of locks for a transaction. In addition to the transaction itself, the list of locks is accessed by operations such as deadlock detection and lock migration during page splits.' where WaitType = 'XACTLOCKINFO'
update WaitTypes set Description = 'Caused during synchronization of defections from a transaction, as well as the number of database locks between enlist members of a transaction.' where WaitType = 'XACTWORKSPACE_MUTEX'
update WaitTypes set Description = 'Caused when Extended Events session buffers are flushed to targets. This wait occurs on a background thread.' where WaitType = 'XE_BUFFERMGR_ALLPROCESSED_EVENT'
update WaitTypes set Description = 'Caused when either of the following conditions is true: (1) An Extended Events session is configured for no event loss, and all buffers in the session are currently full. This can indicate that the buffers for an Extended Events session are too small, or should be partitioned. (2) Audits experience a delay. This can indicate a disk bottleneck on the drive where the audits are written.' where WaitType = 'XE_BUFFERMGR_FREEBUF_EVENT'
update WaitTypes set Description = 'Caused when an Extended Events session that is using asynchronous targets is started or stopped. This wait indicates either of the following: (1) An Extended Events session is registering with a background thread pool. (2) The background thread pool is calculating the required number of threads based on current load.' where WaitType = 'XE_DISPATCHER_CONFIG_SESSION_LIST'
update WaitTypes set Description = 'Caused when a background thread that is used for Extended Events sessions is terminating.' where WaitType = 'XE_DISPATCHER_JOIN'
update WaitTypes set Description = 'Caused when a background thread that is used for Extended Events sessions is waiting for event buffers to process.' where WaitType = 'XE_DISPATCHER_WAIT'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'XE_MODULEMGR_SYNC'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'XE_OLS_LOCK'
update WaitTypes set Description = 'Used for informational purposes only.' where WaitType = 'XE_PACKAGE_LOCK_BACKOFF'
update WaitTypes set Description = '' where WaitType = 'XE_SERVICES_EVENTMANUAL'
update WaitTypes set Description = '' where WaitType = 'XE_SERVICES_MUTEX'
update WaitTypes set Description = '' where WaitType = 'XE_SERVICES_RWLOCK'
update WaitTypes set Description = '' where WaitType = 'XE_SESSION_CREATE_SYNC'
update WaitTypes set Description = '' where WaitType = 'XE_SESSION_FLUSH'
update WaitTypes set Description = '' where WaitType = 'XE_SESSION_SYNC'
update WaitTypes set Description = '' where WaitType = 'XE_STM_CREATE'
update WaitTypes set Description = 'Indicates a background task is waiting for "expired" timers for internal Xevent engine work' where WaitType = 'XE_TIMER_EVENT'
update WaitTypes set Description = '' where WaitType = 'XE_TIMER_MUTEX'
update WaitTypes set Description = '' where WaitType = 'XE_TIMER_TASK_DONE'


-- add helplinks for each wait type
update WaitTypes set HelpLink  = '' where WaitType = 'ABR'
update WaitTypes set HelpLink  = '' where WaitType = 'ASSEMBLY_LOAD'
update WaitTypes set HelpLink  = '' where WaitType = 'ASYNC_DISKPOOL_LOCK'
update WaitTypes set HelpLink  = '' where WaitType = 'ASYNC_IO_COMPLETION'
update WaitTypes set HelpLink  = '' where WaitType = 'ASYNC_NETWORK_IO'
update WaitTypes set HelpLink  = '' where WaitType = 'AUDIT_GROUPCACHE_LOCK'
update WaitTypes set HelpLink  = '' where WaitType = 'AUDIT_LOGINCACHE_LOCK'
update WaitTypes set HelpLink  = '' where WaitType = 'AUDIT_ON_DEMAND_TARGET_LOCK'
update WaitTypes set HelpLink  = '' where WaitType = 'AUDIT_XE_SESSION_MGR'
update WaitTypes set HelpLink  = '' where WaitType = 'BACKUP'
update WaitTypes set HelpLink  = '' where WaitType = 'BACKUP_CLIENTLOCK'
update WaitTypes set HelpLink  = '' where WaitType = 'BACKUP_OPERATOR'
update WaitTypes set HelpLink  = '' where WaitType = 'BACKUPBUFFER'
update WaitTypes set HelpLink  = '' where WaitType = 'BACKUPIO'
update WaitTypes set HelpLink  = '' where WaitType = 'BACKUPTHREAD'
update WaitTypes set HelpLink  = '' where WaitType = 'BAD_PAGE_PROCESS'
update WaitTypes set HelpLink  = '' where WaitType = 'BROKER_CONNECTION_RECEIVE_TASK'
update WaitTypes set HelpLink  = '' where WaitType = 'BROKER_ENDPOINT_STATE_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'BROKER_EVENTHANDLER'
update WaitTypes set HelpLink  = '' where WaitType = 'BROKER_INIT'
update WaitTypes set HelpLink  = '' where WaitType = 'BROKER_MASTERSTART'
update WaitTypes set HelpLink  = '' where WaitType = 'BROKER_RECEIVE_WAITFOR'
update WaitTypes set HelpLink  = '' where WaitType = 'BROKER_REGISTERALLENDPOINTS'
update WaitTypes set HelpLink  = '' where WaitType = 'BROKER_SERVICE'
update WaitTypes set HelpLink  = '' where WaitType = 'BROKER_SHUTDOWN'
update WaitTypes set HelpLink  = '' where WaitType = 'BROKER_TASK_STOP'
update WaitTypes set HelpLink  = '' where WaitType = 'BROKER_TO_FLUSH'
update WaitTypes set HelpLink  = '' where WaitType = 'BROKER_TRANSMITTER'
update WaitTypes set HelpLink  = '' where WaitType = 'BROKER_XMIT_SHUTDOWN'
update WaitTypes set HelpLink  = '' where WaitType = 'BROKER_XMIT_START'
update WaitTypes set HelpLink  = '' where WaitType = 'BROKER_XMIT_TABLE'
update WaitTypes set HelpLink  = '' where WaitType = 'BUILTIN_HASHKEY_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'CHECK_PRINT_RECORD'
update WaitTypes set HelpLink  = '' where WaitType = 'CHECKPOINT_QUEUE'
update WaitTypes set HelpLink  = '' where WaitType = 'CHKPT'
update WaitTypes set HelpLink  = '' where WaitType = 'CLEAR_DB'
update WaitTypes set HelpLink  = '' where WaitType = 'CLR_AUTO_EVENT'
update WaitTypes set HelpLink  = '' where WaitType = 'CLR_CRST'
update WaitTypes set HelpLink  = '' where WaitType = 'CLR_JOIN'
update WaitTypes set HelpLink  = '' where WaitType = 'CLR_MANUAL_EVENT'
update WaitTypes set HelpLink  = '' where WaitType = 'CLR_MEMORY_SPY'
update WaitTypes set HelpLink  = '' where WaitType = 'CLR_MONITOR'
update WaitTypes set HelpLink  = '' where WaitType = 'CLR_RWLOCK_READER'
update WaitTypes set HelpLink  = '' where WaitType = 'CLR_RWLOCK_WRITER'
update WaitTypes set HelpLink  = '' where WaitType = 'CLR_SEMAPHORE'
update WaitTypes set HelpLink  = '' where WaitType = 'CLR_TASK_START'
update WaitTypes set HelpLink  = '' where WaitType = 'CLRHOST_STATE_ACCESS'
update WaitTypes set HelpLink  = '' where WaitType = 'CMEMTHREAD'
update WaitTypes set HelpLink  = '' where WaitType = 'COMMIT_TABLE'
update WaitTypes set HelpLink  = '' where WaitType = 'CURSOR'
update WaitTypes set HelpLink  = '' where WaitType = 'CURSOR_ASYNC'
update WaitTypes set HelpLink  = 'WS Cxpacket.htm' where WaitType = 'CXPACKET'
update WaitTypes set HelpLink  = '' where WaitType = 'CXROWSET_SYNC'
update WaitTypes set HelpLink  = '' where WaitType = 'DAC_INIT'
update WaitTypes set HelpLink  = '' where WaitType = 'DBMIRROR_DBM_EVENT'
update WaitTypes set HelpLink  = '' where WaitType = 'DBMIRROR_DBM_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'DBMIRROR_EVENTS_QUEUE'
update WaitTypes set HelpLink  = '' where WaitType = 'DBMIRROR_SEND'
update WaitTypes set HelpLink  = '' where WaitType = 'DBMIRROR_WORKER_QUEUE'
update WaitTypes set HelpLink  = '' where WaitType = 'DBMIRRORING_CMD'
update WaitTypes set HelpLink  = '' where WaitType = 'DBTABLE'
update WaitTypes set HelpLink  = '' where WaitType = 'DEADLOCK_ENUM_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'DEADLOCK_TASK_SEARCH'
update WaitTypes set HelpLink  = '' where WaitType = 'DEBUG'
update WaitTypes set HelpLink  = '' where WaitType = 'DISABLE_VERSIONING'
update WaitTypes set HelpLink  = '' where WaitType = 'DISKIO_SUSPEND'
update WaitTypes set HelpLink  = '' where WaitType = 'DISPATCHER_QUEUE_SEMAPHORE'
update WaitTypes set HelpLink  = '' where WaitType = 'DLL_LOADING_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'DROPTEMP'
update WaitTypes set HelpLink  = '' where WaitType = 'DTC'
update WaitTypes set HelpLink  = '' where WaitType = 'DTC_ABORT_REQUEST'
update WaitTypes set HelpLink  = '' where WaitType = 'DTC_RESOLVE'
update WaitTypes set HelpLink  = '' where WaitType = 'DTC_STATE'
update WaitTypes set HelpLink  = '' where WaitType = 'DTC_TMDOWN_REQUEST'
update WaitTypes set HelpLink  = '' where WaitType = 'DTC_WAITFOR_OUTCOME'
update WaitTypes set HelpLink  = '' where WaitType = 'DUMP_LOG_COORDINATOR'
update WaitTypes set HelpLink  = '' where WaitType = 'DUMP_LOG_COORDINATOR_QUEUE'
update WaitTypes set HelpLink  = '' where WaitType = 'DUMPTRIGGER'
update WaitTypes set HelpLink  = '' where WaitType = 'EC'
update WaitTypes set HelpLink  = '' where WaitType = 'EE_PMOLOCK'
update WaitTypes set HelpLink  = '' where WaitType = 'EE_SPECPROC_MAP_INIT'
update WaitTypes set HelpLink  = '' where WaitType = 'ENABLE_VERSIONING'
update WaitTypes set HelpLink  = '' where WaitType = 'ERROR_REPORTING_MANAGER'
update WaitTypes set HelpLink  = '' where WaitType = 'EXCHANGE'
update WaitTypes set HelpLink  = '' where WaitType = 'EXECSYNC'
update WaitTypes set HelpLink  = '' where WaitType = 'EXECUTION_PIPE_EVENT_INTERNAL'
update WaitTypes set HelpLink  = '' where WaitType = 'FAILPOINT'
update WaitTypes set HelpLink  = '' where WaitType = 'FCB_REPLICA_READ'
update WaitTypes set HelpLink  = '' where WaitType = 'FCB_REPLICA_START'
update WaitTypes set HelpLink  = '' where WaitType = 'FCB_REPLICA_WRITE'
update WaitTypes set HelpLink  = '' where WaitType = 'FS_FC_RWLOCK'
update WaitTypes set HelpLink  = '' where WaitType = 'FS_GARBAGE_COLLECTOR_SHUTDOWN'
update WaitTypes set HelpLink  = '' where WaitType = 'FS_HEADER_RWLOCK'
update WaitTypes set HelpLink  = '' where WaitType = 'FS_LOGTRUNC_RWLOCK'
update WaitTypes set HelpLink  = '' where WaitType = 'FSA_FORCE_OWN_XACT'
update WaitTypes set HelpLink  = '' where WaitType = 'FSAGENT'
update WaitTypes set HelpLink  = '' where WaitType = 'FSTR_CONFIG_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'FSTR_CONFIG_RWLOCK'
update WaitTypes set HelpLink  = '' where WaitType = 'FT_COMPROWSET_RWLOCK'
update WaitTypes set HelpLink  = '' where WaitType = 'FT_IFTS_RWLOCK'
update WaitTypes set HelpLink  = '' where WaitType = 'FT_IFTS_SCHEDULER_IDLE_WAIT'
update WaitTypes set HelpLink  = '' where WaitType = 'FT_IFTSHC_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'FT_IFTSISM_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'FT_MASTER_MERGE'
update WaitTypes set HelpLink  = '' where WaitType = 'FT_METADATA_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'FT_RESTART_CRAWL'
update WaitTypes set HelpLink  = '' where WaitType = 'FT_RESUME_CRAWL'
update WaitTypes set HelpLink  = '' where WaitType = 'FULLTEXT GATHERER'
update WaitTypes set HelpLink  = '' where WaitType = 'GUARDIAN'
update WaitTypes set HelpLink  = '' where WaitType = 'HTTP_ENDPOINT_COLLCREATE'
update WaitTypes set HelpLink  = '' where WaitType = 'HTTP_ENUMERATION'
update WaitTypes set HelpLink  = '' where WaitType = 'HTTP_START'
update WaitTypes set HelpLink  = '' where WaitType = 'IMP_IMPORT_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'IMPPROV_IOWAIT'
update WaitTypes set HelpLink  = '' where WaitType = 'INDEX_USAGE_STATS_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'INTERNAL_TESTING'
update WaitTypes set HelpLink  = '' where WaitType = 'IO_AUDIT_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'IO_COMPLETION'
update WaitTypes set HelpLink  = '' where WaitType = 'IO_RETRY'
update WaitTypes set HelpLink  = '' where WaitType = 'IOAFF_RANGE_QUEUE'
update WaitTypes set HelpLink  = '' where WaitType = 'KSOURCE_WAKEUP'
update WaitTypes set HelpLink  = '' where WaitType = 'KTM_ENLISTMENT'
update WaitTypes set HelpLink  = '' where WaitType = 'KTM_RECOVERY_MANAGER'
update WaitTypes set HelpLink  = '' where WaitType = 'KTM_RECOVERY_RESOLUTION'
update WaitTypes set HelpLink  = '' where WaitType = 'LATCH_DT'
update WaitTypes set HelpLink  = '' where WaitType = 'LATCH_EX'
update WaitTypes set HelpLink  = '' where WaitType = 'LATCH_KP'
update WaitTypes set HelpLink  = '' where WaitType = 'LATCH_NL'
update WaitTypes set HelpLink  = '' where WaitType = 'LATCH_SH'
update WaitTypes set HelpLink  = '' where WaitType = 'LATCH_UP'
update WaitTypes set HelpLink  = '' where WaitType = 'LAZYWRITER_SLEEP'
update WaitTypes set HelpLink  = 'http://msdn.microsoft.com/en-us/library/ms190345.aspx' where WaitType = 'LCK_M_BU'
update WaitTypes set HelpLink  = 'http://msdn.microsoft.com/en-us/library/ms190345.aspx' where WaitType = 'LCK_M_IS'
update WaitTypes set HelpLink  = 'http://msdn.microsoft.com/en-us/library/ms190345.aspx' where WaitType = 'LCK_M_IU'
update WaitTypes set HelpLink  = 'http://msdn.microsoft.com/en-us/library/ms190345.aspx' where WaitType = 'LCK_M_IX'
update WaitTypes set HelpLink  = 'http://msdn.microsoft.com/en-us/library/ms190345.aspx' where WaitType = 'LCK_M_RIn_NL'
update WaitTypes set HelpLink  = 'http://msdn.microsoft.com/en-us/library/ms190345.aspx' where WaitType = 'LCK_M_RIn_S'
update WaitTypes set HelpLink  = 'http://msdn.microsoft.com/en-us/library/ms190345.aspx' where WaitType = 'LCK_M_RIn_U'
update WaitTypes set HelpLink  = 'http://msdn.microsoft.com/en-us/library/ms190345.aspx' where WaitType = 'LCK_M_RIn_X'
update WaitTypes set HelpLink  = 'http://msdn.microsoft.com/en-us/library/ms190345.aspx' where WaitType = 'LCK_M_RS_S'
update WaitTypes set HelpLink  = 'http://msdn.microsoft.com/en-us/library/ms190345.aspx' where WaitType = 'LCK_M_RS_U'
update WaitTypes set HelpLink  = 'http://msdn.microsoft.com/en-us/library/ms190345.aspx' where WaitType = 'LCK_M_RX_S'
update WaitTypes set HelpLink  = 'http://msdn.microsoft.com/en-us/library/ms190345.aspx' where WaitType = 'LCK_M_RX_U'
update WaitTypes set HelpLink  = 'http://msdn.microsoft.com/en-us/library/ms190345.aspx' where WaitType = 'LCK_M_RX_X'
update WaitTypes set HelpLink  = 'http://msdn.microsoft.com/en-us/library/ms190345.aspx' where WaitType = 'LCK_M_S'
update WaitTypes set HelpLink  = 'http://msdn.microsoft.com/en-us/library/ms190345.aspx' where WaitType = 'LCK_M_SCH_M'
update WaitTypes set HelpLink  = 'http://msdn.microsoft.com/en-us/library/ms190345.aspx' where WaitType = 'LCK_M_SCH_S'
update WaitTypes set HelpLink  = 'http://msdn.microsoft.com/en-us/library/ms190345.aspx' where WaitType = 'LCK_M_SIU'
update WaitTypes set HelpLink  = 'http://msdn.microsoft.com/en-us/library/ms190345.aspx' where WaitType = 'LCK_M_SIX'
update WaitTypes set HelpLink  = 'http://msdn.microsoft.com/en-us/library/ms190345.aspx' where WaitType = 'LCK_M_U'
update WaitTypes set HelpLink  = 'http://msdn.microsoft.com/en-us/library/ms190345.aspx' where WaitType = 'LCK_M_UIX'
update WaitTypes set HelpLink  = 'http://msdn.microsoft.com/en-us/library/ms190345.aspx' where WaitType = 'LCK_M_X'
update WaitTypes set HelpLink  = 'WS Logbuffer.htm' where WaitType = 'LOGBUFFER'
update WaitTypes set HelpLink  = '' where WaitType = 'LOGGENERATION'
update WaitTypes set HelpLink  = '' where WaitType = 'LOGMGR'
update WaitTypes set HelpLink  = '' where WaitType = 'LOGMGR_FLUSH'
update WaitTypes set HelpLink  = '' where WaitType = 'LOGMGR_QUEUE'
update WaitTypes set HelpLink  = 'WS LOGMGR Reserve.htm' where WaitType = 'LOGMGR_RESERVE_APPEND'
update WaitTypes set HelpLink  = '' where WaitType = 'LOWFAIL_MEMMGR_QUEUE'
update WaitTypes set HelpLink  = '' where WaitType = 'METADATA_LAZYCACHE_RWLOCK'
update WaitTypes set HelpLink  = '' where WaitType = 'MIRROR_SEND_MESSAGE'
update WaitTypes set HelpLink  = '' where WaitType = 'MISCELLANEOUS'
update WaitTypes set HelpLink  = '' where WaitType = 'MSQL_DQ'
update WaitTypes set HelpLink  = '' where WaitType = 'MSQL_SYNC_PIPE'
update WaitTypes set HelpLink  = '' where WaitType = 'MSQL_XACT_MGR_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'MSQL_XACT_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'MSQL_XP'
update WaitTypes set HelpLink  = '' where WaitType = 'MSSEARCH'
update WaitTypes set HelpLink  = '' where WaitType = 'NET_WAITFOR_PACKET'
update WaitTypes set HelpLink  = '' where WaitType = 'NODE_CACHE_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'OLEDB'
update WaitTypes set HelpLink  = '' where WaitType = 'ONDEMAND_TASK_QUEUE'
update WaitTypes set HelpLink  = '' where WaitType = 'PAGEIOLATCH_DT'
update WaitTypes set HelpLink  = '' where WaitType = 'PAGEIOLATCH_EX'
update WaitTypes set HelpLink  = '' where WaitType = 'PAGEIOLATCH_KP'
update WaitTypes set HelpLink  = '' where WaitType = 'PAGEIOLATCH_NL'
update WaitTypes set HelpLink  = '' where WaitType = 'PAGEIOLATCH_SH'
update WaitTypes set HelpLink  = '' where WaitType = 'PAGEIOLATCH_UP'
update WaitTypes set HelpLink  = '' where WaitType = 'PAGELATCH_DT'
update WaitTypes set HelpLink  = '' where WaitType = 'PAGELATCH_EX'
update WaitTypes set HelpLink  = '' where WaitType = 'PAGELATCH_KP'
update WaitTypes set HelpLink  = '' where WaitType = 'PAGELATCH_NL'
update WaitTypes set HelpLink  = '' where WaitType = 'PAGELATCH_SH'
update WaitTypes set HelpLink  = '' where WaitType = 'PAGELATCH_UP'
update WaitTypes set HelpLink  = '' where WaitType = 'PARALLEL_BACKUP_QUEUE'
update WaitTypes set HelpLink  = '' where WaitType = 'PERFORMANCE_COUNTERS_RWLOCK'
update WaitTypes set HelpLink  = '' where WaitType = 'PLACEHOLDER1'
update WaitTypes set HelpLink  = '' where WaitType = 'PLACEHOLDER2'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_ABR'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_AUDIT_ACCESS_EVENTLOG'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_AUDIT_ACCESS_SECLOG'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_CLOSEBACKUPMEDIA'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_CLOSEBACKUPTAPE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_CLOSEBACKUPVDIDEVICE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_CLUSAPI_CLUSTERRESOURCECONTROL'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_COCREATEINSTANCE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_COGETCLASSOBJECT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_CREATEACCESSOR'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_DELETEROWS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_GETCOMMANDTEXT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_GETDATA'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_GETNEXTROWS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_GETRESULT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_GETROWSBYBOOKMARK'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_LBFLUSH'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_LBLOCKREGION'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_LBREADAT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_LBSETSIZE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_LBSTAT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_LBUNLOCKREGION'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_LBWRITEAT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_QUERYINTERFACE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_RELEASE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_RELEASEACCESSOR'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_RELEASEROWS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_RELEASESESSION'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_RESTARTPOSITION'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_SEQSTRMREAD'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_SEQSTRMREADANDWRITE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_SETDATAFAILURE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_SETPARAMETERINFO'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_SETPARAMETERPROPERTIES'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_STRMLOCKREGION'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_STRMSEEKANDREAD'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_STRMSEEKANDWRITE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_STRMSETSIZE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_STRMSTAT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_COM_STRMUNLOCKREGION'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_CONSOLEWRITE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_CREATEPARAM'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_DEBUG'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_DFSADDLINK'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_DFSLINKEXISTCHECK'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_DFSLINKHEALTHCHECK'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_DFSREMOVELINK'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_DFSREMOVEROOT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_DFSROOTFOLDERCHECK'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_DFSROOTINIT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_DFSROOTSHARECHECK'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_DTC_ABORT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_DTC_ABORTREQUESTDONE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_DTC_BEGINTRANSACTION'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_DTC_COMMITREQUESTDONE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_DTC_ENLIST'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_DTC_PREPAREREQUESTDONE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_FILESIZEGET'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_FSAOLEDB_ABORTTRANSACTION'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_FSAOLEDB_COMMITTRANSACTION'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_FSAOLEDB_STARTTRANSACTION'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_FSRECOVER_UNCONDITIONALUNDO'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_GETRMINFO'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_LOCKMONITOR'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_MSS_RELEASE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_ODBCOPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OLE_UNINIT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OLEDB_ABORTORCOMMITTRAN'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OLEDB_ABORTTRAN'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OLEDB_GETDATASOURCE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OLEDB_GETLITERALINFO'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OLEDB_GETPROPERTIES'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OLEDB_GETPROPERTYINFO'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OLEDB_GETSCHEMALOCK'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OLEDB_JOINTRANSACTION'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OLEDB_RELEASE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OLEDB_SETPROPERTIES'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OLEDBOPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_ACCEPTSECURITYCONTEXT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_ACQUIRECREDENTIALSHANDLE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_AUTHENTICATIONOPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_AUTHORIZATIONOPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_AUTHZGETINFORMATIONFROMCONTEXT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_AUTHZINITIALIZECONTEXTFROMSID'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_AUTHZINITIALIZERESOURCEMANAGER'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_BACKUPREAD'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_CLOSEHANDLE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_CLUSTEROPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_COMOPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_COMPLETEAUTHTOKEN'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_COPYFILE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_CREATEDIRECTORY'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_CREATEFILE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_CRYPTACQUIRECONTEXT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_CRYPTIMPORTKEY'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_CRYPTOPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_DECRYPTMESSAGE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_DELETEFILE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_DELETESECURITYCONTEXT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_DEVICEIOCONTROL'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_DEVICEOPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_DIRSVC_NETWORKOPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_DISCONNECTNAMEDPIPE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_DOMAINSERVICESOPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_DSGETDCNAME'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_DTCOPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_ENCRYPTMESSAGE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_FILEOPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_FINDFILE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_FLUSHFILEBUFFERS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_FORMATMESSAGE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_FREECREDENTIALSHANDLE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_FREELIBRARY'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_GENERICOPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_GETADDRINFO'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_GETCOMPRESSEDFILESIZE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_GETDISKFREESPACE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_GETFILEATTRIBUTES'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_GETFILESIZE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_GETLONGPATHNAME'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_GETPROCADDRESS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_GETVOLUMENAMEFORVOLUMEMOUNTPOINT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_GETVOLUMEPATHNAME'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_INITIALIZESECURITYCONTEXT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_LIBRARYOPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_LOADLIBRARY'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_LOGONUSER'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_LOOKUPACCOUNTSID'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_MESSAGEQUEUEOPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_MOVEFILE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_NETGROUPGETUSERS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_NETLOCALGROUPGETMEMBERS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_NETUSERGETGROUPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_NETUSERGETLOCALGROUPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_NETUSERMODALSGET'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_NETVALIDATEPASSWORDPOLICY'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_NETVALIDATEPASSWORDPOLICYFREE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_OPENDIRECTORY'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_PIPEOPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_PROCESSOPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_QUERYREGISTRY'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_QUERYSECURITYCONTEXTTOKEN'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_REMOVEDIRECTORY'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_REPORTEVENT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_REVERTTOSELF'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_RSFXDEVICEOPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_SECURITYOPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_SERVICEOPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_SETENDOFFILE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_SETFILEPOINTER'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_SETFILEVALIDDATA'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_SETNAMEDSECURITYINFO'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_SQLCLROPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_SQMLAUNCH'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_VERIFYSIGNATURE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_VSSOPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_WAITFORSINGLEOBJECT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_WINSOCKOPS'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_WRITEFILE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_WRITEFILEGATHER'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_OS_WSASETLASTERROR'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_REENLIST'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_RESIZELOG'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_ROLLFORWARDREDO'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_ROLLFORWARDUNDO'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_SB_STOPENDPOINT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_SERVER_STARTUP'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_SETRMINFO'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_SHAREDMEM_GETDATA'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_SNIOPEN'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_SOSHOST'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_SOSTESTING'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_STARTRM'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_STREAMFCB_CHECKPOINT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_STREAMFCB_RECOVER'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_STRESSDRIVER'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_TESTING'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_TRANSIMPORT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_UNMARSHALPROPAGATIONTOKEN'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_VSS_CREATESNAPSHOT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_VSS_CREATEVOLUMESNAPSHOT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_XE_CALLBACKEXECUTE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_XE_DISPATCHER'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_XE_ENGINEINIT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_XE_GETTARGETSTATE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_XE_SESSIONCOMMIT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_XE_TARGETFINALIZE'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_XE_TARGETINIT'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_XE_TIMERRUN'
update WaitTypes set HelpLink  = '' where WaitType = 'PREEMPTIVE_XETESTING'
update WaitTypes set HelpLink  = 'http://msdn.microsoft.com/en-us/library/ms174269.aspx' where WaitType = 'PRINT_ROLLBACK_PROGRESS'
update WaitTypes set HelpLink  = '' where WaitType = 'QNMANAGER_ACQUIRE'
update WaitTypes set HelpLink  = '' where WaitType = 'QPJOB_KILL'
update WaitTypes set HelpLink  = '' where WaitType = 'QPJOB_WAITFOR_ABORT'
update WaitTypes set HelpLink  = '' where WaitType = 'QRY_MEM_GRANT_INFO_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'QUERY_ERRHDL_SERVICE_DONE'
update WaitTypes set HelpLink  = '' where WaitType = 'QUERY_EXECUTION_INDEX_SORT_EVENT_OPEN'
update WaitTypes set HelpLink  = '' where WaitType = 'QUERY_NOTIFICATION_MGR_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'QUERY_NOTIFICATION_SUBSCRIPTION_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'QUERY_NOTIFICATION_TABLE_MGR_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'QUERY_NOTIFICATION_UNITTEST_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'QUERY_OPTIMIZER_PRINT_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'QUERY_TRACEOUT'
update WaitTypes set HelpLink  = '' where WaitType = 'QUERY_WAIT_ERRHDL_SERVICE'
update WaitTypes set HelpLink  = '' where WaitType = 'RECOVER_CHANGEDB'
update WaitTypes set HelpLink  = '' where WaitType = 'REPL_CACHE_ACCESS'
update WaitTypes set HelpLink  = '' where WaitType = 'REPL_HISTORYCACHE_ACCESS'
update WaitTypes set HelpLink  = '' where WaitType = 'REPL_SCHEMA_ACCESS'
update WaitTypes set HelpLink  = '' where WaitType = 'REPL_TRANHASHTABLE_ACCESS'
update WaitTypes set HelpLink  = '' where WaitType = 'REPLICA_WRITES'
update WaitTypes set HelpLink  = '' where WaitType = 'REQUEST_DISPENSER_PAUSE'
update WaitTypes set HelpLink  = '' where WaitType = 'REQUEST_FOR_DEADLOCK_SEARCH'
update WaitTypes set HelpLink  = '' where WaitType = 'RESMGR_THROTTLED'
update WaitTypes set HelpLink  = '' where WaitType = 'RESOURCE_QUEUE'
update WaitTypes set HelpLink  = '' where WaitType = 'RESOURCE_SEMAPHORE'
update WaitTypes set HelpLink  = '' where WaitType = 'RESOURCE_SEMAPHORE_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'RESOURCE_SEMAPHORE_QUERY_COMPILE'
update WaitTypes set HelpLink  = '' where WaitType = 'RESOURCE_SEMAPHORE_SMALL_QUERY'
update WaitTypes set HelpLink  = '' where WaitType = 'RFS_MSGPUMP'
update WaitTypes set HelpLink  = '' where WaitType = 'RFS_NOTIFYTHREAD'
update WaitTypes set HelpLink  = '' where WaitType = 'RFS_STARTUP'
update WaitTypes set HelpLink  = '' where WaitType = 'RG_RECONFIG'
update WaitTypes set HelpLink  = '' where WaitType = 'SEC_DROP_TEMP_KEY'
update WaitTypes set HelpLink  = '' where WaitType = 'SECURITY_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'SEQUENTIAL_GUID'
update WaitTypes set HelpLink  = '' where WaitType = 'SERVER_IDLE_CHECK'
update WaitTypes set HelpLink  = '' where WaitType = 'SHUTDOWN'
update WaitTypes set HelpLink  = '' where WaitType = 'SLEEP_BPOOL_FLUSH'
update WaitTypes set HelpLink  = '' where WaitType = 'SLEEP_DBSTARTUP'
update WaitTypes set HelpLink  = '' where WaitType = 'SLEEP_DCOMSTARTUP'
update WaitTypes set HelpLink  = '' where WaitType = 'SLEEP_MSDBSTARTUP'
update WaitTypes set HelpLink  = '' where WaitType = 'SLEEP_SYSTEMTASK'
update WaitTypes set HelpLink  = '' where WaitType = 'SLEEP_TASK'
update WaitTypes set HelpLink  = '' where WaitType = 'SLEEP_TEMPDBSTARTUP'
update WaitTypes set HelpLink  = '' where WaitType = 'SNI_CRITICAL_SECTION'
update WaitTypes set HelpLink  = '' where WaitType = 'SNI_HTTP_ACCEPT'
update WaitTypes set HelpLink  = '' where WaitType = 'SNI_HTTP_WAITFOR_0_DISCON'
update WaitTypes set HelpLink  = '' where WaitType = 'SNI_LISTENER_ACCESS'
update WaitTypes set HelpLink  = '' where WaitType = 'SNI_TASK_COMPLETION'
update WaitTypes set HelpLink  = '' where WaitType = 'SOAP_READ'
update WaitTypes set HelpLink  = '' where WaitType = 'SOAP_WRITE'
update WaitTypes set HelpLink  = '' where WaitType = 'SOS_CALLBACK_REMOVAL'
update WaitTypes set HelpLink  = '' where WaitType = 'SOS_DISPATCHER_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'SOS_LOCALALLOCATORLIST'
update WaitTypes set HelpLink  = '' where WaitType = 'SOS_MEMORY_USAGE_ADJUSTMENT'
update WaitTypes set HelpLink  = '' where WaitType = 'SOS_OBJECT_STORE_DESTROY_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'SOS_PROCESS_AFFINITY_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'SOS_RESERVEDMEMBLOCKLIST'
update WaitTypes set HelpLink  = '' where WaitType = 'SOS_SCHEDULER_YIELD'
update WaitTypes set HelpLink  = '' where WaitType = 'SOS_SMALL_PAGE_ALLOC'
update WaitTypes set HelpLink  = 'WS SOS Stackstore.htm' where WaitType = 'SOS_STACKSTORE_INIT_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'SOS_SYNC_TASK_ENQUEUE_EVENT'
update WaitTypes set HelpLink  = '' where WaitType = 'SOS_VIRTUALMEMORY_LOW'
update WaitTypes set HelpLink  = '' where WaitType = 'SOSHOST_EVENT'
update WaitTypes set HelpLink  = '' where WaitType = 'SOSHOST_INTERNAL'
update WaitTypes set HelpLink  = '' where WaitType = 'SOSHOST_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'SOSHOST_RWLOCK'
update WaitTypes set HelpLink  = '' where WaitType = 'SOSHOST_SEMAPHORE'
update WaitTypes set HelpLink  = '' where WaitType = 'SOSHOST_SLEEP'
update WaitTypes set HelpLink  = '' where WaitType = 'SOSHOST_TRACELOCK'
update WaitTypes set HelpLink  = '' where WaitType = 'SOSHOST_WAITFORDONE'
update WaitTypes set HelpLink  = '' where WaitType = 'SQLCLR_APPDOMAIN'
update WaitTypes set HelpLink  = '' where WaitType = 'SQLCLR_ASSEMBLY'
update WaitTypes set HelpLink  = '' where WaitType = 'SQLCLR_DEADLOCK_DETECTION'
update WaitTypes set HelpLink  = '' where WaitType = 'SQLCLR_QUANTUM_PUNISHMENT'
update WaitTypes set HelpLink  = '' where WaitType = 'SQLSORT_NORMMUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'SQLSORT_SORTMUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'SQLTRACE_BUFFER_FLUSH'
update WaitTypes set HelpLink  = '' where WaitType = 'SQLTRACE_LOCK'
update WaitTypes set HelpLink  = '' where WaitType = 'SQLTRACE_SHUTDOWN'
update WaitTypes set HelpLink  = '' where WaitType = 'SQLTRACE_WAIT_ENTRIES'
update WaitTypes set HelpLink  = '' where WaitType = 'SRVPROC_SHUTDOWN'
update WaitTypes set HelpLink  = '' where WaitType = 'TEMPOBJ'
update WaitTypes set HelpLink  = 'WS Threadpool.htm' where WaitType = 'THREADPOOL'
update WaitTypes set HelpLink  = '' where WaitType = 'TIMEPRIV_TIMEPERIOD'
update WaitTypes set HelpLink  = '' where WaitType = 'TRACE_EVTNOTIF'
update WaitTypes set HelpLink  = '' where WaitType = 'TRACEWRITE'
update WaitTypes set HelpLink  = '' where WaitType = 'TRAN_MARKLATCH_DT'
update WaitTypes set HelpLink  = '' where WaitType = 'TRAN_MARKLATCH_EX'
update WaitTypes set HelpLink  = '' where WaitType = 'TRAN_MARKLATCH_KP'
update WaitTypes set HelpLink  = '' where WaitType = 'TRAN_MARKLATCH_NL'
update WaitTypes set HelpLink  = '' where WaitType = 'TRAN_MARKLATCH_SH'
update WaitTypes set HelpLink  = '' where WaitType = 'TRAN_MARKLATCH_UP'
update WaitTypes set HelpLink  = '' where WaitType = 'TRANSACTION_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'UTIL_PAGE_ALLOC'
update WaitTypes set HelpLink  = '' where WaitType = 'VIA_ACCEPT'
update WaitTypes set HelpLink  = '' where WaitType = 'VIEW_DEFINITION_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'WAIT_FOR_RESULTS'
update WaitTypes set HelpLink  = '' where WaitType = 'WAITFOR'
update WaitTypes set HelpLink  = '' where WaitType = 'WAITFOR_TASKSHUTDOWN'
update WaitTypes set HelpLink  = '' where WaitType = 'WAITSTAT_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'WCC'
update WaitTypes set HelpLink  = '' where WaitType = 'WORKTBL_DROP'
update WaitTypes set HelpLink  = '' where WaitType = 'WRITE_COMPLETION'
update WaitTypes set HelpLink  = '' where WaitType = 'WRITELOG'
update WaitTypes set HelpLink  = '' where WaitType = 'XACT_OWN_TRANSACTION'
update WaitTypes set HelpLink  = '' where WaitType = 'XACT_RECLAIM_SESSION'
update WaitTypes set HelpLink  = '' where WaitType = 'XACTLOCKINFO'
update WaitTypes set HelpLink  = '' where WaitType = 'XACTWORKSPACE_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'XE_BUFFERMGR_ALLPROCESSED_EVENT'
update WaitTypes set HelpLink  = '' where WaitType = 'XE_BUFFERMGR_FREEBUF_EVENT'
update WaitTypes set HelpLink  = '' where WaitType = 'XE_DISPATCHER_CONFIG_SESSION_LIST'
update WaitTypes set HelpLink  = '' where WaitType = 'XE_DISPATCHER_JOIN'
update WaitTypes set HelpLink  = '' where WaitType = 'XE_DISPATCHER_WAIT'
update WaitTypes set HelpLink  = '' where WaitType = 'XE_MODULEMGR_SYNC'
update WaitTypes set HelpLink  = '' where WaitType = 'XE_OLS_LOCK'
update WaitTypes set HelpLink  = '' where WaitType = 'XE_PACKAGE_LOCK_BACKOFF'
update WaitTypes set HelpLink  = '' where WaitType = 'XE_SERVICES_EVENTMANUAL'
update WaitTypes set HelpLink  = '' where WaitType = 'XE_SERVICES_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'XE_SERVICES_RWLOCK'
update WaitTypes set HelpLink  = '' where WaitType = 'XE_SESSION_CREATE_SYNC'
update WaitTypes set HelpLink  = '' where WaitType = 'XE_SESSION_FLUSH'
update WaitTypes set HelpLink  = '' where WaitType = 'XE_SESSION_SYNC'
update WaitTypes set HelpLink  = '' where WaitType = 'XE_STM_CREATE'
update WaitTypes set HelpLink  = '' where WaitType = 'XE_TIMER_EVENT'
update WaitTypes set HelpLink  = '' where WaitType = 'XE_TIMER_MUTEX'
update WaitTypes set HelpLink  = '' where WaitType = 'XE_TIMER_TASK_DONE'

---------------------------------------------------------------------------------
--XE wait type maps
-- WaitType, SQL Platform, xe_map
---------------------------------------------------------------------------------
truncate table XEMapKeys
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'BAD_PAGE_PROCESS', 10, 231)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'BAD_PAGE_PROCESS', 11, 238)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'BROKER_EVENTHANDLER', 10, 174)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'BROKER_EVENTHANDLER', 11, 178)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'BROKER_RECEIVE_WAITFOR', 10, 117)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'BROKER_RECEIVE_WAITFOR', 11, 121)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'BROKER_TO_FLUSH', 10, 350)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'BROKER_TO_FLUSH', 11, 397)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'BROKER_TRANSMITTER', 10, 169)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'BROKER_TRANSMITTER', 11, 173)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'CHECKPOINT_QUEUE', 10, 129)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'CHECKPOINT_QUEUE', 11, 133)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'CHKPT', 10, 101)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'CHKPT', 11, 101)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'CLR_SEMAPHORE', 10, 216)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'CLR_SEMAPHORE', 11, 223)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'DBMIRROR_EVENTS_QUEUE', 10, 140)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'DBMIRROR_EVENTS_QUEUE', 11, 144)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'KSOURCE_WAKEUP', 10, 157)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'KSOURCE_WAKEUP', 11, 161)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'LOGMGR_QUEUE', 10, 127)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'LOGMGR_QUEUE', 11, 131)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'ONDEMAND_TASK_QUEUE', 10, 126)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'ONDEMAND_TASK_QUEUE', 11, 130)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'REQUEST_FOR_DEADLOCK_SEARCH', 10, 128)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'REQUEST_FOR_DEADLOCK_SEARCH', 11, 132)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'RESOURCE_QUEUE', 10, 111)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'RESOURCE_QUEUE', 11, 115)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'SLEEP_SYSTEMTASK', 10, 106)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'SLEEP_SYSTEMTASK', 11, 110)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'SLEEP_TASK', 10, 105)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'SLEEP_TASK', 11, 109)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'WAITFOR', 10, 189)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'WAITFOR', 11, 195)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'XE_DISPATCHER_WAIT', 10, 346)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'XE_DISPATCHER_WAIT', 11, 393)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'XE_TIMER_EVENT', 10, 344)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'XE_TIMER_EVENT', 11, 391)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'DISPATCHER_QUEUE_SEMAPHORE', 10, 330)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'DISPATCHER_QUEUE_SEMAPHORE', 11, 377)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'FILESTREAM_WORKITEM_QUEUE', 11, 367)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'FT_IFTSHC_MUTEX', 10, 585)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'FT_IFTSHC_MUTEX', 11, 635)
INSERT [dbo].[XEMapKeys] ([WaitType], [SQLVersion], [MapKey]) VALUES (N'SP_SERVER_DIAGNOSTICS_SLEEP', 11, 736)


--START: SQLdm 10.0 (srisht purohit) -Match Type for Custom Dashboard module
if (select isnull(object_id('tempdb..#upgrade_match_type'), 0)) <> 0 
begin 
	print 'truncating #upgrade_match_type'
	TRUNCATE TABLE #upgrade_match_type
end 
ELSE
begin
	print 'creating #upgrade_match_type'

	CREATE TABLE #upgrade_match_type (TempMatchID [int] NOT NULL,
		TempMatchType [nvarchar](250) NOT NULL,
	 CONSTRAINT [PK_dbo.upgradeMatchType] PRIMARY KEY CLUSTERED 
	(
		TempMatchID ASC
	)
	)
END	
     
INSERT INTO #upgrade_match_type (TempMatchID, TempMatchType) values (1,'Single Instance')
INSERT INTO #upgrade_match_type (TempMatchID, TempMatchType) values(2,'Multiple Instance')
INSERT INTO #upgrade_match_type (TempMatchID, TempMatchType) values(3,'Tag Name')
INSERT INTO #upgrade_match_type (TempMatchID, TempMatchType) values(4,'All Instances')


-- insert new rows 
INSERT INTO CustomDashboardMatchTypes ([MatchID], [MatchType])
	SELECT TempMatchID, TempMatchType FROM #upgrade_match_type 
		WHERE TempMatchID not in (select [MatchID] from CustomDashboardMatchTypes)
-- update all 
UPDATE CustomDashboardMatchTypes
	SET   [MatchType] = TempMatchType
		FROM #upgrade_match_type 
	WHERE
		[MatchID] = TempMatchID 


--END: SQLdm 10.0 (srisht purohit) -Match Type for Custom Dashboard module

--START: SQLdm 10.0 (srisht purohit) -Widgets Type for Custom Dashboard module
if (select isnull(object_id('tempdb..#upgrade_widget_type'), 0)) <> 0 
begin 
	print 'truncating #upgrade_widget_type'
	truncate TABLE #upgrade_widget_type
end 
ELSE
begin
	print 'creating #upgrade_widget_type'

	CREATE TABLE #upgrade_widget_type (TempWidgetTypeID [int] NOT NULL,
		TempWidgetType [nvarchar](250) NOT NULL,
	 CONSTRAINT [PK_dbo.upgradeWidgetType] PRIMARY KEY CLUSTERED 
	(
		TempWidgetTypeID ASC
	)
	)
END	
     
INSERT INTO #upgrade_widget_type (TempWidgetTypeID, TempWidgetType) values (1,'Single Value')
INSERT INTO #upgrade_widget_type (TempWidgetTypeID, TempWidgetType) values(2,'Mini-timeline')
INSERT INTO #upgrade_widget_type (TempWidgetTypeID, TempWidgetType) values(3,'Value and Timeline')
INSERT INTO #upgrade_widget_type (TempWidgetTypeID, TempWidgetType) values(4,'List of Values')
INSERT INTO #upgrade_widget_type (TempWidgetTypeID, TempWidgetType) values(5,'Large Timeline')

-- insert new rows 
INSERT INTO CustomDashboardWidgetTypes ([WidgetTypeID], [WidgetType])
	SELECT TempWidgetTypeID, TempWidgetType FROM #upgrade_widget_type 
		WHERE TempWidgetTypeID not in (select [WidgetTypeID] from CustomDashboardWidgetTypes)
-- update all 
UPDATE CustomDashboardWidgetTypes
	SET   [WidgetType] = TempWidgetType
		FROM #upgrade_widget_type 
	WHERE
		[WidgetTypeID] = TempWidgetTypeID 




--END: SQLdm 10.0 (srisht purohit) -Widgets Type for Custom Dashboard module

--- Create Dashboard Layout Defaults
IF (SELECT COUNT(*) FROM [dbo].DashboardLayouts) = 0
BEGIN
	declare @xmlConfig nvarchar(max)
	SET IDENTITY_INSERT [dbo].DashboardLayouts ON
	SELECT @xmlConfig = '<?xml version="1.0" encoding="utf-16"?><DashboardConfiguration xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">'
		 + '<Panels>'
			 + '<DashboardPanelConfiguration><Column>0</Column><Row>0</Row><Panel>Cpu</Panel></DashboardPanelConfiguration>'
			 + '<DashboardPanelConfiguration><Column>1</Column><Row>0</Row><Panel>ServerWaits</Panel></DashboardPanelConfiguration>'
			 + '<DashboardPanelConfiguration><Column>0</Column><Row>1</Row><Panel>Memory</Panel></DashboardPanelConfiguration>'
			 + '<DashboardPanelConfiguration><Column>1</Column><Row>1</Row><Panel>Cache</Panel></DashboardPanelConfiguration>'
			 + '<DashboardPanelConfiguration><Column>0</Column><Row>2</Row><Panel>Network</Panel></DashboardPanelConfiguration>'
			 + '<DashboardPanelConfiguration><Column>1</Column><Row>2</Row><Panel>Sessions</Panel></DashboardPanelConfiguration>'
			 + '<DashboardPanelConfiguration><Column>0</Column><Row>3</Row><Panel>Disk</Panel></DashboardPanelConfiguration>'
			 + '<DashboardPanelConfiguration><Column>1</Column><Row>3</Row><Panel>Databases</Panel></DashboardPanelConfiguration>'
		 + '</Panels><Name>SQL Server 2005 and later</Name><Columns>2</Columns><Rows>4</Rows></DashboardConfiguration>'
	INSERT INTO [dbo].DashboardLayouts (DashboardLayoutID, Name, Configuration) VALUES (1, 'SQL Server 2005 and later', @xmlConfig)
	SELECT @xmlConfig = '<?xml version="1.0" encoding="utf-16"?><DashboardConfiguration xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">'
		 + '<Panels>'
			 + '<DashboardPanelConfiguration><Column>0</Column><Row>0</Row><Panel>Cpu</Panel></DashboardPanelConfiguration>'
			 + '<DashboardPanelConfiguration><Column>1</Column><Row>0</Row><Panel>LockWaits</Panel></DashboardPanelConfiguration>'
			 + '<DashboardPanelConfiguration><Column>0</Column><Row>1</Row><Panel>Memory</Panel></DashboardPanelConfiguration>'
			 + '<DashboardPanelConfiguration><Column>1</Column><Row>1</Row><Panel>Cache</Panel></DashboardPanelConfiguration>'
			 + '<DashboardPanelConfiguration><Column>0</Column><Row>2</Row><Panel>Network</Panel></DashboardPanelConfiguration>'
			 + '<DashboardPanelConfiguration><Column>1</Column><Row>2</Row><Panel>Sessions</Panel></DashboardPanelConfiguration>'
			 + '<DashboardPanelConfiguration><Column>0</Column><Row>3</Row><Panel>Disk</Panel></DashboardPanelConfiguration>'
			 + '<DashboardPanelConfiguration><Column>1</Column><Row>3</Row><Panel>Databases</Panel></DashboardPanelConfiguration>'
		 + '</Panels><Name>SQL Server 2000</Name><Columns>2</Columns><Rows>4</Rows></DashboardConfiguration>'
	INSERT INTO [dbo].DashboardLayouts (DashboardLayoutID, Name, Configuration) VALUES (2, 'SQL Server 2000', @xmlConfig)
	SELECT @xmlConfig = '<?xml version="1.0" encoding="utf-16"?><DashboardConfiguration xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">'
		 + '<Panels>'
			 + '<DashboardPanelConfiguration><Column>0</Column><Row>0</Row><Panel>Memory</Panel></DashboardPanelConfiguration>'
			 + '<DashboardPanelConfiguration><Column>1</Column><Row>0</Row><Panel>Disk</Panel></DashboardPanelConfiguration>'
			 + '<DashboardPanelConfiguration><Column>0</Column><Row>1</Row><Panel>Databases</Panel></DashboardPanelConfiguration>'
			 + '<DashboardPanelConfiguration><Column>1</Column><Row>1</Row><Panel>FileActivity</Panel></DashboardPanelConfiguration>'
			 + '<DashboardPanelConfiguration><Column>0</Column><Row>2</Row><Panel>TempDB</Panel></DashboardPanelConfiguration>'
			 + '<DashboardPanelConfiguration><Column>1</Column><Row>2</Row><Panel>Sessions</Panel></DashboardPanelConfiguration>'
			 + '<DashboardPanelConfiguration><Column>0</Column><Row>3</Row><Panel>Cpu</Panel></DashboardPanelConfiguration>'
			 + '<DashboardPanelConfiguration><Column>1</Column><Row>3</Row><Panel>LockWaits</Panel></DashboardPanelConfiguration>'
		 + '</Panels><Name>Activity</Name><Columns>2</Columns><Rows>4</Rows></DashboardConfiguration>'
	INSERT INTO [dbo].DashboardLayouts (DashboardLayoutID, Name, Configuration) VALUES (3, 'Activity', @xmlConfig)
	SET IDENTITY_INSERT [dbo].DashboardLayouts OFF
END
--------------------------------------------------------------------------------------------
--- Application Security

-- Add app security flag to RepositoryInfo table
IF (SELECT COUNT([Internal_Value]) FROM [dbo].[RepositoryInfo] WHERE [Name] = 'ApplicationSecurityEnabled') = 0
INSERT INTO [dbo].[RepositoryInfo] ([Name],[Internal_Value],[Character_Value]) VALUES ('ApplicationSecurityEnabled',0,'')

--------------------------------------------------------------------------------------------
--- Copyright

-- Add copyright to RepositoryInfo table
IF (SELECT COUNT(*) FROM [dbo].[RepositoryInfo] WHERE [Name] = 'Copyright') = 0
	INSERT INTO [dbo].[RepositoryInfo] ([Name],[Character_Value]) VALUES ('Copyright','Copyright  2003-2015 Idera, Inc.')
ELSE
	UPDATE [dbo].[RepositoryInfo] SET [Character_Value] = 'Copyright  2003-2015 Idera, Inc.' WHERE [Name] = 'Copyright' AND [Character_Value] LIKE '%Idera%'



--START : SQLdm 10.0 (srishti) - Scripts for Prescriptive Analytics
if (select isnull(object_id('tempdb..#upgrade_PrescriptiveAnalyzerCategory'), 0)) <> 0 
begin 
	print 'truncating #upgrade_PrescriptiveAnalyzerCategory'
	TRUNCATE TABLE #upgrade_PrescriptiveAnalyzerCategory
end 
ELSE
begin
	print 'creating #upgrade_PrescriptiveAnalyzerCategory'

	CREATE TABLE #upgrade_PrescriptiveAnalyzerCategory (TempID [int] NOT NULL,
		TempCategory [nchar](50) NULL,
	 CONSTRAINT [PK_dbo.upgradePrescriptiveAnalyzerCategory] PRIMARY KEY CLUSTERED 
	(
		TempID ASC
	)
	)
END	
     
INSERT INTO #upgrade_PrescriptiveAnalyzerCategory (TempID, TempCategory) values (1,'SnapshotAnalyzer')
INSERT INTO #upgrade_PrescriptiveAnalyzerCategory (TempID, TempCategory) values (2,'DatabaseAnalyzer')
INSERT INTO #upgrade_PrescriptiveAnalyzerCategory (TempID, TempCategory) values (3,'WorkLoadAnalyzer')


-- insert new rows 
INSERT INTO PrescriptiveAnalyzerCategory ([ID], [Category])
	SELECT TempID, TempCategory FROM #upgrade_PrescriptiveAnalyzerCategory 
		WHERE TempID not in (select [ID] from PrescriptiveAnalyzerCategory)
-- update all 
UPDATE PrescriptiveAnalyzerCategory
	SET   [Category] = TempCategory
		FROM #upgrade_PrescriptiveAnalyzerCategory 
	WHERE
		[ID] = TempID 

--END : SQLdm 10.0 (Rajesh) - improved script  Predictive Analytics

--Start : Vineet dm 10.0 - PrescriptiveAnalyzer master data insertion
if (select isnull(object_id('tempdb..#upgrade_PrescriptiveAnalyzer'), 0)) <> 0 
begin 
	print 'truncating #upgrade_PrescriptiveAnalyzer'
	TRUNCATE TABLE #upgrade_PrescriptiveAnalyzer
end 
ELSE
begin
	print 'creating #upgrade_PrescriptiveAnalyzer'

	CREATE TABLE #upgrade_PrescriptiveAnalyzer (TempID [int] NOT NULL,
		TempName [nchar](50) NULL, TempCategoryId [int] NOT NULL
	 CONSTRAINT [PK_dbo.upgradePrescriptiveAnalyzer] PRIMARY KEY CLUSTERED 
	(
		TempID ASC
	)
	)
END	
     

INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (1,'BackupAndRecoveryAnalyzer', 2)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (2,'DBPropertiesAnalyzer', 2)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (3,'DBSecurityAnalyzer', 2)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (4,'DisabledIndexAnalyzer', 2)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (5,'FragmentedIndexesAnalyzer', 2)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (6,'HighIndexUpdatesAnalyzer', 2)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (7,'IndexContentionAnalyzer', 2)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (8,'IoAnalyzer', 1)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (9,'MemoryAnalyzer', 1)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (10,'NetworkAnalyzer', 1)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (11,'OutOfDateStatsAnalyzer', 2)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (12,'OverlappingIndexesAnalyzer', 2)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (13,'ProcessorAnalyzer', 1)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (14,'ServerAnalyzer', 1)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (15,'ServerConfigurationAnalyzer', 1)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (16,'SQLModuleOptionsAnalyzer', 2)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (17,'WaitStatsAnalyzer', 1)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (18,'NonIncrementalColumnStatAnalyzer', 2)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (19,'HashIndexAnalyzer', 2)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (20,'QueryStoreAnalyzer', 2)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (21,'InMemoryTableIndexAnalyzer', 2)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (22,'QueryAnalyzer', 2)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (23,'ColumnStoreIndexAnalyzer', 2)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (24,'FilteredIndexAnalyzer', 2)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (25,'HighCPUTimeProcedureAnalyzer', 2) 
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (26,'LargeTableStatsAnalyzer', 2) 
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (101,'CloseCursorAnalyzer', 3)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (102,'CompositeExpressionSearchAnalyzer', 3)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (103,'FastForwardCursorAnalyzer', 3)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (104,'FunctionInSearchAnalyzer', 3)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (105,'HintAbuseAnalyzer', 3)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (106,'LeftSideExpressionInWhereClauseAnalyzer', 3)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (107,'LeftUsedInSearchAnalyzer', 3)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (108,'LikeAbuseAnalyzer', 3)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (109,'MissingJoinAnalyzer', 3)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (110,'NakedInsertAnalyzer', 3)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (111,'NestedMinMaxAnalyzer', 3)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (112,'SelectDistinctAbuseAnalyzer', 3)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (113,'SemiJoinAnalyzer', 3)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (114,'SelectStarAbuseAnalyzer', 3)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (115,'TopTheHardWayAnalyzer', 3)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (116,'TopVsRowCountAnalyzer', 3)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (117,'TwoExpressionCoalesceAnalyzer', 3)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (118,'UnfilteredDeleteAnalyzer', 3)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (119,'UnionSetAbuseAnalyzer', 3)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (201,'EarlyAbortAnalyzer', 3)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (202,'MissingIndexAnalyzer', 3)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (203,'NotInSubqueryAnalyzer', 3)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (204,'OperatorsAnalyzer', 3)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (205,'WarningAnalyzer', 3)
INSERT INTO #upgrade_PrescriptiveAnalyzer (TempID, TempName, TempCategoryId) values (301,'ExecutionStatsVariationAnalyzer', 3)


-- insert new rows 
INSERT INTO PrescriptiveAnalyzer ([ID], [Name], [AnalyzerCategoryID])
	SELECT TempID, TempName, TempCategoryId FROM #upgrade_PrescriptiveAnalyzer 
		WHERE TempID not in (select [ID] from PrescriptiveAnalyzer)
-- update all 
UPDATE PrescriptiveAnalyzer
	SET   [Name] = TempName,
	[AnalyzerCategoryID] = TempCategoryId
		FROM #upgrade_PrescriptiveAnalyzer 
	WHERE
		[ID] = TempID 

		
--End : Vineet dm 10.0 - PrescriptiveAnalyzer master data insertion


--END : SQLdm 10.0 (Rajesh) - Predictive Analytics

--START: SQLdm 10.0 (srisht purohit) -Prescriptive Recommendation status master data for SQL doctor

--START : SQLdm 10.0 (srishti) - Scripts for presscriptive analsis Recommendation optimization master data
if (select isnull(object_id('tempdb..#upgrade_OptimiztionExecutionStatus'), 0)) <> 0 
begin 
	print 'truncating #upgrade_OptimiztionExecutionStatus'
	TRUNCATE TABLE #upgrade_OptimiztionExecutionStatus
end 
ELSE
begin
	print 'creating #upgrade_OptimiztionExecutionStatus'

	CREATE TABLE #upgrade_OptimiztionExecutionStatus (
		 [TempID] [int] NOT NULL,
		 [TempStatus] [nvarchar](100) NOT NULL,
		 [TempDescription] [nvarchar](250) NULL,
		 
		CONSTRAINT [pk_upgrade_OptimiztionExecutionStatusID] PRIMARY KEY CLUSTERED 
		(
			[TempID] ASC
		))
END	


    
INSERT INTO #upgrade_OptimiztionExecutionStatus (TempID, TempStatus, TempDescription) values (1,'NotOptimized', 'Waiting to start Optimization.')
INSERT INTO #upgrade_OptimiztionExecutionStatus (TempID, TempStatus, TempDescription) values (2,'OptimizationCompleted', 'Optimization completed.')     
INSERT INTO #upgrade_OptimiztionExecutionStatus (TempID, TempStatus, TempDescription) values (3,'OptimizationException', 'Optimization aborted early due to error.')
INSERT INTO #upgrade_OptimiztionExecutionStatus (TempID, TempStatus, TempDescription) values (4,'OptimizationUndone', 'Optimization performed is reverted.')
INSERT INTO #upgrade_OptimiztionExecutionStatus (TempID, TempStatus, TempDescription) values (5,'OptimizationUndoneException', 'Undo optimization aborted early due to error.')

-- insert new rows 
INSERT INTO PrescriptiveOptimiztionExecutionStatus ([ID], [Status], [Description])
	SELECT TempID, TempStatus, TempDescription FROM #upgrade_OptimiztionExecutionStatus 
		WHERE TempID not in (select [ID] from PrescriptiveOptimiztionExecutionStatus)
-- update all 
UPDATE PrescriptiveOptimiztionExecutionStatus
	SET   [Status] = TempStatus,
		[Description] = TempDescription
		FROM #upgrade_OptimiztionExecutionStatus 
	WHERE
		[ID] = TempID
		
--END : SQLdm 10.0 (srisht purohit) - Prescriptive Recommendation status master data for SQL doctor

--START: SQLdm 10.0 (srisht purohit) -Prescriptive Recommendation Category master data for SQL doctor
if (select isnull(object_id('tempdb..#upgrade_PrescriptiveRecommendationCategory'), 0)) <> 0 
begin 
	print 'truncating #upgrade_PrescriptiveRecommendationCategory'
	TRUNCATE TABLE #upgrade_PrescriptiveRecommendationCategory
end 
ELSE
begin
	print 'creating #upgrade_PrescriptiveRecommendationCategory'

	CREATE TABLE #upgrade_PrescriptiveRecommendationCategory (TempCategoryID [int] NOT NULL,
		TempCategoryName [nvarchar](100) NOT NULL,
		TempParentCategory int NULL,
		[TempDescription] [nvarchar](250) NULL,
	 CONSTRAINT [PK_dbo.upgradePrescriptiveRecommendationCategory] PRIMARY KEY CLUSTERED 
	(
		TempCategoryID ASC
	)
	)
END	
     
INSERT INTO #upgrade_PrescriptiveRecommendationCategory (TempCategoryID, TempCategoryName, TempParentCategory, TempDescription) VALUES(1,'Blocking Processes', 19, 'Detect whether processes are blocking other processes.')
INSERT INTO #upgrade_PrescriptiveRecommendationCategory (TempCategoryID, TempCategoryName, TempParentCategory, TempDescription) VALUES(2,'Disk', 20, 'Detect whether SQL Server performance is being affected by disk settings and associated problems.')
INSERT INTO #upgrade_PrescriptiveRecommendationCategory (TempCategoryID, TempCategoryName, TempParentCategory, TempDescription) VALUES(3,'Database Configuration', 21, 'Identify which database configuration settings will improve SQL Server performance.')
INSERT INTO #upgrade_PrescriptiveRecommendationCategory (TempCategoryID, TempCategoryName, TempParentCategory, TempDescription) VALUES(4,'DeadLocks', 19, 'Detect any deadlocks on the SQL Server instance.')
INSERT INTO #upgrade_PrescriptiveRecommendationCategory (TempCategoryID, TempCategoryName, TempParentCategory, TempDescription) VALUES(5,'Index Optimization', 23, 'Determine whether SQL Server performance is being negatively affected by index settings or problems with the indexes themselves.')
INSERT INTO #upgrade_PrescriptiveRecommendationCategory (TempCategoryID, TempCategoryName, TempParentCategory, TempDescription) VALUES(6,'Long Running Jobs', 19, 'Identify any long running jobs.')
INSERT INTO #upgrade_PrescriptiveRecommendationCategory (TempCategoryID, TempCategoryName, TempParentCategory, TempDescription) VALUES(7,'Memory', 20, 'Examine the server''s memory settings and determine whether they affect performance.')
INSERT INTO #upgrade_PrescriptiveRecommendationCategory (TempCategoryID, TempCategoryName, TempParentCategory, TempDescription) VALUES(8,'Network', 20, 'Detect network problems or configuration settings that affect SQL Server performance.')
INSERT INTO #upgrade_PrescriptiveRecommendationCategory (TempCategoryID, TempCategoryName, TempParentCategory, TempDescription) VALUES(9,'Open Transactions', 19, 'Identify any long running open transactions and determine whether the associated T-SQL code should be corrected to improve performance.')
INSERT INTO #upgrade_PrescriptiveRecommendationCategory (TempCategoryID, TempCategoryName, TempParentCategory, TempDescription)  VALUES(10,'Processor', 20, 'Detect processor problems and associated configuration settings.')
INSERT INTO #upgrade_PrescriptiveRecommendationCategory (TempCategoryID, TempCategoryName, TempParentCategory, TempDescription)  VALUES(11,'Query Optimization', 23, 'Detect query problems that negatively affect your SQL Server performance.')
INSERT INTO #upgrade_PrescriptiveRecommendationCategory (TempCategoryID, TempCategoryName, TempParentCategory, TempDescription)  VALUES(12,'Disaster Recovery', 22, 'Detect database and transaction log backup issues such as failures or skips, overdue integrity checks, and corruption issues.')
INSERT INTO #upgrade_PrescriptiveRecommendationCategory (TempCategoryID, TempCategoryName, TempParentCategory, TempDescription)  VALUES(13,'Security', 21, 'Identify non-optimal security settings  on the SQL Server instance.')
INSERT INTO #upgrade_PrescriptiveRecommendationCategory (TempCategoryID, TempCategoryName, TempParentCategory, TempDescription)  VALUES(14,'Server Configuration', 21, 'Detect server configuration settings that could decrease the performance of your SQL Server instance.')
INSERT INTO #upgrade_PrescriptiveRecommendationCategory (TempCategoryID, TempCategoryName, TempParentCategory, TempDescription)  VALUES(15,'System Page Files', 22, NULL)
INSERT INTO #upgrade_PrescriptiveRecommendationCategory (TempCategoryID, TempCategoryName, TempParentCategory, TempDescription)  VALUES(16,'System Upgrade Suggestion', 22, NULL)
INSERT INTO #upgrade_PrescriptiveRecommendationCategory (TempCategoryID, TempCategoryName, TempParentCategory, TempDescription)  VALUES(17,'Virtual Log Files', 22, NULL)
INSERT INTO #upgrade_PrescriptiveRecommendationCategory (TempCategoryID, TempCategoryName, TempParentCategory, TempDescription)  VALUES(18,'Wait Stats', 19, 'Identify any waits that are affecting the SQL Server performance.";')
INSERT INTO #upgrade_PrescriptiveRecommendationCategory (TempCategoryID, TempCategoryName, TempParentCategory, TempDescription)  VALUES(19,'Activity', 22, 'Examines which SQL Server resources have been strained and may be causing performance issues.')
INSERT INTO #upgrade_PrescriptiveRecommendationCategory (TempCategoryID, TempCategoryName, TempParentCategory, TempDescription)  VALUES(20,'Resources', 22 , 'Detects any workload-related issues, such as deadlocks or blocks or waits, that are negatively affecting the SQL Server performance.')
INSERT INTO #upgrade_PrescriptiveRecommendationCategory (TempCategoryID, TempCategoryName, TempParentCategory, TempDescription)  VALUES(21,'Configuration', 22 , 'Identifies any server, database, or security configuration settings that could impact SQL Server performance.')
INSERT INTO #upgrade_PrescriptiveRecommendationCategory (TempCategoryID, TempCategoryName, TempParentCategory, TempDescription)  VALUES(22,'All Category', NULL, 'Examine all categories for issues with configuration, resources, or workload.')
INSERT INTO #upgrade_PrescriptiveRecommendationCategory (TempCategoryID, TempCategoryName, TempParentCategory, TempDescription)  VALUES(23,'Workload', 22, NULL)

-- insert new rows 
INSERT INTO PrescriptiveRecommendationCategory ([CategoryID], [Name], [ParentCategory], [Description])
	SELECT TempCategoryID, TempCategoryName, TempParentCategory, TempDescription FROM #upgrade_PrescriptiveRecommendationCategory 
		WHERE TempCategoryID not in (select [CategoryID] from PrescriptiveRecommendationCategory)
-- update all 
UPDATE PrescriptiveRecommendationCategory
	SET   [Name] = TempCategoryName,
		[ParentCategory] = TempParentCategory,
		[Description] = TempDescription
		FROM #upgrade_PrescriptiveRecommendationCategory 
	WHERE
		[CategoryID] = TempCategoryID 

--END: SQLdm 10.0 (srisht purohit) -Prescriptive Recommendation Category master data for SQL doctor

--START: SQLdm 10.0 (srisht purohit) -Prescriptive Recommendation master data for SQL doctor
if (select isnull(object_id('tempdb..#upgrade_PrescriptiveRecommendation'), 0)) <> 0 
begin 
	print 'truncating #upgrade_PrescriptiveRecommendation'
	TRUNCATE TABLE #upgrade_PrescriptiveRecommendation
end 
ELSE
begin
	print 'creating upgrade_PrescriptiveRecommendation'
	CREATE TABLE #upgrade_PrescriptiveRecommendation (
		[TempRecommendationID] [nvarchar](10) COLLATE Latin1_General_CS_AS NOT NULL,
	[TempAdditionalConsiderations] [nvarchar](1500) NULL,
	[Tempbitly] [nvarchar](500) NULL,
	[TempCategoryID] [int] NOT NULL,
	[TempConfidenceFactor] [int] NULL,
	[TempDescription] [nvarchar](4000) NULL,
	[TempFinding] [nvarchar](500) NULL,
	[TempImpactExplanation] [nvarchar](4000) NULL,
	[TempImpactFactor] [int] NULL,
	[TempInfoLinks] [nvarchar](3000) NULL,
	[TempPluralFormFinding] [nvarchar](500) NULL,
	[TempPluralFormImpactExplanation] [nvarchar](4000) NULL,
	[TempPluralFormRecommendation] [nvarchar](4000) NULL,
	[TempProblemExplanation] [nvarchar](4000) NULL,
	[TempRecommendation] [nvarchar](max) NULL,
	[TempRelevance] [int] NULL,
	[TempTags] [nvarchar](500) NULL,
	[TempIsActive] [bit] NOT NULL,
	 CONSTRAINT [PK_upgrade_PrescriptiveRecommendation] PRIMARY KEY CLUSTERED 
	(
		[TempRecommendationID] ASC
	)
	)
END	
--To store mulitple line for input
DECLARE @multilineInput nvarchar(4000)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-BP1',''  ,'http://bit.ly/aAIS62 ' ,1  ,10  ,'Blocking process' ,'Process $(SPID) has been blocking $(BlockedNumberOfProcesses) other processes from running ' ,'Process $(SPID) has been blocking $(BlockedNumberOfProcesses) other processes from running.  The process has been the lead blocker for $(BlockedWait) ms and is blocking object $(BlockedObject). The following details are relevant to the finding:  $(ApplicationName?application $(ApplicationName): ) $(Database?in [$(Database)]: ) $(HostName?submitted from $(HostName): ) $(UserName?by $(UserName): ) ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Minimize Blocking in SQL Server</Title><Link>http://technet.microsoft.com/en-us/magazine/2008.04.blocking.aspx?pr=blog</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) processes have been blocking other processes from running'  ,'These processes are lead blockers, preventing other processes from running.'  ,''  ,''  ,'It is recommended that the blocking chains be resolved to improve performance. This is typically resolved using the KILL command on the lead blocking process.'  ,0,'',0
)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-D1'  
,''  ,'http://bit.ly/9cFXjh ' ,2  ,10  ,'High average disk queue length: Drive holds swap files' ,'Drive $(DiskName) has a queue length average of $(AvgDiskQueueLength) ' ,'One or more swap files exist on drive $(DiskName) which also contains database files.  The operating system is paging at an average rate of $(AvgPagesPerSecond) pages per second.  Hosting page files on the same drive as database files can cause a performance bottleneck. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Optimize Disk Configuration in SQL Server</Title><Link>http://searchsqlserver.techtarget.com/tip/Optimize-disk-configuration-in-SQL-Server#trace</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) drives have a high average queue length.'  ,'One or more swap files exist on these drives.  Hosting page files on the same drive as database files can cause a performance bottleneck.'  ,''  ,''  ,'It is recommended production servers have zero paging.  Launch Task Manager and view the "Peak working Set" column to determine the largest users of memory and determine which can be removed to reduce the load.  If at all possible, move your database files to a physical disk that does not host page files.It is recommended production servers have zero paging.  Launch Task Manager and view the "Peak working Set" column to determine the largest users of memory and determine which can be removed to reduce the load.  If at all possible, move your database files to a physical disk that does not host page files.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES
('SDR-D10'  ,''  ,'http://bit.ly/aCOOyo' ,2  ,10 ,'Tempdb is not pre-sized appropriately' ,'Tempdb is not pre-sized appropriately ' ,'The TempDB is being recreated each time SQL Server restarts at $(InitialSizeMB)MB but is currently $(CurrentSizeMB)MB which means that significant autogrow activity is occurring. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Compilation of SQL Server TempDB IO Best Practices</Title><Link>http://blogs.msdn.com/b/cindygross/archive/2009/11/20/compilation-of-sql-server-tempdb-io-best-practices.aspx</Link></RecommendationLink><RecommendationLink><Title>Storage Top 10 Best Practices</Title><Link>http://msdn.microsoft.com/en-us/library/cc966534.aspx</Link></RecommendationLink><RecommendationLink><Title>Optimizing tempdb Performance
</Title><Link>http://msdn.microsoft.com/en-us/library/ms175527.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Optimizing tempdb Performance</Title><Link>http://msdn.microsoft.com/en-us/library/ms175527(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Optimizing tempdb Performance</Title><Link>http://msdn.microsoft.com/en-us/library/ms175527(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that autogrow be left on with instant file initialization left on. In addition, the database should be configured so that it never hits an autogrow event or very few autogrow events. Make sure the autogrow growth increment is appropriate.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES
('SDR-D11'  
,'$(li)When there are too many data files available, the allocation of very large objects within tempdb may see reduced performance due to the overhead generated by the allocation system.'  ,'http://bit.ly/9eQhQY ',2  ,10  ,'tempdb is experiencing metadata contention and waits' ,'Your tempdb is experiencing significant metadata contention and waits ' ,'Waits on tempdb can have a significant impact on overall SQL Server performance because all sorting, joining, group by, cursors and many other SQL Server operations rely on temporary objects which are implicitly created in this database. Contention on tempdb resources can result when there are many concurrent operations attempting to allocate/deallocate objects within a tempdb data file. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Compilation of SQL Server TempDB IO Best Practices</Title><Link>http://blogs.msdn.com/b/cindygross/archive/2009/11/20/compilation-of-sql-server-tempdb-io-best-practices.aspx</Link></RecommendationLink><RecommendationLink><Title>Storage Top 10 Best Practices</Title><Link>http://msdn.microsoft.com/en-us/library/cc966534.aspx</Link></RecommendationLink><RecommendationLink><Title>Optimizing tempdb Performance
</Title><Link>http://msdn.microsoft.com/en-us/library/ms175527.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Optimizing tempdb Performance</Title><Link>http://msdn.microsoft.com/en-us/library/ms175527(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Optimizing tempdb Performance</Title><Link>http://msdn.microsoft.com/en-us/library/ms175527(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,'$(li)Numerous SQL Server operations require the creation of temporary objects in tempdb even when the running query does not explicitly use a temp table.  $(li)When the temp object cache is depleted, object allocation/deallocation requires updates to the allocation pages of the data file where that object will be stored. These allocation pages can become a bottleneck when multiple concurrent object allocations are made within a single data file.'  ,'$(TraceStatus) is recommended that you create multiple data files for tempdb so that concurrent object allocations can be made in separate data files in order to avoid waiting for access to the allocation pages. The number of data files needed is based on the number of processor cores available to SQL Server for concurrent query processing.  Generally a data file to processor core ratio between 1/4 and 1/2 will be optimal for most workloads, but in some cases the demands on tempdb may require even more data files in order to avoid allocation page contention and the waits associated with it.However, be aware that if your workload needs to store a small number of very large objects in tempdb, such as very large temp tables or sort operators spilling out of memory into tempdb, then writing out that data can be slowed significantly because of the overhead of the file weighting algorithm used by the allocation system. You should consider the data access patterns of your SQL Server workload when deciding whether new data files should be added to tempdb.$(TraceStatus) is recommended that you create multiple data files for tempdb so that concurrent object allocations can be made in separate data files in order to avoid waiting for access to the allocation pages. The number of data files needed is based on the number of processor cores available to SQL Server for concurrent query processing.  Generally a data file to processor core ratio between 1/4 and 1/2 will be optimal for most workloads, but in some cases the demands on tempdb may require even more data files in order to avoid allocation page contention and the waits associated with it.However, be aware that if your workload needs to store a small number of very large objects in tempdb, such as very large temp tables or sort operators spilling out of memory into tempdb, then writing out that data can be slowed significantly because of the overhead of the file weighting algorithm used by the allocation system. You should consider the data access patterns of your SQL Server workload when deciding whether new data files should be added to tempdb.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-D12'  
,''  ,'http://bit.ly/dlroVZ ' ,2  ,5  ,'Tempdb could use additional data files' ,'Your TempDB performance could be improved by adding additional data files ' ,'Your system has $(ProcessorCount) logical processors but TempDB is only configured to have $(FileCount) data files. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Compilation of SQL Server TempDB IO Best Practices</Title><Link>http://blogs.msdn.com/b/cindygross/archive/2009/11/20/compilation-of-sql-server-tempdb-io-best-practices.aspx</Link></RecommendationLink><RecommendationLink><Title>Optimizing tempdb Performance
</Title><Link>http://msdn.microsoft.com/en-us/library/ms175527.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Optimizing tempdb Performance</Title><Link>http://msdn.microsoft.com/en-us/library/ms175527(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Optimizing tempdb Performance</Title><Link>http://msdn.microsoft.com/en-us/library/ms175527(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that 1/2 to a maximum of 1 TempDB data file  be created for each physical CPU core (not including hyperthreading) available to SQL Server (accounting for any affinity mask settings) up to a maximum of 8 data files  to allow a thread on each processor to use a specific data file.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-D13'  
,'$(li)Workloads that create many small objects in tempdb will not see a significant performance loss, and may actually see performance improvement from having a large number of data files in tempdb due to reduced contention on the allocation maps.$(li)Some workloads will benefit from having a large number of data files in the tempdb. You can ignore this recommendation if your tempdb file structure is already optimized for the common workloads and data access patterns on this server.'  ,'http://bit.ly/bCCaaA',2  ,8  ,'tempdb has too many data files' ,'The number of tempdb data files exceeds half of the number of available processors ' ,'Tempdb is configured to have $(FileCount) data files but your system only has $(ProcessorCount) processor cores.  This can degrade system performance for some workloads. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Compilation of SQL Server TempDB IO Best Practices</Title><Link>http://blogs.msdn.com/b/cindygross/archive/2009/11/20/compilation-of-sql-server-tempdb-io-best-practices.aspx</Link></RecommendationLink><RecommendationLink><Title>Optimizing tempdb Performance
</Title><Link>http://msdn.microsoft.com/en-us/library/ms175527.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Optimizing tempdb Performance</Title><Link>http://msdn.microsoft.com/en-us/library/ms175527(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Optimizing tempdb Performance</Title><Link>http://msdn.microsoft.com/en-us/library/ms175527(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,'$(li)If your workload needs to store a small number of very large objects in tempdb, such as very large temp tables or sort operators spilling out of memory into tempdb, then writing out that data can be slowed significantly because of the overhead of the file-weighting algorithm used by the allocation system.$(li)Having a large number of data files in tempdb can lead to seemingly random I/O when the lazy writer flushes dirty buffer pages from tempdb out to disk.  This can potentially cause longer wait times if the I/O subsystem cannot handle the workload of writing out dirty pages to many different files.'  ,'It is recommended that you review the data access patterns caused by a typical workload on this server to determine if tempdb performance would be improved by reducing the number of data files.  Generally a data file to processor core ratio between 1/4 and 1/2 will be optimal for most workloads.
However, some workloads will benefit from adding tempdb data files beyond half the number of processor cores. When reviewing the typical workloads for this server, you may find that the current number of tempdb data files is required for optimal performance.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-D14'  
,''  ,'http://bit.ly/bE8bhm ' ,2  ,9  ,'Page compression is recommended' ,'Your server is experiencing significant I/O volume with no CPU usage problems. Page compression should be used ' ,'Page compression is not enabled on large and busy tables, which causes system performance degradation due to increase in IO activity and memory usage. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Data Compression: Strategy, Capacity Planning and Best Practices</Title><Link>http://msdn.microsoft.com/en-us/library/dd894051.aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that you turn on page compression on $(ObjectName) which should compress approximately $(CompressionPct)% and save you $(SavingsMB)MB.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-D15'  ,''  ,'http://bit.ly/dmEhZg ' ,2  ,10  ,'Tempdb is not in simple recovery mode' ,'The TempDB database is not in Simple Recovery Mode ' ,'This causes SQL Server to slow dramatically. ' ,3  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Compilation of SQL Server TempDB IO Best Practices</Title><Link>http://blogs.msdn.com/b/cindygross/archive/2009/11/20/compilation-of-sql-server-tempdb-io-best-practices.aspx</Link></RecommendationLink><RecommendationLink><Title>Optimizing tempdb Performance
</Title><Link>http://msdn.microsoft.com/en-us/library/ms175527.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Optimizing tempdb Performance</Title><Link>http://msdn.microsoft.com/en-us/library/ms175527(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Optimizing tempdb Performance</Title><Link>http://msdn.microsoft.com/en-us/library/ms175527(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that the TempDB be set to Simple Recovery Mode as, by default, SQL Server only logs the before images of changes to data in the TempDB. Beginning with SQL Server 2005, it is not possible to set the tempdb recovery model to full or bulk-logged recovery model. If this problem exists in SQL Server 2005 or newer, it may have been upgraded from an earlier version of SQL Server.'  ,1,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
(
'SDR-D17'  ,''  ,'http://bit.ly/buy2g4' ,2  ,8  ,'Low fill factor for large tables' ,'[$(IndexName)] on table [$(SchemaName)].[$(TableName)] in database [$(DatabaseName)] has a fill factor of $(FillFactor) percent ' ,'A low fill factor on a large table causes an increase in the System I/Os as well as an additional memory footprint which slows SQL Server execution. ' ,2 ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Fill Factor</Title><Link>http://msdn.microsoft.com/en-us/library/ms177459.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Fill Factor</Title><Link>http://msdn.microsoft.com/en-us/library/ms177459(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Fill Factor</Title><Link>http://msdn.microsoft.com/en-us/library/ms177459(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) of the server''s busiest databases have tables with low fill factors.'  ,'This causes an increase in the System I/Os as well as an additional memory footprint which slows SQL Server execution.'  ,'It is recommended that these tables be examined to determine whether they need a low fill factor.  If not, alter the table indexes to a more appropriate fill factor.'  ,''  ,'It is recommended that the index [$(IndexName)] on table [$(SchemaName)].[$(TableName)] in database [$(DatabaseName)] be examined to determine if it needs a low fill factor.  If not, alter the table indexes to set a more appropriate fill factor.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-D19'  
,''  ,'http://bit.ly/allM0f ' ,2  ,10 ,'Auto-shrink enabled' ,'Database [$(DatabaseName)] has autoshrink enabled ' ,'Database [$(DatabaseName)] is configured to automatically shrink any data or log file once the file grows beyond the initial startup size defined for the file. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Shrinking a Database</Title><Link>http://msdn.microsoft.com/en-us/library/ms189080.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Shrinking a Database</Title><Link>http://msdn.microsoft.com/en-us/library/ms189080(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Shrinking a Database</Title><Link>http://msdn.microsoft.com/en-us/library/ms189080(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) databases have auto-shrink enabled'  ,'$(Count) databases are configured to automatically shrink any data or log file once the file grows beyond the initial startup size defined for the file.'  ,'It is recommended that autoshrink is turned off on all of the databases.'  ,'$(li)A data file shrink will cause indexes to become fragmented.  The fragmentation reduces the efficiency of range scans by requiring more I/O requests to read the same number of pages.  $(li)There is an increase in the amount of I/O and CPU resource usage when performing the file shrink operations.$(li)The files can get into a cycle of frequently performing an autogrow followed by an autoshrink only to repeat this cycle over and over again.  This repeated cycle will cause fragmentation of the files at the file system level that can cause I/O performance problems.  Additionally this ends up continually wasting I/O and CPU resources by repeating these operations.'  ,'It is recommended that autoshrink is turned off on the database.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-D21'  ,''  ,'http://bit.ly/a74gF9' ,2  ,NULL  ,'' ,'The tables listed below have highly fragmented tables/Indexes: 
- Table - xxx, Index - xxx, fragmentation % - xxx, 
- Table - xxx, Index - xxx, fragmentation % - xxx ' ,'High levels of fragmentation may cause excessive I/Os (by reducing the efficiency of ordered scans and pre-fetches) together with sub-optimal usage of the buffer pool and should be avoided.  ' ,NULL  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Disk Space Requirements for Index DDL Operations</Title><Link>http://msdn.microsoft.com/en-us/library/ms179542(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Disk Space Requirements for Index DDL Operations</Title><Link>http://msdn.microsoft.com/en-us/library/ms179542(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Disk Space Requirements for Index DDL Operations</Title><Link>http://msdn.microsoft.com/en-us/library/ms179542(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'SKIPPED'  ,'SKIPPED'  ,'SKIPPED'  ,''  ,'It is recommended that batch jobs should be created as part of a regularly scheduled maintenance plan to remove fragmentation. In cases where fragmentation builds up really rapidly, lower fill factors can be used to significantly slow the pace of fragmentation.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-D2'  ,''  ,'http://bit.ly/cud2KS' ,2  ,5  ,'High disk queue length' ,'Drive $(DiskName) has a queue length average of $(AvgDiskQueueLength) ' ,'One or more system page files exist on drive $(DiskName) which also contains database files.  Hosting page files on the same drive as database files can cause a performance bottleneck. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Optimize Disk Configuration in SQL Server</Title><Link>http://searchsqlserver.techtarget.com/tip/Optimize-disk-configuration-in-SQL-Server#trace</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) drives have a high queue length'  ,'One or more swap files exist on these drives.  Hosting page files on the same drive as database files can cause a performance bottleneck.'  ,'It is recommended that you reduce the load on these drives by moving the system page file to another drive.'  ,''  ,'It is recommended that you reduce the load on this drive by moving the system page file to another drive.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-D20'  ,''  ,'http://bit.ly/9KrdZ3' ,2  ,NULL ,'' ,'The databases listed below have the Auto-Shrink option enabled: 
- xxx.dbo.xxx, 
- xxx.dbo.xxx ' ,'Auto-shrink is not advised due the following: 1. Causes significant I/O to be exerted on the production system at random intervals which will affect general system responsiveness, 2. Causes significant fragmentation on every table moved due to the Auto-Shrink process of moving blocks of data from the database file into available areas towards the near the beginning of the file, and 3. Causes high numbers of irregularly shaped virtual log files (VLFs) by repeatedly shrinking the log file followed by auto-growing the log file back out. ' ,''  ,''  ,''  ,''  ,''  ,''  ,'It is recommended that DBCC SHRINKDATABASE be scheduled during a batch processing window in order to have control over the impact of shrinking a database and this shrink should be closely followed by a defragmentation of all tables in the database as there is no way of knowing which tables will have fragmented.

It is recommended that you do not shrink databases as part of any regular process. Shrink is intended to be used in emergency situations, such as a disk that has run out of space, or as a one-time process following a very large purge of data. SQL Server will reuse empty space and there is no performance benefit gained, only performance costs incurred, from shrinking database files.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-D18'  ,''  ,'http://bit.ly/biMNsa' ,2  ,NULL  ,'' ,'On some of the server''s busiest databases, a significant amount of table/index fragmentation exists on the following tables: 
- Table - xxx, Index - xxx, fragmentation % - xxx, 
- Table - xxx, Index - xxx, fragmentation % - xxx ' ,'High levels of fragmentation may cause excessive I/Os (by reducing the efficiency of ordered scans and pre-fetches) together with sub-optimal usage of the buffer pool and should be avoided.  ' ,''  ,''  ,'SKIPPED'  ,'SKIPPED'  ,'SKIPPED'  ,''  ,'It is recommended that batch jobs should be created as part of a regularly scheduled maintenance plan to remove fragmentation by rebuilding and/or reorganizing indexes. In cases where fragmentation builds up really rapidly, lower fill factors can be used to significantly slow the pace of fragmentation.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-D3'  ,''  ,'http://bit.ly/dv8TPR' ,2  ,2 ,'I/O subsystem has been under stress' ,'The Wait statistics on your server indicate there have been periods where the I/O subsystem has been under considerable stress ' ,'An accurate analysis of your I/O subsystem cannot be determined unless the  analysis occurs during a busy period. ' ,1 ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>SQL Server Best Practices Article</Title><Link>http://msdn.microsoft.com/en-us/library/cc966412.aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that SQL doctor be scheduled to run during the next period of high I/O stress.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-D16'  ,''  ,'http://bit.ly/aEiiLe' ,2  ,NULL  ,'' ,'The statistics for the following tables may be inaccurate, which may cause the generation of suboptimal execution plans: 
- Table xxx.dbo.xxx, # of rows modified since statistics last updated - xxx, statistics last updated at xx/xx/xx xx:xx (xxhrs ago), 
- Table xxx.dbo.xxx, # of rows modified since statistics last updated - xxx, statistics last updated at xx/xx/xx xx:xx (xxhrs ago) ' 
,'This may lead to greater amounts of I/Os being generated than necessary as well as excessive TempDB and processor usage in order to fulfill TSQL queries. Additionally, inaccurate statistics could lead to selection of a poor execution plan that performs the query in an inefficient manner.' ,''  ,''  ,'SKIPPED'  ,'SKIPPED'  ,'SKIPPED'  ,''  ,'It is recommended that you ensure that regular index and statistics maintenance is occurring during maintenance windows to rebuild indexes or reorganize indexes and update the statistics for those indexes. Column statistics not associated with an index need to be updated manually during a maintenance window if auto-update of stats is not sufficient. It is recommended that you consider enabling startup trace flag 2371 if you are on SQL Server 2008 R2 SP1 or later and have very large tables where the default update setting of 20% of rows is not sufficient to update statistics more aggressively for very large tables 
- Auto create/update stats has been turned off at the database level, 
- Index has been created with STATISTICS_NORECOMPUTE = ON, 
- Statistics have been created with WITH(NORECOMPUTE)'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-D4'  ,''  ,'http://bit.ly/c0R9H9' ,2  ,8  ,'High average disk queue length and fragmentation: Drive holds transaction log and data files' ,'Drive $(DiskName) is responsible for writing the transaction logs sequentially and performing the read/write of SQL Server data pages which is typically random. Mixing random and sequential file activity forces all file activity to be random which can signifigantly reduce performance of log file activity.' ,'This results in latency currently measured at $(AvgDiskSecPerTransfer)ms as the head moves between sequential transactional log writing and the random Reading/Writing of SQL Server pages. Significant fragmentation or a stripe unit size which is not a multiple of 64kb has also been detected, which causes additional head movement and extra delay. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Refer to this Microsoft Hotfix if you are receiving a counter value and base of 0 consistently</Title><Link>http://support.microsoft.com/kb/961435</Link><Condition>OSVersion = 6.0</Condition></RecommendationLink><RecommendationLink><Title>8 Steps to better Transaction Log throughput</Title><Link>http://www.sqlskills.com/BLOGS/KIMBERLY/post/8-Steps-to-better-Transaction-Log-throughput.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) drives are responsible for writing the transaction logs sequentially and performing the read/write of SQL Server data pages, which is typically random. Mixing random and sequential file activity forces all file activity to be random which can signifigantly reduce performance of log file actiivty. '  ,'This results in high latency as the head moves between sequential transactional log writing and the random Reading/Writing of SQL Server pages.  Significant fragmentation or a stripe unit size which is not a multiple of 64kb has also been detected, which causes additional head movement and extra delay.'  ,''  ,''  ,'It is recommended that for busy databases the Transaction logs reside on a different physical drive than the data files and that the database and disk should be defragmented.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-D5'  ,''  ,'http://bit.ly/9KEXbf' ,2  ,10  ,'Incorrect unit allocation disc: Drive holds transaction log and data files' ,'Incorrect unit allocation size. Drive $(DiskName) is responsible for writing the transaction logs sequentially and performing the read/write of SQL Server data pages which is typically random. ' ,'This results in latency currently measured at $(AvgDiskSecPerTransfer)ms as the head moves between sequential transactional log writing and the random Reading/Writing of SQL Server pages.  The unit allocation size has been detected to be $(AllocationSize)KB.  SQL Server works far more efficiently with allocation unit sizes of 64KB and a stripe unit size of 64KB or a multiple of 64KB. ' ,3  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Refer to this Microsoft Hotfix if you are receiving a counter value and base of 0 consistently</Title><Link>http://support.microsoft.com/kb/961435</Link><Condition>OSVersion = 6.0</Condition></RecommendationLink><RecommendationLink><Title>Disk Partition Alignment Best Practices for SQL Server</Title><Link>http://msdn.microsoft.com/en-us/library/dd758814.aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'Incorrect unit allocation size for $(Count) drives.  These drives are responsible for writing the transaction logs sequentially and performing the read/write of SQL Server data pages, which is typically random. '  ,'This results in high latency as the head moves between sequential transactional log writing and the random Reading/Writing of SQL Server pages.  The unit allocation size is insufficient: SQL Server works far more efficiently with allocation unit sizes of 64KB and a stripe unit size of 64KB or a multiple of 64KB.'  ,''  ,''  ,'It is recommended that for busy databases the Transaction logs reside on a different physical drive than the data files and that a unit allocation size of 64KB or larger be used.'  ,1,''

 ,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-D6'  ,''  ,'http://bit.ly/9shrxk ' ,2  ,8  ,'High average disk queue length: Drive holds transaction log and data files' ,'Drive $(DiskName) has a queue length average of $(AvgDiskQueueLength).  This drive is also responsible for writing the transaction logs sequentially and performing the read/write of SQL Server pages which is typically random  ' ,'This results in latency currently measured at $(AvgDiskSecPerTransfer)ms as the head moves between sequential transactional log writing and the random Reading/Writing of SQL Server pages. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Refer to this Microsoft Hotfix if you are receiving a counter value and base of 0 consistently</Title><Link>http://support.microsoft.com/kb/961435</Link><Condition>OSVersion = 6.0</Condition></RecommendationLink><RecommendationLink><Title>Disk Partition Alignment Best Practices for SQL Server</Title><Link>http://msdn.microsoft.com/en-us/library/dd758814.aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) drives have a high average queue length.  These drives are responsible for writing the transaction logs sequentially and performing the read/write of SQL Server pages, which is typically random. '  ,'This results in high latency as the head moves between sequential transactional log writing and the random Reading/Writing of SQL Server pages.'  ,''  ,''  ,'It is recommended that for busy databases the Transaction logs reside on a different physical drive than the data files.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-D7'  ,''  ,'http://bit.ly/afaa2P ' ,2  ,8  ,'High average disk queue length: Drive is SAN, SSD, or RAID array' ,'Your SAN, SSD or RAID array (reported as Drive $(DiskName)) has a queue length average of $(AvgDiskQueueLength) ' ,'The LUN allocated on the SAN, SSD, or RAID array is overloaded. ' ,3  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Refer to this Microsoft Hotfix if you are receiving a counter value and base of 0 consistently</Title><Link>http://support.microsoft.com/kb/961435</Link><Condition>OSVersion = 6.0</Condition></RecommendationLink><RecommendationLink><Title>SQL Server Best Practices Article</Title><Link>http://msdn.microsoft.com/en-us/library/cc966412.aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>Storage Top 10 Best Practices</Title><Link>http://msdn.microsoft.com/en-us/library/cc966534.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) SANs, SSDs, or RAID arrays have a high queue length'  ,'The LUNs allocated on these SANs, SSDs, or RAID arrays are overloaded.'  ,'It is recommended that for a Raid Array, switch to RAID 10 or add additional disks to support a higher rate of IO.  For a SAN, ask the SAN administrator to increase the number of devices participating in the LUN.'  ,''  ,'It is recommended that for a Raid Array, switch to RAID 10 or add additional disks to support a higher rate of IO.  For a SAN, ask the SAN administrator to increase the number of devices participating in this LUN.'  ,1,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-D8'  ,''  ,'http://bit.ly/99Ah9a ' ,2  ,10  ,'Instant initialization is not enabled' ,'Your server has not been optimized to allow SQL Server to instantly expand databases (including TempDB) without first zeroing out space on the disk ' ,'Your server is not currently optimized to allow SQL Server to instantly expand a database (including TempDB) without first zeroing out the space on disk. If SQL Server needs to expand a database (or create a new one) the zeroing out of space on the disk can take a considerable amount of time.  ' ,2 ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>How and Why to Enable Instance File Initialization</Title><Link>http://blogs.msdn.com/b/sql_pfe_blog/archive/2009/12/23/how-and-why-to-enable-instant-file-initialization.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that the Service account of SQL Server $(SQLServerServiceAccount?({0}) include:include) the permission SE_MANAGE_VOLUME_NAME (granted to Windows Admin by default or via the Perform Volume Maintenance Tasks security policy) and that all the drives used by databases must be in an NTFS format to allow SQL Server to perform instant initialization.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-D9'  ,'$(li)If you are not experiencing detrimental wait times when allocating pages for objects in tempdb, then the data file configuration is sufficient for your workload.'  ,'http://bit.ly/byil7H',2  ,10  ,'tempdb data files are not all the same size' ,'tempdb data files are not all the same size ' ,'SQL Server will allocate pages for objects from the various tempdb data files in proportion to their relative sizes. The larger tempdb data files will experience more I/O stress than the smaller files, which will decrease overall performance.  The largest file is $(LargestFileSizeText) and the smallest file is $(SmallestFileSizeText). ' ,1 ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Working with tempdb in SQL Server 2005</Title><Link>http://technet.microsoft.com/en-us/library/cc966545.aspx</Link></RecommendationLink><RecommendationLink><Title>Optimizing tempdb Performance
</Title><Link>http://msdn.microsoft.com/en-us/library/ms175527.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Optimizing tempdb Performance</Title><Link>http://msdn.microsoft.com/en-us/library/ms175527(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Optimizing tempdb Performance</Title><Link>http://msdn.microsoft.com/en-us/library/ms175527(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,'$(li)When new objects are created in tempdb, the allocations will not be spread evenly between the data files, which removes one of the key benefits of using multiple data files for tempdb.$(li)SQL Server will favor the larger data files when allocating pages for objects in tempdb.  This will cause increased contention for access to the allocation pages of those data files, resulting in reduced performance.'  ,'It is recommended that all tempdb data files should be sized exactly the same, and if autogrowth is allowed, then the autogrowth increment should also be equalized across all data files.
However, if autogrow is turned on for these data files, then they may still grow unevenly regardless of the autogrowth increment.  This occurs when a new object allocation necessitates growing some but not all of the data files to find sufficient storage space.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-D22'  ,'$(li)The current configuration is not having a performance impact on the server and is sufficient based on your current workload.'  ,'http://bit.ly/18xJQi2',2  ,10  ,'Data files of tempdb do not have the same auto growth settings' ,'Data files of tempdb do not have the same auto growth settings ' ,'SQL Server will allocate pages for objects from the various tempdb data files in proportion to their relative sizes. The larger tempdb data files will experience more I/O stress than the smaller files, which will decrease overall performance. ' ,'1'  ,''  ,''  ,''  ,''  ,'$(li)When new objects are created in tempdb, the allocations will not be spread evenly between the data files, which removes one of the key benefits of using multiple data files for tempdb.$(li)SQL Server will favor the larger data files when allocating pages for objects in tempdb.  This will cause increased contention for access to the allocation pages of those data files, resulting in reduced performance.'  ,'It is recommended that all tempdb data files should be sized exactly the same, and the autogrowth increment should also be equalized across all data files.
However, they may still grow unevenly regardless of the autogrowth increment.  This occurs when a new object allocation necessitates growing some but not all of the data files to find sufficient storage space. This uneven autogrowth can cause all acitivty to go to a single data file causing tempdb contention. It is recommended that you use startup trace flag 1117 to ensure that if one data file grows, all data files will experience the same growth and keep the files all the same size.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-DC1'  ,'$(li)If the current setting has been verified to provide the greatest value.'  ,'http://bit.ly/av9nSh ' ,3,3  ,'Non-default setting' ,'$(Configuration) is set to value $(CurrentValue) for database $(Database) ' ,'The $(Configuration) setting has been changed from the default value of $(DefaultValue) to $(CurrentValue). ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Setting Database Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms190249(v=sql.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Setting Database Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms190249(v=sql.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Setting Database Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms190249(v=sql.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) non-default database settings'  ,'The default database setting has been changed.'  ,'It is recommended that the default value is used for the database setting.However, all changes to database configuration settings require thorough testing to verify there are no adverse effects. '  ,'$(li)A non-default setting can have an adverse impact on performance.'  ,'It is recommended that the default value of $(DefaultValue) is used for the $(Configuration) database setting.However, all changes to database configuration settings require thorough testing to verify there are no adverse effects. '  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-DC2'  ,''  ,'http://bit.ly/aAmJpH ' ,3 ,10  ,'Page_Verify set to none on writeable database' ,'The PAGE_VERIFY option for database $(Database) is set to None ' ,'When PAGE_VERIFY is set to None on a writeable database it may prevent the early detection of I/O corruption issues. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Behavior Changes to Database Engine Features in SQL Server 2008 R2</Title><Link>http://msdn.microsoft.com/en-us/library/ms143359.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Behavior Changes to Database Engine Features in SQL Server 2008</Title><Link>http://msdn.microsoft.com/en-us/library/ms143359(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Behavior Changes to Database Engine Features in SQL Server 2005</Title><Link>http://msdn.microsoft.com/en-us/library/ms143359(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>Setting Database Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms190249.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Setting Database Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms190249(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Setting Database Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms190249(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>Checksum in SQL2005</Title><Link>http://blogs.msdn.com/b/sqlserverstorageengine/archive/2006/06/29/enabling-checksum-in-sql2005.aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>CHECKSUM and Tempdb</Title><Link>http://blogs.msdn.com/b/sqlserverstorageengine/archive/2008/03/23/checksum-and-tempdb.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'The PAGE_VERIFY option is set to None for $(Count) databases'  ,''  ,'It is recommended that you set the PAGE_VERIFY option to CHECKSUM on TORN_PAGE_DETECTION (for best performance) or to CHECKSUM (for best integrity) on all writable databases.'  ,''  ,'It is recommended that you set the PAGE_VERIFY option to CHECKSUM on SQL Server 2005 and newer or TORN_PAGE_DETECTION on SQL Server 2000 on database $(Database).'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-DC3'  ,''  ,'http://bit.ly/cABc8c ' ,3  ,5  ,'' ,'The PAGE_VERIFY option for read-only database $(Database) is Not set to None ' ,'The PAGE_VERIFY options of TORN_PAGE_DETECTION and CHECKSUM create unnecessary performance overhead on databases where data is not changing. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Behavior Changes to Database Engine Features in SQL Server 2008 R2</Title><Link>http://msdn.microsoft.com/en-us/library/ms143359.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Behavior Changes to Database Engine Features in SQL Server 2008</Title><Link>http://msdn.microsoft.com/en-us/library/ms143359(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Behavior Changes to Database Engine Features in SQL Server 2005</Title><Link>http://msdn.microsoft.com/en-us/library/ms143359(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>Setting Database Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms190249.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Setting Database Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms190249(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Setting Database Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms190249(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'The PAGE_VERIFY option is Not set to None for $(Count) read-only databases'  ,''  ,'It is recommended that you set the PAGE_VERIFY option to None on all read-only databases.'  ,''  ,'It is recommended that you set the PAGE_VERIFY option to None on database $(Database).'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-DC4'  ,''  ,'http://bit.ly/bx6UBe ' ,3  ,3  ,'Database compatibility mode mismatch' ,'The compatibility mode of database $(Database) ($(CurrentCompatibility)) is lower than the SQL Server version ($(TargetCompatibility)) ' ,'Running a database at a lower compatibility mode than the SQL Server version may cause certain features of SQL Server to be unavailable or to function unpredictably or to perform poorly. ' ,'1'  ,''  ,'Database compatibility mode is lower than the target SQL Server version for $(Count) databases'  ,''  ,'If you are unsure of the reasons these databases are running in a lower compatibility mode, it is recommended that you test the impact of setting the compatibility mode to match the SQL Server version.'  ,''  ,'If you are unsure of the reasons this database is running in a lower compatibility mode, it is recommended that you test the impact of setting the $(Database) compatibility mode to $(TargetCompatibility)'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-DC5'  ,''  ,'http://bit.ly/aLRHoG' ,3,3  ,'Database collation mismatch' ,'The collation of database $(Database), $(CurrentCollation), does not match that of the model database ' ,'When database collations differ from the model database, it is possible to experience collation conflicts which may prevent code from executing.  For example, when a table is joined to a temporary table, SQL Server may experience a collation conflict error if the user-defined database collation and the model database collation are different.  This is because temporary tables are created in tempdb, which is created at server startup with the collation of the model database. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Setting and Changing the Database Collation</Title><Link>http://msdn.microsoft.com/en-us/library/ms175835.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Setting and Changing the Database Collation</Title><Link>http://msdn.microsoft.com/en-us/library/ms175835(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Setting and Changing the Database Collation</Title><Link>http://msdn.microsoft.com/en-us/library/ms175835(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'The collations of $(Count) databases do not match that of the model database'  ,''  ,''  ,''  ,'It is recommended that you consider one of the following resolutions: $(li)Export the data from $(Database) and import it into new tables that have the same collation as model ($(ModelCollation)), $(li)Rebuild the system databases to use the same collation as $(Database)  $(li)Modify any stored procedures and ad-hoc code that join user tables to tables in tempdb to prevent collation conflicts.  To do this, add the "COLLATE database_default" clause to the column definitions of the temporary table for uncontained databases or the "COLLATE catalog default" clause for contained databases (SQL Server 2012 or newer).'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-DL1'  ,''  ,'http://bit.ly/bxz4WO ',4  ,10  ,'Deadlock information is not being captured' ,'Deadlock information is not being captured ' ,'Not capturing deadlock events prevents you from knowing whether or not deadlocks are occurring and the underlying cause. Deadlock information can be captured via a SQL trace, by enabling startup trace flags 1204 or 1222, or in the system_health Extended Events session. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Detecting and Ending Deadlocks</Title><Link>http://msdn.microsoft.com/en-us/library/ms178104.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Detecting and Ending Deadlocks</Title><Link>http://msdn.microsoft.com/en-us/library/ms178104(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Detecting and Ending Deadlocks</Title><Link>http://msdn.microsoft.com/en-us/library/ms178104(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that for SQL Server 2008 or newer versions, you leave the system_health Extended Events session enabled to capture deadlock information. For versions of SQL Server prior to SQL Server 2008, it is recommended that you enable startup trace flags 2014 or 1222 or run a SQL Server trace in order to monitor for deadlocks.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-DL2'  ,''  ,'http://bit.ly/b0pDL8',4  ,10  ,'Deadlock' ,'A deadlock was detected $(ApplicationName? in application $(ApplicationName): ) $(Database?in [$(Database)]: ) $(HostName?submitted from $(HostName): ) $(UserName?by $(UserName): ) at $(StartTime) ' ,'Deadlocks are caused by inconsistencies in the order in which an application updates data elements. Details of the deadlock are:
Deadlock Victim Details:  $(ApplicationName? in application $(ApplicationName): ) $(Database?in [$(Database)]: ) $(HostName?submitted from $(HostName): ) $(UserName?by $(UserName): ) 
 ' ,3  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Detecting and Ending Deadlocks</Title><Link>http://msdn.microsoft.com/en-us/library/ms178104.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Detecting and Ending Deadlocks</Title><Link>http://msdn.microsoft.com/en-us/library/ms178104(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Detecting and Ending Deadlocks</Title><Link>http://msdn.microsoft.com/en-us/library/ms178104(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) deadlocks were detected'  ,'Deadlocks are caused when inconsistencies in the order in which an application updates data elements.
'  ,'We recommend you investigate and remedy these deadlocks.  '  ,''  ,'It is recommended that you investigate and remedy the deadlock.  '  ,1,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I1'  ,''  ,'http://bit.ly/aMxFSF',5  ,5 ,'Out-of-date database statistics' ,'Database [$(Database)] may have out-of-date statistics ' ,'Out-of-date statistics can result in poor query performance because the query optimizer might not choose the most efficient plan for retrieving or updating data. ' ,3  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Update Statistics</Title><Link>http://msdn.microsoft.com/en-us/library/ms187348.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Setting Database Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms190249.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Alter Database</Title><Link>http://msdn.microsoft.com/en-us/library/ms174269.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Update Statistics</Title><Link>http://msdn.microsoft.com/en-us/library/ms187348(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Setting Database Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms190249(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Alter Database</Title><Link>http://msdn.microsoft.com/en-us/library/ms174269(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Update Statistics</Title><Link>http://msdn.microsoft.com/en-us/library/ms187348(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>Setting Database Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms190249(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>Alter Database</Title><Link>http://msdn.microsoft.com/en-us/library/ms174269(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>Statistics Used by the Query Optimizer in Microsoft SQL Server 2005</Title><Link>http://technet.microsoft.com/en-us/library/cc966419.aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) databases may have out-of-date statistics'  ,''  ,''  ,''  ,'It is recommended that you set the AUTO_UPDATE_STATISTICS database option to ON by using the ALTER DATABASE statement. Alternatively, you can manually update statistics by using the UPDATE STATISTICS statement. It is recommended that you consider enabling startup trace flag 2371 if you are on SQL Server 2008 R2 SP1 or later and have very large tables where the default update setting of 20% of rows is not sufficient to update statistics more aggressively for large tables.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation 
([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding]
,[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],
[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I10'  ,'$(li)SQLdoctor''s analysis shows that this index is being used to improve the performance of some queries, and there is a trade-off between improved read performance and decreased write performance.  If you are not experiencing any performance issues when updating the underlying table, then this recommendation can be ignored. $(li)Some indexes are designed and implemented to improve the performance of an infrequent but high priority cyclic business process, such as quarterly reporting.  Altering such an index may have an undesired impact that is not obvious until a complete business cycle has elapsed. $(li)The index usage statistics (writes per second and writes per read) are based on usage since the last server restart. If an entire business/usage cycle has not elapsed since that time, then those statistics may be incomplete.  Incomplete statistics may not accurately reflect usage patterns.'  ,'http://bit.ly/aMxFSF' ,5,3  ,'Index is Experiencing Frequent Updates' ,'[$(IndexName)] on [$(Database)].[$(Schema)].[$(Table)] is experiencing frequent updates ' ,'Since this server was restarted $(DaysNotUsed) days ago, this index has experienced an average of $(WritesPerSecond) writes per second with $(WritesPerRead) writes occurring for each read. ' ,'1'  ,''  ,'Indexes are experiencing frequent updates'  ,'These indexes experience high numbers of writes per second and high ratios of writes for each read.'  ,'It is recommended that you review the definition of these indexes to determine whether they should be redesigned or removed to avoid the overhead cost during write operations.  If these indexes are used for infrequent high priority operations, then consider recreating the indexes shortly before they are needed and removing them after the read operations have been completed.

However, altering or dropping any of the existing indexes could have negative consequences for queries which specifically reference those indexes in a query hint.'  ,'$(li)When modifying data in a table with nonclustered indexes, SQL Server incurs additional overhead in order to keep the indexes up-to-date. $(li)If write operations far outnumber read operations on your data set, then the cost of keeping the index up-to-date may outweigh the performance benefits to your queries.'  ,'It is recommended that you review the definition of this index to determine whether it should be redesigned or removed to avoid the overhead cost during write operations.  If the index is used for infrequent high priority operations, then consider disabling the index, re-enabling the index by rebuilding it shortly before it is needed, and then disabling the index again after the read operations have been completed.

However, altering or dropping any of the existing indexes could have negative consequences for queries which specifically reference those indexes in a query hint.'  ,0,''

,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I12'  ,''  ,'http://bit.ly/cjyed9',5  ,8  ,'' ,'The function "$(FunctionName)" may be causing a table scan on [$(Database)].[$(Schema)].[$(Table)] ' ,'The function or expression "$(FunctionName)" on a column can cause index suppression resulting in poor performance due to a scan being performed instead of a seek. ' ,'1'  ,''  ,'$(Count) functions may be causing table scans'  ,'These functions or expressions can cause index suppression, resulting in poor performance due to a scan being performed instead of a seek.'  ,'It is recommended that you consider redesigning these WHERE clauses to prevent index suppression and performance degradation.'  ,''  ,'It is recommended that you consider redesigning this WHERE clause to prevent index suppression and performance degradation.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I11'  ,''  ,'',5  ,5  ,'' ,'Primary key $(PrimaryKeyName) on table $(TableName) is experiencing frequent updates ' ,'Typically a clustered index is maintained for a table''s primary key. SQL Server incurs performance overhead when maintaining this index. If the index requires frequent updates, the cost of maintaining the index may outweigh the benefit of the index. ' ,2  ,''  ,'SKIPPED'  ,'SKIPPED'  ,'SKIPPED'  ,''  ,'It is recommended that you consider altering table $(TableName) to use a different primary key.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I14'  ,''  ,'http://bit.ly/dpLnka ',5  ,8  ,'' ,'An implicit conversion on column [$(Database)].[$(Schema)].[$(Table)].[$(Column)] to data type "$(DataType)" may be causing index suppression ' ,'An implicit conversion in a WHERE clause of a query can cause index suppression if an indexed column is of a different type resulting in a scan rather than a seek. ' ,'1'  ,''  ,'$(Count) implicit conversions may be causing index suppression'  ,''  ,'It is recommended that you consider redesigning these WHERE clauses to prevent index suppression and performance degradation.'  ,''  ,'It is recommended that you consider redesigning this WHERE clause to prevent index suppression and performance degradation.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I13'  ,''  ,'http://bit.ly/9gImFn',5  ,NULL  ,'' ,'The referenced column in Index $(IndexName) begins with a date type ' ,'If the key columns of a multi-column index begins with a date type, queries using the index can experience poor performance due to sub-optimal range scans. ' ,''  ,''  ,'SKIPPED'  ,'SKIPPED'  ,'SKIPPED'  ,''  ,'It is recommended that you consider redesigning index $(IndexName) so that the key columns do not begin with a date type.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I16'  ,'$(li)Some indexes are designed and implemented to improve the performance of an infrequent but high priority cyclic business process, such as quarterly reporting.  Altering such an index may have an undesired impact that is not obvious until a complete business cycle has elapsed. $(li)The index usage statistics (writes per second and writes per read) are based on usage since the last server restart. If an entire business/usage cycle has not elapsed since that time, then those statistics may be incomplete.  Incomplete statistics may not accurately reflect usage patterns.'  ,'http://bit.ly/caOD8r',5  ,0  ,'Unused Index' ,'Index [$(IndexName)] on [$(Database)].[$(Schema)].[$(Table)] has not been used in $(DaysSinceUsed) days ' ,'Since this server was restarted $(DaysNotUsed) days ago, this index has experienced an average of $(WritesPerSecond) writes per second.  However, this index has not been used by any reads during that time. ' ,'1'  ,''  ,'$(Count) indexes have not been used recently'  ,'These indexes experience high numbers of writes per second and high ratios of writes for each read.'  ,'It is recommended that you review the definitions of these indexes to determine whether they should be redesigned or removed to avoid the overhead cost during write operations.  If these indexes are used for infrequent high priority operations, then consider recreating the indexes shortly before they are needed and removing them after the read operations have been completed.

However, altering or dropping any of the existing indexes could have negative consequences for queries which specifically reference those indexes in a query hint.
'  ,'$(li)When modifying data in a table with nonclustered indexes, SQL Server incurs additional overhead in order to keep the indexes up-to-date. $(li)If write operations far outnumber read operations on your data set, then the cost of keeping the index up-to-date may outweigh the performance benefits to your queries.'  ,'It is recommended that you review the definition of this index to determine whether it should be redesigned or removed to avoid the overhead cost during write operations.  If the index is used for infrequent high priority operations, then consider disabling the index, re-enabling the index by rebuilding it shortly before it is needed to re-enable it, and then disabling the index again after the read operations have been completed.

However, altering or dropping any of the existing indexes could have negative consequences for queries which specifically reference those indexes in a query hint.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I15'  ,''  ,'http://bit.ly/bUhP9B',5  ,NULL  ,'' ,'An index covering columns $(ColumnNames) can improve query performance on table $(TableName) ' ,'A large number of queries are accessing table $(TableName) referencing columns $(ColumnNames) that are not covered by an index. The performance of these queries would benefit from a covered index. ' ,''  ,''  ,'SKIPPED'  ,'SKIPPED'  ,'SKIPPED'  ,''  ,'It is recommended that you add an index to $(TableName) including columns $(ColumnNames).'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I17'  ,''  ,'http://bit.ly/aOIDK7',5  ,5  ,'Index experiencing page latch contention' ,'$(IndexName?Index [$(IndexName)] on table:Table) [$(Database)].[$(Schema)].[$(Table)] is experiencing high levels of page latch contention ' ,'The $(IndexName?index:table) is experiencing an average wait time of $(FormattedAvgWait) per wait  with $(WaitCount) waits due to latch contention.  This can significantly degrade the performance of queries using the $(IndexName?index:table). ' ,'1'  ,''  ,'$(Count) objects are experiencing excessive page latch contention'  ,'These objects are experiencing a high average wait time per wait due to latch contention.  This can significantly degrade the performance of queries using these objects.'  ,'It is recommended that you review your application''s use of these objects to determine if optimizations can be introduced to reduce contention.'  ,''  ,'It is recommended that you review your applications usage of $(IndexName?index [$(IndexName)]:table [$(TableName)]) to determine if optimizations can be introduced to reduce contention.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I19'  ,''  ,'http://bit.ly/9bRLae',5  ,10  ,'Out-of-date column statistics' ,'Column [$(Database)].[$(Schema)].[$(Table)].[$(Column)] has missing or out of date statistics ' ,'The statistics used in creating an execution plan based on a column is currently out of date.  The execution plan generated is still correct, but it may not be optimal. ' ,'3'  ,''  ,'$(Count) columns have missing or out of date statistics'  ,''  ,'It is recommended that you create or update the statistics for these columns.'  ,''  ,'It is recommended that you create or update the statistics for [$(Database)].[$(Schema)].[$(Table)].[$(Column)]'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I18'  ,''  ,'http://bit.ly/9OESxU',5  ,10  ,'' ,'The SQL Server memory limit for query plan compilation has been exceeded while generating an execution plan ' ,'The creation of an execution plan caused the SQL Server memory limit for query plan compilation to be exceeded.  The execution plan generated is still usable, but it may not be optimal. ' ,'3'  ,''  ,'SKIPPED'  ,'SKIPPED'  ,'SKIPPED'  ,''  ,'It is recommended that you try one of the following methods to increase available memory: 1) Reduce the load on the server  2) Increase memory available to SQL Server  3) Check the max server memory option that is set with sp_configure and increase the value if it is too low

It is recommended that the offending query be simplified. The optimizer has limits on the amount of memory it can use to optimize a query. The optimizer may be able to find a more optimal query plan if the plan is simplified by removing nested views, simplifying complex joins, reducing the number of elements referenced in the query, or by breaking the query into several smaller queries.'  ,1,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I2'  ,'$(li)The index is very small.$(li)The index is never used by queries that perform range scans.'  ,'http://bit.ly/b3Qv1m ',5  ,8  ,'Index fragmentation' ,'Index [$(Name)] on [$(Database)].[$(Schema)].[$(Table)] with a partition size of $(PartitionSize) is $(FragmentationPercentage)% fragmented ' ,'Queries that perform scans or large seeks on index [$(Name)] may be adversely impacted by fragmentation by limiting the ability of SQL Server to perform large reads of data from disk. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Reorganizing and Rebuilding Indexes</Title><Link>http://technet.microsoft.com/en-us/library/ms189858.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Reorganizing and Rebuilding Indexes</Title><Link>http://msdn.microsoft.com/en-us/library/ms189858(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Reorganizing and Rebuilding Indexes</Title><Link>http://msdn.microsoft.com/en-us/library/ms189858(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>Statistics Used by the Query Optimizer in Microsoft SQL Server 2005</Title><Link>http://technet.microsoft.com/en-us/library/cc966419.aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>Disk Space Requirements for Index DDL Operations</Title><Link>http://msdn.microsoft.com/en-us/library/ms179542(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Disk Space Requirements for Index DDL Operations</Title><Link>http://msdn.microsoft.com/en-us/library/ms179542(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Disk Space Requirements for Index DDL Operations</Title><Link>http://msdn.microsoft.com/en-us/library/ms179542(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) indexes are fragmented'  ,'Queries that perform scans or large seeks on indexes may be adversely impacted by fragmentation by limiting the ability of SQL Server to perform large reads of data from disk.'  ,'It is recommended that you rebuild or reorganize the indexes.'  ,'$(li)Highly fragmented indexes can cause inefficiencies with scans or large seeks because the SQL Server read-ahead logic is unable to read large page ranges into memory with single I/O requests.  Instead, a greater number of smaller IO requests may be performed.'  ,'It is recommended that you rebuild or reorganize the index.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I20'  ,'$(li)If write operations far outnumber read operations on your data set, then the cost of keeping the index up-to-date may outweigh the performance benefits to your queries. $(li)If the increase in performance from adding a new index does not justify the additional storage space on disk, additional time and space spent on backups, or additional maintenance required by the new index.'  ,'http://bit.ly/cnuSux ',5  ,5  ,'Missing Index (DMV)' ,'Missing index on [$(Database)].[$(Schema)].[$(Table)] ' ,'An average of $(AvgUserScansSeeksPerDay) user seeks/scans per day on table [$(Database)].[$(Schema)].[$(Table)] could see performance improvements from adding a new index.  The performance improvement is estimated to be $(AvgUserCostImpact) ms for each query execution. ' ,'3'  ,''  ,'$(count) missing index opportunities were found'  ,'Several queries could see performance improvements from adding additional indexes.  Without proper indexes, the SQL Server query optimizer may not have an efficient path to choose for retrieval of row data to satisfy the query.  This may result in a full scan of the underlying table data.'  ,'It is recommended that you review data access patterns for these tables to determine if the suggested indexes would improve your query performance significantly and to ensure the extra overhead of maintaining these indexes is justified. If the overhead of maintaining these indexes is justified, the suggested indexes should be created. Alternatively, review the existing indexes to determine if there are any indexes which can be modified to incorporate the missing index data.


However, be aware that creating indexes will increase the size of the underlying tables, and that SQL Server will have the additional overhead of keeping indexes up-to-date when the table data changes.'  ,'$(li)Without proper indexes, the SQL Server query optimizer may not have an efficient path to choose for retrieval of row data to satisfy the query.  This may result in a full scan of the underlying table data.'  ,'It is recommended that you review the data access patterns for this table to determine if the suggested index would improve your query performance significantly and to ensure the extra overhead of maintaining the index is justified. If the overhead of maintaining the index is justified, the suggested index should be created. Alternatively, review the existing indexes to determine if there is an index which can be modified to incorporate the missing index data, for example, by recreating the index with one or more additional non-key columns using the INCLUDE option.

However, be aware that creating indexes will increase the size of the underlying table, and that SQL Server will have the additional overhead of keeping indexes up-to-date when the table data changes. '  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I21'  ,'$(li)These indexes may already be optimized to yield maximum performance for particular queries or access patterns (for example, seeking versus scanning). $(li)These indexes may be relatively small, which would invalidate concerns about their storage or memory footprint. $(li)The time SQL Server spends updating these indexes may be very small, which would invalidate concerns about a performance overhead for write operations.$(li)Some indexes are designed and implemented to improve the performance of an infrequent but high priority cyclic business process, such as quarterly reporting.  Altering such an index may have an undesired impact that is not obvious until a complete business cycle has elapsed. '  ,'http://bit.ly/cnuSux ',5  ,7  ,'Overlapping Indexes' ,'Indexes on [$(Database)].[$(Schema)].[$(Table)] overlap ' ,'Index [$(OverlappingIndexName)] and index [$(IndexName)] on table [$(Schema)].[$(Table)] of database [$(Database)] contain the same data in some key columns and included columns. 

These indexes are not identical, but they do share data. Index [$(IndexName)] consists of all the data contained in index [$(OverlappingIndexName)], plus additional columns. Index [$(OverlappingIndexName)] is being updated $(UpdatesPerDay) times per day. ' ,'1'  ,''  ,'$(Count) overlapping indexes found'  ,'Multiple indexes contain the same data in some key columns and included columns. 

These indexes are not identical, but several indexes consist of all the data contained in the smaller indexes, plus additional columns. Maintaining these separate indexes incurs a performance overhead for data modifications on this database. 
'  ,'It is recommended that you review the definitions of these indexes and the queries that use them to determine whether the overlapping indexes can be deleted without negatively impacting the performance of the queries that currently use these indexes.

However, be aware that the larger indexes occupy more space on disk and in memory; therefore queries which currently use small overlapped indexes may not receive the same performance benefit when using the larger indexes.  Also, altering or dropping either of the existing indexes could have negative consequences for queries which specifically reference those indexes in a query hint.
'  ,'$(li)When modifying data in a table with a nonclustered index, SQL Server incurs additional overhead in order to keep the indexes up-to-date. $(li)Using multiple indexes for the same function requires additional storage space on disk and in memory. $(li)If this overlap is not intentional, then one of these indexes may not be used by any queries.'  ,'It is recommended that you review the definitions of these indexes and the queries that use them to determine whether index [$(IndexName)] can replace index [$(OverlappingIndexName)] without negatively impacting the performance of queries that currently use index [$(OverlappingIndexName)]. If this index is used for infrequent high priority operations, then consider disabling the index, re-enabling the index by rebuilding it shortly before it is needed, and then disabling the index again after the read operations have been completed.

However, be aware that index [$(IndexName)] occupies more space on disk and in memory; therefore queries which currently use [$(OverlappingIndexName)] may not receive the same performance benefit when using [$(IndexName)].  Also, altering or dropping either of the existing indexes could have negative consequences for queries which specifically reference those indexes in a query hint.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I22'  ,'$(li)The time SQL Server spends updating these indexes may be very small, which would invalidate concerns about a performance overhead for write operations. $(li)These indexes may be relatively small, which would invalidate concerns about their storage or memory footprint. $(li)The SQL Server query optimizer will favor the non-clustered index for some data access patterns such as queries that aggregate the data in the key columns.  In such cases the non-clustered index presents a performance improvement rather than a problem.$(li)Some indexes are designed and implemented to improve the performance of an infrequent but high priority cyclic business process, such as quarterly reporting.  Altering such an index may have an undesired impact that is not obvious until a complete business cycle has elapsed. $(li)The index usage statistics (including updates per day) are based on usage since the last server restart. If an entire business/usage cycle has not elapsed since that time, then those statistics may be incomplete.  Incomplete statistics may not accurately reflect usage patterns.'  ,'http://bit.ly/cUCyf1',5  ,10  ,'A Non-Clustered Index Key Matches the Clustered Index Key' ,'A non-clustered index key matches the clustered index key on table [$(Database)].[$(Schema)].[$(Table)] ' ,'Non-clustered index [$(NonClusteredIndexName)] contains the same key columns as the clustered index [$(ClusteredIndexName)] on table [$(Database)].[$(Schema)].[$(Table)].  

These indexes are not identical, but the non-clustered index [$(NonClusteredIndexName)] contains a subset of the data in [$(ClusteredIndexName)] while using the same organizational structure.  [$(NonClusteredIndexName)] may not provide a performance benefit over [$(ClusteredIndexName)], so it may not see regular use. Index [$(NonClusteredIndexName)] is being updated an average of $(UpdatesPerDay) times per day, but it has not been used to improve the read performance of any queries. ' ,'1'  ,''  ,'Non-clustered index keys matches the clustered index key '  ,'Non-clustered indexes contain the same key columns as the clustered index on one or more tables.  

These indexes are not identical, but the non-clustered indexes contain a subset of the data in the clustered indexes while using the same organizational structure.  The non-clustered indexes will rarely provide a performance benefit over the clustered indexes, so they will rarely be used to improve query performance. '  ,'It is recommended that you review the definitions of these indexes to determine if the non-clustered indexes are needed and to ensure the extra overhead of maintaining the non-clustered indexes is justified. If the overhead of maintaining the non-clustered indexes is not justified, those indexes should be dropped.

However, be aware that dropping the non-clustered indexes may have negative performance impacts on those queries which are currently using them. The clustered indexes may be larger and may be less optimized to suit your data access patterns.  Also, altering or dropping any of the existing indexes could have negative consequences for queries which specifically reference those indexes in a query hint.'  ,'$(li)When modifying data in a table with a nonclustered index, SQL Server incurs additional overhead in order to keep the indexes up-to-date. $(li)Using multiple indexes for the same function requires additional storage space on disk and in memory. $(li)If this overlap is not intentional, then one of these indexes may not be used by any queries.'  ,'It is recommended that you review the definitions of these indexes to determine whether the non-clustered index is needed and to ensure the extra overhead of maintaining the non-clustered index is justified. If the overhead of maintaining the non-clustered index is not justified, the non-clustered index should be dropped. If this index is used for infrequent high priority operations, then consider disabling the index, re-enabling the index by rebuilding it shortly before it is needed, and then disabling the index again after the read operations have been completed.

However, be aware that dropping the non-clustered index may have negative performance impacts on those queries which are currently using it. The clustered index may be larger and may be less optimized to suit your data access patterns.  Also, altering or dropping either of the existing indexes could have negative consequences for queries which specifically reference those indexes in a query hint.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I3'  ,''  ,'http://bit.ly/bITWMu',5  ,10  ,'Out-of-date statistics object' ,'Statistics object [$(Database)].[$(Schema)].[$(Table)].[$(Name)] was last updated on $(StatsDate) and would benefit from updated statistics ' ,'The optimizer may not be able to create optimal execution plans when statistics are out of date.  This can lead to greater amounts of I/Os being generated than necessary as well as excessive TempDB and processor usage in order to fulfill T-SQL queries. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Index Statistics</Title><Link>http://technet.microsoft.com/en-us/library/ms190397(SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) statistics objects would benefit from updated statistics'  ,''  
,'It is recommended that you schedule a process to update statistics explicitly for these objects. Possible causes are: "Auto create/update stats" has been turned off at the database level; the index has been created with "STATISTICS_NORECOMPUTE = ON"; or the statistics themselves have been created "WITH (NORECOMPUTE)". It is recommended that you consider enabling startup trace flag 2371 if you are on SQL Server 2008 R2 SP1 or later and have very large tables where the default update setting of 20% of rows is not sufficient to update statistics more aggressively for very large tables.'  ,''  ,'It is recommended that you schedule a process to update statistics explicitly for object [$(Name)]. Possible causes are: "Auto create/update stats" has been turned off at the database level; the index has been created with "STATISTICS_NORECOMPUTE = ON"; or the statistics themselves have been created "WITH (NORECOMPUTE)".  It is recommended that you consider enabling startup trace flag 2371 if you are on SQL Server 2008 R2 SP1 or later and have very large tables where the default update setting of 20% of rows is not sufficient to update statistics more aggressively for very large tables.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I4'  ,'$(li)If write operations far outnumber read operations on your data set, then the cost of keeping the index up-to-date may outweigh the performance benefits to your queries. $(li)If the increase in performance from adding a new index does not justify the additional storage space on disk, additional time and space spent on backups, or additional maintenance required by the new index.'  ,'http://bit.ly/ceXqCZ',5  ,10  ,'Missing index' ,'Missing index on [$(Database)].[$(Schema)].[$(Table)] ' ,'Missing $(RecommendedIndexes.Count>1?indexes:index) on [$(Database)].[$(Schema)].[$(Table)] which is experiencing $(TableUpdatesPerMinute) table updates per minute. ' ,'3'  ,''  ,'$(Count) tables are missing indexes'  ,'Adding the recommended indexes will improve SQL Server performance by optimizing the access paths for their respective workloads.'  ,'It is recommended that you review the data access patterns for the tables to determine if the suggested indexes would improve the performance of the queries significantly and to ensure the extra overhead of maintaining any new index is justified.'  ,'$(li)Without proper indexes, the SQL Server query optimizer may not have an efficient path to choose for retrieval of row data to satisfy the query.  This may result in a full scan of the underlying table data.'  ,'It is recommended that you review the data access patterns for this table to determine if the suggested index would improve your query performance significantly and to ensure the extra overhead of maintaining the index is justified. If the overhead of maintaining the index is justified, then the suggested index should be created. Additionally, review the existing indexes for consolidation opportunities and determine if there is an index that can be modified to incorporate the missing index data. For example, it might be possible to consolidate indexes by recreating one of them with one or more additional non-key columns using the INCLUDE option.

The ''Affected Batches'' can be reviewed to see which batches are impacted by the addition of the new index.  Each batch is labeled with the estimated percentage of cost improvement for the corresponding batch based on the addition of the new index.

However, be aware that creating indexes will increase the used allocation space of the database, and that SQL Server will have the additional overhead of keeping indexes up-to-date when the table data changes.
'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I5'  ,'$(li)The index has been disabled to reduce the time taken for data extraction, transformation, and loading.$(li)The index is used rarely (once a week/month/quarter/year/etc.) and the cost of constantly keeping the index maintained is significant enough to justify rebuilding the index prior to using it and then disabling it again.$(li)A large nonclustered index has been disabled prior to rebuilding the index.  Normally, rebuilding a nonclustered index requires enough temporary disk space to store both the old and new index.  By disabling and rebuilding the nonclustered index in separate transactions, the space made available by disabling the index can be reused by the subsequent rebuild.  '  ,'http://bit.ly/bPcpqr',5  ,10  ,'Disabled index' ,'Index [$(Name)] on [$(Database)].[$(Schema)].[$(Table)] is disabled ' ,'A disabled index [$(Name)] has been found on table [$(Database)].[$(Schema)].[$(Table)] ' ,'1'  ,''  ,'$(Count) indexes are disabled'  ,'$(Count) disabled indexes have been found.'  ,'You should consider dropping the disabled indexes if they are no longer needed.

However, before dropping any disabled index, verify that:$(li)The index is not temporarily disabled for data loads.$(li)The index is not rebuilt shortly before infrequent high priority operations and disabled after the read operations have completed.'  ,'$(li)The query optimizer does not consider the index when creating query execution plans.$(li)For nonclustered indexes, disabling the index will delete the index data but leave the metadata for the index definition.  However, for clustered indexes, all nonclustered indexes for the table will be disabled and the clustered index will continue to consume storage space.$(li)If the index is a clustered index, this will prevent user access to the table data.'  ,'You should consider dropping the disabled index if it is no longer needed.

However, before dropping the index, verify that:$(li)The index is not temporarily disabled for data loads.$(li)The index is not rebuilt shortly before infrequent high priority operations and disabled after the read operations have completed.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I6'  ,'$(li)The time SQL Server spends updating these indexes may be negligible, which would invalidate concerns about a performance overhead for write operations.$(li)These indexes may be relatively small, which would invalidate concerns about their storage or memory footprint.'  ,'http://bit.ly/cUCyf1',5  ,10  ,'Duplicate index' ,'Duplicate index found on [$(Database)].[$(Schema)].[$(Table)] ' ,'Duplicate indexes [$(IndexName)] and [$(DuplicateIndexName)] were found on table [$(Database)].[$(Schema)].[$(Table)]. ' ,'1'  ,''  ,'$(Count) duplicate indexes found'  ,'Duplicate indexes require additional overhead in order to keep the indexes up-to-date along with additional storage space on disk and in memory.'  ,'It is recommended that you review the definition of these indexes to determine whether they should be redesigned or removed to avoid the overhead cost during write operations.

However, altering or dropping any of the existing indexes could have negative consequences for queries which specifically reference those indexes in a query hint.'  ,'$(li)When modifying data in a table, SQL Server incurs additional overhead in order to keep the indexes up-to-date.$(li)Using multiple indexes for the same function requires additional storage space on disk and in memory.'  ,'It is recommended that you review the definition of these indexes to determine whether they should be redesigned or removed to avoid the overhead cost during write operations.

However, altering or dropping any of the existing indexes could have negative consequences for queries which specifically reference those indexes in a query hint.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I7'  ,''  ,'http://bit.ly/9PeSLH',5  ,10  ,'Hypothetical index' ,'Hypothetical index found on [$(Database)].[$(Schema)].[$(Table)] ' ,'Hypothetical index [$(IndexName)] was found on [$(TableName)] of database [$(Database)]. This index was used by Microsoft Index Tuning Wizard, Database Tuning Advisor or SQL doctor during index performance analysis and could not be dropped due to a lock on the table.  ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Deleting Hypothetical Indexes and Statistics</Title><Link>http://msdn.microsoft.com/en-us/library/ms190172.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Deleting Hypothetical Indexes and Statistics</Title><Link>http://msdn.microsoft.com/en-us/library/ms190172(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Deleting Hypothetical Indexes and Statistics</Title><Link>http://msdn.microsoft.com/en-us/library/ms190172(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) hypothetical indexes found'  ,'The hypothetical indexes were used by Microsoft Index Tuning Wizard, Database Tuning Advisor or SQL doctor during index performance analysis and could not be dropped due to a lock on the table.'  ,'It is recommended that you drop the indexes.'  ,''  ,'It is recommended that you drop the index.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I8'  ,'$(li)The time SQL Server spends updating these indexes may be very small, which would invalidate concerns about a performance overhead for write operations. $(li)These indexes may be relatively small, which would invalidate concerns about their storage or memory footprint. $(li)These indexes may already be optimized to yield maximum performance for particular queries or access patterns (for example, seeking versus scanning).'  ,'http://bit.ly/d0sGg2',5  ,7  ,'Index Consolidation' ,'Indexes on [$(Database)].[$(Schema)].[$(Table)] could be consolidated ' ,'Index [$(RedundantIndexName)] and index [$(IndexName)] on table [$(Schema)].[$(Table)] of database [$(Database)] may be candidates for index consolidation. 

Although these indexes do share key columns, they are not identical because there were differences found in either the key columns or INCLUDE columns. ' ,'1'  ,''  ,'$(Count) index consolidation opportunities found'  ,'Multiple indexes may be candidates for index consolidation. These indexes are not identical, but they do share key columns. This overlap consists of a subset of columns in the same order as those included in another index. '  ,'It is recommended that you review the definitions of these indexes to determine whether a single index should be created to address the full set of queries currently being covered by these multiple separate indexes.

However, be aware that consolidating these indexes may have undesirable performance impacts.  The consolidated index may be larger and may be less optimized to suit your data access patterns.  Also, altering or dropping either of the existing indexes could have negative consequences for queries which specifically reference those indexes in a query hint.
'  ,'$(li)When modifying data in a table with a nonclustered index, SQL Server incurs additional overhead in order to keep the indexes up-to-date.$(li)Using multiple indexes for the same function requires additional storage space on disk and in memory.$(li)If this overlap is not intentional, then one of these indexes may not be used by any queries.'  ,'It is recommended that you review the definitions of these indexes to determine whether a single index should be created to address the full set of queries currently being covered by [$(RedundantIndexName)] and [$(IndexName)]. If one of these indexes is used for infrequent high priority operations, then consider disabling the index, re-enabling the index by rebuilding it shortly before it is needed, and then disabling the index again after the read operations have been completed.


However, be aware that consolidating these indexes may have undesirable performance impacts.  The consolidated index may be larger and may be less optimized to suit your data access patterns.  Also, altering or dropping either of the existing indexes could have negative consequences for queries which specifically reference those indexes in a query hint.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I9'  ,''  ,'http://bit.ly/bH9cVw',5  ,5  ,'Index experiencing lock contention' ,'$(IndexName?Index [$(IndexName)] on table:Table) [$(Database)].[$(Schema)].[$(Table)] is experiencing excessive $(ContentionType) lock contention ' ,'The $(IndexName?index:table) is experiencing an average wait time of $(FormattedAvgWait) per wait due to lock contention with $(FormattedLockPercent) of the locks experiencing a wait.  This can significantly degrade the performance of queries using the $(IndexName?index:table). ' ,'1'  ,''  ,'$(Count) objects are experiencing excessive lock contention'  ,'These objects are experiencing a high average wait time per wait due to lock contention.  This can significantly degrade the performance of queries using these objects.'  ,'It is recommended that you review your application''s use of these objects to determine if optimizations can be introduced to reduce contention.  Note that other SQL doctor recommendations may be available to help remedy this problem.'  ,''  ,'It is recommended that you review your applications usage of $(IndexName?index [$(IndexName)]:table [$(TableName)]) to determine if optimizations can be introduced to reduce contention. Note that other SQL doctor recommendations may be available to help remedy this problem.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-LR1'  ,''  ,'http://bit.ly/axXNZZ' ,6  ,7  ,'Long running SQL Agent job' ,'Job ''$(JobName)'' ran substantially longer than usual ' ,'The last run of job ''$(JobName)'' ran substantially longer than the prior successful runs.  It ran for a total of $(LastRunDurationMinutes) minutes and it normally runs for $(AvgRunDurationMinutes) minutes. ' ,'1'  ,''  ,'$(Count) jobs ran substantially longer than usual'  ,'The last run of the jobs ran substantially longer than the prior successful runs.  '  ,'It is recommended that the job be examined for possible problems.'  ,''  ,'It is recommended that the job be examined for possible problems.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M28'  ,''  ,'http://bit.ly/9LptAQ',7  ,NULL  ,'' ,'SQL Server memory is experiencing stress while no CPU problems are detected ' ,'A performance bottleneck is being experienced due to page compression settings. ' ,''  ,''  ,'SKIPPED'  ,'SKIPPED'  ,'SKIPPED'  ,''  ,'It is recommended that page compression be turned on for the following large tables which are in your most used databases in terms of I/O usage: Table xxx (xx% and xxMB reduction will be achieved compressing this table), Table xxx (xx% and xxMB reduction will be achieved compressing this table)'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M1'  ,'$(li)When multiple applications are running on a single server, giving SQL Server the right to "Lock Pages in Memory" without also configuring the maximum server memory setting can result in other applications or the operating system becoming unable to allocate sufficient memory.  If it is not possible to configure the maximum server memory for SQL Server, then the "Lock Pages in Memory" right should not be granted. $(li)When multiple applications are running on a single server and have the "Lock Pages in Memory" right, each application should be configured with an upper bound for memory consumption.  Essentially, the total system memory should be divided up and portioned to each application including the operating system in order to ensure that none of your essential applications become memory starved.  If any of the applications running on the server do not support this configuration, then the "Lock Pages in Memory" right should not be granted.'  ,'http://bit.ly/bXIagg',7  ,10  ,'The SQL Server User Right "Lock Pages in Memory" is Not Being Used ' ,'The SQL Server user right "Lock Pages in Memory" is not being used ' ,'Granting the "Lock Pages in Memory" user right to the SQL Server service on a 64-bit system allows SQL Server to manage its memory allocations to ensure that critical data remains in physical memory. ' ,1 ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>How to reduce paging of buffer pool memory in the 64-bit version of SQL Server</Title><Link>http://support.microsoft.com/KB/918483/EN-US</Link><Condition>SQL64Bit = True</Condition></RecommendationLink><RecommendationLink><Title>Support for Locked Pages on Standard Edition 64-bit systems</Title><Link>http://support.microsoft.com/kb/970070/</Link><Condition>SQL64Bit = True</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,'$(li)The right "Lock Pages in Memory" is necessary in order to enable AWE on 32-bit SQL Servers prior to SQL 2012 (SQL 2012 does not support AWE).  AWE has no impact on 64-bit systems, but the user right prevents the Windows OS from removing the SQL Server buffer pool from physical memory in order to make room for other applications.$(li)Without this user right granted, the Windows OS can move large portions of the SQL Server buffer pool to disk when other applications request physical memory. $(li)SQL Server performance is degraded significantly when critical data is paged out of physical memory.'  ,'It is recommended that you review the memory usage of all applications running on the server to determine if it is appropriate to grant the user right "Lock Pages in Memory" to the SQL Server.  You should NOT try to set the AWE switch on 64-bit systems as it has no effect.

However, be aware that with "Lock Pages in Memory" granted, the Windows OS will not page SQL Server''s buffer pool out of physical memory in order to reclaim space, which can lead to memory starvation in other applications running on the server.  To avoid this situation, you should ensure that the SQL Server configuration option "Max Server Memory" is also configured to set an upper bound which will leave sufficient memory available for the operating system and other applications.  

Note: Standard Editions of SQL Server will also require trace flag 845 to be added as a startup parameter so that "Lock Pages in Memory" can be used.  Enterprise editions do not need this trace flag.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M26'  ,''  ,'http://bit.ly/bcgT1p ',7  ,NULL  ,'' ,'The Screen Saver is enabled ' ,'The screen saver can unnecessarily use resources that should be kept available for SQL Server. ' ,''  ,''  ,'SKIPPED'  ,'SKIPPED'  ,'SKIPPED'  ,''  ,'It is recommended that the Screen Saver be set to (none) or blank on a production server to improve performance.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M25'  ,''  ,'http://bit.ly/9WiWK0 ',7  ,NULL  ,'' ,'Visual Effects are not adjusted for best performance ' ,'Visual Effects consume CPU cycles, extra memory and network bandwidth as most production servers are accessed using Remote Desktop. ' ,''  ,''  ,'SKIPPED'  ,'SKIPPED'  ,'SKIPPED'  ,''  ,'It is recommended that Visual Effects on the Control Panel be set for best performance on production servers. '  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M10'  ,'$(li)These applications may be configured to have a very low footprint or to yield resources to SQL Server as necessary. $(li)Your business requirements may consider some of these applications essential.'  ,'http://bit.ly/ch3Blq',7  ,'7'  ,'Non-Essential Applications Detected ' ,'Non-essential applications have been detected running on the server ' ,'Non-essential applications compete for resources and degrade performance on your server. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Operating System Performance Optimization</Title><Link>http://www.sql-server-performance.com/articles/audit/operating_system_performance_p1.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,'$(li)Non-essential applications compete for resources and degrade performance on your server.'  ,'It is recommended that you review these applications to determine if they can be moved to a different server: $(RunningProcesses).'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M11'  ,''  ,'http://bit.ly/8Z0OAR',7  ,10  ,'Server is domain controller' ,'The server is being used as a primary or a backup domain controller ' ,'During periods of high user validation on the domain, SQL Server performance will degrade. Additionaly, high usage of SQL Server can cause domain authentication to take a long time or fail causing transient authentication problems throughout the domain. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Is it recommended to install SQL Server on a Windows domain controller?</Title><Link>http://www.sql-server-performance.com/faq/domain_controller_performance_p1.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that production servers should not be used as primary domain controllers (or backup domain controllers). '  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M22'  ,''  ,'http://bit.ly/aQ78Ba',7  ,NULL  ,'' ,'The Operating System is set to give best performance to the System Cache ' ,'SQL Server performance will increase if the setting is changed to Allow best performance of background services. ' ,''  ,''  ,'SKIPPED'  ,'SKIPPED'  ,'SKIPPED'  ,''  ,'It is recommended that a production SQL Server should have the setting set to Allow best performance of background programs. To make sure that memory is not taken away from SQL Server in order to enlarge Operating System cache which will not help SQL Server.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M12'  ,'$(li)The SQL Server instance is located on a server which is used for file sharing.  This setting is useful for servers that typically run the file sharing service.$(li)Additional memory is available for the larger file system cache that is not needed by the SQL Server instance.'  ,'http://bit.ly/bomYRC',7  ,'10'  ,'Maximize data throughput for file sharing setting is enabled' ,'The ''Maximize data throughput for file sharing'' setting is enabled ' ,'This setting optimizes the Windows server for file and printer sharing resources. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Server Memory Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms178067.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Server Memory Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms178067(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Server Memory Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms178067(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>LargeSystemCache</Title><Link>http://technet.microsoft.com/en-us/library/cc784562(WS.10).aspx</Link><Condition>OSVersion = 5.2</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,'$(li)This setting reduces the amount of memory available for SQL Server by providing additional memory to the file system cache.'  ,'You should consider changing this setting to "Maximize data throughput for network applications" if the SQL Server is not located on a file sharing server.  This can be changed through Network Local Connection Properties on Windows 2003 production servers. '  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M20'  ,''  ,'http://bit.ly/bh1iEm ',7  ,NULL  ,'' ,'The Operating System is set to give best performance to foreground applications ' ,'SQL Server performance will increase if the setting is changed to Allow best performance of background services. ' ,''  ,''  ,'SKIPPED'  ,'SKIPPED'  ,'SKIPPED'  ,''  ,'It is recommended that on high availability SQL Server should have the setting set to Allow best performance of background services.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M13'  ,'$(li)When index page density is high, this indicates that the space left empty due to the fill factor setting has since been filled in due to modifications to the table data, which means that the index pages in the buffer cache are not left partially empty. The next time this index is rebuilt, the data will be redistributed in order to again enforce the fill factor setting. $(li)Increasing the index fill factor will compact the data and save space in memory, but it will also lead to more page splits as the underlying table data is modified.  The cost of page splits in your environment may justify the memory contention created by using a low fill factor.'  ,'http://bit.ly/c4DZhD',7  ,8  ,'Low Default Fill Factor' ,'The server default fill factor is $(FillFactor) which may be contributing to memory pressure ' ,'The SQL Server is currently experiencing memory pressure which may be related to the number of partially-filled index pages loaded into memory. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Fill Factor</Title><Link>http://msdn.microsoft.com/en-us/library/ms177459.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Fill Factor</Title><Link>http://msdn.microsoft.com/en-us/library/ms177459(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Fill Factor</Title><Link>http://msdn.microsoft.com/en-us/library/ms177459(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,'$(li)The server-wide fill factor affects all indexes on the server whenever they are created or rebuilt. Every page of the index will be left partially empty in order to avoid future page splits as the underlying table data is updated. This increases the total size of the index by leaving "air pockets" for future growth. $(li)Because the indexes are larger, they take up more storage in the buffer cache whenever they are being used.  This in turn forces other data pages to be moved out of the buffer cache in order to make room for "air pockets."'  ,'It is recommended that the server-wide fill factor be increased and the indexes of larger tables be rebuilt in order to reduce memory stress as more data will reside on each 8K page.  Additionally, it is possible to control the fill factor for individual indexes when the index is created or rebuilt. This provides more granular control over how much empty space is left in each index so that these settings can be adjusted according to the data access patterns for each table.

However, be aware that increasing the fill factor of an index can lead to more frequent page splits as the data changes.  Such page splits always impact SQL Server performance and generate additional transaction log data.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M14'  ,''  ,'http://bit.ly/9yumDA',7  ,6  ,'' ,'The server default fill factor is $(FillFactor) and the number of page splits is small ' ,'The number of page splits is small and the fill factor is low. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Fill Factor</Title><Link>http://msdn.microsoft.com/en-us/library/ms177459.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Fill Factor</Title><Link>http://msdn.microsoft.com/en-us/library/ms177459(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Fill Factor</Title><Link>http://msdn.microsoft.com/en-us/library/ms177459(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that the fill factor be increased and the indexes of larger tables be re-indexed to reduce I/O usage and to maximize available memory as more data will reside on each 8K page.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M15'  ,''  ,'http://bit.ly/ayvaZa',7  ,6  ,'High page split count' ,'SQL Server is experiencing relatively high levels of page splits and its memory is not under stress ' ,'Page splits are currently accounting for $(PageSplitAllocationPercentage)% of all new page allocations. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>At what point should I worry about page splits, and what can I do to help reduce them?</Title><Link>http://www.sql-server-performance.com/faq/reduce_page_splits_p1.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that the fill factor be lowered on indexes that are experiencing a high number of page splits. This will result in better insert and update performance. '  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M16'  ,''  ,'http://bit.ly/9x9nNT',7  ,10  ,'Physical RAM has decreased' ,'The total amount of physical RAM available on this server has decreased by $(DecreasedBy) ' ,'A decrease in physical RAM has a corresponding decrease in system performance.  ' ,'3'  ,''  ,''  ,''  ,''  ,''  ,'It is recommended that the cause of the decrease in physical RAM on this server be determined and fixed to improve performance. There are several possible causes: $(li)One of your memory modules has failed or become unseated. $(li)Changes either to the BIOS version or on the BIOS have allocated some of the shared memory to another resource (such as video RAM).$(li)If this is a virtual machine then changes to the VM have excluded memory to this VM.$(li)If this server is part of a cluster then a failover may have occurred onto a machine with less physical RAM'  ,1,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M17'  ,'$(li)It may be necessary to lower the max server memory setting to prevent SQL Server from consuming all available resources and starving other applications or even the operating system.'  ,'http://bit.ly/9uzhuu',7  ,10  ,'Max Server Memory Setting has been Reduced' ,'The max server memory setting has been reduced since the last analysis ' ,'The SQL Server is experiencing memory pressure, and the most recent analysis shows that the max server memory setting has been reduced from previous values. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Server Memory Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms178067.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Server Memory Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms178067(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Server Memory Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms178067(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,'$(li)SQL Server is experiencing memory pressure, which may be directly linked to having less memory available.'  ,'It is recommended that you review recent changes to the SQL Server max server memory setting to determine if those changes may be causing the current memory pressure.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M18'  ,''  ,'http://bit.ly/cSsoJ3',7  ,10  ,'Non-default "Max concurrent user connections"' ,'The Max Concurrent User Connections setting is not set to the default of "0" ' ,'The default setting dynamically allocates memory for connection as needed. Each connection requires ~100KB Ram, which means that your setting of $(UserConnections) is reserving $(MemoryEstimate) of memory to be continuously allocated to connections.  ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Memory Used by SQL Server Objects Specifications</Title><Link>http://msdn.microsoft.com/en-us/library/aa337559.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Memory Used by SQL Server Objects Specifications</Title><Link>http://msdn.microsoft.com/en-us/library/aa337559(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Memory Used by SQL Server Objects Specifications</Title><Link>http://msdn.microsoft.com/en-us/library/aa337559(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that you set the Max Concurrent User Connections setting to the default of "0" to allow SQL Server to use free memory to store additional data/index pages or additional query plans.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M19'  ,''  ,'http://bit.ly/aPn5sR',7  ,10  ,'Non-default "Index creation memory"' ,'The Index Creation Memory option is not set to the default of "0" ' ,'The Index Creation Memory option is currently set to $(MemoryInKB) KB. This setting dynamically allocates the memory index creation as it is needed.  ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>index create memory Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms175123.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>index create memory Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms175123(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>index create memory Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms175123(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that the Index Creation Memory option be set to the default of "0" unless very large tables are being indexed as this memory is permanently allocated and cannot be shared by either the buffer pool or procedure cache.'  ,0,''
,1)
--INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
--('SDR-M2'  ,'$(li)There may be a specific requirement for the server to have one or more of these configuration options set.  This could be the requirement of third-party applications or the result of extensive performance tuning relating specifically to memory allocation and management. $(li)In an environment where multiple SQL Server instances are on the same server, or in a clustered environment when multiple SQL Server instances can be active on the same clustered node, consideration should be given to the memory usage of each instance. '  ,'http://bit.ly/bNRKeQ',7  ,'10'  ,'Memory Configuration Not Optimized: 16GB+ RAM' ,'Memory configuration settings are not set for the best performance of a 32-bit SQL Server with 16GB or more of RAM ' ,'Memory options for Physical Address Extension, 3GB, USERVA, Address Windowing Extensions, and Lock Pages in Memory are not configured correctly for optimal performance of a 32-bit SQL Server with 16GB or more of RAM. ' ,'3'  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Physical Address Extension</Title><Link>http://msdn.microsoft.com/en-us/library/aa366796(VS.85).aspx</Link></RecommendationLink><RecommendationLink><Title>Using AWE</Title><Link>http://msdn.microsoft.com/en-us/library/ms175581.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Using AWE</Title><Link>http://msdn.microsoft.com/en-us/library/ms175581(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Using AWE</Title><Link>http://msdn.microsoft.com/en-us/library/ms175581(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>How to Enable the Lock Pages in Memory Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms190730(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>How to Enable the Lock Pages in Memory Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms190730(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>How to Enable the Lock Pages in Memory Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms190730(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>Be Aware Using AWE locked pages in memory, on 64-bit</Title><Link>http://blogs.msdn.com/b/slavao/archive/2005/04/29/413425.aspx</Link><Condition>SQL64Bit = True</Condition></RecommendationLink><RecommendationLink><Title>Boot Configuration Data Editor Frequently Asked Questions</Title><Link>http://technet.microsoft.com/en-us/library/cc721886(WS.10).aspx</Link><Condition>OSVersionMajor = 6</Condition></RecommendationLink><RecommendationLink><Title>Who Moved My /3GB?</Title><Link>http://blogs.technet.com/b/askperf/archive/2009/04/03/who-moved-my-3gb.aspx</Link><Condition>OSVersionMajor = 6</Condition></RecommendationLink><RecommendationLink><Title>BCD Boot Options Reference</Title><Link>http://msdn.microsoft.com/en-us/library/ff542205(VS.85).aspx </Link><Condition>OSVersionMajor = 6</Condition></RecommendationLink><RecommendationLink><Title>How to edit the Boot.ini file in Windows Server 2003</Title><Link>http://support.microsoft.com/kb/323427</Link><Condition>OSVersion = 5.2</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,'$(li)Physical Address Extension (PAE) is a feature of the processor that allows access to more than 4GB of physical memory.  
--Without this enabled, the additional physical memory cannot be accessed on a 32-bit system. $(li)The /3GB switch will allot 3GB of virtual address space to user mode processes and 1GB of virtual address space to the operating system.  When you limit the operating system to only 1GB, you limit the amount of physical memory that can be managed by the operating system to only 16GB.  Because this server has 16GB or more of memory, do not set the /3GB switch to limit the operating system to only 1GB.$(li)Address Windowing Extensions (AWE) on a 32-bit SQL Server will allow for SQL Server to access physical memory greater than 4GB.  Because this server has 16GB or more of memory, AWE will allow the 32-bit SQL Server process to access to the additional memory. $(li)The Lock Pages in Memory user right must be assigned to the user account that the SQL Server process is executed under.  This right is assigned by default to the Local System account.  Without the Lock Pages in Memory user right, AWE cannot be used by the SQL Server process.'  ,'It is recommended you implement all of the following recommendations on 32-bit SQL Servers that have 16GB or more of RAM:
--$(li)Enable Physical Address Extensions (/PAE) in the startup configuration $(li)Disable /3GB in the startup configuration $(li)Enable Address Windowing Extensions (AWE) in the SQL Server configuration $(li)Enable the SQL Server advanced user right lock pages in memory
----However, extra steps should be taken to verify the current configuration is not required.  The recommended configuration is very specific to a 32-bit SQL Server with 16GB or more of physical memory.  If the amount of physical memory has been changed on the system, these settings must be verified again to ensure optimum performance of both the operating system and applications.'  ,1,''
--,0)
INSERT INTO #upgrade_PrescriptiveRecommendation (
[TempRecommendationID],
[TempAdditionalConsiderations]
,[Tempbitly]
,[TempCategoryID]
,[TempConfidenceFactor]
,[TempDescription]
,[TempFinding]
,[TempImpactExplanation]
,[TempImpactFactor]
,[TempInfoLinks]
,[TempPluralFormFinding]
,[TempPluralFormImpactExplanation]
,[TempPluralFormRecommendation]
,[TempProblemExplanation]
,[TempRecommendation]
,[TempRelevance]
,[TempTags],[TempIsActive]) VALUES 
('SDR-M2'  
,'$(li)There may be a specific requirement for the server to have one or more of these configuration options set.  This could be the requirement of third-party applications or the result of extensive performance tuning relating specifically to memory allocation and management. $(li)In an environment where multiple SQL Server instances are on the same server, or in a clustered environment when multiple SQL Server instances can be active on the same clustered node, consideration should be given to the memory usage of each instance. '  
,'http://bit.ly/bNRKeQ'
,7  
,10  
,'Memory Configuration Not Optimized: 16GB+ RAM' ,'Memory configuration settings are not set for the best performance of a 32-bit SQL Server with 16GB or more of RAM ' ,'Memory options for ''Physical Address Extension,'' ''3GB,'' ''USERVA,'' ''Address Windowing Extensions,'' and ''Lock Pages in Memory'' are not configured correctly for optimal performance of a 32-bit SQL Server with 16GB or more of RAM. ' 
,3  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Physical Address Extension</Title><Link>http://msdn.microsoft.com/en-us/library/aa366796(VS.85).aspx</Link></RecommendationLink><RecommendationLink><Title>Using AWE</Title><Link>http://msdn.microsoft.com/en-us/library/ms175581.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Using AWE</Title><Link>http://msdn.microsoft.com/en-us/library/ms175581(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Using AWE</Title><Link>http://msdn.microsoft.com/en-us/library/ms175581(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>How to Enable the Lock Pages in Memory Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms190730(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>How to Enable the Lock Pages in Memory Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms190730(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>How to Enable the Lock Pages in Memory Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms190730(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>Be Aware Using AWE locked pages in memory, on 64-bit</Title><Link>http://blogs.msdn.com/b/slavao/archive/2005/04/29/413425.aspx</Link><Condition>SQL64Bit = True</Condition></RecommendationLink><RecommendationLink><Title>Boot Configuration Data Editor Frequently Asked Questions</Title><Link>http://technet.microsoft.com/en-us/library/cc721886(WS.10).aspx</Link><Condition>OSVersionMajor = 6</Condition></RecommendationLink><RecommendationLink><Title>Who Moved My /3GB?</Title><Link>http://blogs.technet.com/b/askperf/archive/2009/04/03/who-moved-my-3gb.aspx</Link><Condition>OSVersionMajor = 6</Condition></RecommendationLink><RecommendationLink><Title>BCD Boot Options Reference</Title><Link>http://msdn.microsoft.com/en-us/library/ff542205(VS.85).aspx </Link><Condition>OSVersionMajor = 6</Condition></RecommendationLink><RecommendationLink><Title>How to edit the Boot.ini file in Windows Server 2003</Title><Link>http://support.microsoft.com/kb/323427</Link><Condition>OSVersion = 5.2</Condition></RecommendationLink></ArrayOfRecommendationLink>'  
,''  
,'' 
 ,''  
 ,'$(li)Physical Address Extension (PAE) is a feature of the processor that allows access to more than 4GB of physical memory.  Without this enabled, the additional physical memory cannot be accessed on a 32-bit system. $(li)The /3GB switch will allot 3GB of virtual address space to user mode processes and 1GB of virtual address space to the operating system.  When you limit the operating system to only 1GB, you limit the amount of physical memory that can be managed by the operating system to only 16GB.  Because this server has 16GB or more of memory, do not set the /3GB switch to limit the operating system to only 1GB.$(li)Address Windowing Extensions (AWE) on a 32-bit SQL Server will allow for SQL Server to access physical memory greater than 4GB.  Because this server has 16GB or more of memory, AWE will allow the 32-bit SQL Server process to access to the additional memory. $(li)The ''Lock Pages in Memory'' user right must be assigned to the user account that the SQL Server process is executed under.  This right is assigned by default to the ''Local System'' account.  Without the ''Lock Pages in Memory'' user right, AWE cannot be used by the SQL Server process.'
 ,'$(li)Enable Physical Address Extensions (/PAE) in the startup configuration $(li)Disable /3GB in the startup configuration $(li)Enable Address Windowing Extensions (AWE) in the SQL Server configuration $(li)Enable the SQL Server advanced user right lock pages in memory

However, extra steps should be taken to verify the current configuration is not required.  The recommended configuration is very specific to a 32-bit SQL Server with 16GB or more of physical memory.  If the amount of physical memory has been changed on the system, these settings must be verified again to ensure optimum performance of both the operating system and applications.'  
,1
,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M21'  ,''  ,'http://bit.ly/91AWUg',7  ,10  ,'OS optimized for foreground applications' ,'The Operating System is set to give best performance to foreground applications ' ,'SQL Server performance will increase if the setting is changed to ''Allow best performance of background services''. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Operating System Performance Optimization</Title><Link>http://www.sql-server-performance.com/articles/audit/operating_system_performance_p1.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that your Operating System should have the setting set to ''Allow best performance of background services'' to improve SQL Server performance.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M23'  ,''  ,'http://bit.ly/9UAeS2',7  ,10  ,'Memory performance of cache' ,'The Operating System is set to give best performance to the System Cache ' ,'This setting enlarges the system cache at the expense of giving SQL Server extra memory for data or index pages as well as procedure plans.  ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Best Practices: Adjust performance options to speed up Windows XP clients</Title><Link>http://articles.techrepublic.com.com/5100-10878_11-5034438.html</Link></RecommendationLink><RecommendationLink><Title>Operating System Performance Optimization</Title><Link>http://www.sql-server-performance.com/articles/audit/operating_system_performance_p1.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that the Operating System should have the Memory Usage adjusted for ''best performance of programs'' to increase performance.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M9'  ,''  ,'http://bit.ly/bwtmh8 ',7  ,NULL  ,'' ,'The production server has more than one SQL Server instance running ' ,'SQL Server instances compete for resources (CPU, Memory and I/O) potentially degrading performance. ' ,''  ,''  ,'SKIPPED'  ,'SKIPPED'  ,'SKIPPED'  ,''  ,'It is recommended that on high availability production servers, only one instance of SQL Server should be running.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M24'  ,''  ,'http://bit.ly/aO7KPX',7  ,9  ,'Need to optimize for ad-hoc workloads' ,'Single use Ad-hoc plans are using $(AdhocCacheSizeFormatted) of procedure cache   ' ,'These plans consume storage that can be better utilized by other plans or data pages.  ' ,'2'  ,''  ,''  ,''  ,''  ,''  ,'It is recommended that the ''Optimize For Ad-Hoc Workloads'' configuration setting should be enabled via sp_configure. '  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M27'  ,''  ,'http://bit.ly/b0FKxx',7  ,8  ,'Paging detected' ,'Your Server is currently paging at $(PagesPerSec) pages per second ' ,'This is putting a strain on both the processor and I/O subsystems and significantly slowing response times.  ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Tips for Using Performance Monitor Memory Counters</Title><Link>http://www.sql-server-performance.com/tips/performance_monitor_memory_counter_p1.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that physical page faults be kept to a minimum. Paging occurs when there is not enough RAM available to perform a process in memory or when SQL Server needs to shrink one section of cache in order to expand a different section of cache or to release memory to the operating system. This issue can be addressed by ensuring that the Max Server Memory setting is set appropriately for the server and ensuring that the SQL Server agent service account has the Lock Pages in Memory privilege set. It may also be addressed by tuning queries that use large amount of memory. For paging from processes other than SQL Server, the lack of memory may be a result of SQL Server not leaving sufficient memory free. In this case, the Max Server Memory setting may need to be lowered to a setting that would allow additional memory to be left free for the Operating System and other non-SQL Server processes to use. The list below contains the 10 processes which are currently consuming the greatest amount of total memory on your Server: $(Processes).'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M29'  ,''  ,'http://bit.ly/aD6kth',7  ,10  ,'SQL Server memory limit reached' ,'The SQL Server memory limit has been exceeded while generating an execution plan ' ,'The creation of an execution plan caused the SQL Server memory limit to be exceeded.  The execution plan generated is still correct, but it may not be optimal. ' ,3  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Server Memory Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms178067.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Effects of min and max server memory</Title><Link>http://msdn.microsoft.com/en-us/library/ms180797(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Server Memory Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms178067(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Effects of min and max server memory</Title><Link>http://msdn.microsoft.com/en-us/library/ms180797(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Server Memory Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms178067(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>Effects of min and max server memory</Title><Link>http://msdn.microsoft.com/en-us/library/ms180797(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>How to adjust memory usage by using configuration options in SQL Server</Title><Link>http://support.microsoft.com/kb/321363</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that you try one of the following methods to increase available memory: $(br)1. Reduce the load on the server  $(br)2. Increase memory available to SQL Server  $(br)3. Check the max server memory option that is set with sp_configure and increase the value if it is too low'  ,1,''
,0)
--INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
--('SDR-M3'  ,'$(li)There may be a specific requirement for the server to have one or more of these configuration options set.  This could be the requirement of third-party applications or the result of extensive performance tuning relating specifically to memory allocation and management.'  ,'http://bit.ly/a9WU82 ',7  ,10  ,'Memory Configuration Not Optimized: 4-16GB RAM' ,'Memory configuration settings are not set for best performance of a 32-bit SQL Server with greater than 4GB and less than 16GB of RAM ' ,'Memory options for Physical Address Extension, 3GB, USERVA, and Address Windowing Extensions are not configured correctly for optimal performance of a 32-bit SQL Server with greater than 4GB and less than 16GB of RAM. ' ,3  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Physical Address Extension</Title><Link>http://msdn.microsoft.com/en-us/library/aa366796(VS.85).aspx</Link></RecommendationLink><RecommendationLink><Title>Using AWE</Title><Link>http://msdn.microsoft.com/en-us/library/ms175581.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Using AWE</Title><Link>http://msdn.microsoft.com/en-us/library/ms175581(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Using AWE</Title><Link>http://msdn.microsoft.com/en-us/library/ms175581(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>How to Enable the Lock Pages in Memory Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms190730(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>How to Enable the Lock Pages in Memory Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms190730(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>How to Enable the Lock Pages in Memory Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms190730(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>Be Aware Using AWE locked pages in memory, on 64-bit</Title><Link>http://blogs.msdn.com/b/slavao/archive/2005/04/29/413425.aspx</Link><Condition>SQL64Bit = True</Condition></RecommendationLink><RecommendationLink><Title>Boot Configuration Data Editor Frequently Asked Questions</Title><Link>http://technet.microsoft.com/en-us/library/cc721886(WS.10).aspx</Link><Condition>OSVersionMajor = 6</Condition></RecommendationLink><RecommendationLink><Title>Who Moved My /3GB?</Title><Link>http://blogs.technet.com/b/askperf/archive/2009/04/03/who-moved-my-3gb.aspx</Link><Condition>OSVersionMajor = 6</Condition></RecommendationLink><RecommendationLink><Title>BCD Boot Options Reference</Title><Link>http://msdn.microsoft.com/en-us/library/ff542205(VS.85).aspx </Link><Condition>OSVersionMajor = 6</Condition></RecommendationLink><RecommendationLink><Title>How to edit the Boot.ini file in Windows Server 2003</Title><Link>http://support.microsoft.com/kb/323427</Link><Condition>OSVersion = 5.2</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,'$(li)Physical Address Extension (PAE) is a feature of the processor that allows access to more than 4GB of physical memory.  Without this enabled, the additional physical memory cannot be accessed on a 32-bit system. $(li)The /3GB switch will allot 3GB of virtual address space to user mode processes and 1GB of virtual address space to the operating system.  When you limit the operating system to only 1GB, you limit the amount of physical memory that can be managed by the operating system to only 16GB.  Because this server has between 4GB and 16GB of physical memory, the /3GB switch should be set to limit the operating system to only 1GB.$(li)Address Windowing
--However, extra steps should be taken to verify the current configuration is not required.  The recommended configuration is very specific to a 32-bit SQL Server with greater than 4GB and less than 16GB of physical memory.  If the amount of physical memory has been changed on the system, these settings must be verified again to ensure optimum performance of both the operating system and applications.'  ,1,''
--,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
(
'SDR-M3'  
,'$(li)There may be a specific requirement for the server to have one or more of these configuration options set.  This could be the requirement of third-party applications or the result of extensive performance tuning relating specifically to memory allocation and management.'  
,'http://bit.ly/a9WU82 '
,7 
,'10'  
,'Memory Configuration Not Optimized: 4-16GB RAM' 
,'Memory configuration settings are not set for best performance of a 32-bit SQL Server with greater than 4GB and less than 16GB of RAM ' 
,'Memory options for ''Physical Address Extension,'' ''3GB,'' ''USERVA,'' and ''Address Windowing Extensions'' are not configured correctly for optimal performance of a 32-bit SQL Server with greater than 4GB and less than 16GB of RAM. ' 
,'3'  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Physical Address Extension</Title>
<Link>http://msdn.microsoft.com/en-us/library/aa366796(VS.85).aspx</Link></RecommendationLink><RecommendationLink>
<Title>Using AWE</Title><Link>http://msdn.microsoft.com/en-us/library/ms175581.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink>
<RecommendationLink><Title>Using AWE</Title><Link>http://msdn.microsoft.com/en-us/library/ms175581(v=SQL.100).aspx</Link>
<Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink>
<RecommendationLink><Title>Using AWE</Title><Link>http://msdn.microsoft.com/en-us/library/ms175581(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink>
<RecommendationLink><Title>How to Enable the Lock Pages in Memory Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms190730(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink>
<RecommendationLink><Title>How to Enable the Lock Pages in Memory Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms190730(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>How to Enable the Lock Pages in Memory Option</Title>
<Link>http://msdn.microsoft.com/en-us/library/ms190730(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>Be Aware Using AWE locked pages in memory, on 64-bit</Title><Link>http://blogs.msdn.com/b/slavao/archive/2005/04/29/413425.aspx</Link><Condition>SQL64Bit = True</Condition></RecommendationLink>
<RecommendationLink><Title>Boot Configuration Data Editor Frequently Asked Questions</Title><Link>http://technet.microsoft.com/en-us/library/cc721886(WS.10).aspx</Link><Condition>OSVersionMajor = 6</Condition></RecommendationLink><RecommendationLink><Title>Who Moved My /3GB?</Title><Link>http://blogs.technet.com/b/askperf/archive/2009/04/03/who-moved-my-3gb.aspx</Link><Condition>OSVersionMajor = 6</Condition></RecommendationLink>
<RecommendationLink><Title>BCD Boot Options Reference</Title><Link>http://msdn.microsoft.com/en-us/library/ff542205(VS.85).aspx </Link><Condition>OSVersionMajor = 6</Condition></RecommendationLink><RecommendationLink><Title>How to edit the Boot.ini file in Windows Server 2003</Title><Link>http://support.microsoft.com/kb/323427</Link><Condition>OSVersion = 5.2</Condition></RecommendationLink></ArrayOfRecommendationLink>'  
,''  
,''  
,''
,'$(li)Physical Address Extension (PAE) is a feature of the processor that allows access to more than 4GB of physical memory.  Without this enabled, the additional physical memory cannot be accessed on a 32-bit system. $(li)The /3GB switch will allot 3GB of virtual address space to user mode processes and 1GB of virtual address space to the operating system.  When you limit the operating system to only 1GB, you limit the amount of physical memory that can be managed by the operating system to only 16GB. 
Because this server has between 4GB and 16GB of physical memory, the /3GB switch should be set to limit the operating system to only 1GB.$(li)Address Windowing Extensions (AWE) on a 32-bit SQL Server will allow for SQL Server to access physical memory greater than 4GB.  
Because this server has more than 4GB of memory, AWE will allow the 32-bit SQL Server process to access to this memory. 
$(li)The ''Lock Pages in Memory'' user right must be assigned to the user account that the SQL Server process is executed under.  
This right is assigned by default to the ''Local System'' account.  Without the ''Lock Pages in Memory'' user right, 
AWE cannot be used by the SQL Server process.'  
,'It is recommended you implement all of the following recommendations on 32-bit SQL Servers that have greater than 4GB and less than 16GB of RAM: 
$(li)Enable Physical Address Extensions (/PAE) in the startup configuration $(li)Enable /3GB in the startup configuration $(li)Enable Address Windowing Extensions (AWE) in the SQL Server configuration $(li)Enable the SQL Server advanced user right lock pages in memory'
,1
,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M4'  ,'$(li)There may be a specific requirement for the server to have one or more of these configuration options set.  This could be the requirement of third-party applications or the result of extensive performance tuning relating specifically to memory allocation and management.'  ,'http://bit.ly/9igrOB ',7  ,'10'  ,'Memory Configuration Not Optimized: 4GB RAM' ,'Memory configuration settings are not set for best performance for a 32-bit SQL Server with 4GB of RAM ' ,'Memory options for ''Physical Address Extension,'' ''3GB,'' ''USERVA,'' and ''Address Windowing Extensions'' are not configured correctly for optimal performance of a 32-bit SQL Server with 4GB of RAM. ' ,'3'  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Physical Address Extension</Title><Link>http://msdn.microsoft.com/en-us/library/aa366796(VS.85).aspx</Link></RecommendationLink><RecommendationLink><Title>Using AWE</Title><Link>http://msdn.microsoft.com/en-us/library/ms175581.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Using AWE</Title><Link>http://msdn.microsoft.com/en-us/library/ms175581(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Using AWE</Title><Link>http://msdn.microsoft.com/en-us/library/ms175581(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>How to Enable the Lock Pages in Memory Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms190730(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>How to Enable the Lock Pages in Memory Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms190730(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>How to Enable the Lock Pages in Memory Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms190730(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>Be Aware Using AWE locked pages in memory, on 64-bit</Title><Link>http://blogs.msdn.com/b/slavao/archive/2005/04/29/413425.aspx</Link><Condition>SQL64Bit = True</Condition></RecommendationLink><RecommendationLink><Title>Boot Configuration Data Editor Frequently Asked Questions</Title><Link>http://technet.microsoft.com/en-us/library/cc721886(WS.10).aspx</Link><Condition>OSVersionMajor = 6</Condition></RecommendationLink><RecommendationLink><Title>Who Moved My /3GB?</Title><Link>http://blogs.technet.com/b/askperf/archive/2009/04/03/who-moved-my-3gb.aspx</Link><Condition>OSVersionMajor = 6</Condition></RecommendationLink><RecommendationLink><Title>BCD Boot Options Reference</Title><Link>http://msdn.microsoft.com/en-us/library/ff542205(VS.85).aspx </Link><Condition>OSVersionMajor = 6</Condition></RecommendationLink><RecommendationLink><Title>How to edit the Boot.ini file in Windows Server 2003</Title><Link>http://support.microsoft.com/kb/323427</Link><Condition>OSVersion = 5.2</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,'$(li)Physical Address Extension (PAE) is a feature of the processor that allows access to more than 4GB of physical memory.  This feature will not help the performance of SQL Server when the system has 4GB or less of physical memory. 
$(li)The /3GB switch will allot 3GB of virtual address space to user mode processes and 1GB of virtual address space to the operating system.  When you limit the operating system to only 1GB, you limit the amount of physical memory that can be managed by the operating system to only 16GB.  Because this server has 4GB of physical memory, the /3GB switch should be set to limit the operating system to only 1GB and allow 3GB for user mode processes.$(li)Address Windowing Extensions (AWE) on a 32-bit SQL Server will allow for SQL Server to access physical memory greater than 4GB.  Because this server has 4GB of memory, AWE is not needed.'  ,'It is recommended you implement all of the following recommendations on 32-bit SQL Servers that have 4GB of RAM: 
$(li)Disable Physical Address Extensions (/PAE) in the startup configuration $(li)Enable /3GB in the startup configuration $(li)Disable Address Windowing Extensions (AWE) in the SQL Server configuration

However, extra steps should be taken to verify the current configuration is not required.  The recommended configuration is very specific to a 32-bit SQL Server with 4GB of physical memory.  If the amount of physical memory has been changed on the system, these settings must be verified again to ensure optimum performance of both the operating system and applications.'  ,1,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M5'  ,'$(li)There may be a specific requirement for the server to have one or more of these configuration options set.  This could be the requirement of third-party applications or the result of extensive performance tuning relating specifically to memory allocation and management.'  ,
'http://bit.ly/aOT72F ',7  ,
'6'  ,
'Memory Configuration Not Optimized: 3-4GB RAM' ,
'Memory configuration settings are not set for best performance of a 32-bit SQL Server with greater than 3GB and less than 4GB of RAM ' ,
'Memory options for ''Physical Address Extension,'' ''3GB,'' and ''Address Windowing Extensions'' are not configured correctly for optimal performance of a 32-bit SQL Server with greater than 3GB and less than 4GB of RAM. ' ,
'3'  ,
'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Physical Address Extension</Title><Link>http://msdn.microsoft.com/en-us/library/aa366796(VS.85).aspx</Link></RecommendationLink><RecommendationLink><Title>Using AWE</Title><Link>http://msdn.microsoft.com/en-us/library/ms175581.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Using AWE</Title><Link>http://msdn.microsoft.com/en-us/library/ms175581(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Using AWE</Title><Link>http://msdn.microsoft.com/en-us/library/ms175581(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>How to Enable the Lock Pages in Memory Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms190730(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>How to Enable the Lock Pages in Memory Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms190730(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>How to Enable the Lock Pages in Memory Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms190730(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>Be Aware Using AWE locked pages in memory, on 64-bit</Title><Link>http://blogs.msdn.com/b/slavao/archive/2005/04/29/413425.aspx</Link><Condition>SQL64Bit = True</Condition></RecommendationLink><RecommendationLink><Title>Boot Configuration Data Editor Frequently Asked Questions</Title><Link>http://technet.microsoft.com/en-us/library/cc721886(WS.10).aspx</Link><Condition>OSVersionMajor = 6</Condition></RecommendationLink><RecommendationLink><Title>Who Moved My /3GB?</Title><Link>http://blogs.technet.com/b/askperf/archive/2009/04/03/who-moved-my-3gb.aspx</Link><Condition>OSVersionMajor = 6</Condition></RecommendationLink><RecommendationLink><Title>BCD Boot Options Reference</Title><Link>http://msdn.microsoft.com/en-us/library/ff542205(VS.85).aspx </Link><Condition>OSVersionMajor = 6</Condition></RecommendationLink><RecommendationLink><Title>How to edit the Boot.ini file in Windows Server 2003</Title><Link>http://support.microsoft.com/kb/323427</Link><Condition>OSVersion = 5.2</Condition></RecommendationLink></ArrayOfRecommendationLink>'  
,''  ,''  ,''  ,
'$(li)Physical Address Extension (PAE) is a feature of the processor that allows access to more than 4GB of physical memory.  This feature will not help the performance of SQL Server when the system has less than 4GB of physical memory. $(li)The /3GB switch will allot 3GB of virtual address space to user mode processes and 1GB of virtual address space to the operating system.  When you limit the operating system to only 1GB, you limit the amount of physical memory that can be managed by the operating system to only 16GB.  Because this server has enough physical memory, the /3GB switch should be set to limit the operating system to only 1GB and allow 3GB for user mode processes. $(li)The /USERVA switch will allow for a more precise tuning of user and kernel virtual memory space.  This switch in combination with the /3GB switch will allow for fine tuning the user mode space to a value between 2GB and 3GB.  Because this server has between 3GB and 4GB of physical memory, precise tuning of the space available to user mode processes should be considered.$(li)Address Windowing Extensions (AWE) on a 32-bit SQL Server will allow for SQL Server to access physical memory greater than 4GB.  Because this server has less than 4GB of memory, AWE is not needed.'  
,'It is recommended you implement all of the following recommendations on 32-bit SQL Servers that have greater than 3GB and less than 4GB of RAM: 
$(li)Disable Physical Address Extensions (/PAE) in the startup configuration $(li)Enable /3GB in the startup configuration $(li)Disable Address Windowing Extensions (AWE) in the SQL Server configuration
However, extra steps should be taken to verify the current configuration is not required.  The recommended configuration is very specific to a 32-bit SQL Server with greater than 3GB and less than 4GB of physical memory.  If the amount of physical memory has been changed on the system, these settings must be verified again to ensure optimum performance of both the operating system and applications.'  ,1,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M6'  ,
'$(li)There may be a specific requirement for the server to have one or more of these configuration options set.  This could be the requirement of third-party applications or the result of extensive performance tuning relating specifically to memory allocation and management.'  ,
'http://bit.ly/c41jzI ',7  ,'10'  ,
'Memory Configuration Not Optimized: <3GB RAM' ,
'Memory configuration settings are not set for best performance of a 32-bit SQL Server with 3GB or less RAM ' ,
'Memory options for ''Physical Address Extension,'' ''3GB,'' ''USERVA,'' and ''Address Windowing Extensions'' are not configured correctly for optimal performance of a 32-bit SQL Server with 3GB or less of RAM. ' 
,'3'
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Physical Address Extension</Title><Link>http://msdn.microsoft.com/en-us/library/aa366796(VS.85).aspx</Link></RecommendationLink><RecommendationLink><Title>Using AWE</Title><Link>http://msdn.microsoft.com/en-us/library/ms175581.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Using AWE</Title><Link>http://msdn.microsoft.com/en-us/library/ms175581(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Using AWE</Title><Link>http://msdn.microsoft.com/en-us/library/ms175581(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>How to Enable the Lock Pages in Memory Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms190730(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>How to Enable the Lock Pages in Memory Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms190730(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>How to Enable the Lock Pages in Memory Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms190730(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>Be Aware Using AWE locked pages in memory, on 64-bit</Title><Link>http://blogs.msdn.com/b/slavao/archive/2005/04/29/413425.aspx</Link><Condition>SQL64Bit = True</Condition></RecommendationLink><RecommendationLink><Title>Boot Configuration Data Editor Frequently Asked Questions</Title><Link>http://technet.microsoft.com/en-us/library/cc721886(WS.10).aspx</Link><Condition>OSVersionMajor = 6</Condition></RecommendationLink><RecommendationLink><Title>Who Moved My /3GB?</Title><Link>http://blogs.technet.com/b/askperf/archive/2009/04/03/who-moved-my-3gb.aspx</Link><Condition>OSVersionMajor = 6</Condition></RecommendationLink><RecommendationLink><Title>BCD Boot Options Reference</Title><Link>http://msdn.microsoft.com/en-us/library/ff542205(VS.85).aspx </Link><Condition>OSVersionMajor = 6</Condition></RecommendationLink><RecommendationLink><Title>How to edit the Boot.ini file in Windows Server 2003</Title><Link>http://support.microsoft.com/kb/323427</Link><Condition>OSVersion = 5.2</Condition></RecommendationLink></ArrayOfRecommendationLink>'  
,''  ,''  ,''  
,'$(li)Physical Address Extension (PAE) is a feature of the processor that allows access to more than 4GB of physical memory.  This feature will not help the performance of SQL Server when the system has 3GB or less of physical memory. $(li)The /3GB switch will allot 3GB of virtual address space to user mode processes and 1GB of virtual address space to the operating system.  Because there is not enough physical memory available to account for larger user mode and allotted operating system address space, the SQL Server process performance could be hindered by excessive memory paging to when supporting the additional memory requirements. $(li)The /USERVA switch will allow for a more precise tuning of user and kernel virtual memory space.  This switch in combination with the /3GB switch will allow for fine tuning the user mode space to a value between 2GB and 3GB.  Because there is not enough physical memory available to account for larger user mode and allotted operating system address space, the SQL Server process performance could be hindered by excessive memory paging to when supporting the additional memory requirements.$(li)Address Windowing Extensions (AWE) on a 32-bit SQL Server will allow for SQL Server to access physical memory greater than 4GB.  Because this server has 3GB or less of memory, AWE is not needed.'  ,'It is recommended that the following settings be used on 32-bit SQL Servers with 3GB or less RAM: 
$(li)Disable Physical Address Extensions (/PAE), /3GB, and /USERVA in the startup configuration $(li)Disable Address Windowing Extensions (AWE) in the SQL Server configuration

However, extra steps should be taken to verify the current configuration is not required.  There are configurations which make use of SQLCLR, Extended Stored Procedures, OLE Automation, linked servers, or other heavy MemToLeave users where it may be necessary to use the /3GB switch in conjunction with the -g startup parameter to the SQL Server process.  

This recommendation is very specific to a 32-bit SQL Server with 3GB or less of physical memory.  If the amount of physical memory has been changed on the system, these settings must be verified again to ensure optimum performance of both the operating system and applications.',1,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M7'  ,''  ,'http://bit.ly/9qGa6O ',7  ,9  ,'Memory contention' ,'The SQL Server instance is experiencing memory stress ' ,'The SQL Server instance is experiencing at least some memory stress that could be relieved due to one or more of the following conditions:
$(li)1. Page Life Expectancy of less than 5 minutes.
$(li)2. Buffer Cache Hit Ratio of less than 95%
$(li)3. Memory Grants Pending has remained about 10 on average over a 5 minute period. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Server Memory Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms178067.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Server Memory Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms178067(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Server Memory Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms178067(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>Effects of min and max server memory</Title><Link>http://msdn.microsoft.com/en-us/library/ms180797.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Effects of min and max server memory</Title><Link>http://msdn.microsoft.com/en-us/library/ms180797(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Effects of min and max server memory</Title><Link>http://msdn.microsoft.com/en-us/library/ms180797(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>How to adjust memory usage by using configuration options in SQL Server</Title><Link>http://support.microsoft.com/kb/321363</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that the Max Server Memory option in SQL Server which is currently set to $(MaxServerMemory) be set to $(SuggestedMaxServerMemory). After setting Max Server Memory to an appropriate level, it is recommended that you ensure the Lock Pages in Memory privilege is granted to the SQL Server service account to prevent SQL Server from responding to memory requests from the Operating System.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M30'  ,''  ,'',7  ,10  ,'Available memory not used' ,'This version of SQL Server will not use all of the available memory  ' ,'The system has $(ServerMemory)gigs of memory available which cannot be accessed by the 32-bit version of SQL Server.  To access more than 4gigs of RAM, 32-bit Address Windowing Extensions (AWE) must be used which is no longer supported in SQL Server as of SQL Server 2012. ' ,3  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Discontinued Database Engine Functionality in SQL Server 2012</Title><Link>http://msdn.microsoft.com/en-us/library/ms144262(SQL.110).aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that a 64-bit Operating System and hardware be used to allow access to more memory.'  ,1,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M8'  ,'$(li)If the performance implications of the ''Min Server Memory'' setting are understood and acceptable for the SQL Server instance.'  ,'http://bit.ly/9rZPq1',7  ,9  ,'System paging' ,'The system is paging excessively ' ,'Your system is paging at a rate of $(PagesPerSec) pages per second and the SQL Server instance is configured with a high ''Min Server Memory'' setting. ' ,2 ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Server Memory Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms178067.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Server Memory Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms178067(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Server Memory Options</Title><Link>http://msdn.microsoft.com/en-us/library/ms178067(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>Effects of min and max server memory</Title><Link>http://msdn.microsoft.com/en-us/library/ms180797.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Effects of min and max server memory</Title><Link>http://msdn.microsoft.com/en-us/library/ms180797(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Effects of min and max server memory</Title><Link>http://msdn.microsoft.com/en-us/library/ms180797(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>How to adjust memory usage by using configuration options in SQL Server</Title><Link>http://support.microsoft.com/kb/321363</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>How to reduce paging of buffer pool memory in the 64-bit version of SQL Server</Title><Link>http://support.microsoft.com/kb/918483</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5 AND SQL64Bit = True</Condition></RecommendationLink><RecommendationLink><Title>How to reduce paging of buffer pool memory in the 64-bit version of SQL Server</Title><Link>http://support.microsoft.com/kb/918483</Link><Condition>SQLVersionMajor = 9 AND SQL64Bit = True</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,'$(li)SQL Server will not release memory if it will be less than the ''Min Server Memory'' setting.  This can cause additional memory pressure on the server and require the operating system to page out SQL Server memory.$(li)If ''Lock pages in memory'' is used by SQL Server, a high ''Min Server Memory'' setting can starve the operating system of physical memory by preventing the operating system from paging out the memory allocated to SQL Server.'  ,'You should consider setting the ''Min Server Memory'' configuration value to zero.  This will provide SQL Server with the needed flexibility to properly manage the memory requirements of the SQL Server instance.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-N1'  ,''  ,'http://bit.ly/8ZLb0k',8  ,10  ,'Failed network card' ,'One or more network cards have stopped working ' ,'In a previous analysis $(PreviousCards) network cards were detected with a total bandwidth of $(PreviousBandwidthMB) MB/s. In the current analysis $(Cards) network cards with a total bandwidth of $(BandwidthMB) MB/s were found (representing a $(BandwidthLost)% reduction in capacity). ' ,'2'  ,''  ,''  ,''  ,''  ,''  ,'It is recommended that the Network cards be examined to determine which are having problems. Either a network card has stopped working or been unplugged either on the card or network switch or the network cable/fiber is faulty or another server is being used or a failover has occurred on a cluster to a server with lesser network capability.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-N2'  ,''  ,'http://bit.ly/9zFqUa',8  ,8  ,'Reduced network bandwidth' ,'The server has lost network bandwidth ' ,'In a previous analysis, the total active bandwidth was $(PreviousBandwidthMB) MB/s and it is now $(BandwidthMB) MB/s representing a $(BandwidthLost)% reduction. ' ,'2'  ,''  ,''  ,''  ,''  ,''  ,'It is recommended that you check the following:  $(br)1. Have you exchanged your network card recently with a lower bandwidth card? $(br)2. Has a network driver BIOS change been made? $(br)3. Has the "teaming" between network cards changed?  $(br)4. Are there hardware/cable/fiber errors preventing a card from operating at full potential? $(br)5. Has a failover occurred on a cluster to a server with a less capable card?'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-N6'  ,''  ,'http://bit.ly/9Eleuj ',8  ,10  ,'Network SSL Encryption high impact' ,'Network encryption has been turned on by default ' ,'There are high security environments where network encryption is required.  It is important to note that encryption and decryption of network transmission streams places additional CPU load on the server as well as double the number of network transmissions during each connection made. ' ,'1'  ,''  ,''  ,''  ,''  ,''  ,'It is recommended that, if the network transmission encryption is not necessary,  network encryption be disabled.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-N3'  ,''  ,'http://bit.ly/90sWu3',8  ,4  ,'Non-SQL Server network load' ,'Significant non-SQL Server network load ' ,'SQL Server is generating only $(SqlNetworkLoad)% of the network load on your production server while $(NonSqlNetworkLoad)% is being generated by non-SQL Server processes and your network is under stress. ' ,2 ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Operating System Performance Optimization</Title><Link>http://www.sql-server-performance.com/articles/audit/operating_system_performance_p1.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that non-essential applications be stopped on production servers.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-N4'  ,''  ,'http://bit.ly/cP2PpO',8  ,5  ,'TCP segments being retransmitted' ,'High number of TCP segments are being retransmitted ' ,'The number of TCP segments being retransmitted is $(SegmentsRetransmittedPerSec).  This represents $(SegmentsRetransmittedPercent)% of the total.  TCP segments are typically retransmitted either due to the lack of timely acknowledgement or when segments are being acknowledged out of sequence. A high level of retransmissions will significantly slow SQL Server. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>TCP Retransmission Behavior</Title><Link>http://msdn.microsoft.com/en-us/library/ms819737.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that you check the following for the following problems: 1. Either the network card in the server or the network switch is highly congested. 2. There is a cabling problem between the network card and switch. 3. There are intermittent hardware faults in the NIC or switch. 4. There is a firmware problem. 5. There is an issue with the firewall.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-N5'  ,''  ,'http://bit.ly/cmY6ba',8  ,10  ,'Network errors' ,'The network redirector is experiencing $(Errors) errors ' ,'Such network redirect errors generally indicate that the redirector and one or more servers are having serious communication difficulties. For example, a Server Message Block protocol error generates a network error.  ' ,3 ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Redirector Object</Title><Link>http://technet.microsoft.com/en-us/library/cc783876(WS.10).aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that the errors which are written to the system event log should be closely scrutinized as the log entries will give further details.'  ,1,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-N7'  ,'$(li)Some third-party applications require the rows affected message and will experience unexpected results or errors when these messages are not returned.'  ,'http://bit.ly/cyNu82 ',8  ,10  ,'SET NOCOUNT ON Not Being Used' ,'The SET NOCOUNT ON connection option is not being used ' ,'The default ''nocount on'' option is not being used and a sample of the text of the T-SQL being executed by SQL Server shows that in most cases the SET NOCOUNT ON statement is not being included. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Server Properties (Connections Page)</Title><Link>http://msdn.microsoft.com/en-us/library/ms180124.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>SET NOCOUNT (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms189837.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Server Properties (Connections Page)</Title><Link>http://msdn.microsoft.com/en-us/library/ms180124(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>SET NOCOUNT (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms189837(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Server Properties (Connections Page)</Title><Link>http://msdn.microsoft.com/en-us/library/ms180124(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>SET NOCOUNT (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms189837(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,'$(li)This causes additional network traffic as packets containing the number of rows affected are being transmitted back to the clients for many of the T-SQL statements being executed.'  ,'It is recommended that you change SET NOCOUNT to ON for the default network setting on your SQL Server instance. Alternatively, you can modify T-SQL batches, stored procedures, etc. to include the option SET NOCOUNT ON which will only affect that one batch. This will reduce network traffic for connections executing that batch without affecting all connections coming into the SQL Server.

However, some ActiveX Data Objects (ADO) functions rely on row count information and may return unexpected results or errors when SET NOCOUNT is ON. If applications in your environment use ADO to communicate with SQL Server, they may be negatively impacted by this setting.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-N8'  ,''  ,'http://bit.ly/bZzOem ',8  ,8  ,'Multiple network cards recommended' ,'Multiple active cards are not being used in either a teamed or un-teamed mode ' ,'It is a suggested best practice that for mission critical servers either 2 redundant network cards are used on the server or 2 network cards are "teamed" to provide both network redundancy and increased performance (via load balancing). ' ,1 ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Network interface card (NIC) teaming is enabled</Title><Link>http://msdn.microsoft.com/en-us/library/bb219040(technet.10).aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that one or more additional network cards should be added for both redundancy and performance.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-N9'  ,''  ,'http://bit.ly/asUP0Z ',8  ,4  ,'Network card errors' ,'Network errors detected ' ,'The network card $(Name) has given $(Errors) errors within the analysis period. ' ,'1'  ,''  ,''  ,''  ,''  ,''  ,'It is recommended that you check the following: $(br)1. The network card in the server or the network switch/hub is highly congested.  $(br)2. The cabling between the network card and the switch/hub is faulty/sub-standard.  $(br)3. The network card or switch/hub is giving intermittent hardware faults.  $(br)4. The firmware installed on either the network card and/or the switch/hub has bugs.  $(br)5. A problem or bug in the firewall hardware or software.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-OT1'  ,''  ,'http://bit.ly/dzmSXJ' ,9  ,10  ,'Long running open transaction' ,'Process $(SPID) has an open transaction for $(DurationMinutes) minutes ' ,'Long running transactions prevent transaction logs from being offloaded or truncated and can result in uncontrolled growth of the transaction log file as only the committed portion of the transaction log can be offloaded/truncated.
Details are:
$(ApplicationName?on $(ApplicationName): ) $(Database?in [$(Database)]: ) $(HostName?submitted from $(HostName): ) $(UserName?by $(UserName): )  ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>DBCC OPENTRAN (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms182792.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>DBCC OPENTRAN (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms182792(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>DBCC OPENTRAN (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms182792(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) Processes have long-running open transactions'  ,'Long running transactions prevent transaction logs from being offloaded or truncated and can result in uncontrolled growth of the transaction log file as only the committed portion of the transaction log can be offloaded/truncated.'  ,''  ,''  ,'It is recommended that you examine the T-SQL running via the open transaction to determine if its runtime could be reduced.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-P1'  ,'$(li)The CPU cores are intentionally limited to allow other SQL Server instances or applications to utilize the CPU cores not available to this SQL Server instance.'  ,'http://bit.ly/cjQauo',10  ,10  ,'Affinity mask set' ,'The affinity mask setting is limiting the available CPU cores ' ,'Only $(AllowedToUseCpuCount) out of $(TotalCpuCount) CPU cores can be used by the SQL Server instance. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>affinity mask Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms187104(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>affinity mask Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms187104(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>affinity mask Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms187104(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,'$(li)Limiting the number of CPU cores available to SQL Server will limit the number of ONLINE Schedulers that are available to process requests.  This will limit the number of requests that can be concurrently processed and therefore increases the amount of work for each of the CPU cores available to SQL Server. '  ,'The affinity mask setting should be reviewed to ensure the correct number of CPU cores is available for this SQL Server instance.  Because the CPU was under stress, you should consider increasing the number of CPU cores for this SQL Server instance to improve overall performance.

However, before making any changes you should understand the exact reason why the affinity mask was set for this SQL Server instance.  This is an advanced configuration setting that should be changed only when all application requirements and hardware configurations for this server have been taken into account.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-P10'  ,''  ,'http://bit.ly/9P2pta',10  ,10  ,'Multiple SQL Server instances' ,'More than one SQL Server instance has been detected on your production server  ' ,'A production server consuming significant CPU resources should not share its CPU and memory resources with other SQL Server instances. This practice leads to highly variable response times. There are currently $(Count) SQL Server instances running on your server.  ' ,3  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>SQL Server Consolidation Guidance</Title><Link>http://msdn.microsoft.com/en-us/library/ee819082.aspx</Link><Condition>SQLVersionMajor = 10</Condition></RecommendationLink><RecommendationLink><Title>SQL Server Best Practices Article</Title><Link>http://msdn.microsoft.com/en-us/library/cc966485.aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that production servers consuming significant CPU and/or memory resources should not share CPU and memory resources with any other SQL Server instances. This practice leads to highly variable response times. $(br)If you do need to run a number of other instances on a production server, then either CPU affinity should be used to guarantee CPU exclusivity for production instances or the priority of those other instances should be set to "below-normal" (or at least below the priority of  the production SQL Server instance) in order to make sure that they have as little impact on the production instance as possible. In addition, it is recommended that in cases where secondary SQL Server instances must be used that you configure the Max Memory for the secondary instances to prevent them from consuming more memory than necessary.

Additionally, it is recommended that the database files of multiple instances be segregated to different physical drives to prevent one instance from overwhelming the I/O capabilities of the drives used by databases on another instance.'  ,1,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-P9'  ,''  ,'http://bit.ly/cvcIqD ',10  ,NULL  ,'' ,'Xxx of your tables have the primary key encrypted ' ,'This is an inefficient method of encryption when secondary indexes exist on those same tables. Secondary indexes point to the primary key (if present) on a table and therefore encrypting the primary key makes these indexes (and the primary key itself) far less efficient during joins and other operations.  ' ,''  ,''  ,'SKIPPED'  ,'SKIPPED'  ,'SKIPPED'  ,''  ,'It is recommended that the primary key on tables with secondary indexes not be encrypted. If data has been properly normalized the key is typically not something secret enough to have to be encrypted. Only the columns that contain vital information should be encrypted.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-P22'  ,''  ,'http://bit.ly/9w2K6G ',10  ,NULL  ,'' ,'The Screen Saver is enabled ' ,'The screen saver can unnecessarily use resources that should be kept available for SQL Server. ' ,''  ,''  ,'SKIPPED'  ,'SKIPPED'  ,'SKIPPED'  ,''  ,'It is recommended that the Screen Saver be set to (none) or blank on a production server to improve performance.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-P11'  ,''  ,'http://bit.ly/9qoqcb',10  ,8  ,'CPU Lightweight Pooling' ,'The system is experiencing $(ContextSwitches) context switches per second ' ,'The system is in privileged mode $(PrivilegedTime)% of the time and cannot execute user threads. SQL Server uses these user threads to respond to T-SQL requests. SQL Server is currently running $(ThreadCount) threads which in turn causes many context switches to occur. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>lightweight pooling Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms178074(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>lightweight pooling Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms178074(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>lightweight pooling Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms178074(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that SQL Server instances that operate with a large number of threads be switched to use lightweight fiber mode scheduling which eliminates context switches and reduces the time the system spends in privileged mode. It is important to note that certain components like SQLMXL, SQLMail, SQLCLR and even SQL doctor may not work or may work erratically.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-P12'  ,''  ,'http://bit.ly/8Z5Mu1',10  ,10  ,'CPU Encryption Connections' ,'Network encryption is being used for $(EncryptedConnections) $(EncryptedConnections>1?connections:connection) ' ,'There are high security environments where network encryption is required.  It is important to note that encryption and decryption of network transmission streams places additional CPU load on the server as well as double the number of network transmissions during each connection made. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Network encryption in use</Title><Link>http://technet.microsoft.com/en-us/library/ms189067.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Network encryption in use</Title><Link>http://technet.microsoft.com/en-us/library/ms189067(SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Network encryption in use</Title><Link>http://technet.microsoft.com/en-us/library/ms189067(SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that, if the network transmission encryption is not necessary, it should be disabled.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-P13'  ,''  ,'http://bit.ly/9HMtXI',10  ,4  ,'Network card causing processor interrupts' ,'Your network card appears to be causing a high rate of processor interrupts ' ,'The number of processor interrupts should not be higher than a ratio of 1:4 when compared to the total activity exhibited by the network subsystem, I/O subsystem as well as other device activity (after subtracting the hardware interrupts generated by the system clock). Your server has a ratio of $(DeviceReqPerInterrupt) device requests for each interrupt which is causing your processor(s) to spend $(PercentInterruptTime)% of its time handling interrupts. Modern disk and network controllers give a ratio of 1:4-5 device requests per interrupt using a combination of interrupt modulation and interrupt avoidance. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Analyzing Performance Data</Title><Link>http://technet.microsoft.com/en-us/library/cc784871(WS.10).aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that you upgrade the drivers (and possibly the firmware) of your network cards, disk I/O subsystem and even the server''s mouse (if one is physically attached). If you have recently upgraded drivers and firmware, review the technical bulletins regularly issued by manufactures for possible errors and associated fixes. In certain cases the physical device or PCI card or cabling may be intermittently malfunctioning at the hardware level. This may be reported in the System event log which you should examine. $(Cards.Count>0?:There is a queue forming behind network device $(Cards), which indicates that the device would be the first place to start checking.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-P14'  ,''  ,'http://bit.ly/abo05p',10  ,4  ,'Disk I/O causing processor interrupts' ,'Your disk I/O subsystem appears to be causing a high rate of processor interrupts ' ,'The number of processor interrupts should not be higher than a ratio of 1:4 when compared to the total activity exhibited by the network subsystem, I/O subsystem as well as other device activity (after subtracting the hardware interrupts generated by the system clock). Your server has a ratio of $(DeviceReqPerInterrupt) device requests for each interrupt which is causing your processor(s) to spend $(PercentInterruptTime)% of its time handling interrupts. Modern disk and network controllers give a ratio of 1:4-5 device requests per interrupt using a combination of interrupt modulation and interrupt avoidance. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Analyzing Performance Data</Title><Link>http://technet.microsoft.com/en-us/library/cc784871(WS.10).aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that you upgrade the drivers (and possibly the firmware) of your network cards, disk I/O subsystem and even the server''s mouse (if one is physically attached). If you have recently upgraded drivers and firmware, review the technical bulletins regularly issued by manufactures for possible errors and associated fixes. In certain cases the physical device or PCI card or cabling may be intermittently malfunctioning at the hardware level. This may be reported in the System event log which you should examine. In addition, a queue has been detected forming behind disk device $(Disks). This device could be the cause of the interrupts and should be checked first.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-P15'  ,''  ,'http://bit.ly/9VsomP',10  ,4  ,'Server experiencing processor interrupts' ,'Your server is currently experiencing a high rate of processor interrupts per second ' ,'The number of processor interrupts should not be higher than a ratio of 1:4 when compared to the total activity exhibited by the network subsystem, I/O subsystem as well as other device activity (after subtracting the hardware interrupts generated by the system clock). Your server has a ratio of $(DeviceReqPerInterrupt) device requests for each interrupt which is causing your processor(s) to spend $(PercentInterruptTime)% of its time handling interrupts. Modern disk and network controllers give a ratio of 1:4-5 device requests per interrupt using a combination of interrupt modulation and interrupt avoidance. ' ,2 ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Analyzing Performance Data</Title><Link>http://technet.microsoft.com/en-us/library/cc784871(WS.10).aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that you upgrade the drivers (and possibly the firmware) of your network cards, disk I/O subsystem and even the server''s mouse (if one is physically attached). If you have recently upgraded drivers and firmware, review the technical bulletins regularly issued by manufactures for possible errors and associated fixes. In certain cases the physical device or PCI card or cabling may be intermittently malfunctioning at the hardware level. This may be reported in the System event log which you should examine. In addition, a queue has not been detected forming behind any specific device. All devices should be examined (network, I/O, and mouse).'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-P16'  ,'$(li)If the additional resource usage overhead required by the encryption algorithm is acceptable.$(li)If volume level encryption is required for the volumes hosting the SQL Server data files, log files, or the system page file.'  ,'http://bit.ly/dkubSO',10  ,9  ,'Bitlocker drive encryption detected' ,'Bitlocker drive encryption has been detected on $(DriveLetter) ' ,'Drive $(DriveLetter) is used for SQL Server data files, log files, or the system page file.  ' ,3 ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Bitlocker Versus True Crypt Performance</Title><Link>http://www.ghacks.net/2009/11/26/bitlocker-versus-true-crypt-performance/</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'Bitlocker drive encryption has been detected on $(Count) drives'  ,'The drives are used for SQL Server data files, log files, or the system page file. '  ,'You should consider the performance implications of enabling Bitlocker drive encryption on volumes hosting the SQL Server data files, log files, or the system page file.  

As an alternative, Transparent Data Encryption (TDE) could be used to encrypt all files and filegroups for specific databases.  This will generally provide better performance than using Bitlocker drive encryption.'  ,'$(li)Volume encryption will require additional CPU processing to perform the encryption.  This could have a significant impact on performance when used for heavily accessed drives, such as the drives hosting SQL Server data files, log files, or the server''s page file.'  ,'You should consider the performance implications of enabling Bitlocker drive encryption on volumes hosting the SQL Server data files, log files, or the system page file.  

As an alternative, Transparent Data Encryption (TDE) could be used to encrypt all files and filegroups for specific databases.  This will generally provide better performance than using Bitlocker drive encryption.'  ,1,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-P17'  ,''  ,'http://bit.ly/9JY969',10  ,6  ,'' ,'C2 auditing is enabled on your production server ' ,'C2 auditing on a production server will degrade performance by increasing the workload of processors and the I/O subsystem significantly when writing all successful and failed logging events. ' ,1 ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Basics of C2 Auditing</Title><Link>http://www.sqlservercentral.com/articles/Monitoring/basicsofc2auditing/1547/</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that C2 auditing be disabled and that correct user access permissions be applied to SQL Server and its associated objects. A restart is required for this change to take effect.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-P18'  ,''  ,'http://bit.ly/co89QH',10  ,8  ,'' ,'Your production server is operating within a virtual machine ' ,'Having a SQL Server instance reside within a Virtual Machine can limit performance.  ' ,2 ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Virtual Machine CPU Performance</Title><Link>http://www.hanselman.com/blog/VirtualMachineCPUPerformance.aspx</Link></RecommendationLink><RecommendationLink><Title>SQL Server on VM</Title><Link>http://sqlblog.com/blogs/rick_heiges/archive/2007/02/16/sql-server-on-vm.aspx</Link></RecommendationLink><RecommendationLink><Title>Best Practices and Considerations for Virtualizing Microsoft SQL Server on Vmware</Title><Link>http://matthensley.wordpress.com/2010/05/16/best-practices-and-considerations-for-virtualizing-microsoft-sql-server-on-vmware/</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that to guarantee consistent performance and steady transaction response times, your production server should not reside within a virtual machine. 
$(br)If your production server must reside within a virtual machine:
$(li)Pair critical production servers with far quieter VMs on the same physical hardware.
$(li)Properly designate sufficient resources to the VM that your critical production server resides on and limit the resources of the other VMs that reside on the same physical hardware to prevent VMs of lesser importance from using too many resources to the detriment of your critical server.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-P2'  ,''  ,'http://bit.ly/9vtin8',10  ,10  ,'Number of processors reduced' ,'Your SQL Server is only allowed to use $(AllowedToUseCpuCount) of $(TotalCpuCount) CPU cores ' ,'The last analysis indicated that SQL Server was allowed to use $(PreviousAllowedToUseCpuCount) cores which has now been reduced to $(AllowedToUseCpuCount) cores. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>affinity mask Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms187104.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>affinity mask Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms187104(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>affinity mask Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms187104(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that SQL Server be allowed to use all CPU cores via CPU affinity settings to increase performance when SQL Server requires more CPU power.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-P21'  ,''  ,'http://bit.ly/cwsz5E',10  ,10  ,'Visual effects not optimized' ,'Visual Effects are not adjusted for best performance ' ,'Visual Effects consume CPU cycles, extra memory and network bandwidth as most production servers are accessed using Remote Desktop. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>How to set performance options in Windows XP</Title><Link>http://support.microsoft.com/kb/308417</Link><Condition>OSVersion = 5.1</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that, as most production servers are accessed via Remote Desktop Connect, Visual Effects be adjusted for best Performance.
$(br) Visual Effects consume CPU cycles, extra memory, and network bandwidth. Visual Effects settings are located in the Performance section of the Advanced System Properties dialog.
$(br)In addition, It is recommended that you stop the Themes service and that it be changed to a manually started service. '  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-P3'  ,''  ,'http://bit.ly/brk9tf ',10  ,10  ,'Processing ability reduced' ,'Your server has lost some processing ability since it was last checked ' ,'Previously this server had $(PreviousCpuCount) processors running at a total processing "horsepower" of $(PreviousSpeed) GHz. It currently has $(CurrentCpuCount) processors running at a total processing speed of $(CurrentSpeed) GHz which represents a loss of $(LostPercent).  ' ,'2'  ,''  ,''  ,''  ,''  ,''  ,'It is recommended that, if this is not a known issue, check to see if: 
$(br)1. A CPU has been lost (or disabled via BIOS).
$(br)2. A failover has occurred on a cluster machine.
$(br)3. Your power settings have changed.
If the CPUs are not running at full power, you should ensure that CPU power is not being throttled. Ensure that the power plan is set to High Performance. If CPU power is still throttled, it may need to be set in the server BIOS, or in the integrate Lights Out (iLO) management software connected to the server'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-P4'  ,''  ,'http://bit.ly/9nEt2y ',10  ,9  ,'Power or BIOS settings incorrect' ,'Your BIOS settings or Control Panel Power Settings are not allowing the server''s CPUs to run at full frequency. Additionally, CPU power may be throttled by integrated Lights Out (iLO) management software connected to the server.' ,'During the system analysis the CPUs averaged $(AvgFrequencyPercentString)% of maximum frequency and have never reached 100% of their rated frequency. This causes significant performance impact. ' ,'3'  ,''  ,''  ,''  ,''  ,''  ,'It is recommended that you ensure that CPU power is not being throttled. Ensure that the power plan is set to High Performance. If CPU power is still throttled, it may need to be set in the server BIOS, or in the integrate Lights Out (iLO) management software connected to the server.'  ,1,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-P5'  ,''  ,'http://bit.ly/aQsFIr ',10  ,5  ,'Power or BIOS settings not set to "high performance"' ,'Your BIOS settings or Control Panel Power settings are not set to High Performance' ,'This may affect performance as it takes a finite amount of time to increase the processors frequency when it is needed by increasing voltage to the core. During this state transition the core clock and the phase-locked loop are both stopped and restarted which prevents the core from performing any work during that period. ' ,'1'  ,''  ,''  ,''  ,''  ,''  ,'It is recommended that your Power or BIOS settings be set to High Performance to increase server performance and then recheck the CPU power to ensure it is not still being throttled. If CPU power is still throttled, it may need to be set in the integrate Lights Out (iLO) management software connected to the server.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-P6'  
,'$(li)The server is not a true OLTP server but is a hybrid-OLTP server used for data warehousing or reporting. $(li)The current setting has been tuned specifically for the data access patterns, IO subsystem, CPU cores, and acceptable user response time for the specific SQL Server instance.'  
,'http://bit.ly/cyJsRK '
,10  ,8  
,'Excessive Max Degree of Parallelism' 
,'The Max Degree of Parallelism parameter setting allows a single query to use more than half the number of available processor cores ' 
,'The Max Degree of Parallelism option is set to $(MaxDOP) with $(Cores) processor cores available for the SQL Server process to use. '
 ,2  
 ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>max degree of parallelism Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms181007.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>max degree of parallelism Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms181007(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>max degree of parallelism Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms181007(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>Managing Max Degree of Parallelism</Title><Link>http://www.sqlservercentral.com/articles/Configuring/managingmaxdegreeofparallelism/1029/</Link></RecommendationLink></ArrayOfRecommendationLink>'  
 ,''  
 ,''  ,''  
 ,'$(li)A single, large query could monopolize the server to the detriment of other OLTP transactions, causing a significant backlog. $(li)True OLTP transactions generally will not parallelize unless they are not tuned correctly, i.e., missing/incomplete WHERE clause, missing index, out-of-data statistics, or it is not a true OLTP transaction.'  
 ,'It is recommended that on an OLTP production server, the Max Degree of Parallelism parameter should be set to a value greater than zero and not exceeding half the number of available processor cores up to a maximum setting of 8.  For servers that have NUMA configured, the Max Degree of Parallelism parameter should be set to the number of CPUs that are assigned to each NUMA node up to a maximum setting of 8.However, you should verify that the specific database usage model for the server is ''online transaction processing'' (OLTP) and the usage pattern will benefit from the setting change.  Note the following guidelines when making this setting change for an OLTP server:$(li)The ''max degree of parallelism'' server option should never be set to a value greater than the number of physical cores available. $(li)The ''affinity mask'' and ''affinity64 mask'' server configuration option should be considered to determine the total number of physical cores available. $(li)Consider the impact that Hyper-Threading may have on performance.  If Hyper-Threading is not disabled in your environment, verify that Hyper-Threading is enhancing the performance of the SQL Server instance and not comprising performance.  $(li)Never exceed the number of CPUs assigned to each NUMA node for servers configured to use NUMA.$(li)For true OLTP environments, some experts recommend setting ''max degree of parallelism'' to 1 to prevent query parallelization.  There are situations where this is justified but only after an in-depth analysis of wait statistics, data access patterns, the IO subsystem, processor core usage, and other important factors. $(li)Parallelism can be controlled on specific queries by the MAXDOP query hint. $(li)The ''cost threshold for parallelism'' server configuration option can allow for preventing parallelism on queries that don''t exceed the estimated query cost.It is recommended that on an OLTP production server, the Max Degree of Parallelism parameter should be set to a value greater than zero and not exceeding half the number of available processor cores up to a maximum setting of 8.  For servers that have NUMA configured, the Max Degree of Parallelism parameter should be set to the number of CPUs that are assigned to each NUMA node up to a maximum setting of 8.However, you should verify that the specific database usage model for the server is ''online transaction processing'' (OLTP) and the usage pattern will benefit from the setting change.  Note the following guidelines when making this setting change for an OLTP server:$(li)The ''max degree of parallelism'' server option should never be set to a value greater than the number of physical cores available. $(li)The ''affinity mask'' and ''affinity64 mask'' server configuration option should be considered to determine the total number of physical cores available. $(li)Consider the impact that Hyper-Threading may have on performance.  If Hyper-Threading is not disabled in your environment, verify that Hyper-Threading is enhancing the performance of the SQL Server instance and not comprising performance.  $(li)Never exceed the number of CPUs assigned to each NUMA node for servers configured to use NUMA.$(li)For true OLTP environments, some experts recommend setting ''max degree of parallelism'' to 1 to prevent query parallelization.  There are situations where this is justified but only after an in-depth analysis of wait statistics, data access patterns, the IO subsystem, processor core usage, and other important factors. $(li)Parallelism can be controlled on specific queries by the MAXDOP query hint. $(li)The ''cost threshold for parallelism'' server configuration option can allow for preventing parallelism on queries that don''t exceed the estimated query cost.It is recommended that on an OLTP production server, the Max Degree of Parallelism parameter should be set to a value greater than zero and not exceeding half the number of available processor cores up to a maximum setting of 8.  For servers that have NUMA configured, the Max Degree of Parallelism parameter should  However, you should verify that the specific database usage model for the server is ''online transaction processing'' (OLTP) and the usage pattern will benefit from the setting change.  Note the following guidelines when making this setting change for an OLTP server:$(li)The ''max degree of parallelism'' server option should never be set to a value greater than the number of physical cores available. $(li)The ''affinity mask'' and ''affinity64 mask'' server configuration option should be considered to determine the total number of physical cores available. $(li)Consider the impact that Hyper-Threading may have on performance.  If Hyper-Threading is not disabled in your environment, verify that Hyper-Threading is enhancing the performance of the SQL Server instance and not comprising performance.  $(li)Never exceed the number of CPUs assigned to each NUMA node for servers configured to use NUMA.$(li)For true OLTP environments, some experts recommend setting ''max degree of parallelism'' to 1 to prevent query parallelization.  There are situations where this is justified but only after an in-depth analysis of wait statistics, data access patterns, the IO subsystem, processor core usage, and other important factors. $(li)Parallelism can be controlled on specific queries by the MAXDOP query hint. $(li)The ''cost threshold for parallelism'' server configuration option can allow for preventing parallelism on queries that don''t exceed the estimated query cost.'  
 ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-P7'  ,''  ,'http://bit.ly/agslkv ',10  ,10  ,'' ,'Databases with high usage are being encrypted ' ,'Encrypting entire high usage databases as was detected on $(EncryptedDatabases.Count>1?databases:database) $(EncryptedDatabases) (representing $(EncryptedIOPercentString)% of all IO traffic performed by this SQL Server. This places an additional CPU processing burden on your server.  ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Understanding Transparent Data Encryption</Title><Link>http://msdn.microsoft.com/en-us/library/bb934049(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Database Encryption in SQL Server 2008 Enterprise Edition</Title><Link>http://msdn.microsoft.com/en-us/library/cc278098.aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,'Note: 256-bit AES may be required by certain IT departments, but be aware that it requires additional processing overhead and 128-bit AES has never been cracked.'  ,''  ,''  ,'It is recommended that only the columns that contain vital data be encrypted. It is seldom necessary to encrypt every single column of every table in a database. Typically, only a few select columns actually hold vital data which must be kept secret at all costs and it is only those columns which should be encrypted.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-P8'  ,''  ,'http://bit.ly/cZs5Ia' ,10  ,8  ,'' ,'Inefficient encryption has been detected on database $(Database)  ' ,'Encryption methods other than 128-bit AES place an unnecessary additional CPU processing burden on your Server. 
$(br)Note: 256-bit AES may be required by certain IT departments, but be aware that it requires additional processing overhead and 128-bit AES has never been cracked.
$(br)Note: DES, RC2 and SQL Server''s implementation of RC4 and RC4_128 are no longer considered secure and can typically be cracked in a few hours or days.
Encryption methods other than 128-bit AES place an unnecessary additional CPU processing burden on your Server. 
$(br)Note: 256-bit AES may be required by certain IT departments, but be aware that it requires additional processing overhead and 128-bit AES has never been cracked.
$(br)Note: DES, RC2 and SQL Server''s implementation of RC4 and RC4_128 are no longer considered secure and can typically be cracked in a few hours or days.
Encryption methods other than 128-bit AES place an unnecessary additional CPU processing burden on your Server. 
$(br)Note: 256-bit AES may be required by certain IT departments, but be aware that it requires additional processing overhead and 128-bit AES has never been cracked.
$(br)Note: DES, RC2 and SQL Server''s implementation of RC4 and RC4_128 are no longer considered secure and can typically be cracked in a few hours or days.
Encryption methods other than 128-bit AES place an unnecessary additional CPU processing burden on your Server. 
$(br)Note: 256-bit AES may be required by certain IT departments, but be aware that it requires additional processing overhead and 128-bit AES has never been cracked.
$(br)Note: DES, RC2 and SQL Server''s implementation of RC4 and RC4_128 are no longer considered secure and can typically be cracked in a few hours or days.
Encryption methods other than 128-bit AES place an unnecessary additional CPU processing burden on your Server. 
$(br)Note: 256-bit AES may be required by certain IT departments, but be aware that it requires additional processing overhead and 128-bit AES has never been cracked.
$(br)Note: DES, RC2 and SQL Server''s implementation of RC4 and RC4_128 are no longer considered secure and can typically be cracked in a few hours or days.
Encryption methods other than 128-bit AES place an unnecessary additional CPU processing burden on your Server. 
$(br)Note: 256-bit AES may be required by certain IT departments, but be aware that it requires additional processing overhead and 128-bit AES has never been cracked.
$(br)Note: DES, RC2 and SQL Server''s implementation of RC4 and RC4_128 are no longer considered secure and can typically be cracked in a few hours or days.
 ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>EFF DES cracker</Title><Link>http://en.wikipedia.org/wiki/EFF_DES_cracker</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'Inefficient encryption has been detected on $(Count) databases'  ,'Encryption methods other than 128-bit AES place an unnecessary additional CPU processing burden on your Server. 
Note: 256-bit AES may be required by certain IT departments, but be aware that it requires additional processing overhead and 128-bit AES has never been cracked.
Note: DES, RC2 and SQL Server''s implementation of RC4 and RC4_128 are no longer considered secure and can typically be cracked in a few hours or days.Encryption methods other than 128-bit AES place an unnecessary additional CPU processing burden on your Server. 
Note: 256-bit AES may be required by certain IT departments, but be aware that it requires additional processing overhead and 128-bit AES has never been cracked.
Note: DES, RC2 and SQL Server''s implementation of RC4 and RC4_128 are no longer considered secure and can typically be cracked in a few hours or days.Encryption methods other than 128-bit AES place an unnecessary additional CPU processing burden on your Server. 
Note: 256-bit AES may be required by certain IT departments, but be aware that it requires additional processing overhead and 128-bit AES has never been cracked.
Note: DES, RC2 and SQL Server''s implementation of RC4 and RC4_128 are no longer considered secure and can typically be cracked in a few hours or days.Encryption methods other than 128-bit AES place an unnecessary additional CPU processing burden on your Server. 
Note: 256-bit AES may be required by certain IT departments, but be aware that it requires additional processing overhead and 128-bit AES has never been cracked.
Note: DES, RC2 and SQL Server''s implementation of RC4 and RC4_128 are no longer considered secure and can typically be cracked in a few hours or days.Encryption methods other than 128-bit AES place an unnecessary additional CPU processing burden on your Server. 
Note: 256-bit AES may be required by certain IT departments, but be aware that it requires additional processing overhead and 128-bit AES has never been cracked.
Note: DES, RC2 and SQL Server''s implementation of RC4 and RC4_128 are no longer considered secure and can typically be cracked in a few hours or days.Encryption methods other than 128-bit AES place an unnecessary additional CPU processing burden on your Server. 
Note: 256-bit AES may be required by certain IT departments, but be aware that it requires additional processing overhead and 128-bit AES has never been cracked.
Note: DES, RC2 and SQL Server''s implementation of RC4 and RC4_128 are no longer considered secure and can typically be cracked in a few hours or days.'  ,'It is recommended that 128-bit AES encryption be used for these databases. 128-bit AES represents a 15-25% computational efficiency over other encryption methods (3DES, asymmetric encryption, RC2, etc).'  ,''  ,'It is recommended that 128-bit AES encryption be used for the database. 128-bit AES represents a 15-25% computational efficiency over other encryption methods (3DES, asymmetric encryption, RC2, etc).'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-P19'  ,''  ,'http://bit.ly/8XCDIj ' ,10  ,NULL  ,'' ,'Your production server is operating in a VM server and is sharing physical server resources with xx other VMs ' ,'Although the other virtual machines may be stopped, operating a server on a virtual machine causes you to lose approximately 15-20% performance. ' ,''  ,''  ,'SKIPPED'  ,'SKIPPED'  ,'SKIPPED'  ,''  ,'It is recommended that your server not reside within a  virtual machine.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-P20'  ,''  ,'',10  ,NULL  ,'' ,'Your production server is operating in a virtual server and is sharing physical server resources with another xx virtual machines ' ,'Although the other virtual machines may be stopped, operating a server on a virtual machine causes you to lose approximately 15-20% performance. ' ,''  ,''  ,'SKIPPED'  ,'SKIPPED'  ,'SKIPPED'  ,''  ,'It is recommended that your server not reside within a virtual machine. '  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-P23'  ,'$(li)When CXPACKET waits are not excessive and parallelism is desired for the workload.$(li)This is not a true online transaction processing (OLTP) server or it is a hybrid server.'  ,'',10  ,10  ,'High CXPACKET waits on OLTP Server' ,'Your OLTP Server is experiencing high CPU usage along with a high number of CXPACKET waits ' ,'A high number of CXPACKET waits indicate parallel queries are running on your server.  This is an indication that one or more threads of the parallelized queries are waiting for another thread to complete before the parallel operation can be completed.   ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>CXPACKET Wait Stats &amp; ''max degree of parallelism'' Option</Title><Link>http://blogs.msdn.com/b/jimmymay/archive/2008/11/28/case-study-part-1-cxpacket-wait-stats-max-degree-of-parallelism-option-introduction-to-using-wait-stats-to-identify-remediate-query-parallelism-bottlenecks.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'SKIPPED'  ,'SKIPPED'  ,'SKIPPED'  ,'$(li)Indexes may be missing which are causing queries to be less efficient.$(li)Statistics could be out-of-date or missing which will cause the optimizer to not properly estimate the cost of the query.$(li)Fragmentation could be causing additional I/O requests for one or more of the parallel threads.$(li)Query filter predicates may be incomplete or missing causing queries to be less efficient.$(li)Query filter predicates may contain functions on column values forcing a scan to be used instead of a seek.$(li)Query filter predicates may be causing an implicit conversion of a column value because of mismatched data types.$(li)Queries are not true online transaction processing (OLTP) transactions.'  ,'You should consider the following which can have a significant impact on CPU usage and CXPACKET wait times:$(li)Updating statistics to ensure the query optimizer is estimating the cost of queries correctly.$(li)Rebuild highly fragmented indexes which are experiencing range scans.$(li)Research the addition of new indexes to improve workload performance.$(li)Review queries to ensure they are optimized for OLTP transactions.$(li)Revise filter criteria to prevent implicit conversions which could be causing index/table scans.$(li)Revise filter criteria to prevent functions from being used on columns which could be causing index/table scans.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q1'  ,''  ,'http://bit.ly/9GblQc',11  ,10 ,'Unclosed or non-deallocated cursor' ,'Cursor $(CursorName) is not properly closed or deallocated ' ,'Cursors that have not been deallocated can consume memory resources and hold locks that affect data availability. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>DEALLOCATE (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms188782.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>DEALLOCATE (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms188782(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>DEALLOCATE (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms188782(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) cursors are not properly closed or deallocated'  ,''  ,'It is recommended that these cursors be explicitly closed and deallocated after use. One common cause of cursors failing to be close and deallocated is when a loop is exited due to an error without error handling that explicitly closes and deallocates the cursor. Ensure that error handling that exits a cursor loop closes and deallocates the cursor.'  ,''  ,'It is recommended that cursor $(CursorName) should be explicitly closed and deallocated after use. One common cause of cursors failing to be close and deallocated is when a loop is exited due to an error without error handling that explicitly closes and deallocates the cursor. Ensure that error handling that exits a cursor loop closes and deallocates the cursor.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q10'  ,''  ,'',11  ,NULL  ,'' ,'A filter predicate contains mismatched data types ' ,'One side of the query predicate has a data type of $(FoundType) while the other side has a data type of $(DesiredType). This condition will cause implicit conversions for data type matching and likely prevent the query optimizer from using indexes to access the data more efficiently. ' ,''  ,''  ,'SKIPPED'  ,'SKIPPED'  ,'SKIPPED'  ,''  ,'It is recommended that you re-write the predicate to explicitly CAST the data type $(FoundType) to match data type $(DesiredType) to avoid implicit conversions.'  ,0,''
,0)

SET @multilineInput = 'You should consider rewriting the query to use a TRUNCATE instead of a DELETE.  The TRUNCATE operation is much faster and uses far less system and transaction log resources than a DELETE.

However, you should be aware that the TRUNCATE should not be performed in the following situations:$(li)A trigger exists and should be fired for each row deletion.$(li)An identity column exists and the identity counter should be retained.$(li)This table is referenced by another table in a FOREIGN KEY constraint.$(li)The table is used in an indexed view.$(li)Transactional replication or merge replication is in use.You should consider rewriting the query to use a TRUNCATE instead of a DELETE.  The TRUNCATE operation is much faster and uses far less system and transaction log resources than a DELETE.

However, you should be aware that the TRUNCATE should not be performed in the following situations:$(li)A trigger exists and should be fired for each row deletion.$(li)An identity column exists and the identity counter should be retained.$(li)This table is referenced by another table in a FOREIGN KEY constraint.$(li)The table is used in an indexed view.$(li)Transactional replication or merge replication is in use.You should consider rewriting the query to use a TRUNCATE instead of a DELETE.  The TRUNCATE operation is much faster and uses far less system and transaction log resources than a DELETE.

However, you should be aware that the TRUNCATE should not be performed in the following situations:$(li)A trigger exists and should be fired for each row deletion.$(li)An identity column exists and the identity counter should be retained.$(li)This table is referenced by another table in a FOREIGN KEY constraint.$(li)The table is used in an indexed view.$(li)Transactional replication or merge replication is in use.You should consider rewriting the query to use a TRUNCATE instead of a DELETE.  The TRUNCATE operation is much faster and uses far less system and transaction log resources than a DELETE.

However, you should be aware that the TRUNCATE should not be performed in the following situations:$(li)A trigger exists and should be fired for each row deletion.$(li)An identity column exists and the identity counter should be retained.$(li)This table is referenced by another table in a FOREIGN KEY constraint.$(li)The table is used in an indexed view.$(li)Transactional replication or merge replication is in use.You should consider rewriting the query to use a TRUNCATE instead of a DELETE.  The TRUNCATE operation is much faster and uses far less system and transaction log resources than a DELETE.

However, you should be aware that the TRUNCATE should not be performed in the following situations:$(li)A trigger exists and should be fired for each row deletion.$(li)An identity column exists and the identity counter should be retained.$(li)This table is referenced by another table in a FOREIGN KEY constraint.$(li)The table is used in an indexed view.$(li)Transactional replication or merge replication is in use.You should consider rewriting the query to use a TRUNCATE instead of a DELETE.  The TRUNCATE operation is much faster and uses far less system and transaction log resources than a DELETE.

However, you should be aware that the TRUNCATE should not be performed in the following situations:$(li)A trigger exists and should be fired for each row deletion.$(li)An identity column exists and the identity counter should be retained.$(li)This table is referenced by another table in a FOREIGN KEY constraint.$(li)The table is used in an indexed view.$(li)Transactional replication or merge replication is in use.'  

INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q11'  
,'$(li)If a trigger must be fired for each individual row deletion.$(li)If an identity column exists and the identity counter value must be retained.$(li)If another table references this table in a FOREIGN KEY constraint.$(li)If the table is used by an indexed view.$(li)If the delete operation will be published by using transactional replication or merge replication.$(li)If the table is small enough that the overhead of the DELETE is negligible.'  ,'http://bit.ly/d9FNEi',11  ,10  ,'Unfiltered delete statement' ,'An unfiltered delete on [$(TableName)] in [$(Database)] ' ,'The query deletes all data from table [$(TableName)]. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>TRUNCATE TABLE (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms177570.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>TRUNCATE TABLE (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms177570(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>TRUNCATE TABLE (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms177570(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) unfiltered delete statements have been detected'  ,'These queries delete all data from the tables they reference'  ,''  ,'$(li)A significant amount of system resources and transaction log space could be used due to the DELETE operation logging each row deleted.$(li)The duration of the delete operation could be significant depending on the number of rows deleted.$(li)When the DELETE is executed using a row lock, each row is locked for deletion which may require a significant amount of locking.$(li)The table can still contain empty pages which may account for a large amount of excess space allocated to the table.'  
,@multilineInput,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q12'  ,''  ,'',11  ,NULL  ,'' ,'SELECT DISTINCT abuse has been detected ' ,'The query''s SELECT clause contains a potentially redundant DISTINCT operator. The select list of this query contains $(ColumnNames.Count>1?columns:column) from table [$(TableName)] that $(ColumnNames.Count>1?are:is) unique. Analysis of this query indicates that the result rows will be unique without using DISTINCT, use of which results in performance overhead since SQL Server must sort or group the result set to remove duplicate rows. ' ,''  ,''  ,'SKIPPED'  ,'SKIPPED'  ,'SKIPPED'  ,''  ,'It is recommended that you re-write the SELECT clause of this query to remove the use of DISTINCT.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q13'  ,''  ,'http://bit.ly/9WsIiq',11  ,5  ,'Query hint abuse' ,'Query hint abuse has been detected ' ,'The following query hints were detected: ($(Hints)).  Query hints can have an adverse impact on performance or introduce other unforeseen problems. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Query Hints (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms181714(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Query Hints (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms181714(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Query Hints (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms181714(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>Query Tuning Recommendations</Title><Link>http://msdn.microsoft.com/en-us/library/ms188722(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Query Tuning Recommendations</Title><Link>http://msdn.microsoft.com/en-us/library/ms188722(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Query Tuning Recommendations</Title><Link>http://msdn.microsoft.com/en-us/library/ms188722(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'Query hint abuse has been detected $(Count) times'  ,'Query hints can have an adverse impact on performance or introduce other unforeseen problems.'  ,''  ,''  ,'It is recommended that queries be reviewed to determine if the query hints are needed, that they are not causing any unforeseen problems, and they are not forcing a specific behavior that may not be desirable when the underlying data increases.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q14'  ,''  ,'http://bit.ly/d0mtyg',11  ,5  ,'' ,'Obsolete recommendation ' ,'Please perform a new analysis for updated recommendations. ' ,'2'  ,''  ,''  ,''  ,''  ,''  ,''  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q15'  ,''  ,'http://bit.ly/bcU4S8 ',11  ,NULL ,'' ,'Obsolete recommendation ' ,'Please perform a new analysis for updated recommendations. ' ,''  ,''  ,''  ,''  ,''  ,''  ,''  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q16'  ,''  ,'http://bit.ly/deZV4X ',11  ,7  ,'Function used in query predicate' ,'A function is being used in a query predicate ' ,'The use of a function on a column value within a search predicate may prevent the query optimizer from performing an index seek and requires all column values to be scanned and processed by the function. ' ,'2'  ,''  ,'A function is being used in a query predicate for $(Count) queries'  ,''  ,'It is recommended that you rewrite the query to remove the use of the function within the search predicate.  One option to remove the use of the LEFT function would be to replace it with LIKE and the % wild card. Using LIKE instead of the LEFT function will allow the query optimizer to consider index seeks for satisfying the query.'  ,''  ,'It is recommended that you rewrite the query to remove the use of the function within the search predicate.  One option to remove the use of the LEFT function would be to replace it with LIKE and the % wild card. Using LIKE instead of the LEFT function will allow the query optimizer to consider index seeks for satisfying the query.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q17'  ,''  ,'http://bit.ly/dzsakC ',11  ,10  ,'Like Used Not Needed' ,'Obsolete recommendation ' ,'Please perform a new analysis for updated recommendations. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Match your String with Wild Card Characters</Title><Link>http://www.codeproject.com/KB/java/Wild_card_in_Java.aspx</Link></RecommendationLink><RecommendationLink><Title>LIKE (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms179859.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>LIKE (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms179859(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>LIKE (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms179859(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,''  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q18'  ,''  ,'http://bit.ly/aKmL5d ',11  ,8  ,'Nested Min Max' ,'Obsolete recommendation ' ,'Please perform a new analysis for updated recommendations. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>MIN (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms179916(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>MIN (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms179916(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>MIN (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms179916(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>MAX (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms187751(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>MAX (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms187751(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>MAX (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms187751(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,''  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q19'  ,''  ,'http://bit.ly/bHQH5C',11  ,9  ,'No join predicate' ,'No join predicate has been detected ' ,'The search condition for a joined table is missing in the either the ON clause or the FROM clause.  This could result in the query running longer than necessary. ' ,3  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Using Inner Joins</Title><Link>http://msdn.microsoft.com/en-us/library/ms190014(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Using Inner Joins</Title><Link>http://msdn.microsoft.com/en-us/library/ms190014(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Using Inner Joins</Title><Link>http://msdn.microsoft.com/en-us/library/ms190014(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>Using Cross Joins</Title><Link>http://msdn.microsoft.com/en-us/library/ms190690(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Using Cross Joins</Title><Link>http://msdn.microsoft.com/en-us/library/ms190690(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Using Cross Joins</Title><Link>http://msdn.microsoft.com/en-us/library/ms190690(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) no join predicates detected'  ,'These queries are missing the search condition of either a ON clause or a FROM clause for a joined table.  This could result in the query running longer than necessary.'  ,'It is recommended that you add the search condition to either the ON clause or the FROM clause for all joined tables.'  ,''  ,'It is recommended that you add the search condition to either the ON clause or the FROM clause for all joined tables.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q2'  ,''  ,'http://bit.ly/d80EOh',11  ,8  ,'Potential cursor optimizations' ,'Cursor $(CursorName) could be optimized for better performance ' ,'If cursor $(CursorName) is only used to read sequentially from the first to the last row, using the FAST_FORWARD option will allow performance optimizations to be enabled. Additionaly, if the rows are not being modified directly using the WHERE CURRENT OF clause, further optimizations can be made by using the READ_ONLY option.' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Understanding Cursor Types</Title><Link>http://msdn.microsoft.com/en-us/library/ms378405(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Understanding Cursor Types</Title><Link>http://msdn.microsoft.com/en-us/library/ms378405(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Understanding Cursor Types</Title><Link>http://msdn.microsoft.com/en-us/library/ms378405(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>Understanding SQL Server Fast_Forward Server Cursors</Title><Link>http://blogs.msdn.com/b/sqlqueryprocessing/archive/2009/08/12/understanding-sql-server-fast-forward-server-cursors.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'There are $(Count) cursors that could be optimized for better performance'  ,'If these cursors are only used to read sequentially from the first to the last row, using the FAST_FORWARD option will allow performance optimizations to be enabled. Additionaly, if the rows are not being modified directly using the WHERE CURRENT OF clause, further optimizations can be made by using the READ_ONLY option.'  ,'It is recommended that performance optimizations be enabled for the cursors by using the FAST_FORWARD cursor option.'  ,''  ,'It is recommended that performance optimizations be enabled for cursor $(CursorName) by using the FAST_FORWARD cursor option.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q20'  ,''  ,'http://bit.ly/bUCNVt',11  ,NULL ,'Table/index scan due to NOT IN' ,'The NOT IN predicate is causing a table or index scan ' ,'The query execution plan indicates that a table or index scan is being performed for each column value filterd by the NOT IN predicate.  This could be caused by column $(ColumnName) allowing NULL values. ' ,NULL  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>IN (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-US/library/ms177682%28v=SQL.105%29.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>IN (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-US/library/ms177682(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>IN (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-US/library/ms177682(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) queries found where the NOT IN predicate is causing a table or index scan'  ,''  ,'It is recommended that the NOT IN portion of the query be reviewed to determine if an alternate method could be used for filtering.  If the NOT IN must be used, consider modifying the NOT IN subquery to filter out null values (WHERE [ColumnName] IS NOT NULL).

Additionally, it recommended that EXISTS or NOT EXISTS clauses correlated back to the parent query be used instead of IN or NOT IN with a non-correlated query. The engine is able to short-circuit an EXISTS clause when the first match is found rather than searching the entire subquery result set and may result in faster execution.

All query modifications must be thoroughly tested before implemented into production.  A simple change to a query could have a significant impact on the results of executing that query.
'  ,''  ,'It is recommended that the NOT IN portion of the query be reviewed to determine if an alternate method could be used for filtering.  If the NOT IN must be used, consider modifying the NOT IN subquery to filter out null values (WHERE $(ColumnName) IS NOT NULL).

Additionally, it recommended that EXISTS or NOT EXISTS clauses correlated back to the parent query be used instead of IN or NOT IN with a non-correlated query. The engine is able to short-circuit an EXISTS clause when the first match is found rather than searching the entire subquery result set and may result in faster execution.

All query modifications must be thoroughly tested before implemented into production.  A simple change to a query could have a significant impact on the results of executing that query. 
 
'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q21'  ,''  ,'',11  ,NULL  ,'' ,'Obsolete recommendation ' ,'Please perform a new analysis for updated recommendations. ' ,''  ,''  ,''  ,''  ,''  ,''  ,''  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q22'  ,''  ,'http://bit.ly/aRACoI',11  ,6  ,'Select * found' ,'The use of SELECT * has been found ' ,'The use of SELECT * will return all of the columns found in the tables and/or views of the FROM clause.  This can lead to a number of unused columns being returned. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>SELECT Clause (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms176104.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>SELECT Clause (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms176104(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>SELECT Clause (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms176104(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'The use of SELECT * has been found $(Count) times'  ,''  ,'It is recommended that you change all of the SELECT * queries to explicitly include only the columns needed and remove the *.'  ,''  ,'It is recommended that you change the SELECT * to explicitly include only the columns needed and remove the *.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q23'  ,''  ,'http://bit.ly/aHoji9 ',11  ,NULL  ,'' ,'Obsolete recommendation ' ,'Please perform a new analysis for updated recommendations. ' ,''  ,''  ,''  ,''  ,''  ,''  ,''  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q24'  ,''  ,'http://bit.ly/9dhQyO',11  ,6  ,'Search predicate contains a column expression in a function' ,'A Search predicate contains a column expression in a function ' ,'The query optimizer may not be able to perform an index seek on search predicates that include the column in a function, resulting in a less optimal execution plan. ' ,'2'  ,''  ,'$(Count) search predicates contain a column expression in a function'  ,''  ,''  ,''  ,'It is recommended that you modify the search predicate to no longer filter based on the result of a function on a column value.  This will allow the query optimizer to consider index seeks to satisfy the search predicate and not require a scan of all column values.

All query modifications must be thoroughly tested before implemented into production.  A simple change to a query could have a significant impact on the results of executing that query. '  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q25'  ,''  ,'http://bit.ly/a1wbPY ',11  ,NULL  ,'' ,'Function $(FunctionName) called for a row set ' ,'SQL is a set based programming language, not a procedural language. Using functions to encapsulate procedural code can result in significant performance overhead when called on a row set because the function is executed for each row of the set. ' ,''  ,''  ,'SKIPPED'  ,'SKIPPED'  ,'SKIPPED'  ,''  ,'It is recommended that this query be re-written to include the function logic as in-line code, allowing the query optimizer to produce a more optimal execution plan.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q26'  ,''  ,'http://bit.ly/c83yoX',11  ,2  ,'Union operator found' ,'The UNION operator has been found on a query ' ,'The UNION operator combines the results of two or more queries into a single result set and removes duplicate rows.  The overhead required to remove the duplicate rows from the result set can be significant for a large result set. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>UNION (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms180026(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>UNION (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms180026(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>UNION (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms180026(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>SQL SERVER - Difference Between Union vs. Union All - Optimal PerformanceComparison</Title><Link>http://blog.sqlauthority.com/2009/03/11/sql-server-difference-between-union-vs-union-all-optimal-performance-comparison/</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'The UNION operator has been found on a $(Count) queries'  ,''  ,''  ,''  ,'It is recommended that the use of UNION ALL be considered if the result set is large and will not contain duplicate rows. 

Additionally, if duplicate rows do exist in the result set, consider the option of filtering out the duplicate rows by the querying application.  It is common for the consuming application to perform the duplicate filtering regardless of the result set already being filtered by SQL Server.  In this situation, the additional performance hit on SQL Server may not be justified in the reduced result set transferred back to the client application.  

All query modifications must be thoroughly tested before implemented into production.  A simple change to a query could have a significant impact on the results of executing that query. '  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q27'  ,''  ,'',11  ,NULL  ,'' ,'Subquery used instead of JOIN ' ,'A subquery is used in the WHERE clause of the query. The query optimizer will typically generate a less optimal execution plan than if an explicit JOIN were used. ' ,''  ,''  ,'SKIPPED'  ,'SKIPPED'  ,'SKIPPED'  ,''  ,'It is recommended that the WHERE clause of this query be re-written to use a JOIN rather than a subquery.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q28'  ,''  ,'http://bit.ly/cabWQq',11  ,9  ,'SET ROWCOUNT used instead of TOP' ,'SET ROWCOUNT used instead of TOP ' ,'The query is using SET ROWCOUNT to limit the size of the result set instead of the TOP clause. Since SET ROWCOUNT is used outside the statement that executes the query, its value cannot be used to produce an optimal execution plan. The query optimizer can use the value of the expression in the TOP clause to generate a more optimal execution plan. 

Additionally, using SET ROWCOUNT to limit an update, insert, or delete query is deprecated and will be removed in a future version of SQL Server. This command should not be used with queries that perform data modifications.
' ,1 ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>SET ROWCOUNT (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms188774(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>SET ROWCOUNT (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms188774(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>SET ROWCOUNT (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms188774(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'SET ROWCOUNT used instead of TOP $(Count) times'  ,'These queries are using SET ROWCOUNT to limit the size of their result sets instead of the TOP clause. Since SET ROWCOUNT is used outside the statement that executes the query, its value cannot be used to produce an optimal execution plan. The query optimizer can use the value of the expression in the TOP clause to generate a more optimal execution plan.

Additionally, using SET ROWCOUNT to limit an update, insert, or delete query is deprecated and will be removed in a future version of SQL Server. This command should not be used with queries that perform data modifications.
'  ,'It is recommended that these queries be rewritten to use the TOP clause instead of SET ROWCOUNT.'  ,''  ,'It is recommended that the query be rewritten to use the TOP clause instead of SET ROWCOUNT.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q29'  ,''  ,'http://bit.ly/bMsKmB',11  ,9  ,'Search predicate used instead of TOP' ,'Search predicate is being used to limit result set instead of TOP ' ,'The WHERE clause of the query limited the result set instead of the applicable TOP clause. Using TOP may or may not result in a more optimal execution plan. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>TOP (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms189463(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>TOP (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms189463(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>TOP (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms189463(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) instances of search predicate being used to limit result sets instead of TOP'  ,'The WHERE clause of these queries limited their result sets instead of using the applicable TOP clause. Using TOP may or may not result in a more optimal execution plan.'  ,'It is recommended that these queries be evaluated using an equivalent TOP clause versus limiting results via the search predicate.'  ,''  ,'It is recommended that the query be evaluated using an equivalent TOP clause versus limiting results via the search predicate.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q3'  ,''  ,'http://bit.ly/acMX06',11  ,5  ,'Inefficient SQL Module settings' ,'SQL Module settings may prevent query optimization ' ,'SQL Module $(DatabaseName).$(SchemaName).$(ObjectName) was found with ANSI_NULLS and/or QUOTED_IDENTIFIER set to OFF.  These settings can prevent the query optimizer from using an index seek for certain queries. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>SET ANSI_NULLS (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms188048(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>SET ANSI_NULLS (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms188048(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>SET ANSI_NULLS (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms188048(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink><RecommendationLink><Title>Query Tuning Recommendations</Title><Link>http://msdn.microsoft.com/en-us/library/ms188722(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Query Tuning Recommendations</Title><Link>http://msdn.microsoft.com/en-us/library/ms188722(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Query Tuning Recommendations</Title><Link>http://msdn.microsoft.com/en-us/library/ms188722(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) SQL Modules have settings that may prevent query optimization'  ,'SQL Modules found with ANSI_NULLS and/or QUOTED_IDENTIFIER set to OFF.  These settings can prevent the query optimizer from using an index seek for certain queries.'  ,''  ,''  ,'It is recommended that ANSI_NULLS is always set to ON.  In a future version of SQL Server, setting ANSI_NULLS to OFF will generate an error.

Additionally, if QUOTED_IDENTIFIER is set to OFF, change the setting to ON unless the object requires the setting to be OFF.

All query modifications must be thoroughly tested before implemented into production.  A simple change to a query could have a significant impact on the results of executing that query.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q30'  ,''  ,'http://bit.ly/d93X4k ',11  ,NULL  ,'' ,'Invariant operation found inside a loop ' ,'An invariant operation inside of a loop will result in unnecessary performance overhead. ' ,''  ,''  ,'SKIPPED'  ,'SKIPPED'  ,'SKIPPED'  ,''  ,'It is recommended that the query be rewritten to move the invariant operation outside of the loop.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q31'  ,''  ,'http://bit.ly/d7zlzw ',11  ,NULL  ,'' ,'Columns $(ColumnNames) referenced in a different order than their covered index $(IndexName) ' ,'Referencing columns in a different order than that of their covered index will result in a less optimal execution plan. ' ,''  ,''  ,'SKIPPED'  ,'SKIPPED'  ,'SKIPPED'  ,''  ,'It is recommended that the WHERE clause of this query be rewritten to reference the columns in the same order as the covering index.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q32'  ,''  ,'http://http://bit.ly/aE07TU 2',11  ,NULL  ,'' ,'Use of NOT NULL condition on column $(ColumnName) is suppressing an index range scan ' ,'Column $(ColumnName) in table [$(TableName)] is covered by an index but not producing an index range scan for the query due to the use of the NOT NULL condition, resulting in a suboptimal execution plan. ' ,''  ,''  ,'$(Count) usages of NOT NULL conditions are suppressing index range scans'  ,'The use of the NOT NULL expression is preventing index range scans on indexed columns, resulting in suboptimal execution plans.'  ,''  ,''  ,'It is recommended that the search predicate of the query be rewritten using an upper and lower limit that will allow for an index range scan, resulting in a more optimal execution plan.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q33'  ,''  ,'http://bit.ly/cM8VRo ',11  ,NULL  ,'' ,'Use of not-equal operator on column $(ColumnName) is suppressing an index range scan ' ,'Column $(ColumnName) in table [$(TableName)] is covered by an index but not producing an index range scan for the query due to the use of the not-equal operator, resulting in a suboptimal execution plan. ' ,''  ,''  ,'$(Count) usages of not-equal operators suppressing an index range scan'  ,'The use of the not-equal operator is preventing index range scans on indexed columns, resulting in suboptimal execution plans.'  ,'SKIPPED'  ,''  ,'It is recommended that the query be rewritten, if the not-equal operator covers most rows, replacing the not-equal operator with the IN clause, allowing for an index range scan and more optimal execution plan.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q34'  ,''  ,'http://bit.ly/bbUDWs',11  ,NULL  ,'Insert statement without column list' ,'Insert statement without column list ' ,'Although this will not affect performance it is a best practice to specify a column list on insert statements to avoid creating bad data if columns change in a way that allows existing queries to insert data into columns that now represent some other value (e.g., a column is dropped and a different one is added). ' ,''  ,''  ,'$(Count) insert statements without column lists'  ,''  ,''  ,''  ,'It is recommended that you specify a column list on insert statements.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q5'  ,''  ,'http://bit.ly/a5riMX ',11  ,NULL  ,'' ,'Row count logging is turned on ' ,'The SET NOCOUNT option isn''t explicitly configured in the batch. By default, SET NOCOUNT is set to OFF resulting in additional information about the affected row count of each query being sent back to the client application. While some applications require this information, many do not and the information is discarded. Sending this information back to the client application results in network overhead for each execution. ' ,''  ,''  ,'$(Count) instances where row count logging is turned on'  ,''  ,''  ,''  ,'It is recommended that you evaluate the necessity of row count information for the client application. If this information is not required, re-write stored procedures used by the client application to include SET NOCOUNT ON at the beginning for the procedure definition.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q35'  ,''  ,'http://bit.ly/9cZpwC',11  ,8  ,'Function causing table scan' ,'The function "$(FunctionName)" on column [$(Database)].[$(Schema)].[$(Table)].[$(Column)] may be causing a table scan ' ,'The function or expression "$(FunctionName)" in a query $(ObjectName?in $(ObjectName) :)$(ApplicationName?from $(ApplicationName) :)$(Database?in [$(Database)] :)$(HostName?submitted from $(HostName) :)$(UserName?by $(UserName) :)can cause index suppression resulting in poor performance due to a scan being performed instead of a seek. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Implicit Conversion Recommendation</Title><Link>http://sqldoctor.idera.com/query-optimization/implicit-conversion-recommendation/</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) functions may be causing table scans'  ,'A function or expression can cause index suppression resulting in poor performance due to a scan being performed instead of a seek.'  ,'It is recommended that you consider redesigning the WHERE clause for the affected queries to prevent index suppression and performance degradation.'  ,''  ,'It is recommended that you consider redesigning this WHERE clause to prevent index suppression and performance degradation.
$(br)Note: This recommendation can be caused from T-SQL  that is nested in a function, view or stored procedure.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q36'  ,''  ,'http://bit.ly/aTCOcL',11  ,8  ,'Implicit conversion may be causing index suppression' ,'An implicit conversion on column [$(Database)].[$(Schema)].[$(Table)].[$(Column)] to data type "$(DataType)" may be causing index suppression ' ,'An implicit conversion in a WHERE clause of a query $(ObjectName?in $(ObjectName) :)$(ApplicationName?on $(ApplicationName) :)$(Database?in [$(Database)] :)$(HostName?submitted from $(HostName) :)$(UserName?by $(UserName) :)can cause index suppression if an indexed column is of a different data type resulting in a scan rather than a seek. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Implicit Conversion Recommendation</Title><Link>http://sqldoctor.idera.com/query-optimization/implicit-conversion-recommendation/</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'Implicit conversions may be causing index suppression for $(Count) columns'  ,'An implicit conversion in a WHERE clause of a query can cause index suppression if an indexed column is of a different data type resulting in a scan rather than a seek.'  ,'It is recommended that you consider redesigning the WHERE clause for the affected queries to avoid data type conversions that cause index suppression and performance degradation.'  ,''  ,'It is recommended that you consider redesigning this WHERE clause to avoid data type conversions that cause index suppression and performance degradation.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q4'  ,''  ,'http://bit.ly/cMjC0j ',11  ,NULL  ,'' ,'DML parameters are being explicitly manipulated ' ,'One or more parameters used in a DML statement are being explicitly manipulated prior to execution of the statement. This may prevent the query optimizer from generating optimal execution plans because the actual parameter value is not known at optimization and compile time. ' ,''  ,''  ,'$(Count) instances of DML parameters being explicitly manipulated'  ,''  ,'It is recommended that you re-write these procedures to execute DML statements dynamically, passing the manipulated parameters as input parameters at run time. This will allow the optimizer to estimate the internal costs more accurately, resulting in more optimized execution plans.'  ,''  ,'It is recommended that you re-write the procedure to execute the DML statement dynamically, passing the manipulated parameter as an input parameter at run time. This will allow the optimizer to estimate the internal costs more accurately, resulting in more optimized execution plans.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q6'  ,''  ,'http://bit.ly/9mDDyI',11  ,5  ,'Inconsistent procedure execution times' ,'Inconsistent execution times for $(ObjectName?$(ObjectName):procedure) ' ,'Execution time varied between $(MinimumDuration)ms and $(MaximumDuration)ms with reads varying from $(MinimumReads) to $(MaximumReads) for $(ObjectName?$(ObjectName):the query).  This inconsistency could be caused from a cached execution plan being reused that was compiled for a set of parameters that are not optimal for each execution. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Query Hints (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms181714.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Query Hints (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms181714(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Query Hints (Transact-SQL)</Title><Link>http://msdn.microsoft.com/en-us/library/ms181714(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) queries with inconsistent execution times'  ,'Execution time varied for $(Count) queries.  This inconsistency could be caused from a cached execution plan being reused that was compiled for a set of parameters that are not optimal for each execution.'  ,'It is recommended that the procedure be tuned to ensure that SQL Server is able to choose the best plan for multiple parameters. A common scenario that causes this are when the optimizer has to choose between performing a nonclustered index seek plus key or RID lookups or performing a clustered index seek. This issue can be addressed by determining the additional columns being used or returned by query that is not part of the nonclustered index and either modifying the existing nonclustered index to include them or by creating a new index that includes all needed columns (covering index).
Other ways to address the issue are by using one of the query optimization hints RECOMPILE, OPTIMIZE FOR UNKNOWN, or OPTIMIZE FOR a specific value. The options should be tested to determine which option provides the optimal behavior. If the recompile hint is used, additional testing should be performed to verify the extra overhead of compiling an execution plan on each execution is justified and that overall performance is improved.'  ,''  ,'It is recommended that the procedure be tuned to ensure that SQL Server is able to choose the best plan for multiple parameters. A common scenario that causes this are when the optimizer has to choose between performing a nonclustered index seek plus key or RID lookups or performing a clustered index seek. This issue can be addressed by determining the additional columns being used or returned by query that is not part of the nonclustered index and either modifying the existing nonclustered index to include them or by creating a new index that includes all needed columns (covering index).
Other ways to address the issue are by using one of the query optimization hints RECOMPILE, OPTIMIZE FOR UNKNOWN, or OPTIMIZE FOR a specific value. The options should be tested to determine which option provides the optimal behavior. If the recompile hint is used, additional testing should be performed to verify the extra overhead of compiling an execution plan on each execution is justified and that overall performance is improved.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q7'  ,''  ,'http://bit.ly/9ITt1L',11  ,10  ,'Query plan compilations per second  greater than batch requests' ,'Query plan compilations per second are greater than batch requests ' ,'Query plan compilations ($(CompilationsPerSec) per second) should be a fraction of the number of batch requests ($(BatchesPerSec) per second) flowing through your SQL Server system, ideally less than 10%. If compilations are running high, it likely indicates a high degree of Ad hoc query executions rather than stored procedures, which will result in higher CPU usage due to recurring execution plan compiles. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Execution Plan Caching and Reuse</Title><Link>http://msdn.microsoft.com/en-us/library/ms181055(v=SQL.105).aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>Execution Plan Caching and Reuse</Title><Link>http://msdn.microsoft.com/en-us/library/ms181055(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>Execution Plan Caching and Reuse</Title><Link>http://msdn.microsoft.com/en-us/library/ms181055(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that you re-write Ad hoc queries as stored procedures to improve cached plan reuse and CPU performance by dramatically reducing the number of compilations.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q8'  ,'$(li)When more than two arguments are tested for NULL, COALESCE must be used instead of ISNULL.$(li)The performance gain from using ISNULL does not justify making the query changes.$(li)The query must stay compliant to the ANSI SQL standards (ISNULL is a Transact-SQL function and is not ANSI compliant).$(li)ISNULL has other behavior differences that could affect usage in rare situations and should be tested to ensure that changing to ISNULL does not result in a different result set.'  ,'http://bit.ly/asTIy2',11  ,7 ,'COALESCE used in place of ISNULL' ,'COALESCE is used in place of ISNULL ' ,'The COALESCE function is being used to return the first non-null expression from two arguments.  This could be implemented with the more efficient ISNULL function. ' ,'1'  ,''  ,'COALESCE is used in place of ISNULL for $(Count) queries'  ,''  ,'It is recommended that you modify the queries to use the ISNULL function in place of COALESCE where it make sense.

All query modifications must be thoroughly tested before implemented into production.  A simple change to a query could have a significant impact on the results of executing that query.'  ,'$(li)The COALESCE function is basically translated to a CASE expression that requires more overhead than using the ISNULL function.  The ISNULL function is a built-in function implemented within the database engine that will generally provide better performance.'  ,'It is recommended that you modify the query to use the ISNULL function in place of COALESCE where it make sense.

All query modifications must be thoroughly tested before implemented into production.  A simple change to a query could have a significant impact on the results of executing that query.
'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q9'  ,''  ,'http://bit.ly/aDWS1u',11  ,7  ,'' ,'Composite expression including column used in a search predicate ' ,'A composite expression is an expression that contains two or more sub-expressions. The value of the composite expression is calculated at run time and not at compile time, preventing the optimizer from considering the expression''s value, resulting in a less optimal execution plan. ' ,'1'  ,''  ,'$(Count) instances of a composite expression including column being used in a search predicate'  ,''  ,'It is recommended that you re-write these queries so that the composite expression is pre-calculated, providing the optimizer with a non-composite value that can be used to generate a more optimal execution plan.'  ,''  ,'It is recommended that you re-write the query so that the composite expression is pre-calculated, providing the optimizer with a non-composite value that can be used to generate a more optimal execution plan.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-S1'  ,'$(li)Even though Windows Authentication is more secure, SQL Server Authentication is required for non-Windows based clients or clients running Windows OS versions prior to Windows NT 4.0 and Windows 2000 Server. $(li)Some applications require the use of SQL Server Authentication.'  ,'http://bit.ly/bTqf0v',13  ,'4'  ,'Mixed Mode Authentication' ,'Authentication set to Mixed Mode ' ,'The SQL Server instance is configured to allow both Windows Authentication and SQL Server Authentication. ' ,0  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Choosing an Authentication Mode</Title><Link>http://technet.microsoft.com/en-us/library/ms144284.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,'$(li)Windows Authentication is more secure than SQL Server Authentication, primarily due to its integration with the Windows security system. Windows security provides more features, such as secure validation and encryption of passwords, auditing, password expiration, minimum password length, and account lockout after multiple invalid login requests.'  ,'It is recommended that whenever possible, you use Windows Authentication instead of Mixed Mode Authentication to secure your SQL Server.  Note that changing this setting will prevent login using SQL Authentication accounts.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-S10'  ,''  ,'http://bit.ly/b4bNH3',13  ,2  ,'Guest user has database access' ,'Guest user has permission to access database $(Database) ' ,'While the guest user cannot be dropped and is necessary in system database and certain cross-database applications, in many cases it is not necessary. ' ,0 ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Guest account in User Databases</Title><Link>http://blogs.msdn.com/b/sqlsecurity/archive/2010/09/24/guest-account-in-user-databases.aspx</Link></RecommendationLink><RecommendationLink><Title>Basic SQL Server Security concepts</Title><Link>http://blogs.msdn.com/b/lcris/archive/2007/09/12/basic-sql-server-security-concepts-permissions-and-special-principals-sa-dbo-guest.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'Guest user has permission to access $(Count) databases'  ,''  ,''  ,''  ,'Remove access to the guest user if it is not required by disabling the user or expressly denying CONNECT permissions to the user.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-S2'  ,''  ,'http://bit.ly/arK1go',13  ,5  ,'BUILTIN\Administrator included in sysadmin role' ,'BUILTIN\Administrator is included in sysadmin Role  ' ,'The Windows BUILTIN\Administrators group is added to the SQL Server sysadmin role by default.  However, this causes all local administrators to be granted full administrative rights to the SQL Server, which may not be intended. ' ,0 ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>How to prevent local and domain administrators from accessing SQL Server?</Title><Link>http://blogs.msdn.com/b/john_daskalakis/archive/2009/01/20/9345324.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'Research the possibility of removing the BUILTIN\Administrators group from the sysadmin SQL Server group and provide administrative access to individual users as required.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-S3'  ,''  ,'http://bit.ly/dh7VAQ',13  ,5  ,'Public role enabled for SQL Server Agent Proxy Account' ,'Public role is enabled for SQL Server Agent Proxy Account ' ,'The SQL Server Agent proxy account is given elevated privileges, while the Public role has fewer privileges.  Someone using the Public role could therefore take advantage of a higher privilege level. ' ,0  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Best Practices in Configuring SQL Server Agent Proxy account.</Title><Link>http://support.microsoft.com/kb/2160741</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'Research the possibility of removing the Public role from the SQL Server Agent proxy account.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-S4'  ,''  ,'http://bit.ly/a894XV',13  ,10  ,'Deprecated SQL Agent token in use' ,'Deprecated SQL Server Agent Token in use for step "$(StepName)" of job "$(JobName)" ' ,'Beginning with SQL 2005, the token syntax used in SQL Agent jobs must use escaped notation.  This will cause SQL Agent jobs to fail on SQL Server 2005 SP1 or later. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>SQL Server Agent jobs fail when the jobs contain job steps that use tokens after you install SQL Server 2005 Server Pack 1</Title><Link>http://support.microsoft.com/kb/915845</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,'Deprecated SQL Server Agent Tokens in use in $(Count) job steps'  ,''  ,''  ,''  ,'Change any job steps which are using outdated tokens to use proper escape notation.  A script to assist in transitioning job steps, sp_AddEscapeNoneToJobStepTokens, is available from Microsoft.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-S5'  ,''  ,'http://bit.ly/bS6yOc',13  ,5  ,'' ,'SQL Server instance is running on a domain controller ' ,'Microsoft recommends that SQL Server not be installed on a primary or backup domain controller.  Installing a failover cluster on a domain controller is not supported. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>You may encounter problems when installing SQL Server on a domain controller</Title><Link>http://support.microsoft.com/kb/2032911</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'If possible, move the SQL Server instance to a non domain controller server.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-S6'  ,'$(li)While enforcing password policies is a best practice, there may be business reasons that such a policy is undesirable, such as supporting legacy applications. $(li)When a password expiration policy is used to manage the lifespan of the password, one password cannot be used forever.  If a database application requires SQL Server Authentication and there is no provision for changing the password regularly, it may be disruptive to change from the existing policy, though doing so would be in line with recommended security practices.$(li)When a vendor application has a required SQL Login password that fails to meet the complexity requirements.'  ,'http://bit.ly/bNV0ZV',13  ,10  ,'Vulnerable SQL Server Password Policy' ,'SQL Server password policy is vulnerable for login $(Name) ' ,'The SQL login $(Name) is vulnerable to exploitation because it does not enforce both a password policy and password expiration. ' ,0  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>SQL Server: Password policy FAQ</Title><Link>http://blogs.msdn.com/b/lcris/archive/2008/02/20/sql-server-password-policy-faq.aspx</Link></RecommendationLink><RecommendationLink><Title>CREATE LOGIN</Title><Link>http://msdn.microsoft.com/en-us/library/ms189751.aspx</Link></RecommendationLink><RecommendationLink><Title>Enforce Windows Password Policy on SQL Server Logins</Title><Link>http://blogs.msdn.com/b/sqlsecurity/archive/2009/03/25/enforce-password-policy-on-sql-server-logins.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'SQL Server password policy is weak for $(Count) logins'  ,'A SQL login is vulnerable to exploitation when it does not enforce both a password policy and password expiration.'  ,'If SQL Server Authentication is not required in your environment, use Windows Authentication instead.  Otherwise, enable both "Enforce password policy" and "Password expiration" for all SQL Server logins.'  ,'$(li)Without a password complexity policy, there is nothing preventing the user from using a password that is easy to guess or that is not complex enough to prevent a brute force attack. $(li)Passwords with no expiration allow the user to use the same password indefinitely.  This increases the likelihood that the user will never change the password and that others will learn the password and use the account without proper authorization. $(li)When a password complexity policy is in place, the user must use a password that meets the requirements of that policy.  These requirements generally mean the user cannot use all or part of the account name as the password, the password is at least eight characters long, and contains a mix of upper and lower case, alphanumeric, and special characters.'  ,'If SQL Server Authentication is not required in your environment, use Windows Authentication instead.  Otherwise, enable both "Enforce password policy" and "Password expiration" for all SQL Server logins.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-S7'  ,''  ,'http://bit.ly/cyQygd',13  ,5  ,'Trustworthy bit vulnerability' ,'Trustworthy bit vulnerability exists for database $(Database) ' ,'If the database owner is assigned a fixed server sysadmin role and the database has its trustworthy bit set to ON, a privileged database user can elevate privileges and possibly compromise the system. ' ,0  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>TRUSTWORTHY Database Property</Title><Link>http://technet.microsoft.com/en-us/library/ms187861.aspx</Link></RecommendationLink><RecommendationLink><Title>Guidelines on using the Trustworthy setting for SQL Server Database.</Title><Link>http://support.microsoft.com/kb/2183687</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'Trustworthy bit vulnerabilities exist for $(Count) databases'  ,''  ,''  ,''  ,'Turn off the trustworthy bit or change the database owner to a login that is assigned a fixed server role other than sysadmin.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-S8'  ,''  ,'http://bit.ly/c6qhrC',13  ,8  ,'Symmetric key in system database' ,'Symmetric key exists in system database $(Database) ' ,'Microsoft recommends that symmetric keys not be created in SQL Server system databases master, msdb, model, and tempdb though symmetric keys will exist in the master database including the Service Master Key and a copy of every Database Master Key used in a user database.' ,0 ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Best Practices in Creating and Managing Symmetric and Asymmetric keys used for Encryption</Title><Link>http://support.microsoft.com/kb/2162020</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'Symmetric keys exist in $(Count) system databases'  ,''  ,'Investigate the possibility of removing symmetric keys from system databases'  ,''  ,'Investigate the possibility of removing the symmetric key from $(Database)'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-S9'  ,''  ,'http://bit.ly/afjhhN',13  ,5  ,'Weak encryption algorithm for secret keys' ,'Encryption algorithm for secret keys is weak for database $(Database) ' ,'A weak symmetric key has been detected in $(Database).  Microsoft recommends AES 128 bit and above for data encryption. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>SQL Server Security Best Practice</Title><Link>http://www.microsoft.com/technet/prodtechnol/sql/2005/sql2005secbestpract.mspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'Encryption algorithm for secret keys is weak for $(Count) databases'  ,'A weak symmetric key has been detected in $(Count) databases.  Microsoft recommends AED 128 bit and above for data encryption.'  ,''  ,''  ,'Update your encryption key to AES 128 bit or above. If AES is not supported by your operating system, use 3DES.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-SC1'  ,'$(li)If the current setting has been verified to provide the greatest value.'  ,'http://bit.ly/9WH8Id',14  ,5  ,'Non-default server setting' ,'$(Configuration) is set to value $(CurrentValue) ' ,'The $(Configuration) setting has been changed from the default value of $(DefaultValue) to $(CurrentValue). ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Setting Server Configuration Options</Title><Link>http://technet.microsoft.com/en-us/library/ms189631.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) non-default server settings'  ,'The default server setting has been changed.'  ,'It is recommended that the default value is used for the server setting.

However, all changes to server configuration settings require thorough testing to verify there are no adverse effects. '  ,'$(li)A non-default setting can have an adverse impact on performance.'  ,'It is recommended that the default value of -1 is used for the query wait (s) server setting.

However, all changes to server configuration settings require thorough testing to verify there are no adverse effects.  '  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-SC2'  ,''  ,'http://bit.ly/b6wWJZ',14  ,5  ,'Server configuration option requires restart' ,'SQL Server configuration option "$(Configuration)" has been changed but requires a server restart to take effect ' ,'Certain server configuration options do not take effect until after a server restart. ' ,0  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Setting Server Configuration Options</Title><Link>http://technet.microsoft.com/en-us/library/ms189631.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) SQL Server configuration options have been changed but require a server restart to take effect'  ,''  ,'Schedule a server restart when possible to finalize these configuration changes.  If a server restart is expected soon and the configuration options are non-critical, ignore this recommendatioon.'  ,''  ,'Schedule a server restart when possible to finalize this configuration change.  If a server restart is expected soon and the configuration option is non-critical, ignore this recommendation.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-SC3'  ,''  ,'http://bit.ly/9Oum0f',14  ,5  ,'Blocked process threshold too low' ,'The Blocked Process Threshold is set too low ($(CurrentValue) sec) ' ,'Setting the Blocked Process Threshold below 5 seconds may cause the deadlock monitor to run constantly and therefore should only be used for short term troubleshooting. ' ,0  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>blocked process threshold</Title><Link>http://msdn.microsoft.com/en-us/library/ms181150.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that the Blocked Process Threshold be set to at least 5 seconds or to 0 to disable the Blocked Process monitor.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-SC4'  ,''  ,'http://bit.ly/d6botW',14  ,5  ,'Non-dynamic lock configuration' ,'Lock configuration is not dynamic ' ,'A setting other than the default of 0 for the Locks configuration option may causes code termination and "out of locks" error messages if the specified number of locks is exceeded and may cause lock escalation to occur earlier increasing contention for locks.. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>How to troubleshoot SQL Server lock related problems and errors</Title><Link>http://support.microsoft.com/kb/2199576</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that the Locks option be set to the default setting of 0, which allows the database engine to allocate and deallocate locks based on system requirements. This option is going to be removed in a future version of SQL Server. If you are currently relying on a customized setting for this option, you should consider alternative solutions. 
Making this change will require a SQL Server restart.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-SC5'  ,''  ,'http://bit.ly/dyRuwl',14  ,5  ,'Default trace log files disabled' ,'Default trace log files are disabled ' ,'Default tracing tracks information about configuration and DDL changes to the SQL Server.  This information may be useful when troubleshooting issues with the database engine. ' ,0  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>SQL Server Default Trace</Title><Link>http://blogs.technet.com/b/beatrice/archive/2008/04/29/sql-server-default-trace.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that the default trace be enabled.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-SC6'  ,'$(li)If your database applications are making use of this feature, it may be undesirable to change this setting.  The following error message will be given when this option is set to ON and a result set is returned from a trigger: "Msg 524, Level 16, State 1, Procedure <Procedure Name>, Line <Line#> - A trigger returned a resultset and the server option ''disallow_results_from_triggers'' is true." $(li)Result sets are often returned to aid in testing and debugging triggers.'  ,'http://bit.ly/aLrJAj',14  ,2  ,'Disallow Results from Triggers is OFF' ,'Disallow results from triggers is OFF ' ,'The server is currently configured to allow triggers to return result sets. ' ,0  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>disallow results from triggers Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms186337.aspx</Link><Condition>SQLVersion = 10.5</Condition></RecommendationLink><RecommendationLink><Title>disallow results from triggers Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms186337(v=SQL.100).aspx</Link><Condition>SQLVersionMajor = 10 AND SQLVersion &lt; 10.5</Condition></RecommendationLink><RecommendationLink><Title>disallow results from triggers Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms186337(v=SQL.90).aspx</Link><Condition>SQLVersionMajor = 9</Condition></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,'$(li)Triggers that return result sets may cause unexpected behavior in applications that are not designed to work with them. $(li)This option will be removed in a future version of Microsoft SQL Server and triggers will no longer be able to return result sets.'  ,'It is recommended that the ''Disallow results from triggers'' option be set to ON.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-SC7'  ,''  ,'http://bit.ly/ayZ9vO',14  ,1  ,'CLR enabled' ,'The Common Language Runtime (CLR) option is enabled ' ,'The CLR Enabled option controls whether user assemblies may be run by SQL Server.  CLR cannot be enabled on servers which are using Lightweight Pooling. ' ,0 ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>clr enabled Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms175193.aspx</Link></RecommendationLink><RecommendationLink><Title>SQL Server Best Practices Article </Title><Link>http://msdn.microsoft.com/en-us/library/cc966485.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'Consider disabling CLR if user assemblies are not used in your environment.  Otherwise ignore this recommendation.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-SC8'  ,''  ,'http://bit.ly/9EoQfg',14  ,8  ,'McAfee buffer overflow protection detected' ,'McAfee Buffer Overflow Protection may cause SQL Server to lock up ' ,'McAfee Buffer Overflow Protection may inject a thread into SQL Server which may cause SQL Server to become unresponsive. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>You may experience performance and consistency issues with SQL Server when certain modules are loaded into SQL Server address space</Title><Link>http://support.microsoft.com/kb/2033238</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'Ensure all updates to McAfee Virus scan are applied.  You may need to disable Buffer Overflow Protection.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-SC9'  ,''  ,'http://bit.ly/ba7R6T',14  ,4  ,'Non-standard network packet size' ,'Network Packet Size ($(CurrentValue) B) is a non-standard value ' ,'The default Network Packet Size is 4,096 bytes, with the maximum recommended value 8,060 bytes.  SQL Server performs different memory allocation operations for values above 8,060 which can cause an increase in the process virtual address space that is not reserved for the buffer pool. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>network packet size Option</Title><Link>http://msdn.microsoft.com/en-us/library/aa196719(SQL.80).aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'If there is not a specific reason that the network packet size has been set outside of the customary range, consider setting the size back to the default of 4,096. Any non-standard setting should be validated as being no larger than the maximum packet size supported by the network or packets will be broken down into smaller packets at the network layer which could severely degrade performance of the network transport of the packets from SQL Server.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-SF1'  ,''  ,'http://bit.ly/9D1qwj',15  ,10  ,'' ,'The system page file is incorrectly sized ' ,'When a process asks for MEM_COMMIT memory via the VirtualAlloc API, physical pages of memory are allocated and space is reserved in the page file. Errors 801 and 802 will eventually be entered in the SQL Server''s error log when the memory cannot be successfully reserved.
When a process asks for MEM_COMMIT memory via the VirtualAlloc API, physical pages of memory are allocated and space is reserved in the page file. Errors 801 and 802 will eventually be entered in the SQL Server''s error log when the memory cannot be successfully reserved.
 ' ,'1'  ,''  ,''  ,''  ,''  ,''  ,'It is recommended that even on systems that do not page, the page file size should still be 1.5 times the size of the physical memory. 
The total available system page file size is xxx.xGB and the server has xxx.xGB of physical memory.It is recommended that even on systems that do not page, the page file size should still be 1.5 times the size of the physical memory. 
The total available system page file size is xxx.xGB and the server has xxx.xGB of physical memory.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-UG1'  ,''  ,'http://bit.ly/9m5FCp',16  ,3  ,'' ,'Upgrading certain system components may improve performance ' ,'The list below shows ranks the system components by the amount of stress they are under. Upgrading the system will improve your overall performance: 1. The I/O subsystem - (generating xx% of the waits), 2. The Network subsystem -  (generating xx% of the waits), 3. The Memory subsystem -  (generating xx% of the waits), 4. The CPU subsystem - (generating xx% of the waits) ' ,'3'  ,''  ,''  ,''  ,''  ,''  ,'It is recommended that the waits for the various components should be examined and, if found to be excessive, upgraded to improve system performance.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-VL1'  ,''  ,'http://bit.ly/bCtPRS',17  ,6  ,'' ,'The following databases have highly fragmented transaction logs: $(li) Database xxx - xxx virtual log files $(li)Database xxx - xxx virtual log files ' ,'Fragmentation occurs where the transaction log file was initially incorrectly sized far too small and has gone through many rounds of autogrowth. Fragmented transaction log files containing many virtual log files can significantly slow performance and should be corrected. ' ,'2'  ,''  ,'$(Count) databases have highly fragmented transaction log files'  ,''  ,''  ,''  ,'It is recommended that these transaction log files be defragmented and their size increased to improve performance.'  ,0,''
,0)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-W1'  ,'$(li)CXPACKET waits should not be seen as a problem.  They are only an indication of parallel query execution.  $(li)PAGEIOLATCH_XX waits should not be seen as a problem.  They are only an indication that waits occurred when data pages are being read into the buffer pool.$(li)If no performance problems have been experienced by any of the ''Affected Batches,'' then the CXPACKET and PAGEIOLATCH_XX waits may be negligible.'  ,'',18  ,5  ,'High CXPACKET and PAGEIOLATCH_XX waits' ,'High CXPACKET and PAGEIOLATCH_XX waits ' ,'The CXPACKET and PAGEIOLATCH_XX waits were found among the highest waits experienced during the analysis. ' ,'3'  ,''  ,''  ,''  ,''  ,'$(li)CXPACKET waits occur when a parallel query is executed and one or more threads have to wait for another thread to complete.  The time spent in the waiting threads of the parallel query is the time that is measured by CXPACKET waits.  When CXPACKET waits are high, this could be an indication that the query optimizer could not properly estimate equal amounts of work for each of the parallel threads.$(li)PAGEIOLATCH_XX waits occur when a data page was not found in the buffer pool and a physical I/O must be performed to read the page into the buffer pool.  When PAGEIOLATCH_XX waits are high, this could be an indication that a large number of data pages are being loaded into the buffer pool from disk to satisfy various queries.$(li)When both CXPACKET and PAGEIOLATCH_XX waits are high, this could mean that there are parallelized queries performing large table scans and the query optimizer was not able to correctly parallelize the query into equal sets for each of the parallel threads.  This can occur when the query optimizer cannot find a suitable non-clustered index to speed up the query, possibly because no such index exists, the index statistics are out-of-date, a function is used on a column within a query filter predicate, or an implicit conversion is occurring within a query filter predicate.  Additionally, fragmentation could be a contributing factor due to the fragmentation causing an inefficient read-ahead for index range scans.'  ,'It is recommended that you review the ''Affected Batches'' below and consider the following: $(li)Update the relevant statistics objects to improve query plan generation $(li)Rebuild highly fragmented indexes for the tables used by the ''Affected Batches''$(li)Revise filter criteria to prevent implicit conversions which could be causing table scans$(li)Add missing indexes to prevent excessive I/O $(li)As a last resort, you may want to try reducing MAXDOP for the offending queries within the ''Affected Batches.''  If you have a NUMA system, then try setting MAXDOP equal to the number of processor cores available in a single NUMA node.$(li)Evaluate the plan cost and execution frequency to determine if the server configuration option "cost threshold for parallelism" should be adjusted to prevent SQL Server from using parallelism in execution plans which do not benefit from it.$(li)Review the sys.dm_io_virtual_file_stats DMV output to determine whether the I/O characteristics have changed from your I/O subsystem baseline measurements.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-W2'  ,'$(li)If the performance benefit of parallelizing the short running queries outweighs the overhead required to initialize, synchronize, and terminate the parallel plans.'  ,'',18  ,10  ,'Parallelism threshold too low' ,'High CXPACKET waits with the parallelism threshold set below recommended levels ' ,'High CXPACKET waits were found and the Cost Threshold for Parallelism configuration value of $(CurrentThreshold) is set below the recommended level of $(RecommendedThreshold).  ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>sys.dm_os_wait_stats</Title><Link>http://msdn.microsoft.com/en-us/library/ms179984.aspx</Link></RecommendationLink><RecommendationLink><Title>Performance Tuning using the Waits and Queues</Title><Link>http://msdn.microsoft.com/en-us/library/cc966413.aspx</Link></RecommendationLink><RecommendationLink><Title>Parallelism: Hurry up and wait</Title><Link>http://sqldoctor.idera.com/wait-stats/parallelism-hurry-up-and-wait/</Link></RecommendationLink><RecommendationLink><Title>Parallelism: Stop waiting!</Title><Link>http://sqldoctor.idera.com/wait-stats/parallelism-stop-waiting/</Link></RecommendationLink><RecommendationLink><Title>Waits and Queues</Title><Link>http://technet.microsoft.com/en-us/sqlserver/gg508897.aspx</Link></RecommendationLink><RecommendationLink><Title>Performance Tuning with Wait Statistics</Title><Link>http://blogs.msdn.com/b/joesack/archive/2009/04/22/presentation-deck-for-performance-tuning-with-wait-statistics.aspx</Link></RecommendationLink><RecommendationLink><Title>Pinal Dave - Wait Types and Wait Queues</Title><Link>http://blog.sqlauthority.com/2011/02/01/sql-server-wait-stats-wait-types-wait-queues-day-0-of-28-2/</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,'$(li)This can cause queries to become parallelized that would not benefit from parallel execution.  These extra parallel queries may be contributing to higher CXPACKET waits which occur when parallel queries are executed.   $(li)Short running queries do not benefit from parallelism because the additional time required to initialize, synchronize, and terminate parallel plans can outweigh the benefits of distributing the workload across multiple processors.'  ,'It is recommended that the ''Cost Threshold for Parallelism'' configuration value should be increased to $(RecommendedThreshold) or higher.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-W3'  ,'$(li)If the current ''max degree of parallelism'' has been tuned for the current hardware and workload requirements of the SQL Server instance.$(li)If you are not experiencing poor performance from parallelized queries or parallel queries are not monopolizing CPU usage, then the CXPACKET waits described above may be negligible in your environment.'  ,'',18  ,10  ,'CXPACKET waits with current max degree of parallelism setting' ,'High CXPACKET waits found with the current max degree of parallelism setting ' ,'CXPACKET waits are among the highest waits found during the analysis and the current max degree of parallelism setting is $(CurrentMaxDOP). ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>sys.dm_os_wait_stats</Title><Link>http://msdn.microsoft.com/en-us/library/ms179984.aspx</Link></RecommendationLink><RecommendationLink><Title>Performance Tuning using the Waits and Queues</Title><Link>http://msdn.microsoft.com/en-us/library/cc966413.aspx</Link></RecommendationLink><RecommendationLink><Title>Parallelism: Hurry up and wait</Title><Link>http://sqldoctor.idera.com/wait-stats/parallelism-hurry-up-and-wait/</Link></RecommendationLink><RecommendationLink><Title>Parallelism: Stop waiting!</Title><Link>http://sqldoctor.idera.com/wait-stats/parallelism-stop-waiting/</Link></RecommendationLink><RecommendationLink><Title>Waits and Queues</Title><Link>http://technet.microsoft.com/en-us/sqlserver/gg508897.aspx</Link></RecommendationLink><RecommendationLink><Title>Performance Tuning with Wait Statistics</Title><Link>http://blogs.msdn.com/b/joesack/archive/2009/04/22/presentation-deck-for-performance-tuning-with-wait-statistics.aspx</Link></RecommendationLink><RecommendationLink><Title>Pinal Dave - Wait Types and Wait Queues</Title><Link>http://blog.sqlauthority.com/2011/02/01/sql-server-wait-stats-wait-types-wait-queues-day-0-of-28-2/</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,'$(li)An incorrectly configured ''max degree of parallelism'' can cause inefficiencies with parallel query execution by requiring more CPU cores for the parallel plan than physically available at the time of execution.$(li)A single query could monopolize all available CPU cores and prevent other queries from running. '  ,'It is recommended that the ''Max Degree of Parallelism'' configuration option should be set to a value not exceeding half the number of available physical processor cores, ignoring any logical CPUs from hyper-threading. If you have a NUMA system, then try setting ''Max Degree of Parallelism'' equal to the number of processor cores available in a single NUMA node. Also, no matter how many cores are available the parameter should not be set above eight.  '  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-W4'  ,'$(li)If you are not experiencing poor performance from parallelized queries, then the CXPACKET waits described above may be negligible in your environment.'  ,'',18  ,10  ,'High CXPACKET waits' ,'The server is experiencing high CXPACKET waits ' ,'CXPACKET waits are among the highest waits found during the analysis.  These waits are occur when multiple threads are used to run a query in parallel and one or more of the threads lag behind causing the other threads to wait.   ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>sys.dm_os_wait_stats</Title><Link>http://msdn.microsoft.com/en-us/library/ms179984.aspx</Link></RecommendationLink><RecommendationLink><Title>Performance Tuning using the Waits and Queues</Title><Link>http://msdn.microsoft.com/en-us/library/cc966413.aspx</Link></RecommendationLink><RecommendationLink><Title>Parallelism: Hurry up and wait</Title><Link>http://sqldoctor.idera.com/wait-stats/parallelism-hurry-up-and-wait/</Link></RecommendationLink><RecommendationLink><Title>Parallelism: Stop waiting!</Title><Link>http://sqldoctor.idera.com/wait-stats/parallelism-stop-waiting/</Link></RecommendationLink><RecommendationLink><Title>Waits and Queues</Title><Link>http://technet.microsoft.com/en-us/sqlserver/gg508897.aspx</Link></RecommendationLink><RecommendationLink><Title>Performance Tuning with Wait Statistics</Title><Link>http://blogs.msdn.com/b/joesack/archive/2009/04/22/presentation-deck-for-performance-tuning-with-wait-statistics.aspx</Link></RecommendationLink><RecommendationLink><Title>Pinal Dave - Wait Types and Wait Queues</Title><Link>http://blog.sqlauthority.com/2011/02/01/sql-server-wait-stats-wait-types-wait-queues-day-0-of-28-2/</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,'$(li)The query optimizer may not be able to properly estimate the cost of the parallel query plans.  $(li)Indexes may be highly fragmented.  Highly fragmented indexes can cause inefficiencies with range scans because the SQL Server read-ahead logic is unable to read large page ranges into memory with single I/O requests.  Instead, a greater number of smaller IO requests may be performed which can slow down one or more of the parallel threads.$(li)Statistics may be out-of-date.  Without up-to-date statistics, the query optimizer cannot properly estimate query plan costs, causing one or more threads to get a disproportionate amount of work to perform.$(li)Query filter predicates may contain functions on column values forcing a scan to be used instead of a seek.$(li)Query filter predicates may be causing an implicit conversion of a column value because of mismatched data types.'  ,'It is recommended that you review the server activity and consider the following: $(li)Rebuild highly fragmented indexes to improve read-ahead performance for range scans$(li)Update the relevant statistics objects to improve query plan generation $(li)Revise filter criteria to prevent implicit conversions which could be causing index/table scans$(li)Revise filter criteria to prevent functions from being used on columns which could be causing index/table scans$(li)Add missing indexes to improve performance of queries$(li)Reduce MAXDOP for the offending queries.  If you have a NUMA system, then try setting MAXDOP equal to the number of processor cores available in a single NUMA node.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-W5'  ,''  ,'',18  ,10  ,'High ASYNC_NETWORK_IO waits' ,'The server is experiencing high ASYNC_NETWORK_IO waits ' ,'High ASYNC_NETWORK_IO waits normally indicate one or more applications are not pulling result sets fast enough from the SQL Server instance. This is usually an indication of the behavior being exhibited by the client application. This behavior may be expected, such as an application that uses a data reader to display one page of results at a time without requerying, or it may be application that processes data in a suboptimal fashion. A low percentage of time this may indicate a network latency issue. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>sys.dm_os_wait_stats</Title><Link>http://msdn.microsoft.com/en-us/library/ms179984.aspx</Link></RecommendationLink><RecommendationLink><Title>Performance Tuning using the Waits and Queues</Title><Link>http://msdn.microsoft.com/en-us/library/cc966413.aspx</Link></RecommendationLink><RecommendationLink><Title>Troubleshooting ASYNC_NETWORK_IO</Title><Link>http://blogs.msdn.com/b/joesack/archive/2009/01/09/troubleshooting-async-network-io-networkio.aspx</Link></RecommendationLink><RecommendationLink><Title>Waits and Queues</Title><Link>http://technet.microsoft.com/en-us/sqlserver/gg508897.aspx</Link></RecommendationLink><RecommendationLink><Title>Performance Tuning with Wait Statistics</Title><Link>http://blogs.msdn.com/b/joesack/archive/2009/04/22/presentation-deck-for-performance-tuning-with-wait-statistics.aspx</Link></RecommendationLink><RecommendationLink><Title>Pinal Dave - Wait Types and Wait Queues</Title><Link>http://blog.sqlauthority.com/2011/02/01/sql-server-wait-stats-wait-types-wait-queues-day-0-of-28-2/</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that you review the Affected Batches and ensure the following: $(li)The applications are processing the result sets efficiently $(li)The queries are not pulling more data than needed by the calling application $(li)The SQL Server instance is not experiencing network problems $(li)The client machines hosting the calling applications are not experiencing network problems '  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-W6'  ,''  ,'',18  ,10  ,'High THREADPOOL waits' ,'The server is experiencing high THREADPOOL waits due to the Max Worker Threads option being too low ' ,'The Max Worker Threads option is set too low causing high THREADPOOL waits.  This is causing tasks to wait too long for worker threads to become available. ' ,3  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>sys.dm_os_wait_stats</Title><Link>http://msdn.microsoft.com/en-us/library/ms179984.aspx</Link></RecommendationLink><RecommendationLink><Title>Performance Tuning using the Waits and Queues</Title><Link>http://msdn.microsoft.com/en-us/library/cc966413.aspx</Link></RecommendationLink><RecommendationLink><Title>max worker threads Option</Title><Link>http://msdn.microsoft.com/en-us/library/ms187024.aspx</Link></RecommendationLink><RecommendationLink><Title>Waits and Queues</Title><Link>http://technet.microsoft.com/en-us/sqlserver/gg508897.aspx</Link></RecommendationLink><RecommendationLink><Title>Performance Tuning with Wait Statistics</Title><Link>http://blogs.msdn.com/b/joesack/archive/2009/04/22/presentation-deck-for-performance-tuning-with-wait-statistics.aspx</Link></RecommendationLink><RecommendationLink><Title>Pinal Dave - Wait Types and Wait Queues</Title><Link>http://blog.sqlauthority.com/2011/02/01/sql-server-wait-stats-wait-types-wait-queues-day-0-of-28-2/</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,''  ,''  ,''  ,''  ,'It is recommended that you change the Max Worker Threads option to zero.  This will allow the SQL Server Database Engine to calculate the optimal number of threads. '  ,1,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-W7'  ,'$(li)When the server is ''warming up,'' there will be a significant amount of PAGEIOLATCH_XX waits due to SQL Server loading needed pages into the buffer pool.  High PAGEIOLATCH_XX should normally be ignored until the SQL Server instance has had a chance to run long enough to load the most often needed data pages into the buffer pool.$(li)When executing large reports that require large table scans or index range scans.$(li)If you are not experiencing poor performance from any of the affected batches, then the waits described above may be negligible in your environment.'  ,'',18  ,'10'  ,'High PAGEIOLATCH_XX waits' ,'Database [$(Database)] is experiencing high PAGEIOLATCH_XX waits ' ,'The queries using database [$(Database)] may be impacted by PAGEIOLATCH_XX waits.  PAGEIOLATCH_XX waits occur when a data page was not found in the buffer pool and a physical I/O must be performed to read the page into the buffer pool.  When PAGEIOLATCH_XX waits are high, this could be an indication that a large number of data pages are being loaded into the buffer pool from disk to satisfy various queries. ' ,'2'  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>sys.dm_os_wait_stats</Title><Link>http://msdn.microsoft.com/en-us/library/ms179984.aspx</Link></RecommendationLink><RecommendationLink><Title>Performance Tuning using the Waits and Queues</Title><Link>http://msdn.microsoft.com/en-us/library/cc966413.aspx</Link></RecommendationLink><RecommendationLink><Title>Waits and Queues</Title><Link>http://technet.microsoft.com/en-us/sqlserver/gg508897.aspx</Link></RecommendationLink><RecommendationLink><Title>Performance Tuning with Wait Statistics</Title><Link>http://blogs.msdn.com/b/joesack/archive/2009/04/22/presentation-deck-for-performance-tuning-with-wait-statistics.aspx</Link></RecommendationLink><RecommendationLink><Title>Pinal Dave - Wait Types and Wait Queues</Title><Link>http://blog.sqlauthority.com/2011/02/01/sql-server-wait-stats-wait-types-wait-queues-day-0-of-28-2/</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) databases are experiencing high PAGEIOLATCH_XX waits '  ,'Queries may be impacted by PAGEIOLATCH_XX waits.  PAGEIOLATCH_XX waits occur when a data page was not found in the buffer pool and a physical I/O must be performed to read the page into the buffer pool.  When PAGEIOLATCH_XX waits are high, this could be an indication that a large number of data pages are being loaded into the buffer pool from disk to satisfy various queries.'  ,'You should consider the following:$(li)Review all query optimization recommendations to determine if efficiency changes can be made to the queries.  $(li)Revise filter criteria to prevent implicit conversions which could be causing index/table scans$(li)Revise filter criteria to prevent functions from being used on columns which could be causing index/table scans$(li)Ensure statistics are up-to-date.  Without up-to-date statistics, the query optimizer will not be able to generate an efficient execution plan and could potentially cause the query to perform an excessive amount of I/O.$(li)Ensure large indexes are not highly fragmented.  Fragmented indexes reduce the efficiency of the read-ahead logic used for index range scans.
$(li)Review all missing indexes to determine if new indexes can be added to improve query performance and reduce the amount of I/O required to satisfy the workload requirements.$(li)Review memory recommendations to ensure SQL Server is configured correctly for optimum memory performance.$(li)Review disk recommendations to determine if optimizations can be made to improve I/O performance on the drives hosting the database data files.$(li)Review the sys.dm_io_virtual_file_stats DMV output to determine whether the I/O characteristics have changed from your I/O subsystem baseline measurements.'  ,'$(li)This may be an indication of poorly optimized queries.  Queries which are defined without search predicates or cannot find an efficient index to use may require a scan of all data pages for the table.  This can cause excessive I/O and contribute to the PAGEIOLATCH_XX waits.$(li)Query filter predicates may be causing an implicit conversion to occur on a column value due to mismatched data types.$(li)Query filter predicates may contain functions on column values forcing a scan to be used instead of a seek.$(li)This may be an indication of out-of-date statistics.  Without up-to-date statistics, the query optimizer cannot generate an efficient execution plan due to inaccurate cost estimates.  This can cause the query optimizer to choose an inefficient data access path and generate additional I/O which can contribute to the PAGEIOLATCH_XX waits.$(li)Fragmentation can contribute to longer PAGEIOLATCH_XX wait times when index range scans are performed because the SQL Server read-ahead logic may have to perform single page I/O requests instead of larger multi-page I/O requests.$(li)This may be an indication that the buffer pool is under high pressure due to large table scans or because a large number of dirty pages exist in the buffer pool that must first be written to disk before new data can be loaded.  This slowdown due to flushing out existing pages from the buffer pool can contribute to the time spent in the PAGEIOLATCH_XX waits.$(li)This could indicate that the workload requirements for the server are too high based on the available amount of buffer pool memory.$(li)PAGEIOLATCH_XX waits can result when problems or bottlenecks exists within the disk subsystem.'  ,'You should consider the following:$(li)Review all query optimization recommendations to determine if efficiency changes can be made to the queries.  $(li)Revise filter criteria to prevent implicit conversions which could be causing index/table scans$(li)Revise filter criteria to prevent functions from being used on columns which could be causing index/table scans$(li)Ensure statistics are up-to-date.  Without up-to-date statistics, the query optimizer will not be able to generate an efficient execution plan and could potentially cause the query to perform an excessive amount of I/O.$(li)Ensure large indexes are not highly fragmented.  Fragmented indexes reduce the efficiency of the read-ahead logic used for index range scans.$(li)Review all missing indexes to determine if new indexes can be added to improve query performance and reduce the amount of I/O required to satisfy the workload requirements.$(li)Review memory recommendations to ensure SQL Server is configured correctly for optimum memory performance.$(li)Review disk recommendations to determine if optimizations can be made to improve I/O performance on the drives hosting the database data files.$(li)Review the sys.dm_io_virtual_file_stats DMV output to determine whether the I/O characteristics have changed from your I/O subsystem baseline measurements.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-W8'  ,'$(li)If you are not experiencing poor performance from operations on this index, then the waits described above may be negligible in your environment.'  ,'',18  ,10  ,'High PAGELATCH_EX and PAGELATCH_SH waits on index' ,'$(IndexId>1?Index [$(IndexName)]:Clustered index) on table [$(Schema)].[$(Table)] is experiencing high PAGELATCH_EX and/or PAGELATCH_SH waits ' ,'The performance of the $(IndexId>1?index [$(IndexName)]:clustered index) on table [$(Schema)].[$(Table)] is adversely impacted by PAGELATCH_EX and/or PAGELATCH_SH waits.   ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>sys.dm_os_wait_stats</Title><Link>http://msdn.microsoft.com/en-us/library/ms179984.aspx</Link></RecommendationLink><RecommendationLink><Title>Performance Tuning using the Waits and Queues</Title><Link>http://msdn.microsoft.com/en-us/library/cc966413.aspx</Link></RecommendationLink><RecommendationLink><Title>Waits and Queues</Title><Link>http://technet.microsoft.com/en-us/sqlserver/gg508897.aspx</Link></RecommendationLink><RecommendationLink><Title>Performance Tuning with Wait Statistics</Title><Link>http://blogs.msdn.com/b/joesack/archive/2009/04/22/presentation-deck-for-performance-tuning-with-wait-statistics.aspx</Link></RecommendationLink><RecommendationLink><Title>Pinal Dave - Wait Types and Wait Queues</Title><Link>http://blog.sqlauthority.com/2011/02/01/sql-server-wait-stats-wait-types-wait-queues-day-0-of-28-2/</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) indexes are experiencing high PAGELATCH_EX and/or PAGELATCH_SH waits '  ,'Index performance is being adversely impacted by PAGELATCH_EX and/or PAGELATCH_SH waits.  This can be an indication of contention on the same index range by concurrent inserts.  If concurrent inserts are being made to the same page, the inserts are serialized using latches.  These inserts can also cause page splits that keeps the latch while allocating the new page which will take additional time to complete.  Additionally, reads accessing these pages would conflict with the latches causing additional waits.'  ,'It is recommended that the index be reviewed to determine if it can be restructured in order to distribute the range being inserted across multiple partitions. If your SQL Server version does not support index partitioning, then it is recommended that the index be reviewed to determine if the columns of the index key can be changed so that the inserts are distributed across the pages of the index.  If page splits are impacting the index, the fill factor of the index should be adjusted to reduce the occurrence of the page splits.'  ,'$(li)When PAGELATCH_EX or PAGELATCH_SH waits occur on an index this can be an indication of contention on the same index range by concurrent inserts or updates.  If concurrent inserts/updates are made to the same page, the operations are serialized using latches.$(li)These inserts/updates can also cause page splits that keep the latch while allocating the new page which will take additional time to complete. Additionally, reads accessing these pages would conflict with the latches causing additional waits.'  ,'It is recommended that the index be reviewed to determine if it can be restructured in order to distribute the range being inserted across multiple partitions. If your SQL Server version does not support index partitioning, then it is recommended that the index be reviewed to determine if the columns of the index key can be changed so that the inserts are distributed across the pages of the index.  If page splits are impacting the index, the fill factor of the index should be adjusted to reduce the occurrence of the page splits.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-W9'  ,'$(li)If you are not experiencing poor performance from operations on this table, then the waits described above may be negligible in your environment.'  ,'',18  ,10  ,'High PAGELATCH_EX and PAGELATCH_SH waits on table' ,'Table [$(Schema)].[$(Table)] is experiencing high PAGELATCH_EX and/or PAGELATCH_SH waits ' ,'The performance of table [$(Schema)].[$(Table)] is adversely impacted by PAGELATCH_EX and/or PAGELATCH_SH waits.   ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>sys.dm_os_wait_stats</Title><Link>http://msdn.microsoft.com/en-us/library/ms179984.aspx</Link></RecommendationLink><RecommendationLink><Title>Performance Tuning using the Waits and Queues</Title><Link>http://msdn.microsoft.com/en-us/library/cc966413.aspx</Link></RecommendationLink><RecommendationLink><Title>Waits and Queues</Title><Link>http://technet.microsoft.com/en-us/sqlserver/gg508897.aspx</Link></RecommendationLink><RecommendationLink><Title>Performance Tuning with Wait Statistics</Title><Link>http://blogs.msdn.com/b/joesack/archive/2009/04/22/presentation-deck-for-performance-tuning-with-wait-statistics.aspx</Link></RecommendationLink><RecommendationLink><Title>Pinal Dave - Wait Types and Wait Queues</Title><Link>http://blog.sqlauthority.com/2011/02/01/sql-server-wait-stats-wait-types-wait-queues-day-0-of-28-2/</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) tables are experiencing high PAGELATCH_EX and/or PAGELATCH_SH waits '  ,'Table performance is being adversely impacted by PAGELATCH_EX and/or PAGELATCH_SH waits.  This can be an indication of contention for access to the data pages by concurrent inserts/updates.  If concurrent inserts/updates are made to the same page, the operations are serialized using latches.  Additionally, reads accessing these pages would conflict with the latches causing additional waits.'  ,'It is recommended that the table be reviewed to determine if it can be restructured in order to distribute the range being inserted across multiple partitions. If your SQL Server version does not support table partitioning, then it is recommended that the table be reviewed to determine if a clustered index can be created on the table so that the inserts are distributed across the pages of the index.'  ,'$(li)PAGELATCH_EX or PAGELATCH_SH waits that occur on a table can be an indication of contention for access to the data pages by concurrent inserts/updates.  If concurrent inserts/updates are made to the same page, the operations are serialized using latches.  Additionally, reads accessing these pages would conflict with the latches causing additional waits.'  ,'It is recommended that the table be reviewed to determine if it can be restructured in order to distribute the range being inserted across multiple partitions. If your SQL Server version does not support table partitioning, then it is recommended that the table be reviewed to determine if a clustered index can be created on the table so that the inserts are distributed across the pages of the index.'  ,0,''
,1)
SET @multilineInput = 'You should consider adding more files to the database.  This will allow for additional distribution of updates to allocation pages. SQL Server''s proportional fill algorithm will allocate based on the amount of free space in each of the files proportionately, so new files should be created with the size proportional to the amount of free space in the existing data files.  Additionally, if the data files are allowed to autogrow, then the autogrowth settings should be equalized across all data files.'
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-W10'  ,'$(li)If you are not experiencing poor performance from operations on this database, then the waits described above may be negligible in your environment.'  ,'',12  ,10  ,'High PAGELATCH_UP waits' 
,'Database [$(Database)] is experiencing high PAGELATCH_UP waits' 
,'The performance of database [$(Database)] is adversely impacted by PAGELATCH_UP waits. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>sys.dm_os_wait_stats</Title><Link>http://msdn.microsoft.com/en-us/library/ms179984.aspx</Link></RecommendationLink><RecommendationLink><Title>Performance Tuning using the Waits and Queues</Title><Link>http://msdn.microsoft.com/en-us/library/cc966413.aspx</Link></RecommendationLink><RecommendationLink><Title>Waits and Queues</Title><Link>http://technet.microsoft.com/en-us/sqlserver/gg508897.aspx</Link></RecommendationLink><RecommendationLink><Title>Performance Tuning with Wait Statistics</Title><Link>http://blogs.msdn.com/b/joesack/archive/2009/04/22/presentation-deck-for-performance-tuning-with-wait-statistics.aspx</Link></RecommendationLink><RecommendationLink><Title>Pinal Dave - Wait Types and Wait Queues</Title><Link>http://blog.sqlauthority.com/2011/02/01/sql-server-wait-stats-wait-types-wait-queues-day-0-of-28-2/</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) databases are experiencing high PAGELATCH_UP waits ','Database performance is being adversely impacted by PAGELATCH_UP waits.  This indicates that contention is occurring due to updates being made on allocation pages and is usually a sign that more files are needed for the database.  Having multiple files will allow the allocations to be distributed which will reduce the demands on the allocation pages within the existing files.'
,'You should consider adding more files to the database.  This will allow for additional distribution of updates to allocation pages. SQL Server''s proportional fill algorithm will allocate based on the amount of free space in each of the files proportionately, so new files should be created with the size proportional to the amount of free space in the existing data files.  Additionally, if the data files are allowed to autogrow, then the autogrowth settings should be equalized across all data files.  However, adding a new file with significantly more free space can result in a hot spot on that file and continued PAGELATCH_UP waits.You should consider adding more files to the database.  This will allow for additional distribution of updates to allocation pages. SQL Server''s proportional fill algorithm will allocate based on the amount of free space in each of the files proportionately, so new files should be created with the size proportional to the amount of free space in the existing data files.  Additionally, if the data files are allowed to autogrow, then the autogrowth settings should be equalized across all data files.  However, adding a new file with significantly more free space can result in a hot spot on that file and continued PAGELATCH_UP waits.','$(li)This indicates that contention is occurring due to updates made on allocation pages and is usually a sign that more files are needed for the database.  Having multiple files will allow the allocations to be distributed which will reduce the demands on the allocation pages within the existing files.' ,@multilineInput  ,0,'',1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-R1'  ,''  ,'',12  ,10  ,'Database has suspect pages' ,'Database [$(Database)] has suspect pages ' ,'Suspect pages have been found in database [$(Database)] based on information in the msdb..suspect_pages table.  The pages for this database are suspected of being bad, but may be fine. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Understanding and Managing the suspect_pages Table</Title><Link>http://msdn.microsoft.com/en-us/library/ms191301.aspx</Link></RecommendationLink><RecommendationLink><Title>Performing Page Restores</Title><Link>http://msdn.microsoft.com/en-us/library/ms175168.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) databases have suspect pages '  ,'Suspect pages have been found based on information in the msdb..suspect_pages table.  The pages for the databases are suspected of being bad, but may be fine.'  ,'It is recommended that you run DBCC CHECKDB against the database with the NO_INFOMSGS option so that only error messages are shown.  These error messages should be reviewed and researched using SQL Server Books Online.'  ,''  ,'It is recommended that DBCC CHECKDB be run against database [$(Database)] with the NO_INFOMSGS option so that only error messages are shown.  These error messages should be reviewed and researched using SQL Server Books Online.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-R2'  ,''  ,'',12  ,10  ,'Backups should be on separate volumes' ,'Backups for database [$(Database)] are on the same volume as the data files ' ,'If the device containing the database fails, neither the data files nor backup files will be available.  Additionally, using separate devices will optimize the I/O performance for the database while backups are being performed. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Backup Devices</Title><Link>http://msdn.microsoft.com/en-us/library/ms179313.aspx</Link></RecommendationLink><RecommendationLink><Title>Optimizing Backup and Restore Performance in SQL Server</Title><Link>http://msdn.microsoft.com/en-us/library/ms190954.aspx</Link></RecommendationLink><RecommendationLink><Title>Introduction to Backup and Restore Strategies in SQL Server</Title><Link>http://msdn.microsoft.com/en-us/library/ms191239.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) databases should be on separate volumes'  ,'If the device containing the database fails, neither the data files nor backup files will be available.  Additionally, using separate devices will optimize the IO performance for the database while backups are being performed.'  ,'It is recommended that the database data files and backup files be placed on separate devices.'  ,''  ,'It is recommended that the database data files and backup files be stored on separate devices, such as two different physical disks, different LUNs of a SAN, or separate arrays. Note that this analysis only checks logical volumes. While the analysis considers each logical volume as a unique device, mount points are not identified as unique devices. Verify that each logical volume and mount point is located on a separate physical device. 

It is also recommended that you check the database backup history to ensure it correctly reflects the locations of your data files and backup files. To clean your backup history, run the sp_delete_database_backuphistory stored procedure.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-R3'  ,''  ,'',12  ,10  ,'Database integrity should be checked' ,'The integrity of database [$(Database)] has not been checked in $(DaysSinceLastCheck) days ' ,'The physical integrity of a database [$(Database)] should be checked regularly to allow for early detection of errors so that downtime and data loss can be minimized. ' ,2  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>DBCC CHECKDB</Title><Link>http://msdn.microsoft.com/en-us/library/ms176064.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'The integrity of $(Count) databases should be checked'  ,'The physical integrity of databases should be checked regularly to allow for early detection of errors so that downtime and data loss can be minimized.'  ,'It is recommended that you run DBCC CHECKDB against the databases to ensure there are no data integrity problems.'  ,''  ,'It is recommended that you run DBCC CHECKDB against database [$(Database)] to ensure there are no data integrity problems.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-R4'  ,''  ,'',12  ,1  ,'Database using Simple recovery model' ,'Database [$(Database)] is using Simple Recovery Model ' ,'Using Simple Recovery Model for database [$(Database)] prevents point-in-time recovery which will increase the amount of data loss in the event of a disaster recovery. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Choosing the Recovery Model for a Database</Title><Link>http://msdn.microsoft.com/en-us/library/ms175987.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) databases are using Simple Recovery Model'  ,'Using Simple Recovery Model for databases prevents point-in-time recovery which will increase the amount of data loss in the event of a disaster recovery.'  ,'It is recommended that you use Full Recovery Model on all production databases and that frequent transaction log backups are taken.  This will ensure recoverability with minimal loss of data.'  ,''  ,'It is recommended that Full Recovery Model is used on all production databases and that frequent transaction log backups are taken.  This will ensure recoverability with minimal loss of data.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-R5'  ,''  ,'',12  ,1  ,'Database has outdated backups' ,'Database [$(Database)] has outdated backups ' ,'Up-to-date backups are not available for database [$(Database)].  The lack of backups will hinder the ability to recover the database in the event of a disaster recovery. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Introduction to Backup and Restore Strategies in SQL Server</Title><Link>http://msdn.microsoft.com/en-us/library/ms191239.aspx</Link></RecommendationLink><RecommendationLink><Title>Unbelievable tale of disaster and recovery</Title><Link>*http://www.sqlskills.com/BLOGS/PAUL/post/Unbelievable-tale-of-disaster-and-recovery.aspx</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) databases have outdated backups'  ,'Up to date backups are not available for databases.  The lack of backups will hinder the ability to recover the databases in the event of a disaster recovery.'  ,'It is recommended that a database maintenance plan be put in place to keep the database backups up-to-date.'  ,''  ,'It is recommended that a database maintenance plan be put in place to keep the database backups up to date.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-R6'  ,''  ,'',12  ,'1'  ,'Recent backup file has been deleted or moved' ,'The most recent backup for database [$(Database)] has been deleted or moved to another location. ' ,'The most recent backup for database [$(Database)] had been written to [$(FileName)], but this file no longer exists. Without this file, you will not be able to fully recover your database to its most recent state. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>SQL Server Backup Best Practices</Title><Link>http://www.brentozar.com/archive/2007/10/backing-up-sql-server-my-own-mediocre-practices/</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) databases are missing backup files'  ,'Recent backups no longer exist for $(Count) databases on this server. Without these files, you will not be able to fully recover your databases to their most recent states.'  ,'It is recommended that at least one recent backup set for each database be maintained on disk for fastand accuraterecovery. To ensure you will be able to restore your databases in the event of a disaster recovery,identify the alternate location of these backup sets or perform new backups.'  ,''  ,'It is recommended that at least one recent backup set be maintained on disk for fast and accuraterecovery. To ensure you will be able to restore this database in the event of a disaster recovery,identify the alternate location of this backup set or perform a new backup.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-R7'  ,''  ,'',12  ,1  ,'Database transaction log has not been backed up recently' ,'Database [$(Database)] is set to [$(RecoveryMode)] recovery mode, and the transaction log has not been backed up in [$(Age)] days. ' ,'Databases that do not use the simple recovery model maintain a log of the transactions performed on that database. If the transaction log is not backed up regularly, the log files can become very large and point-in-time recovery becomes impossible. ' ,1  ,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>How to stop the transaction log of a SQL Server database from growing unexpectedly</Title><Link>http://support.microsoft.com/kb/873235</Link></RecommendationLink></ArrayOfRecommendationLink>'  ,'$(Count) databases maintain a transaction log which has not been backed up recently'  ,'Databases that do not use the simple recovery model maintain a log of the transactions performed on that database. If the transaction log is not backed up regularly, the log files can become very large and point-in-time recovery becomes impossible.'  ,'For those databases that maintain transaction logs, it is recommended that your maintenance plans include periodic transaction log backups to checkpoint the log and remove inactive transactions. Full, differential, and filegroup backups do not remove inactive transactions from the log, nor can they be used for point-in-time recovery. For databases that do not require point-in-time recovery, use the simple recovery model to preventunnecessary growth of the transaction log over time.'  ,''  ,'For those databases that maintain transaction logs, it is recommended that your maintenance plans include periodic transaction log backups to checkpoint the log and remove inactive transactions. Full, differential, andfilegroup backups do not remove inactive transactions from the log, nor can they be used for point-in-time recovery. For databases that do not require point-in-time recovery, use the simple recovery model to preventunnecessary growth of the transaction log over time.'  ,0,''
,1)
-- New Recommendations added after 10.0 beta
PRINT 'Adding New Set of Master Recommendations'
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q37'  ,'This may not be a problem if there are other reasons that a lower database compatibility level is being used.'  ,'',11  ,10  
,'Trace flag 4199 is enabled globally for SQL Server 2016 and there are databases running in compatibility level 120 or lower.' 
,'Trace flag 4199 is enabled globally for SQL Server 2016 and there are databases running in compatibility level 120 or lower.' 
,'Trace flag 4199 is enabled globally for SQL Server 2016 and there are databases running in compatibility level 120 or lower.' ,2  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>KB974006: SQL Server query optimizer hotfix trace flag 4199 servicing model: </Title><Link>https://support.microsoft.com/en-us/kb/974006 </Link></RecommendationLink></ArrayOfRecommendationLink>'  
,''  ,''  ,''  ,'Trace flag 4199 is a catch-all trace flag that was implemented to enable select query optimizer enhancements. Beginning with SQL Server 2016, these enhancements are enabled by default for databases in compatibility level 130 (SQL Server 2016) and only new query optimizer enhancements will be implemented via trace flag 4199.
The behavior of trace flag 4199 is tied to the compatibility level of the database beginning with SQL Server 2016. Because someone may choose to upgrade the compatibility level of the database without realizing that it will affect the query optimizer behavior, we recommend upgrading the compatibility level and removing the trace flag in a controlled manner where any behavior changes can be tested thoroughly.
Once the compatibility level is raised to level 130, the trace flag may invoke new, unexpected behaviors and the trace flag should be removed unless there is a specific query optimizer fix for SQL Server 2016 that is needed.'  
,'It is recommended that the database compatibility level of all databases on SQL Server 2016 be raised to level 130 and trace flag 4199 be removed unless there is a specific query optimizer fix for SQL Server 2016 enabled under this trace flag that is needed.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q38'  ,'This may not be a problem if there have been new query optimizer enhancements created after the release of SQL Server 2016 that are verified as needed for the existing instance.'  ,'',11  ,10  
,'Trace flag 4199 is enabled globally for SQL Server 2016 and all databases are running in compatibility level 130.' 
,'Trace flag 4199 is enabled globally for SQL Server 2016 and all databases are running in compatibility level 130.' 
,'Trace flag 4199 is enabled globally for SQL Server 2016 and all databases are running in compatibility level 130.' ,1  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>KB974006: SQL Server query optimizer hotfix trace flag 4199 servicing model:  </Title><Link>https://support.microsoft.com/en-us/kb/974006 </Link></RecommendationLink></ArrayOfRecommendationLink>'  
,''  ,''  ,''  ,'Trace flag 4199 is a catch-all trace flag that was implemented to enable select query optimizer enhancements. Beginning with SQL Server 2016, these enhancements are enabled by default for databases in compatibility level 130 (SQL Server 2016) and only new query optimizer enhancements will be implemented via trace flag 4199.
The behavior of trace flag 4199 is tied to the compatibility level of the database beginning with SQL Server 2016. For databases running in compatibility level 130, the previous query optimizer enhancements enabled under trace flag 4199 will be enabled by default. If new query optimizer enhancements are implemented after the release of SQL Server 2016, they may be implemented via trace flag 4199.
Because new query optimizer enhancements may be enabled with trace flag 4199, we recommend removing the trace flag to avoid invoking new, unexpected behaviors unless there is a specific query optimizer fix for SQL Server 2016 that is needed.'  
,'It is recommended that race flag 4199 be removed unless there is a specific query optimizer fix for SQL Server 2016 enabled under this trace flag that is needed and all databases are running at compatibility level 130.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M31'  ,'When the ratio of Max Server Memory setting to buffer pool extension size is no greater than 16 to 1 or when alternate configurations have been tested and performance is acceptable at current thresholds.'  ,'',7  ,5  
,'The Buffer Pool Extension size may be too large relative to the size of the in-memory buffer pool.' 
,'The Buffer Pool Extension size may be too large relative to the size of the in-memory buffer pool.' 
,'The Buffer Pool Extension size may be too large relative to the size of the in-memory buffer pool.' ,1  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Books Online article: Buffer Pool Extensions:   </Title><Link>https://msdn.microsoft.com/en-us/library/dn133176.aspx </Link></RecommendationLink></ArrayOfRecommendationLink>'
,''  ,''  ,''  ,'Pages in the buffer pool extension are tracked in system memory, and the overhead of managing a buffer pool extension that is too large in comparison to the buffer pool in memory'
,'It is recommended that the buffer pool extension size compared to the in-memory buffer pool not exceed a ratio of 16 to 1 with an optimal size between 4 to 1 and 8 to 1 even though the buffer pool extension may be up to 32 times the size of the in-memory buffer pool. It is recommended that the buffer pool extension be thoroughly tested with multiple sizes to determine the best size setting for your workload and server.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M32'  ,'This may not be a problem when tests confirm that the benefit of the buffer pool extension is more than the overhead of maintaining it.'  ,'',7  ,5  
,'The Buffer Pool Extension feature my not be providing much benefit for this server.' 
,'The Buffer Pool Extension feature my not be providing much benefit for this server.' 
,'The Buffer Pool Extension feature my not be providing much benefit for this server.' ,1  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Books Online article: Buffer Pool Extensions:   </Title><Link>https://msdn.microsoft.com/en-us/library/dn133176.aspx </Link></RecommendationLink><RecommendationLink><Title>Microsoft Data Platform blog post: Buffer Pool Extension to SSDs in SQL Server 2014:   </Title><Link>http://blogs.technet.com/b/dataplatforminsider/archive/2013/07/25/buffer-pool-extension-to-ssds-in-sql-server-2014.aspx </Link></RecommendationLink></ArrayOfRecommendationLink>'
,''  ,''  ,''  ,'Because the buffer pool extension stores only the oldest clean buffer pages that would have otherwise been evicted from cache, the overhead of maintaining a really large buffer pool extension may be more than the limited benefit of the buffer pool extension for SQL Servers with a very large in-memory buffer pool.'
,'It is recommended that for SQL Servers with more than 64 GB of memory allocated to SQL Server (Max Server Memory), the buffer pool extension feature should be thoroughly tested to ensure that the benefit it provides is greater than the overhead of maintaining such a large buffer pool extension.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I23'  ,'This may not be a problem if the statistics are filtered so that they only contain rows from the active partitions.'  ,'',5  ,8  
,'Partitioned table has column statistics that are not incremental.' 
,'Partitioned table [$(Schema)].[$(Table)] in database [$(Database)] has column statistics [$(StatsName)] that are not incremental.' 
,'Partitioned table [$(Schema)].[$(Table)] in database [$(Database)] has column statistics [$(StatsName)] that are not incremental.' ,1  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>BOL article What''s New (Database Engine): Incremental Statistics:  </Title><Link>https://msdn.microsoft.com/en-us/library/bb510411%28v=sql.120%29.aspx#Stats </Link></RecommendationLink></ArrayOfRecommendationLink>'  
,''  ,''  ,''  ,'Partitioned tables are often a mixture of static, historical data and new, changing data. Because changes may be occurring in only a few partitions, statistics for some partitions may not be updated frequently enough to properly represent the changes of data in those active partitions. Additionally, with non-incremental statistics, the stats have a very high overhead for maintenance due to the need to update stats for the entire table, even the non-changing partitions.'  
,'It is recommended that for table-wide, non-incremental column statistics on partitioned tables, the statistics should be dropped and replaced with incremental statistics. Incremental statistics are created and maintained per partition allowing statistics on active partitions to be automatically updated based on changes to their own partition and for statistics updates to be completed much quicker as they are updated per partitions.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I25'  ,'It is not a problem if the table is very small.'  ,'',5  ,9  
,'A memory-optimized hash index has too few buckets.' 
,'A memory-optimized hash index [$(Name)] on table [$(Schema)].[$(Table)] in database [$(Database)] has too few buckets.' 
,'A memory-optimized hash index [$(Name)] on table [$(Schema)].[$(Table)] in database [$(Database)] has too few buckets.' ,2  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Books Online article: Determining the Correct Bucket Count for Hash Indexes:  </Title><Link>https://msdn.microsoft.com/en-us/library/dn494956.aspx </Link></RecommendationLink></ArrayOfRecommendationLink>'
,''  ,''  ,''  ,'When there are too few buckets for a hash index, searches can be significantly slower. The hashing function only resolves which bucket a particular record is in, and all records in a selected bucket (bucket chain) must be read to find the correct rows. The more rows there are in a bucket (the longer the bucket chain), the more data that must be inspected to find the correct rows. Too many rows per bucket will hinder search performance. Additionally, long bucket chains due to too few buckets for an index can hinder recovery time and make database startup slow.'
,'It is recommended that the bucket count be between 1 and 2 times the number of unique index key values with the actual value being closer to 2 times. The empty bucket count in index [$(Name)] on table [$(Schema)].[$(Table)] in database [$(Database)] has an empty bucket count of less than 10% indicating that it likely has too few buckets for this index. It is recommended that you recreate the table with a larger number of buckets equaling 2 times the expected number of unique index key values. Memory-optimized indexes cannot be altered and changing the bucket count requires recreating the table.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I26'  ,'It is not a problem if the table is very small.'  ,'',5  ,8  
,'There are many duplicate key values in a memory-optimized hash index.'
,'There are many duplicate key values in a memory-optimized hash index [$(Name)] on table [$(Schema)].[$(Table)] in database [$(Database)].' 
,'There are many duplicate key values in a memory-optimized hash index [$(Name)] on table [$(Schema)].[$(Table)] in database [$(Database)].' ,2  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Books Online article: Determining the Correct Bucket Count for Hash Indexes:  </Title><Link>https://msdn.microsoft.com/en-us/library/dn494956.aspx </Link></RecommendationLink></ArrayOfRecommendationLink>'

,''  ,''  ,''  ,'Duplicate key values in a hash index get hashed to the same bucket which can create long bucket chains (chain of records in a single bucket) that hinders search performance. All records in a selected bucket (bucket chain) must be read to find the correct rows. The more rows there are in a bucket (the longer the bucket chain), the more data that must be inspected to find the correct rows. Too many rows per bucket will hinder search performance. Additionally, long bucket chains for an index can hinder recovery time and make database startup slow.'
,'It is recommended that when the key columns of an index have a lot of duplicate values that a non-hashed memory-optimized nonclustered index be used rather than a hash index.  Memory-optimized indexes cannot be altered and changing the index type requires recreating the table with the changed indexes.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I28'  ,'This is not a problem if the high empty bucket count is due to planning for expected growth of the data of the table and the table is expected to grow into the bucket count.'  ,'',5  ,6  
,'A memory-optimized hash index has too many buckets.' 
,'A memory-optimized hash index [$(Name)] on table [$(Schema)].[$(Table)] in database [$(Database)] has too many buckets.' 
,'A memory-optimized hash index [$(Name)] on table [$(Schema)].[$(Table)] in database [$(Database)] has too many buckets.' ,1  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Books Online article: Determining the Correct Bucket Count for Hash Indexes:  </Title><Link>https://msdn.microsoft.com/en-us/library/dn494956.aspx </Link></RecommendationLink></ArrayOfRecommendationLink>'
,''  ,''  ,''  ,'Unlike pages in disk-based indexes, all hash buckets are maintained in memory, even empty buckets. Every bucket uses 8 bytes of space in memory. An index with a large number of empty buckets can consume a lot of memory that could be used for other purposes.'
,'It is recommended that the bucket count be between 1 and 2 times the number of unique index key values with the actual value being closer to 2 times. The empty bucket count in index [$(Name)] on table [$(Schema)].[$(Table)] in database [$(Database)] has an empty bucket count of greater than 67% indicating that it likely has too many buckets for this index. The empty buckets in this index are consuming ($(EmptyBucketCount) * 8)/1024  KB or ($(EmptyBucketCount) * 8)/1024/1024 MB of memory. If the table is not expected to grow to use a majority of the empty buckets, it is recommended that you recreate the table with a smaller number of buckets equaling 2 times the expected number of unique index key values. Memory-optimized indexes cannot be altered and changing the bucket count requires recreating the table.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I29'  ,'When additional indexes are not needed or the index is present to support specific queries that are performance-critical but only get executed infrequently.'  ,'',5  ,6  
,'There are rarely used indexes on in-memory tables.' 
,'There is a rarely used index [$(Name)] on in-memory table [$(Schema)].[$(Table)] in database [$(Database)].' 
,'There is a rarely used index [$(Name)] on in-memory table [$(Schema)].[$(Table)] in database [$(Database)].' ,1  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Books Online article: Guidelines for Using Indexes on Memory-Optimized Tables:   </Title><Link>https://msdn.microsoft.com/en-us/library/dn133166.aspx </Link></RecommendationLink><RecommendationLink><Title>Microsoft Data Platform blog post: Buffer Pool Extension to SSDs in SQL Server 2014:   </Title><Link>http://blogs.technet.com/b/dataplatforminsider/archive/2013/07/25/buffer-pool-extension-to-ssds-in-sql-server-2014.aspx </Link></RecommendationLink></ArrayOfRecommendationLink>'  
,''  ,''  ,''  ,'Indexes that are scanned frequently but return very few rows have a high overhead to maintain them. Often the overhead of maintaining the indexes may hinder performance more than it helps it. Additionally in-memory tables are limited to only 8 indexes, and a different index may be better in its place.'  
,'It is recommended that infrequently used indexes on in-memory tables be evaluated for removal after thorough testing to ensure no critical queries rely on it.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q39'  ,'It may not be a problem if the database is not critical or not being actively monitored for performance. Additionally, this feature is not allowed in master and tempdb, and it should only be used in msdb or model if there is a strong compelling performance reason driving the decision. Should not recommend enabling for msdb or model.'  ,'',11  ,6  
,'The Query Store feature in database [$(Database)] is currently disabled.' 
,'The Query Store feature in database [$(Database)] is currently disabled.' 
,'The Query Store feature in database [$(Database)] is currently disabled.' ,1  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Books Online article: Monitoring Performance By Using the Query Store:  </Title><Link>https://msdn.microsoft.com/en-us/library/dn817826.aspx </Link></RecommendationLink></ArrayOfRecommendationLink>'
,''  ,''  ,''  ,'The Query Store is a valuable performance tool that provides insight on query plan choice and performance. Additionally, the Query Store provides a better process for freezing and forcing plans for queries with known plan selection issues.'
,'It is recommended that the Query Store be enabled for database [$(Database)] so query plan performance can be monitored and to ease troubleshooting queries suffering from plan selection issues.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q40'  ,'It may not be a problem if the database is not critical or not being actively monitored for performance.'  ,'',11  ,10  
,'The Query Store in database [$(Database)] is not collecting data because it is out of space.' 
,'The Query Store in database [$(Database)] is not collecting data because it is out of space.' 
,'The Query Store in database [$(Database)] is not collecting data because it is out of space.' ,1  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Books Online article: Monitoring Performance By Using the Query Store:  </Title><Link>https://msdn.microsoft.com/en-us/library/dn817826.aspx </Link></RecommendationLink></ArrayOfRecommendationLink>'
,''  ,''  ,''  ,'The Query Store is a valuable performance tool that provides insight on query plan choice and performance. Additionally, the Query Store provides a better process for freezing and forcing plans for queries with known plan selection issues. The query store is still functional for some operations in read-only mode, but it is no longer able to collect new data.'
,'It is recommended that the space issue for Query Store in database [$(Database)] be addressed by cleaning up old data, reducing the amount of data that is stored, or by expanding the amount of space the Query Store is allowed to use. If you clear out data that is stored and the issue reoccurs, it is recommended that you take a permanent approach to addressing the issue by reducing the amount of data saved or by increasing the amount of space the Query Store can use.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q41'  ,'It may not be a problem if the database is not critical or not being actively monitored for performance.'  ,'',11  ,8  
,'The Query Store feature in database [$(Database)] is almost full.' 
,'The Query Store feature in database [$(Database)] is almost full.' 
,'The Query Store feature in database [$(Database)] is almost full.' ,1  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Books Online article: Monitoring Performance By Using the Query Store:  </Title><Link>https://msdn.microsoft.com/en-us/library/dn817826.aspx </Link></RecommendationLink></ArrayOfRecommendationLink>'
,''  ,''  ,''  ,'The Query Store is a valuable performance tool that provides insight on query plan choice and performance. Additionally, the Query Store provides a better process for freezing and forcing plans for queries with known plan selection issues. If the Query Store runs out of space, it will be switched to read-only state until space is freed up. The query store is still functional for some operations in read-only mode, but it is no longer able to collect new data.'
,'It is recommended that the space issue for Query Store in database [$(Database)] be addressed by cleaning up old data, reducing the amount of data that is stored, or by expanding the amount of space the Query Store is allowed to use before it runs out of space and switches to a read-only state. If you clear out data that is stored and the issue reoccurs, it is recommended that you take a permanent approach to addressing the issue by reducing the amount of data saved or by increasing the amount of space the Query Store can use.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q42'  ,'It may not be a problem if the data is not expected to change and performance of the forced plan guide is not expected to change over time.'  ,'',11  ,5  
,'Plan guides are being used instead of forcing a plan in the Query Store in database [$(Database)].' 
,'Plan guides are being used instead of forcing a plan in the Query Store in database [$(Database)].' 
,'Plan guides are being used instead of forcing a plan in the Query Store in database [$(Database)].' ,1  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Books Online article: Monitoring Performance By Using the Query Store:  </Title><Link>https://msdn.microsoft.com/en-us/library/dn817826.aspx </Link></RecommendationLink></ArrayOfRecommendationLink>',''  ,''  ,''  
,'The Query Store is a valuable performance tool that provides insight on query plan choice and performance. Additionally, the Query Store provides a better process for freezing and forcing plans for queries with known plan selection issues. The Query Store allows for tracking of forced plan performance over time to easily identify plans that are no longer effective.'
,'It is recommended that plan guides be removed and the Query Store in database [$(Database)] be used to evaluate if forcing a plan is still needed. If forcing a plan is still needed, the Query Store should be used to force the best plan for the query.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q46'  ,'It may not be a problem if the queries are heavily tuned already.'  ,'',11  ,5  
,'These queries have the top 10 longest average execution time within the last hour in database [$(Database)].' 
,'These queries have the top 10 longest average execution time within the last hour in database [$(Database)].' 
,'These queries have the top 10 longest average execution time within the last hour in database [$(Database)].' ,1  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Books Online article: Monitoring Performance By Using the Query Store:   </Title><Link>https://msdn.microsoft.com/en-US/library/dn817826.aspx </Link></RecommendationLink><RecommendationLink><Title>Microsoft Data Platform blog post: Buffer Pool Extension to SSDs in SQL Server 2014:   </Title><Link>http://blogs.technet.com/b/dataplatforminsider/archive/2013/07/25/buffer-pool-extension-to-ssds-in-sql-server-2014.aspx </Link></RecommendationLink></ArrayOfRecommendationLink>',''  ,''  ,''  
,'Queries with a long average execution time are prime candidates to be tuned to make them run faster.'
,'It is recommended that these queries be investigated to see if they can be tuned to make them run faster.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q47'  ,'It may not be a problem if the queries are already highly tuned.'  ,'',11  ,5  
,'The following queries are the top 10 most I/O consuming queries in the last 24 hours in database [$(Database)].' 
,'The following queries are the top 10 most I/O consuming queries in the last 24 hours in database [$(Database)].' 
,'The following queries are the top 10 most I/O consuming queries in the last 24 hours in database [$(Database)].' ,1  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Books Online article: Monitoring Performance By Using the Query Store:   </Title><Link>https://msdn.microsoft.com/en-US/library/dn817826.aspx </Link></RecommendationLink><RecommendationLink><Title>Microsoft Data Platform blog post: Buffer Pool Extension to SSDs in SQL Server 2014:   </Title><Link>http://blogs.technet.com/b/dataplatforminsider/archive/2013/07/25/buffer-pool-extension-to-ssds-in-sql-server-2014.aspx </Link></RecommendationLink></ArrayOfRecommendationLink>',''  ,''  ,''  
,'Queries that perform a lot of I/O operations are prime candidates for tuning to see if the amount of I/O can be decreased, often by using better indexing.'
,'It is recommended that the following queries be investigated to see if they can be tuned to reduce the amount of I/O they require. I/O requirements are often reduced by implementing different indexes for all queries or by removing unused indexes for data modification queries.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q48'  ,'It may not be a problem if the plan change and increase in execution time are due to an environmental change like a sudden large increase in the amount of data.'  ,'',11  ,8  
,'The following queries experienced an increase of at least double the execution time in the last 48 hours due to a change in the query plan in database [$(Database)].' 
,'The following queries experienced an increase of at least double the execution time in the last 48 hours due to a change in the query plan in database [$(Database)].' 
,'The following queries experienced an increase of at least double the execution time in the last 48 hours due to a change in the query plan in database [$(Database)].' ,2
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Books Online article: Monitoring Performance By Using the Query Store:   </Title><Link>https://msdn.microsoft.com/en-US/library/dn817826.aspx </Link></RecommendationLink><RecommendationLink><Title>Microsoft Data Platform blog post: Buffer Pool Extension to SSDs in SQL Server 2014:   </Title><Link>http://blogs.technet.com/b/dataplatforminsider/archive/2013/07/25/buffer-pool-extension-to-ssds-in-sql-server-2014.aspx </Link></RecommendationLink></ArrayOfRecommendationLink>',''  ,''  ,''  
,'A large increase in execution time due to a plan change may be an indicator that the plan has regressed to a less than optimal plan.'
,'It is recommended that the following plans be investigated to determine why the plan changed and whether or not the plan change was the best plan for the query. It is recommended that the query be tuned, if possible, to avoid the change in plan, or if necessary, force the better plan.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q49'  ,'It may not be a problem if the increase in execution duration is due to normal increases in activity or data or if the plan is still optimal for the query.'  ,'',11  ,5  
,'The following top 10 queries have a longer run duration during the last 1 hour than did during the last day in database [$(Database)].' 
,'The following top 10 queries have a longer run duration during the last 1 hour than did during the last day in database [$(Database)].' 
,'The following top 10 queries have a longer run duration during the last 1 hour than did during the last day in database [$(Database)].' ,1  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Books Online article: Monitoring Performance By Using the Query Store:   </Title><Link>https://msdn.microsoft.com/en-US/library/dn817826.aspx </Link></RecommendationLink><RecommendationLink><Title>Microsoft Data Platform blog post: Buffer Pool Extension to SSDs in SQL Server 2014:   </Title><Link>http://blogs.technet.com/b/dataplatforminsider/archive/2013/07/25/buffer-pool-extension-to-ssds-in-sql-server-2014.aspx </Link></RecommendationLink></ArrayOfRecommendationLink>',''  ,''  ,''  
,'Queries that are experiencing a longer run time may indicate that the current plan is no longer optimal or that some additional factor is affecting duration of the queries (such as increased blocking or waits).'
,'It is recommended that the following queries be investigated to determine the cause for the longer execution duration. The additional duration may be a sign of the plan no longer being optimal or it may be a symptom of external factors such as increased blocking or additional waits.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q50'  ,'It may not be a problem as long as execution time remains consistent across different plans.'  ,'',11  ,6  
,'The following queries have had more than 4 different plans in the last 48 hours in database [$(Database)].' 
,'The following queries have had more than 4 different plans in the last 48 hours in database [$(Database)].' 
,'The following queries have had more than 4 different plans in the last 48 hours in database [$(Database)].' ,1  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Books Online article: Monitoring Performance By Using the Query Store:   </Title><Link>https://msdn.microsoft.com/en-US/library/dn817826.aspx </Link></RecommendationLink><RecommendationLink><Title>Microsoft Data Platform blog post: Buffer Pool Extension to SSDs in SQL Server 2014:   </Title><Link>http://blogs.technet.com/b/dataplatforminsider/archive/2013/07/25/buffer-pool-extension-to-ssds-in-sql-server-2014.aspx </Link></RecommendationLink></ArrayOfRecommendationLink>',''  ,''  ,''  
,'Queries that change plans often are prime candidates for plan regression resulting in inconsistent execution times.'
,'It is recommended that the following queries by investigated to determine why they change plans frequently to see if the query can be optimized to avoid generating different plans or if the most optimal plan should be stabilized by forcing a specific plan.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I30'  ,'If old data is not being frequently queried or if current performance is acceptable.'  ,'',5  ,5  
,'Large tables with a high number of table or clustered index scans are not taking advantage of columnstore indexes.' 
,'Large table [$(Schema)].[$(Table)] in database [$(Database)] with a high number of table or clustered index scans is not taking advantage of columnstore indexes.' 
,'Large table [$(Schema)].[$(Table)] in database [$(Database)] with a high number of table or clustered index scans is not taking advantage of columnstore indexes.' ,1  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Books Online article: Columnstore Indexes for Operational Analytics: </Title><Link>https://msdn.microsoft.com/en-us/library/dn817827.aspx </Link></RecommendationLink></ArrayOfRecommendationLink>'  
,''  ,''  ,''  ,'Large tables often have a small subset of active data and large blocks of inactive data. The active portion of the data benefits from standard indexes whereas queries on the large blocks of data would benefit from columnstore indexes. SQL Server 2015 introduced the ability to add columnstore indexes to tables with standard indexes already in place. Additionally, the indexes can take advantage of filtering to ensure that the columnstore index only covers the old, unchanging data.'  
,'It is recommended that large tables with a high number of table or clustered index scans be considered for applying columnstore indexes after thorough testing.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I31'  ,'It may not be a problem if the queries do not need to return the filtered column or do not need to use the filtered column value in an expression that does not exactly match the filter definition.'  ,'',5  ,7
,'Filtered index [$(Name)] on Table [$(Schema)].[$(Table)] in database [$(Database)] does not list the filtered column in the key of the index.' 
,'Filtered index [$(Name)] on Table [$(Schema)].[$(Table)] in database [$(Database)] does not list the filtered column in the key of the index.' 
,'Filtered index [$(Name)] on Table [$(Schema)].[$(Table)] in database [$(Database)] does not list the filtered column in the key of the index.' ,2
,''  
,''  ,''  ,''  ,'Filtered indexes that do not include the filtered column in the key of the index may not be used for queries unless the filter matches exactly and does not need to use or return the filtered column value. Including the filtered column in the key of the index allows the index to be used for a wider variety of queries.'  
,'It is recommended that the column in the filter of the filtered index be included in the key of the index to increase the chances that it will be used by the optimizer.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q43'  ,'It is not a problem if overall performance of the procedure is acceptable.'  ,'',11  ,5  
,'Frequently executed procedure [$(ProcedureName)] with high CPU time to total elapsed time ratio was found in database [$(Database)].' 
,'Frequently executed procedure [$(ProcedureName)] with high CPU time to total elapsed time ratio was found in database [$(Database)].' 
,'Frequently executed procedure [$(ProcedureName)] with high CPU time to total elapsed time ratio was found in database [$(Database)].' ,1  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Books Online Article: Determining if a Table or Stored Procedure Should Be Ported to In-Memory OLTP: </Title><Link>https://msdn.microsoft.com/en-us/library/dn205133.aspx </Link></RecommendationLink></ArrayOfRecommendationLink>',''  ,''  ,''  
,'Procedures that consume a high amount of CPU time in relation to the total elapsed time could run faster in natively compiled code.'
,'It is recommended that frequently executed procedures that have a high CPU time to total elapsed time ratio be considered for native compilation. Native compilation requires that referenced tables are in-memory tables so native compilation may not be possible for all procedures that are good candidates for native compilation.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I27'  ,'It may not be a problem if the table is very small.'  ,'',5  ,5  
,'Hash indexes are being scanned.' 
,'Hash index $(Name) on table $(Schema).$(Table) in database [$(Database)] is being scanned.' 
,'Hash index $(Name) on table $(Schema).$(Table) in database [$(Database)] is being scanned.' ,1  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Books Online article: Troubleshooting Common Performance Problems with Memory-Optimized Hash Indexes: </Title><Link>https://msdn.microsoft.com/en-us/library/dn589805.aspx </Link></RecommendationLink></ArrayOfRecommendationLink>'  
,''  ,''  ,''  ,'Hash indexes are not ordered by the keys and scans on hash indexes hinder performance significantly. Hash index functions require that all key columns be supplied in equality expressions. If any of the key columns are not referenced by the criteria of the query, the hash index cannot be used to find buckets with matching columns. Likewise, non-equality expressions on the key columns will result in a scan because the function requires explicit values, not a range of values.'  
,'It is recommended that the code causing the scan be modified to include equality statements for columns of the hash index key or that a non-hashed nonclustered index scan be used instead or in addition to the hash index. Memory-optimized indexes cannot be altered and can only be created with the CREATE TABLE statement. Changing or adding a memory=optimized index recreating the table with the changed and new indexes.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-I24'  ,'It may not be a problem if the queries on the table are not experiencing poor plan selection due to inaccurate statistics.'  ,'',5  ,8  
,'There is very large table (greater than or equal to 1 million rows) [$(Schema)].[$(Table)] in database [$(Database)] and a high number of modifications have been made since the last time statistics were updated.' 
,'There is very large table (greater than or equal to 1 million rows) [$(Schema)].[$(Table)] in database [$(Database)] and a high number of modifications have been made since the last time statistics were updated.' 
,'There is very large table (greater than or equal to 1 million rows) [$(Schema)].[$(Table)] in database [$(Database)] and a high number of modifications have been made since the last time statistics were updated.' ,2
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>KB2754171 Controlling Autostat (AUTO_UPDATE_STATISTICS) behavior in SQL Server: </Title><Link>https://support.microsoft.com/en-us/kb/2754171 </Link></RecommendationLink><RecommendationLink><Title>Microsoft blog post: Changes to automatic update statistics in SQL Server - traceflag 2371: </Title><Link>http://blogs.msdn.com/b/saponsqlserver/archive/2011/09/07/changes-to-automatic-update-statistics-in-sql-server-traceflag-2371.aspx  </Link></RecommendationLink></ArrayOfRecommendationLink>'  
,''  ,''  ,''  ,'The default behavior for automatically updated statistics on large tables is to update when the number of changes equals 500 + 20% of the total rows. For example, statistics for a table with 10 million rows will not be updated until there have been 2,500,000 changes to the table. This may not be enough to maintain statistics accurately enough for a large table.'  
,'It is recommended that statistics be kept up to date for all tables, however keeping very large tables up to date without manual intervention is difficult. Trace flag 2371 changes the calculation for when to automatically update statistics. Statistics are updated on a sliding scale, for example, statistics for a table with 10 million rows will be updated after 100,000 changes rather than 2,500,000 changes.
Really small tables will not be affected by this change as the statistics update threshold will be the lessor of the new formula or the old formula (500 + 20%).'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-D23'  ,'May not be a problem if less critical queries are not causing high levels of I/O operations.'  ,'',2  ,6  
,'Resource Governor is being used to limit resources of some queries, but I/O operations are not being limited and there have been occurrences of I/O stall detected.' 
,'Resource Governor is being used to limit resources of some queries, but I/O operations are not being limited and there have been occurrences of I/O stall detected.'
,'Resource Governor is being used to limit resources of some queries, but I/O operations are not being limited and there have been occurrences of I/O stall detected.' ,1  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>BOL article Resource Governor Enhancements for Physical IO Control: </Title><Link>https://msdn.microsoft.com/en-us/library/bb510411%28v=sql.120%29.aspx#RG </Link></RecommendationLink></ArrayOfRecommendationLink>'  
,''  ,''  ,''  ,'Resource Governor allows you to cap the resources used by queries in a pre-defined pool to prevent less critical queries from using too many resources that are needed for more critical queries. SQL Server 2014 added the ability to limit the number of I/O operations per second per disk that a query can use. Because pending I/O stall is occurring, critical processes may be experiencing performance degradation if less critical queries are issuing high levels of I/O operations.'  
,'It is recommended that Resource Governor pools that are intended to limit resources for less critical queries be evaluated to see if they are issuing high levels of I/O operations and consider limiting the amount of I/O for the resource pool.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q44'  ,'It may not be a problem if query performance is acceptable as is.'  ,'',11  ,5  
,'New cardinality estimator is not being used.' 
,'New cardinality estimator is not being used.' 
,'New cardinality estimator is not being used.' ,1  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Books Online article: Cardinality Estimation (SQL Server): </Title><Link>https://msdn.microsoft.com/en-us/library/dn600374%28v=sql.120%29.aspx </Link></RecommendationLink></ArrayOfRecommendationLink>',''  ,''  ,''  
,'The cardinality estimator estimates the number of rows that will be affected or returned by a specific relational expression in a query (such as a join) and accurate estimations are critical for making the correct plan choice. SQL Server 2014 introduced a new, improved cardinality estimator, but it is not enabled unless the database compatibility is set to at least 120 (SQL Server 2014).'
,'It is recommended that all databases be set to the current compatibility level unless there is a compelling reason to use a lower level setting. The new cardinality estimator introduced in SQL Server 2014 should yield more consistent good plans than the old cardinality estimator.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-Q45'  ,'If the query does not have any relational expressions (such as joins).'  ,'',11  ,7  
,'Both new and old cardinality estimators are being forced at the same time.' 
,'Both new and old cardinality estimators are being forced at the same time.' 
,'Both new and old cardinality estimators are being forced at the same time.' ,1  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Books Online article: Cardinality Estimation (SQL Server): </Title><Link>https://msdn.microsoft.com/en-us/library/dn600374%28v=sql.120%29.aspx </Link></RecommendationLink></ArrayOfRecommendationLink>',''  ,''  ,''  
,'A new cardinality estimator was written for SQL Server 2014. When using the new cardinality estimator on compatibility level 120, you can use the trace flag 9481 as a query hint to force a specific query to use the old cardinality estimator. You can also use trace flag 9481 as a session or global trace flag to force the behavior on a wider scope.
If you are still running on the old cardinality estimator in SQL Server 2014+, you can test a specific query using the new cardinality estimator by using trace flag 2312 to force the new cardinality estimator. The trace flag may also be set as a session or global trace flag to force the behavior on a wider scope.
If both of these trace flags are enabled at the same time, the behavior of the cardinality estimator may be unpredictable.'
,'It is recommended that trace flags that change the default behavior of SQL Server only be implemented when absolutely required. The queries affected by the trace flag should be thoroughly tested to determine which cardinality estimator provides the desired results and ensure that only that estimator is being used though either database compatibility setting and only use the trace flag when required to change the behavior for specific queries.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-R8'  ,'It may not be a problem if you would prefer the database stay offline rather than failover.'  ,'',12  ,5  
,'Availability Group [$(AvailabilityGroupName)] is not enabled for failover if a database is not online.' 
,'Availability Group [$(AvailabilityGroupName)] is not enabled for failover if a database is not online.' 
,'Availability Group [$(AvailabilityGroupName)] is not enabled for failover if a database is not online.' ,2  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Books Online article: ALTER AVAILABILITY GROUP (Transact-SQL): </Title><Link>https://msdn.microsoft.com/en-us/library/ff878601.aspx </Link></RecommendationLink></ArrayOfRecommendationLink>'  
,''
,''
,''
,'If the database on the active node of an Availability Group is not online but the server is still functioning normally, the Availability Group will not fail over. SQL Server 2016 introduced a new option that enables the Availability Group to fail over if this event occurs.'  
,'It is recommended that DB_FAILOVER be enabled for synchronous Availability Groups to allow the Availability Group to fail over if one of the member databases is not online to avoid a prolonged outage.'  ,0,''
,1)
INSERT INTO #upgrade_PrescriptiveRecommendation ([TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags],[TempIsActive]) VALUES 
('SDR-M33'  ,'When there is no possibility to increase the amount of memory allocated to SQL Server and I/O response time is faster than disk I/O response times would be.'  ,'',7  ,7  
,'The Buffer Pool Extension is experiencing high levels of I/O queuing.' 
,'The Buffer Pool Extension is experiencing high levels of I/O queuing.' 
,'The Buffer Pool Extension is experiencing high levels of I/O queuing.' ,1  
,'<?xml version="1.0" encoding="utf-16"?><ArrayOfRecommendationLink xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><RecommendationLink><Title>Books Online article: Buffer Pool Extensions: </Title><Link>https://msdn.microsoft.com/en-us/library/dn133176.aspx </Link></RecommendationLink><RecommendationLink><Title>Books Online article: SQL Server, Buffer Manager Object: </Title><Link>https://msdn.microsoft.com/en-us/library/ms189628.aspx </Link></RecommendationLink></ArrayOfRecommendationLink>'
,''  ,''  ,''  ,'If the buffer pool extension is experiencing high levels of I/O queuing, logical I/O response times may be slow and hinder query performance.'
,'It is recommended that only Enterprise class SSD drives be used for the buffer pool extension. If the drives are not fast enough, query performance will degrade, especially on a busy system that results in many I/O operations queuing up.'  ,0,''
,1)
-- insert new rows
INSERT INTO PrescriptiveRecommendation ([RecommendationID],[AdditionalConsiderations],[bitly],[CategoryID],
[ConfidenceFactor],[Description],[Finding],[ImpactExplanation],[ImpactFactor],[InfoLinks],[PluralFormFinding],
[PluralFormImpactExplanation],[PluralFormRecommendation],[ProblemExplanation],[Recommendation],[Relevance],[Tags],[IsActive])
	SELECT [TempRecommendationID],[TempAdditionalConsiderations],[Tempbitly],[TempCategoryID],[TempConfidenceFactor],[TempDescription],
	[TempFinding],[TempImpactExplanation],[TempImpactFactor],[TempInfoLinks],[TempPluralFormFinding],[TempPluralFormImpactExplanation],
	[TempPluralFormRecommendation],[TempProblemExplanation],[TempRecommendation],[TempRelevance],[TempTags]
	,[TempIsActive] FROM #upgrade_PrescriptiveRecommendation
		WHERE [TempRecommendationID] not in (select [RecommendationID] COLLATE SQL_Latin1_General_CP1_CS_AS from PrescriptiveRecommendation)
-- update all 
UPDATE PrescriptiveRecommendation
	SET   [AdditionalConsiderations] = [TempAdditionalConsiderations]
	,[bitly] = [Tempbitly]
	,[CategoryID] = [TempCategoryID]
	,[ConfidenceFactor] = [TempConfidenceFactor]
	,[Description]=[TempDescription]
	,[Finding] = [TempFinding]
	,[ImpactExplanation]= [TempImpactExplanation]
	,[ImpactFactor] = [TempImpactFactor]
	,[InfoLinks] = [TempInfoLinks]
	,[PluralFormFinding] = [TempPluralFormFinding]
	,[PluralFormImpactExplanation]= [TempPluralFormImpactExplanation]
	,[PluralFormRecommendation] = [TempPluralFormRecommendation]
	,[ProblemExplanation]= [TempProblemExplanation]
	,[Recommendation]= [TempRecommendation]
	,[Relevance] = [TempRelevance]
	,[Tags]= [TempTags] 
	,[IsActive] = [TempIsActive]
		FROM #upgrade_PrescriptiveRecommendation
	WHERE
		[RecommendationID] = TempRecommendationID COLLATE SQL_Latin1_General_CP1_CS_AS

--END: SQLdm 10.0 (srisht purohit) -Prescriptive Recommendation master data for SQL doctor

--START SQLdm 10.0 (Gaurav Karwal): for upgrade. updating active flag of all templates
UPDATE [dbo].[BaselineTemplates]
SET [Active] = '1'
WHERE TemplateID IN (SELECT TemplateID FROM (SELECT TemplateID,SQLServerID, ROW_NUMBER() OVER(PARTITION BY SQLServerID ORDER BY TemplateID DESC) RowNum FROM BaselineTemplates) T WHERE T.RowNum = 1)
--END SQLdm 10.0 (Gaurav Karwal): for upgrade. updating active flag of all templates


--START: SQLdm 10.0 (srisht purohit) -Prescriptive Analysis Type master data for SQL doctor
if (select isnull(object_id('tempdb..#upgrade_PrescriptiveAnalysisType'), 0)) <> 0 
begin 
	print 'truncating #upgrade_PrescriptiveAnalysisType'
	TRUNCATE TABLE #upgrade_PrescriptiveAnalysisType
end 
ELSE
begin
	print 'creating #upgrade_PrescriptiveAnalysisType'

	CREATE TABLE #upgrade_PrescriptiveAnalysisType (TempAnalysisTypeID [int] NOT NULL,
		TempAnalysisType [nvarchar](100) NOT NULL,
	 CONSTRAINT [PK_dbo.upgradePrescriptiveAnalysisType] PRIMARY KEY CLUSTERED 
	(
		TempAnalysisTypeID ASC
	)
	)
END	
     
INSERT INTO #upgrade_PrescriptiveAnalysisType (TempAnalysisTypeID, TempAnalysisType) VALUES(1,'Default')
INSERT INTO #upgrade_PrescriptiveAnalysisType (TempAnalysisTypeID, TempAnalysisType) VALUES(2,'WorkLoad')
INSERT INTO #upgrade_PrescriptiveAnalysisType (TempAnalysisTypeID, TempAnalysisType) VALUES(3,'AdHocBatch')
INSERT INTO #upgrade_PrescriptiveAnalysisType (TempAnalysisTypeID, TempAnalysisType) VALUES(4,'Scheduled-Default')
INSERT INTO #upgrade_PrescriptiveAnalysisType (TempAnalysisTypeID, TempAnalysisType) VALUES(5,'Scheduled-WorkLoad')
INSERT INTO #upgrade_PrescriptiveAnalysisType (TempAnalysisTypeID, TempAnalysisType) VALUES(6,'Scheduled-AdHocBatch')
INSERT INTO #upgrade_PrescriptiveAnalysisType (TempAnalysisTypeID, TempAnalysisType) VALUES(7,'Alert-Default')
INSERT INTO #upgrade_PrescriptiveAnalysisType (TempAnalysisTypeID, TempAnalysisType) VALUES(8,'Alert-WorkLoad')
INSERT INTO #upgrade_PrescriptiveAnalysisType (TempAnalysisTypeID, TempAnalysisType) VALUES(9,'Alert-AdHocBatch')

-- insert new rows 
INSERT INTO PrescriptiveAnalysisType ([AnalysisTypeID], [AnalysisType])
	SELECT TempAnalysisTypeID, TempAnalysisType FROM #upgrade_PrescriptiveAnalysisType 
		WHERE TempAnalysisTypeID not in (select [AnalysisTypeID] from PrescriptiveAnalysisType)
-- update all 
UPDATE PrescriptiveAnalysisType
	SET   [AnalysisType] = TempAnalysisType
		FROM #upgrade_PrescriptiveAnalysisType 
	WHERE
		[AnalysisTypeID] = TempAnalysisTypeID 

--END: SQLdm 10.0 (srisht purohit) -Prescriptive Recommendation Category master data for SQL doctor


grant SELECT on [DiskDrives] to [SQLdmConsoleUser] -- SQLdm 9.0 (Tarun Sapra) -- Fixing rally defect DE41961. Granting permissions to SQLdmConsoleUser for DiskDrives table
grant SELECT on [DatabaseStatistics] to [SQLdmConsoleUser]
grant SELECT on [DatabaseSize] to [SQLdmConsoleUser]
grant SELECT on [OSStatistics] to [SQLdmConsoleUser]
grant SELECT on [ServerStatistics] to [SQLdmConsoleUser]
grant SELECT on [TableGrowth] to [SQLdmConsoleUser]
grant SELECT on [TableReorganization] to [SQLdmConsoleUser]
grant SELECT on [CustomCounterMap] to [SQLdmConsoleUser]
grant SELECT on [CustomCounterStatistics] to [SQLdmConsoleUser]
grant SELECT on [ServerTags] to [SQLdmConsoleUser]
grant SELECT on [CustomCounterTags] to [SQLdmConsoleUser]
grant SELECT on [PermissionTags] to [SQLdmConsoleUser]
grant SELECT on [ReportPeriods] to [SQLdmConsoleUser]
grant SELECT on [MonitoredSQLServers] to [SQLdmConsoleUser]
grant SELECT on [ActiveWaitStatistics] to [SQLdmConsoleUser]
grant SELECT on [WaitCategories] to [SQLdmConsoleUser]
grant SELECT on [WaitStatistics] to [SQLdmConsoleUser]
grant SELECT on [WaitStatisticsDetails] to [SQLdmConsoleUser]
grant SELECT on [WaitTypes] to [SQLdmConsoleUser]
grant SELECT on [CustomCounterDefinition] to [SQLdmConsoleUser]
grant SELECT on [AlertTemplateLookup] to [SQLdmConsoleUser]
grant SELECT on [SQLServerDatabaseNames] to [SQLdmConsoleUser]
grant SELECT on [VirtualHostServers] to [SQLdmConsoleUser]
grant SELECT on [BaselineMetaData] to [SQLdmConsoleUser]
grant SELECT on [BaselineStatistics] to [SQLdmConsoleUser]
grant SELECT on [BaselineTemplates] to [SQLdmConsoleUser]
grant SELECT on [VMConfigData] to [SQLdmConsoleUser]
grant SELECT on [VMStatistics] to [SQLdmConsoleUser]
grant SELECT on [ESXConfigData] to [SQLdmConsoleUser]
grant SELECT on [ESXStatistics] to [SQLdmConsoleUser]
grant SELECT on [fn_GetFormattedTemplate] to [SQLdmConsoleUser]
grant SELECT on [fn_GetChartTimeLabels] to [SQLdmConsoleUser]
grant SELECT on [AlwaysOnStatistics] to [SQLdmConsoleUser]
grant SELECT on [AuditableActions] to [SQLdmConsoleUser]
grant SELECT on [AuditableEvents] to [SQLdmConsoleUser]
--[START] SQLdm 10.0 (Gaurav Karwal): grant for tables that were missing
grant SELECT on ActiveWaitStatistics to [SQLdmConsoleUser]
grant SELECT on Alerts to [SQLdmConsoleUser]
grant SELECT on AlertTemplateLookup to [SQLdmConsoleUser]
grant SELECT on AlwaysOnAvailabilityGroups to [SQLdmConsoleUser]
grant SELECT on AlwaysOnDatabases to [SQLdmConsoleUser]
grant SELECT on AlwaysOnReplicas to [SQLdmConsoleUser]
grant SELECT on AlwaysOnStatistics to [SQLdmConsoleUser]
grant SELECT on ApplicationNames to [SQLdmConsoleUser]
grant SELECT on AuditableActions to [SQLdmConsoleUser]
grant SELECT on AuditableEvents to [SQLdmConsoleUser]
grant SELECT on BaselineMetaData to [SQLdmConsoleUser]
grant SELECT on BaselineStatistics to [SQLdmConsoleUser]
grant SELECT on BaselineTemplates to [SQLdmConsoleUser]
grant SELECT on BlockingSessionStatistics to [SQLdmConsoleUser]
grant SELECT on Blocks to [SQLdmConsoleUser]
grant SELECT on CollectionServices to [SQLdmConsoleUser]
grant SELECT on CounterMasterList to [SQLdmConsoleUser]
grant SELECT on CustomCounterDefinition to [SQLdmConsoleUser]
grant SELECT on CustomCounterMap to [SQLdmConsoleUser]
grant SELECT on CustomCounterStatistics to [SQLdmConsoleUser]
grant SELECT on CustomCounterTags to [SQLdmConsoleUser]
grant SELECT on CustomDashboard to [SQLdmConsoleUser]
grant SELECT on CustomDashboardMatchTypes to [SQLdmConsoleUser]
grant SELECT on CustomDashboardWidgets to [SQLdmConsoleUser]
grant SELECT on CustomDashboardWidgetTypes to [SQLdmConsoleUser]
grant SELECT on CustomReports to [SQLdmConsoleUser]
grant SELECT on CustomReportsCounters to [SQLdmConsoleUser]
grant SELECT on DashboardDefaults to [SQLdmConsoleUser]
grant SELECT on DashboardLayouts to [SQLdmConsoleUser]
grant SELECT on DatabaseFileActivity to [SQLdmConsoleUser]
grant SELECT on DatabaseFiles to [SQLdmConsoleUser]
grant SELECT on DatabaseFileStatistics to [SQLdmConsoleUser]
grant SELECT on DatabaseSize to [SQLdmConsoleUser]
grant SELECT on DatabaseSizeDateTime to [SQLdmConsoleUser]
grant SELECT on DatabaseStatistics to [SQLdmConsoleUser]
grant SELECT on DBMetrics to [SQLdmConsoleUser]
grant SELECT on DeadlockProcesses to [SQLdmConsoleUser]
grant SELECT on Deadlocks to [SQLdmConsoleUser]
grant SELECT on DefaultMetricThresholds to [SQLdmConsoleUser]
grant SELECT on DiskDrives to [SQLdmConsoleUser]
grant SELECT on DiskDriveStatistics to [SQLdmConsoleUser]
grant SELECT on ESXConfigData to [SQLdmConsoleUser]
grant SELECT on ESXStatistics to [SQLdmConsoleUser]
grant SELECT on GroomingLog to [SQLdmConsoleUser]
grant SELECT on HostNames to [SQLdmConsoleUser]
grant SELECT on LatestGroomingStatus to [SQLdmConsoleUser]
grant SELECT on LicenseKeys to [SQLdmConsoleUser]
grant SELECT on LoginNames to [SQLdmConsoleUser]
grant SELECT on ManagementServices to [SQLdmConsoleUser]
grant SELECT on MetricInfo to [SQLdmConsoleUser]
grant SELECT on MetricMetaData to [SQLdmConsoleUser]
grant SELECT on MetricMetaDataMessageMap to [SQLdmConsoleUser]
grant SELECT on MetricMetaDataMessages to [SQLdmConsoleUser]
grant SELECT on MetricThresholdInstances to [SQLdmConsoleUser]
grant SELECT on MetricThresholds to [SQLdmConsoleUser]
grant SELECT on MirroringParticipants to [SQLdmConsoleUser]
grant SELECT on MirroringPreferredConfig to [SQLdmConsoleUser]
grant SELECT on MirroringStatistics to [SQLdmConsoleUser]
grant SELECT on MonitoredServerSQLsafeInstance to [SQLdmConsoleUser]
grant SELECT on MonitoredSQLServers to [SQLdmConsoleUser]
grant SELECT on NotificationProviders to [SQLdmConsoleUser]
grant SELECT on NotificationRules to [SQLdmConsoleUser]
grant SELECT on OSStatistics to [SQLdmConsoleUser]
grant SELECT on Permission to [SQLdmConsoleUser]
grant SELECT on PermissionServers to [SQLdmConsoleUser]
grant SELECT on PermissionTags to [SQLdmConsoleUser]
grant SELECT on PredictiveForecasts to [SQLdmConsoleUser]
grant SELECT on PredictiveModels to [SQLdmConsoleUser]
grant SELECT on PrescriptiveAnalysis to [SQLdmConsoleUser]
grant SELECT on PrescriptiveAnalysisDetails to [SQLdmConsoleUser]
grant SELECT on PrescriptiveAnalysisRecommendation to [SQLdmConsoleUser]
grant SELECT on PrescriptiveAnalyzer to [SQLdmConsoleUser]
grant SELECT on PrescriptiveAnalyzerCategory to [SQLdmConsoleUser]
grant SELECT on PrescriptiveRecommendation to [SQLdmConsoleUser]
grant SELECT on PrescriptiveRecommendationCategory to [SQLdmConsoleUser]
grant SELECT on QueryMonitorStatistics to [SQLdmConsoleUser]
grant SELECT on QuerySignatureAggregation to [SQLdmConsoleUser]
grant SELECT on ReplicationTopology to [SQLdmConsoleUser]
grant SELECT on ReportIntervals to [SQLdmConsoleUser]
grant SELECT on ReportPeriodIntervals to [SQLdmConsoleUser]
grant SELECT on ReportPeriods to [SQLdmConsoleUser]
grant SELECT on RepositoryInfo to [SQLdmConsoleUser]
grant SELECT on RunQueryScripts to [SQLdmConsoleUser]
grant SELECT on ServerActivity to [SQLdmConsoleUser]
grant SELECT on ServerStatistics to [SQLdmConsoleUser]
grant SELECT on ServerTags to [SQLdmConsoleUser]
grant SELECT on SQLQueryPlans to [SQLdmConsoleUser]
grant SELECT on SQLQueryPlansOverflow to [SQLdmConsoleUser]
grant SELECT on SQLsafeConnections to [SQLdmConsoleUser]
grant SELECT on SQLServerDatabaseNames to [SQLdmConsoleUser]
grant SELECT on SQLServerTableNames to [SQLdmConsoleUser]
grant SELECT on SQLServerVersions to [SQLdmConsoleUser]
grant SELECT on SQLSignatures to [SQLdmConsoleUser]
grant SELECT on SQLSignaturesOverflow to [SQLdmConsoleUser]
grant SELECT on SQLStatements to [SQLdmConsoleUser]
grant SELECT on SQLStatementsOverflow to [SQLdmConsoleUser]
grant SELECT on stageDatabaseStatistics to [SQLdmConsoleUser]
grant SELECT on TableGrowth to [SQLdmConsoleUser]
grant SELECT on TableReorganization to [SQLdmConsoleUser]
grant SELECT on Tags to [SQLdmConsoleUser]
grant SELECT on Tasks to [SQLdmConsoleUser]
grant SELECT on TempdbFileData to [SQLdmConsoleUser]
grant SELECT on VirtualHostServers to [SQLdmConsoleUser]
grant SELECT on VMConfigData to [SQLdmConsoleUser]
grant SELECT on VMStatistics to [SQLdmConsoleUser]
grant SELECT on WaitCategories to [SQLdmConsoleUser]
grant SELECT on WaitStatistics to [SQLdmConsoleUser]
grant SELECT on WaitStatisticsDetails to [SQLdmConsoleUser]
grant SELECT on WaitTypes to [SQLdmConsoleUser]
grant SELECT on WebFramework to [SQLdmConsoleUser]
grant SELECT on WidgetSourceMapping to [SQLdmConsoleUser]
grant SELECT on WidgetTagMapping to [SQLdmConsoleUser]
grant SELECT on XEMapKeys to [SQLdmConsoleUser]
grant SELECT on CloudProviders to [SQLdmConsoleUser]
--[END] SQLdm 10.0 (Gaurav Karwal): grant for tables that were missing


grant EXECUTE on [fn_CompareDateTimeRange] to [SQLdmConsoleUser]
grant EXECUTE on [fn_GetDatabaseCreationDate] to [SQLdmConsoleUser]
grant EXECUTE on [fn_GetDatabaseVersion] to [SQLdmConsoleUser]
grant EXECUTE on [fn_ServerVersionnVarcharToBigInt] to [SQLdmConsoleUser]
grant EXECUTE on [fn_CompareDateTimeRange] to [SQLdmConsoleUser]
grant EXECUTE on [fn_RoundDateTime] to [SQLdmConsoleUser]
grant EXECUTE on [fn_GetServerName] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetAlerts] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetBaselineMetaData] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetBaselineParameters] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetBlockingDetails] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetCounterCategories] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetCounterNameAvailable] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetCounters] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetCustomCounterStatistics] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetDatabases] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetDefaultManagementService] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetDefaultManagementServiceID] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetInstancesMonitoringCustomCounter] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetLicenseKeys] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetLocksDetails] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetManagementServices] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetMetricInfo] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetMetricThresholds] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetMonitoredSqlServerById] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetMonitoredSQLServerCounters] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetMonitoredSqlServers] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetMonitoredSqlServerStatus] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetNextServerActivitySnapshotDateTime] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetPermissions] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetPreviousServerActivitySnapshotDateTime] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetQueryMonitorStatements] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetServerActivity] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetServerOverview] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetServerOverviewStatistics] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetServerSummary] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetServerWideStatistics] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetSessionsDetails] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetSnoozedAlerts] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetAllMetricsAlertsName] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetSqlAgentRunning] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetStateOverview] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetTableFragmentation] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetTables] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetTasks] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetUserToken] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetUserTokenInternal] to [SQLdmConsoleUser]
grant EXECUTE on [p_HeartbeatCollectionService] to [SQLdmConsoleUser]
grant EXECUTE on [p_ImportGetMonitoredSqlServers] to [SQLdmConsoleUser]
grant EXECUTE on [p_ImportUpdateEarliestDateImported] to [SQLdmConsoleUser]
grant EXECUTE on [p_InsertDatabaseName] to [SQLdmConsoleUser]
grant EXECUTE on [p_InsertTableName] to [SQLdmConsoleUser]
grant EXECUTE on [p_IsUserAdministrator] to [SQLdmConsoleUser]
grant EXECUTE on [p_RepositoryInfo] to [SQLdmConsoleUser]
grant EXECUTE on [p_SetBaselineParameters] to [SQLdmConsoleUser]
grant EXECUTE on [p_TopServersCpu] to [SQLdmConsoleUser]
grant EXECUTE on [p_TopServersAlerts] to [SQLdmConsoleUser]
grant EXECUTE on [p_TopServersResponseTime] to [SQLdmConsoleUser]
grant EXECUTE on [p_TopServersMemory] to [SQLdmConsoleUser]
grant EXECUTE on [p_TopServersDisk] to [SQLdmConsoleUser]
grant EXECUTE on [p_DatabaseGrowthForecast] to [SQLdmConsoleUser]
grant EXECUTE on [p_DiskUsageForecast] to [SQLdmConsoleUser]
grant EXECUTE on [p_TableGrowthForecast] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetEnterpriseSummary] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetDatabaseOverview] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetServerSummaryReport] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetMasterMetrics] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetTags] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetServerTags] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetServersWithTagId] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetCustomCountersWithTagIds] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetMirroringHistory] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetMirroringServerStatus] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetMirroringSessions] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetMonitoredMirroredServers] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetServerInventory] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetAlertThresholdsForNumerics] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetAlertThresholdsForEnums] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetAlertHistory] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetActiveAlerts] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetDiskDrives] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetCurrentDiskDrives] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetMirroredDatabases] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetMemorySummary] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetDiskSummary] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetSessionsSummary] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetCPUSummary] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetReplicationSummary] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetOSStatisticsAvailable] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetReportPeriodIntervals] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetTagServersAsXML] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetTagsWithMirroredServers] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetCustomCounterTagsAndServers] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetPermissionTagsAndServers] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetReplicationParticipantsForServer] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetReplicationChartMetrics] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetListOfCounters] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetCustomReports] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetSelectedCustomReportCounters] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetDeadlock] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetCustomReportsDataSet] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetWaitStatistics] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetCopyright] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetWaitCategory] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetExcludedWaitTypes] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetActiveWaits] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetSQLText] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetPredictiveForecasts] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetPredictiveAnalyticsEnabled] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetFileActivity] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetUserIdentifiers] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetNotificationProviders] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetNotificationRules] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetMostCriticalServers] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetMetricThresholdDetails] to [SQLdmConsoleUser]
grant EXECUTE on [p_DiskDetailsReport] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetNewTemplateOptions] to [SQLdmConsoleUser]
grant EXECUTE on [p_AddDefaultAlertTemplate] to [SQLdmConsoleUser]
grant EXECUTE on [p_AddAlertTemplate] to [SQLdmConsoleUser]
grant EXECUTE on [p_UpdateAlertTemplate] to [SQLdmConsoleUser]
grant EXECUTE on [p_SetDefaultAlertTemplate] to [SQLdmConsoleUser]
grant EXECUTE on [p_DeleteAlertTemplate] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetAlertTemplates] to [SQLdmConsoleUser]
grant EXECUTE on [p_AddVMToMonitoredServer] to [SQLdmConsoleUser]
grant EXECUTE on [p_AddUpdateVirtualHost] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetVirtualHostServers] to [SQLdmConsoleUser]
grant EXECUTE on [p_DeleteVirtualHost] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetTempdbSummaryData] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetDatabaseCounters] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetTempdbFileData] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetVirtualizationStatistics] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetTempdbStatistics] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetTempdbOverall] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetVMConfigReport] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetVMSummaryReport] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetHoursList] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetEarliestDataAvailable] to [SQLdmConsoleUser]
grant EXECUTE on [p_AddBaselineTemplate] to [SQLdmConsoleUser]
grant EXECUTE on [p_AddBaselineStatistics] to [SQLdmConsoleUser]
grant EXECUTE on [p_AddDashboardLayout] to [SQLdmConsoleUser]
grant EXECUTE on [p_DeleteDashboardLayout] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetDashboardLayoutID] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetDashboardLayout] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetDashboardLayouts] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetServerDashboardLayout] to [SQLdmConsoleUser]
grant EXECUTE on [p_SetDefaultDashboardLayout] to [SQLdmConsoleUser]
grant EXECUTE on [p_UpdateDashboardLayout] to [SQLdmConsoleUser]
grant EXECUTE on [p_UpdateDashboardLayoutViewed] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetBaselineStatisticsReport] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetBaselineMetrics] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetCPUSummaryBaseline] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetServerTimeline] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetSessionSummaryBaseline] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetMemorySummaryBaseline] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetDiskStatisticsBaseline] to [SQLdmConsoleUser]
grant EXECUTE on [p_AddAuditableEvent] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetAllAuditableEvents] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetChangeLogSummary] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetChangeLogRepositoryUser] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetChangeLogWorkstation] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetChangeLogWorkstationUser] to [SQLdmConsoleUser]
grant EXECUTE on [p_InsertAlwaysOnStatistics] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetAlwaysOnStatistics] to [SQLdmConsoleUser]
grant EXECUTE on [p_UpdateAlwaysOnDatabaseTopologyXml] to [SQLdmConsoleUser]
grant EXECUTE on [p_UpdateAlwaysOnAvailabilityReplicaTopologyXml] to [SQLdmConsoleUser]
grant EXECUTE on [p_UpdateAlwaysOnAvailabilityGroupTopologyXml] to [SQLdmConsoleUser]
grant EXECUTE on [p_GroomAlwaysOnDatabaseTopologyXml] to [SQLdmConsoleUser]
grant EXECUTE on [p_GroomAlwaysOnAvailabilityReplicaTopologyXml] to [SQLdmConsoleUser]
grant EXECUTE on [p_GroomAlwaysOnAvailabilityGroupTopologyXml] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetAlwaysOnDatabases] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetMonitoredAlwaysOnServers] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetAlwaysOnAvailabilityReplica] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetAlwaysOnDatabaseStatistics] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetAlwaysOnAGBasedActiveServers] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetBlocksList] to [SQLdmConsoleUser]
grant EXECUTE on [p_GetDeadlocksList] to [SQLdmConsoleUser]
--[START] SQLdm 10.0 (Gaurav Karwal): Grant execute permissions to remaining tables
grant EXECUTE on p_AddAlert to [SQLdmConsoleUser]
grant EXECUTE on p_AddCollectionServices to [SQLdmConsoleUser]
grant EXECUTE on p_AddCounter to [SQLdmConsoleUser]
--grant EXECUTE on p_AddCustomDashboard to [SQLdmConsoleUser]
grant EXECUTE on p_AddDatabaseFileInformation to [SQLdmConsoleUser]
grant EXECUTE on p_AddDefaultMetricThreshold to [SQLdmConsoleUser]
grant EXECUTE on p_AddDiskDriveInformation to [SQLdmConsoleUser]
grant EXECUTE on p_AddLatestGroomingStatus to [SQLdmConsoleUser]
grant EXECUTE on p_AddLicenseKey to [SQLdmConsoleUser]
grant EXECUTE on p_AddLogin to [SQLdmConsoleUser]
grant EXECUTE on p_AddManagementService to [SQLdmConsoleUser]
grant EXECUTE on p_AddMetricThresholdInstance to [SQLdmConsoleUser]
grant EXECUTE on p_AddMonitoredSqlServer to [SQLdmConsoleUser]
grant EXECUTE on p_AddNotificationProvider to [SQLdmConsoleUser]
grant EXECUTE on p_AddNotificationRule to [SQLdmConsoleUser]
grant EXECUTE on p_AddPermission to [SQLdmConsoleUser]
grant EXECUTE on p_AddPredictiveForecast to [SQLdmConsoleUser]
grant EXECUTE on p_AddPredictiveModel to [SQLdmConsoleUser]
grant EXECUTE on p_AddSQLsafeReferenceLink to [SQLdmConsoleUser]
grant EXECUTE on p_AddSQLsafeRepository to [SQLdmConsoleUser]
grant EXECUTE on p_AddTag to [SQLdmConsoleUser]
grant EXECUTE on p_AddTask to [SQLdmConsoleUser]
grant EXECUTE on p_AddTheProductRegistrationInformation to [SQLdmConsoleUser]
grant EXECUTE on p_AddThresholdInstance to [SQLdmConsoleUser]
grant EXECUTE on p_AggregateQueryData to [SQLdmConsoleUser]
grant EXECUTE on p_AppendToMetricThreshold to [SQLdmConsoleUser]
grant EXECUTE on p_AppSecDisable to [SQLdmConsoleUser]
grant EXECUTE on p_AppSecEnable to [SQLdmConsoleUser]
grant EXECUTE on p_AssignCountersToServer to [SQLdmConsoleUser]
grant EXECUTE on p_AssignCounterToServers to [SQLdmConsoleUser]
grant EXECUTE on p_AuthenticateWebConsoleUserAppSecOn to [SQLdmConsoleUser]
grant EXECUTE on p_CheckDashboardExists to [SQLdmConsoleUser]
grant EXECUTE on p_CheckDuplicateCustomDashboardName to [SQLdmConsoleUser]
grant EXECUTE on p_ClearAlerts to [SQLdmConsoleUser]
grant EXECUTE on p_CreateAggregationJob to [SQLdmConsoleUser]
grant EXECUTE on p_CreateCopyOfCustomDashboard to [SQLdmConsoleUser]
grant EXECUTE on p_CreateGroomJob to [SQLdmConsoleUser]
grant EXECUTE on p_DatabaseStatisticsFromStaging to [SQLdmConsoleUser]
grant EXECUTE on p_DeactivateMonitoredSqlServer to [SQLdmConsoleUser]
grant EXECUTE on p_DeleteCounter to [SQLdmConsoleUser]
grant EXECUTE on p_DeleteCountersFromCustomReport to [SQLdmConsoleUser]
grant EXECUTE on p_DeleteCustomDashboardRecord to [SQLdmConsoleUser]
grant EXECUTE on p_DeleteCustomDashboardWidgetRecord to [SQLdmConsoleUser]
grant EXECUTE on p_DeleteCustomReport to [SQLdmConsoleUser]
grant EXECUTE on p_DeleteLicenseKey to [SQLdmConsoleUser]
grant EXECUTE on p_DeleteMetricThresholdInstance to [SQLdmConsoleUser]
grant EXECUTE on p_DeleteMirroringPreferredConfig to [SQLdmConsoleUser]
grant EXECUTE on p_DeleteMirroringSessionFromServer to [SQLdmConsoleUser]
grant EXECUTE on p_DeleteMonitoredSqlServer to [SQLdmConsoleUser]
grant EXECUTE on p_DeleteNotificationProvider to [SQLdmConsoleUser]
grant EXECUTE on p_DeleteNotificationRule to [SQLdmConsoleUser]
grant EXECUTE on p_DeletePermission to [SQLdmConsoleUser]
grant EXECUTE on p_DeleteReplicationSessionFromServer to [SQLdmConsoleUser]
grant EXECUTE on p_DeleteRunQueryScript to [SQLdmConsoleUser]
grant EXECUTE on p_DeleteSQLsafeRepository to [SQLdmConsoleUser]
grant EXECUTE on p_DeleteTagsById to [SQLdmConsoleUser]
grant EXECUTE on p_DeleteTasks to [SQLdmConsoleUser]
grant EXECUTE on p_GetAlert to [SQLdmConsoleUser]
grant EXECUTE on p_GetAlertsCountPerCategory to [SQLdmConsoleUser]
grant EXECUTE on p_GetAlertsCountPerDatabase to [SQLdmConsoleUser]
grant EXECUTE on p_GetAlertsForWebConsole to [SQLdmConsoleUser]
grant EXECUTE on p_GetAlertsHistory to [SQLdmConsoleUser]
grant EXECUTE on p_GetAllCategories to [SQLdmConsoleUser]
grant EXECUTE on p_GetAllDisks to [SQLdmConsoleUser]
grant EXECUTE on p_GetApplicationsForServer to [SQLdmConsoleUser]
grant EXECUTE on p_GetBaselinesForMetric to [SQLdmConsoleUser]
grant EXECUTE on p_GetBaselineStatistics to [SQLdmConsoleUser]
grant EXECUTE on p_GetBaselineTemplatesById to [SQLdmConsoleUser]
grant EXECUTE on p_GetBlock to [SQLdmConsoleUser]
grant EXECUTE on p_GetBlockedRecommendationDatabaseAnalysisConfiguration to [SQLdmConsoleUser]
grant EXECUTE on p_GetClientsForServer to [SQLdmConsoleUser]
grant EXECUTE on p_GetCollectionServiceForSQLServer to [SQLdmConsoleUser]
grant EXECUTE on p_GetCollectionServices to [SQLdmConsoleUser]
grant EXECUTE on p_GetCustomCounterTags to [SQLdmConsoleUser]
grant EXECUTE on p_GetCustomDashboards to [SQLdmConsoleUser]
grant EXECUTE on p_GetCustomReportName to [SQLdmConsoleUser]
grant EXECUTE on p_GetDatabaseByInstance to [SQLdmConsoleUser]
--grant EXECUTE on p_GetDatabaseFilesInformation to [SQLdmConsoleUser]
grant EXECUTE on p_GetDatabasesForServer to [SQLdmConsoleUser]
grant EXECUTE on p_GetDatabaseStatistics to [SQLdmConsoleUser]
grant EXECUTE on p_GetDataForMetrics to [SQLdmConsoleUser]
grant EXECUTE on p_GetDefaultTemplateID to [SQLdmConsoleUser]
--grant EXECUTE on p_GetDiskDrivesInformation to [SQLdmConsoleUser]
grant EXECUTE on p_GetDiskSizeDetails to [SQLdmConsoleUser]
grant EXECUTE on p_GetDiskSpaceHistoryOverall to [SQLdmConsoleUser]
grant EXECUTE on p_GetDiskSpaceHistoryReportData to [SQLdmConsoleUser]
grant EXECUTE on p_GetDiskSpaceUsageReportData to [SQLdmConsoleUser]
grant EXECUTE on p_GetGraphRepresentationDataByApplication to [SQLdmConsoleUser]
grant EXECUTE on p_GetGraphRepresentationDataByClient to [SQLdmConsoleUser]
grant EXECUTE on p_GetGraphRepresentationDataByDatabase to [SQLdmConsoleUser]
grant EXECUTE on p_GetGraphRepresentationDataByQuerySignature to [SQLdmConsoleUser]
grant EXECUTE on p_GetGraphRepresentationDataByQueryStatement to [SQLdmConsoleUser]
grant EXECUTE on p_GetGraphRepresentationDataByUser to [SQLdmConsoleUser]
grant EXECUTE on p_GetGrooming to [SQLdmConsoleUser]
grant EXECUTE on p_GetGroomingStatusInfo to [SQLdmConsoleUser]
grant EXECUTE on p_GetInstanceAvailbilityGroupDetails to [SQLdmConsoleUser]
grant EXECUTE on p_GetInstanceQueryStats to [SQLdmConsoleUser]
grant EXECUTE on p_GetInstanceResources to [SQLdmConsoleUser]
--grant EXECUTE on p_GetInstancesByQueries to [SQLdmConsoleUser]
grant EXECUTE on p_GetInstancesList to [SQLdmConsoleUser]
grant EXECUTE on p_GetInstanceStatus to [SQLdmConsoleUser]
grant EXECUTE on p_GetLatestResponseTimesByInstance to [SQLdmConsoleUser]
grant EXECUTE on p_GetLicenseKeysAndListener to [SQLdmConsoleUser]
grant EXECUTE on p_GetMasterRecommendations to [SQLdmConsoleUser]
grant EXECUTE on p_GetMatchTypes to [SQLdmConsoleUser]
grant EXECUTE on p_GetMaxAlertID to [SQLdmConsoleUser]
grant EXECUTE on p_GetMetricList to [SQLdmConsoleUser]
grant EXECUTE on p_GetMetricsHistoryForAlert to [SQLdmConsoleUser]
grant EXECUTE on p_GetMetricsHistoryForCustomDashboard to [SQLdmConsoleUser]
grant EXECUTE on p_GetMetricThresholdsForWebConsole to [SQLdmConsoleUser]
grant EXECUTE on p_GetMirroringParticipantsForServer to [SQLdmConsoleUser]
grant EXECUTE on p_GetMirroringPreferredConfig to [SQLdmConsoleUser]
grant EXECUTE on p_GetMonitoredServersSummary to [SQLdmConsoleUser]
grant EXECUTE on p_GetMonitoredSqlServerId to [SQLdmConsoleUser]
grant EXECUTE on p_GetMonitoredSqlServerNames to [SQLdmConsoleUser]
grant EXECUTE on p_GetMonitoredSqlServersUsingCounter to [SQLdmConsoleUser]
grant EXECUTE on p_GetMonitoredSQLServerWorkload to [SQLdmConsoleUser]
grant EXECUTE on p_GetNextPredictiveForecast to [SQLdmConsoleUser]
grant EXECUTE on p_GetNextPredictiveModelRebuild to [SQLdmConsoleUser]
grant EXECUTE on p_GetPredictiveModelInput to [SQLdmConsoleUser]
grant EXECUTE on p_GetPredictiveModelsCount to [SQLdmConsoleUser]
grant EXECUTE on p_GetPredictiveTrainingData to [SQLdmConsoleUser]
grant EXECUTE on p_GetPrescriptiveAnalysis to [SQLdmConsoleUser]
--grant EXECUTE on p_GetPrescriptiveAnalysisRecommendation to [SQLdmConsoleUser]
grant EXECUTE on p_GetProductStatus to [SQLdmConsoleUser]
grant EXECUTE on p_GetQueryMonitorDataByApplication to [SQLdmConsoleUser]
grant EXECUTE on p_GetQueryMonitorDataByClient to [SQLdmConsoleUser]
grant EXECUTE on p_GetQueryMonitorDataByDatabase to [SQLdmConsoleUser]
grant EXECUTE on p_GetQueryMonitorDataByQuerySignature to [SQLdmConsoleUser]
grant EXECUTE on p_GetQueryMonitorDataByQueryStatement to [SQLdmConsoleUser]
--grant EXECUTE on p_GetQueryMonitorDataByQueryStatement_2 to [SQLdmConsoleUser]
grant EXECUTE on p_GetQueryMonitorDataByUser to [SQLdmConsoleUser]
grant EXECUTE on p_GetQueryMonitorUpgradeData to [SQLdmConsoleUser]
grant EXECUTE on p_GetQueryOverview to [SQLdmConsoleUser]
grant EXECUTE on p_GetQueryOverviewBatches to [SQLdmConsoleUser]
grant EXECUTE on p_GetQueryOverviewStatements to [SQLdmConsoleUser]
grant EXECUTE on p_GetQueryOverviewStoredProcedures to [SQLdmConsoleUser]
grant EXECUTE on p_GetQueryPlan to [SQLdmConsoleUser]
grant EXECUTE on p_GetQueryStatistics to [SQLdmConsoleUser]
grant EXECUTE on p_GetQueryWaitStatistics to [SQLdmConsoleUser]
--grant EXECUTE on p_GetRecommendationHisotry to [SQLdmConsoleUser]
grant EXECUTE on p_GetRecommendationHistory to [SQLdmConsoleUser]
grant EXECUTE on p_GetRecommendations to [SQLdmConsoleUser]
grant EXECUTE on p_GetReportServers to [SQLdmConsoleUser]
grant EXECUTE on p_GetRuleNameAvailable to [SQLdmConsoleUser]
grant EXECUTE on p_GetRunQueryScripts to [SQLdmConsoleUser]
grant EXECUTE on p_GetServerOverviewHistory to [SQLdmConsoleUser]
grant EXECUTE on p_GetSessionByCPUUsage to [SQLdmConsoleUser]
grant EXECUTE on p_GetSessionList to [SQLdmConsoleUser]
grant EXECUTE on p_GetSessionStatisticsForWebConsole to [SQLdmConsoleUser]
grant EXECUTE on p_GetSQLDrives to [SQLdmConsoleUser]
grant EXECUTE on p_GetSQLServerUsers to [SQLdmConsoleUser]
grant EXECUTE on p_GetTagAssociations to [SQLdmConsoleUser]
grant EXECUTE on p_GetTagConfiguration to [SQLdmConsoleUser]
grant EXECUTE on p_GetTheProductRegistrationInformation to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopBlockedSessionCount to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopDatabaseApplications to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopDatabaseByActivity to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopDatabaseByProjectedGrowth to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopDatabases to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopDatabasesByAlerts to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopDatabasesByGrowth to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopDatabasesByQueryWaits to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopDatabasesByReads to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopDatabasesBySize to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopDatabasesBySizeForWebConsole to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopDatabasesByTransactions to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopDatabasesByWrites to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopInstancesByAlerts to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopInstancesByConnections to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopInstancesByCPUUsage to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopInstancesByDiskSpace to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopInstancesByIO to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopInstancesByQueries to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopInstancesByQueryCount to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopInstancesByQueryDuration to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopInstancesByResponseTime to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopInstancesBySessionCount to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopInstancesBySQLMemory to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopQueries to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopQueriesByCPU to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopQueriesByDuration to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopQueriesByFrequency to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopQueriesByReads to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopQueriesByWrites to [SQLdmConsoleUser]
--grant EXECUTE on p_GetTopServerByTempDbUtilization to [SQLdmConsoleUser]
--grant EXECUTE on p_GetTopSessionByCpuUsage to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopSessionsByCpuUsage to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopTablesFragmentation to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopTablesFragmentationChart to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopTablesGrowth to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopTablesGrowthChart to [SQLdmConsoleUser]
grant EXECUTE on p_GetTopXServerByTempDbUtilization to [SQLdmConsoleUser]
grant EXECUTE on p_GetUsersForServer to [SQLdmConsoleUser]
grant EXECUTE on p_GetVirtualHostServersByAddress to [SQLdmConsoleUser]
grant EXECUTE on p_GetWaitsByInstance to [SQLdmConsoleUser]
grant EXECUTE on p_GetWebApplicationUser to [SQLdmConsoleUser]
grant EXECUTE on p_GetWidgetsofDashboard to [SQLdmConsoleUser]
grant EXECUTE on p_GetWidgetTypes to [SQLdmConsoleUser]
grant EXECUTE on p_GetAvailbilityGroups to [SQLdmConsoleUser] --Ankit Nagpal SQLDM 10.0.0 
--grant EXECUTE on p_GroomAlerts to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomAlwaysOnStatistics to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomApplicationNames to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomAuditedEvents to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomBaselineStatistics to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomBaselineTemplates to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomBlockingSessionStatistics to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomBlocks to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomCustomCounterStatistics to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomDatabaseFileActivity to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomDatabaseFiles to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomDatabaseNames to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomDatabaseSize to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomDatabaseStatistics to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomDatabaseStatistics_upgrade to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomDatabaseStatisticsStaging to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomDeadlocks to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomDiskDrives to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomDiskDriveStatistics to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomESXConfigData to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomESXStatistics to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomExpiredForecasts to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomGroomingLog to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomHostNames to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomingDefrag to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomJobMaintenance to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomLegacyQueryMonitor to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomLoginNames to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomMetricMetaData to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomMirroringStatistics to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomMonitoredSQLServers to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomOSStatistics to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomQueryMonitorStatistics to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomQuerySignatureAggregation to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomReplicationTopology to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomRepositoryData to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomRepositoryOrphanData to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomServerActivity to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomServerStatistics to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomSQLSignatures to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomSQLStatements to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomTableGrowth to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomTableReorganization to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomTasks to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomTempdbFileData to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomVMConfigData to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomVMStatistics to [SQLdmConsoleUser]
--grant EXECUTE on p_GroomWaitStatistics to [SQLdmConsoleUser]
grant EXECUTE on p_InsertActiveWait to [SQLdmConsoleUser]
grant EXECUTE on p_InsertApplicationName to [SQLdmConsoleUser]
grant EXECUTE on p_InsertBlock to [SQLdmConsoleUser]
grant EXECUTE on p_InsertBlockingSession to [SQLdmConsoleUser]
grant EXECUTE on p_InsertCustomCounterStatistics to [SQLdmConsoleUser]
grant EXECUTE on p_InsertCustomReportsCounters to [SQLdmConsoleUser]
grant EXECUTE on p_InsertDatabaseFile to [SQLdmConsoleUser]
grant EXECUTE on p_InsertDatabaseSize to [SQLdmConsoleUser]
grant EXECUTE on p_InsertDatabaseStatistics to [SQLdmConsoleUser]
grant EXECUTE on p_InsertDeadlock to [SQLdmConsoleUser]
grant EXECUTE on p_InsertDeadlockProcess to [SQLdmConsoleUser]
grant EXECUTE on p_InsertDiskDrive to [SQLdmConsoleUser]
grant EXECUTE on p_InsertESXConfigData to [SQLdmConsoleUser]
grant EXECUTE on p_InsertESXStatistics to [SQLdmConsoleUser]
grant EXECUTE on p_InsertFileActivity to [SQLdmConsoleUser]
grant EXECUTE on p_InsertHostName to [SQLdmConsoleUser]
grant EXECUTE on p_InsertLoginName to [SQLdmConsoleUser]
grant EXECUTE on p_InsertMirroringStatistics to [SQLdmConsoleUser]
grant EXECUTE on p_InsertOSStatistics to [SQLdmConsoleUser]
--grant EXECUTE on p_InsertPrescriptiveAnalysis to [SQLdmConsoleUser]
--grant EXECUTE on p_InsertPrescriptiveAnalysisDetails to [SQLdmConsoleUser]
--grant EXECUTE on p_InsertPrescriptiveAnalysisRecommendation to [SQLdmConsoleUser]
grant EXECUTE on p_InsertQueryMonitorStatement to [SQLdmConsoleUser]
grant EXECUTE on p_InsertRunQueryScript to [SQLdmConsoleUser]
grant EXECUTE on p_InsertServerActivity to [SQLdmConsoleUser]
grant EXECUTE on p_InsertServerStatistics to [SQLdmConsoleUser]
grant EXECUTE on p_InsertSQLQueryPlan to [SQLdmConsoleUser]
grant EXECUTE on p_InsertSQLSignature to [SQLdmConsoleUser]
grant EXECUTE on p_InsertSQLStatement to [SQLdmConsoleUser]
grant EXECUTE on p_InsertTableGrowth to [SQLdmConsoleUser]
grant EXECUTE on p_InsertTableReorganization to [SQLdmConsoleUser]
grant EXECUTE on p_InsertTempdbFileData to [SQLdmConsoleUser]
grant EXECUTE on p_InsertVMConfigData to [SQLdmConsoleUser]
grant EXECUTE on p_InsertVMStatistics to [SQLdmConsoleUser]
grant EXECUTE on p_InsertWaitStatistics to [SQLdmConsoleUser]
grant EXECUTE on p_InsertWaitStatisticsDetails to [SQLdmConsoleUser]
grant EXECUTE on p_InsertWaitTypes to [SQLdmConsoleUser]
grant EXECUTE on p_IsAppSecEnabled to [SQLdmConsoleUser]
--grant EXECUTE on p_LogGroomingAction to [SQLdmConsoleUser]
grant EXECUTE on p_MoveQueryMonitorStatement to [SQLdmConsoleUser]
grant EXECUTE on p_PopulateMetricThresholds to [SQLdmConsoleUser]
grant EXECUTE on p_PopulateMetricThresholdsNew to [SQLdmConsoleUser]
grant EXECUTE on p_PostInstallUpgrade to [SQLdmConsoleUser]
grant EXECUTE on p_RemoveFromMetricThreshold to [SQLdmConsoleUser]
grant EXECUTE on p_RemoveManagementService to [SQLdmConsoleUser]
grant EXECUTE on p_SaveAnalysisConfiguration to [SQLdmConsoleUser]
grant EXECUTE on p_SaveAnalysisRecommendationAndProperties to [SQLdmConsoleUser]
grant EXECUTE on p_SaveAnalysisRecords to [SQLdmConsoleUser]
grant EXECUTE on p_SavePrescriptiveAnalysis to [SQLdmConsoleUser]
grant EXECUTE on p_SavePrescriptiveAnalysisDetails to [SQLdmConsoleUser]
grant EXECUTE on p_SetAggregationFlag to [SQLdmConsoleUser]
grant EXECUTE on p_SetDefaultCollectionService to [SQLdmConsoleUser]
grant EXECUTE on p_SetDefaultManagementService to [SQLdmConsoleUser]
grant EXECUTE on p_SetMirroringPreferredConfig to [SQLdmConsoleUser]
grant EXECUTE on p_SetNextPredictiveForecast to [SQLdmConsoleUser]
grant EXECUTE on p_SetNextPredictiveModelRebuild to [SQLdmConsoleUser]
grant EXECUTE on p_SetPredictiveAnalyticsEnabled to [SQLdmConsoleUser]
grant EXECUTE on p_SnoozeAlerts to [SQLdmConsoleUser]
grant EXECUTE on p_StartAggregationJob to [SQLdmConsoleUser]
grant EXECUTE on p_StartGroomJob to [SQLdmConsoleUser]
grant EXECUTE on p_SyncCustomCounterThresholds to [SQLdmConsoleUser]
grant EXECUTE on p_TopServersDatabaseAlerts to [SQLdmConsoleUser]
grant EXECUTE on p_TopServersQueryWaits to [SQLdmConsoleUser]
grant EXECUTE on p_UnsnoozeAlerts to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateBlockedRecommendationDatabaseAnalysisConfiguration to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateCounter to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateCounterStatus to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateCustomCounterTags to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateCustomReport to [SQLdmConsoleUser]
--grant EXECUTE on p_UpdateFlagStatusPrescriptiveAnalysisRecommendation to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateGrooming to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateLastDatabaseRefreshTime to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateLastRefreshTime to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateMetricInfo to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateMetricThreshold to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateMonitoredSqlServer to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateNotificationProvider to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateNotificationRule to [SQLdmConsoleUser]
grant EXECUTE on p_UpdatePermission to [SQLdmConsoleUser]
grant EXECUTE on p_UpdatePermissionStatus to [SQLdmConsoleUser]
grant EXECUTE on p_UpdatePermissionTags to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateRecommendationFlagStatus to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateRecommendationOptimizationStatus to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateReplicationTopology to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateReplicationTopologyDistributor to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateReplicationTopologySubscriber to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateRunQueryScript to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateServerTags to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateServerVersion to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateSQLsafeLastBackupActionId to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateSQLsafeLastDefragActionId to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateSQLsafeRepository to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateStatisticsRunTime to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateTag to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateTagConfiguration to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateTask to [SQLdmConsoleUser]
grant EXECUTE on p_UpdateWebAppPermissionStatus to [SQLdmConsoleUser]
grant EXECUTE on p_UpgradeAlertData to [SQLdmConsoleUser]
grant EXECUTE on p_UpgradeDatabaseStatistics to [SQLdmConsoleUser]
grant EXECUTE on p_UpsertBaselineTemplate to [SQLdmConsoleUser]
grant EXECUTE on p_UpsertCustomDashboard to [SQLdmConsoleUser]
grant EXECUTE on p_UpsertCustomDashboardWidget to [SQLdmConsoleUser]
--[END] SQLdm 10.0 (Gaurav Karwal): Grant execute permissions to remaining tables
grant EXECUTE on p_GetPrescriptiveAnalysisSchedule to [SQLdmConsoleUser] -- SQLdm 10.0 (Praveen Suhalka): Grant execute permissions to new procedure
grant EXECUTE on p_GetCloudProviders to [SQLdmConsoleUser] -- SQLdm 10.0 (Gaurav Karwal): Grant execute permissions to new procedure
grant EXECUTE on p_GetAllBaselinesData to [SQLdmConsoleUser] -- SQLdm 10.0 (Gaurav Karwal): Grant execute permissions to new procedure
 
GO 
